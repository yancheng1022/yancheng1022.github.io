<<<<<<< HEAD
{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":1,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/custom.css","path":"css/custom.css","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/foot.js","path":"js/foot.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":1,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":1,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/css/LXGWZhenKai.ttf","path":"css/LXGWZhenKai.ttf","modified":1,"renderable":0}],"Cache":[{"_id":"source/README.md","hash":"3cf29680a7f1c21572333cf7cf2029c6c567e670","modified":1690291154793},{"_id":"source/_posts/Nginx.md","hash":"859f0713169b5d093cfe86cab01455ff30281b57","modified":1690291154796},{"_id":"source/CNAME","hash":"0ba2ea8a346b2e193945de5bc8f9d9aa4a81461b","modified":1690291154793},{"_id":"source/about/index.md","hash":"c1d344f09e319216d06e80750c3e5a23068bafff","modified":1690291154801},{"_id":"source/_posts/JUC.md","hash":"8aaf0db24ff40f8cad44a994372cc47879194a57","modified":1690291154794},{"_id":"source/_posts/spring.md","hash":"5c440b91d0bbc87e07d6ab7a0ab3a430978259fd","modified":1690291154801},{"_id":"source/_posts/RabbitMQ.md","hash":"178b6b0683440a91dd2ffe0a9ad049da63af7a93","modified":1690291154796},{"_id":"source/tags/index.md","hash":"537fa92c4d8d77af6f4a699df28695fe0c9a6565","modified":1690291154845},{"_id":"source/_posts/商.md","hash":"e601d48cb689917bd78655a98ac6c73070381ef5","modified":1690813965134},{"_id":"source/categories/index.md","hash":"2f5289cf24818f4762f158fd603bdc47ca3cf1bf","modified":1690291154802},{"_id":"source/css/custom.css","hash":"72b3900fac2a8af003a1bf4abba69dcfa6251f22","modified":1690291154845},{"_id":"source/_posts/中国历史年表.md","hash":"0241714aba15345b66cffd06d6b4558bd9484396","modified":1690553973229},{"_id":"source/_posts/夏.md","hash":"cbd889ca9ade5d8f1012f263cca14eca58b0f80e","modified":1690556281636},{"_id":"source/_posts/springCloud.md","hash":"962b9c9154ffebe288d3611cae8495d81ac0b4b8","modified":1690610956800},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1690291154846},{"_id":"themes/butterfly/README.md","hash":"5ca893c78f8971f512da55c785b8ccbfa9d37cfc","modified":1690291154846},{"_id":"themes/butterfly/package.json","hash":"a6a032654a36408d7b7274bc9cfe21f89946d29c","modified":1690291154861},{"_id":"themes/butterfly/README_CN.md","hash":"f6ae7f38d016135340fd25c5fd1be65452b6773d","modified":1690291154846},{"_id":"themes/butterfly/plugins.yml","hash":"6d68dab3b79accb1bceb4710c8aaab724a45053a","modified":1690291154861},{"_id":"themes/butterfly/languages/en.yml","hash":"4957fd976c99745d3aa24000a85b2955e8d1cf81","modified":1690291154847},{"_id":"themes/butterfly/languages/default.yml","hash":"d444cbb5c5456aaf27f3fb1b4308634689c7bb53","modified":1690291154847},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"145ec301db185c8a06de1f34a77ca391e1d2729b","modified":1690291154847},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"cc8672dc0c2762b694f689cbeb6e34810f1c194e","modified":1690291154847},{"_id":"themes/butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1690291154847},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1690291154848},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1690291154860},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1690291154860},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1690291154861},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1690291154861},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1690291154848},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"e334a2688ca1ae9095dd4058710fc5eaf1353cca","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"c55f05400eb27ab051f47396ec8d4249ce6f71ec","modified":1690291154852},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1690291154852},{"_id":"themes/butterfly/source/img/avatar.jpg","hash":"bbf597f4a75a617bed638ac124502fd76068f62b","modified":1690291154870},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1690291154870},{"_id":"themes/butterfly/source/img/favicon.png","hash":"f17fd89a2e05a689c4f5481be9ea6b09f7b8d945","modified":1690291154870},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1690291154871},{"_id":"themes/butterfly/source/css/custom.css","hash":"941d80e05e34f710eb978e0040ab14e3a6f727bf","modified":1690291154869},{"_id":"themes/butterfly/source/css/var.styl","hash":"e1e37a2e932163886789b72624c7348545003f1d","modified":1690291154869},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1690291154869},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1690291154861},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1690291154862},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1690291154862},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1690291154862},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1690291154862},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1690291154862},{"_id":"themes/butterfly/source/js/foot.js","hash":"65cf405d3e3e37682062d948924d8101b566e31b","modified":1690291154871},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"a102a6cacf7b20183946a54580867a964f3674c4","modified":1690291154873},{"_id":"themes/butterfly/source/js/main.js","hash":"4fd1cd7a02dedcb686caf6149c35fd8e1fbcafc9","modified":1690291154872},{"_id":"themes/butterfly/source/js/utils.js","hash":"13b2b02118a0f4ec2e9e0bb1b90f5b1a30a70f44","modified":1690291154873},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a3323fcb11cfd3f3e21230737341beb5d76b40aa","modified":1690291154862},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"8ff03b35385f9162e1eb54dceb5fa7f781306caf","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"7222102f9919f8e961d4f1688425845fb7775ada","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"6005907245dd74b153f03afdccfae1abb66bb482","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1690291154863},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"b8d95ac1851c37f1dce4b1dd4a1d3ffdff501a03","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"fc5a80707cf522378be3cf8638ef78bccc88c510","modified":1690291154864},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1690291154864},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1690291154864},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1690291154864},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"f5207840c96df6b26ad227433babca4f8c362624","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"3adb731465a4ab14529277fd7867889e0800ad16","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"82bb447a5d045980789cf3f9de9d49cc32011b13","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"ba94ceb40d7c81372a76103d958dcc2cc6a84f00","modified":1690291154860},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1690291154864},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"431b4a252443e224872bd6b4f6aa76ed1679a82c","modified":1690291154864},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"e43017dbc73e0ce95dcfcb9dfb4fcce0c1715dd4","modified":1690291154864},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1690291154864},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"3969f599e8657adf8c3ce287d83f5d0a23f276a9","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"e2869b71266bd49285f22da89560d875e8c61541","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"20303c0dad28e5c5335ce2fa6582f1fafae5b628","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc029f5e00d7904c0878efd20dd4e09fc55e1d03","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"824b2b2d2ee72583b9e009c0bb13e29e806534cc","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1690291154866},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"9066a62e442affce3a923a06a90486bf9d364e0e","modified":1690291154866},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1690291154868},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"4c86c10f8ec0c8fb60b400a5a2f14699d3155be4","modified":1690291154866},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1690291154868},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"57d333ef47bfb8fd22da31f600527c9d91e8e322","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1690291154867},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1690291154869},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"7c463ba25b3b54f0f46dfd75971d792816e942a8","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1690291154869},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"bbe930d8425bdaee2a5ba3cade42b617cee42934","modified":1690291154872},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"40e76d6da538cb3c1ef6b79ffc0adfa64fe6b8ba","modified":1690291154872},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"0010c7a10d265c4329f0fd4db85b4a9ea7ba06b5","modified":1690291154852},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"c42bbce31fcd8846cf3360f4c383dec9368daeba","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"b47698e153c73cb29286b19bec5ddd920cb7ffba","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"7c7fbe27d82becc9ee509765f1195c69f5864a0b","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b19b123df682b23491b17dcca386d79062cd8f6e","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"1a20b11fa0e6b1943e9b4d81e197a25ca36af66d","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a56edeb1ce2f1b1fb0e866a30543f274b9f7d69e","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f8b73bc63ec1b45d86aa3891d8c81ef4d5980943","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"c5e131d65a7ad30f3cb98ac3b94cd2f6a94c22e9","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f618457d62ef35d78a31e7fb1e375a462f64b228","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4bb4cf58e219dfb8787273c931b1ea978b2ab88f","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"386a2b371644c2682560733617561ba6e6bf9ab2","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"6b0d28671afd5ed286a714f25ba16256a2e7d880","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"2f3af113713563e34b10bbe998cc15008f81c85a","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"da94966a9650ef3e4c69f3ee93758b30fa42cb78","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"ba04174d977da988a1d49c06641262c413352346","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1690291154859},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1690291154864},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1690291154864},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1690291154864},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1690291154859},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1690291154864},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1690291154864},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1690291154859},{"_id":"themes/butterfly/source/js/jquery.js","hash":"aab820a7c9bb693c5df41f9886179eba2649b028","modified":1690291154872},{"_id":"themes/butterfly/_config.yml","hash":"818dc0782ca6713379e164e2741cb9578d29b0fd","modified":1690610899791},{"_id":"source/css/LXGWZhenKai.ttf","hash":"3e173155b120631bbf5c7a7921308977bdd48cf2","modified":1690291154844},{"_id":"public/css/custom.css","hash":"d6a18ee419b53590c6c6f241718b63c380658959","modified":1690814114964},{"_id":"public/search.xml","hash":"6c83c037bd371c149573bd78c909a2d2a31c5799","modified":1690814114964},{"_id":"public/README.html","hash":"588b4cae3e8197311cae30b40499556aa38491fa","modified":1690814114964},{"_id":"public/categories/index.html","hash":"2613bf70626023100e6bc03eb08a0d29a7635cf9","modified":1690814114964},{"_id":"public/categories/coding/index.html","hash":"5790aa6583c1779652da2afd38e2a6ffee80ef1f","modified":1690814114964},{"_id":"public/categories/历史/index.html","hash":"0e92d2d2cbe316db44ae7393e0e8fa3f1b47a682","modified":1690814114964},{"_id":"public/tags/juc/index.html","hash":"53e1e535edcb771376a01f9687022ec2541daecd","modified":1690814114964},{"_id":"public/tags/多线程/index.html","hash":"315ad470bc7ccfbb165dc92771bd4125e05ee704","modified":1690814114964},{"_id":"public/tags/并发编程/index.html","hash":"91a560e091354e99c0cac96160503e0bc48f55f5","modified":1690814114964},{"_id":"public/tags/RabbitMQ/index.html","hash":"4663a15b055174b21512e8b2f7a2dfabf8314077","modified":1690814114964},{"_id":"public/tags/消息队列/index.html","hash":"e089b10c80ead5dd34c4e69df2efa46fe5f2904c","modified":1690814114964},{"_id":"public/tags/spring/index.html","hash":"fa0b1e220a0e1ca9fa338015955bec2c7405553e","modified":1690814114964},{"_id":"public/tags/nginx/index.html","hash":"f1e382c28e94ca89b375289332b0428a670fcbe4","modified":1690814114964},{"_id":"public/tags/中国历史/index.html","hash":"9a983ee744bcdc5813f87460b7432eb61952e5ae","modified":1690814114964},{"_id":"public/tags/商朝/index.html","hash":"e235a350beca8b9d42d33aef4156f66ac9b93576","modified":1690814114964},{"_id":"public/tags/springCloud/index.html","hash":"24cd8e6251ae5730e0b6e20cd89964e0a68d2493","modified":1690814114964},{"_id":"public/tags/编程基础/index.html","hash":"690d5cbd8a52dc139b226ec573d8466a34151084","modified":1690814114964},{"_id":"public/about/index.html","hash":"fb56380207834fd264b5e1e5b8bc8141d2046115","modified":1690814114964},{"_id":"public/tags/index.html","hash":"ae10ae187e13280679e1a51d6744b6c9d649d6f6","modified":1690814114964},{"_id":"public/posts/37674.html","hash":"ab33dacea6194192f8da1b0bce1aefd491818f13","modified":1690814114964},{"_id":"public/posts/26325.html","hash":"58c1dfc87a0510efb2ced79f79622b0ed48431be","modified":1690814114964},{"_id":"public/posts/63398.html","hash":"603c6fd8c683fd5740e68316a6c93059a1143dbf","modified":1690814114964},{"_id":"public/posts/23609.html","hash":"7e5a263284ce15a20ff66bb7c2a38702974f59b8","modified":1690814114964},{"_id":"public/posts/33708.html","hash":"d13744870acd17f70d1a51e1eb55d9d97e2923f5","modified":1690814114964},{"_id":"public/posts/9964.html","hash":"d8c74c2249764d33684eef508419de63b80aaf22","modified":1690814114964},{"_id":"public/posts/42310.html","hash":"041db4b2a4db5b6f414ff5d3024b744794953f32","modified":1690814114964},{"_id":"public/posts/58122.html","hash":"5cee0f1370278fa2e5d74937fce1ebae4aaf8d63","modified":1690814114964},{"_id":"public/archives/index.html","hash":"aa4a32689d7b869bd927da597896d7306ae896f1","modified":1690814114964},{"_id":"public/archives/2023/index.html","hash":"ed1bde1b12acb76ee3dc3f1a760ad9327a1f0908","modified":1690814114964},{"_id":"public/archives/2023/07/index.html","hash":"57e1c79d4b46780c4705040ee36661b3074ae5e6","modified":1690814114964},{"_id":"public/index.html","hash":"1512a7721932f16b6e94cdb60b5049b48eceb2e8","modified":1690814114964},{"_id":"public/img/favicon.png","hash":"f17fd89a2e05a689c4f5481be9ea6b09f7b8d945","modified":1690814114964},{"_id":"public/img/avatar.jpg","hash":"bbf597f4a75a617bed638ac124502fd76068f62b","modified":1690814114964},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1690814114964},{"_id":"public/CNAME","hash":"0ba2ea8a346b2e193945de5bc8f9d9aa4a81461b","modified":1690814114964},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1690814114964},{"_id":"public/js/foot.js","hash":"c5462aab335dca72e6cc7e4427e3e4996b9357c5","modified":1690814114964},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1690814114964},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1690814114964},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1690814114964},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1690814114964},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1690814114964},{"_id":"public/css/index.css","hash":"b3e22c48b65075f4ee8c026344f026c25fe18c8d","modified":1690814114964},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1690814114964},{"_id":"public/js/jquery.js","hash":"0fa72756e48c33a6feeace1ffa5d790d58b53729","modified":1690814114964},{"_id":"public/css/LXGWZhenKai.ttf","hash":"3e173155b120631bbf5c7a7921308977bdd48cf2","modified":1690814114964}],"Category":[{"name":"coding","_id":"clkqz2ips00046wuj2bs2cmdw"},{"name":"历史","_id":"clkqz2iq0000r6wujcuwk38p3"}],"Data":[],"Page":[{"_content":"my blog","source":"README.md","raw":"my blog","date":"2023-07-25T13:19:14.793Z","updated":"2023-07-25T13:19:14.793Z","path":"README.html","title":"","comments":1,"layout":"page","_id":"clkqz2ipk00006wuj6y3n9w7k","content":"<p>my blog</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>my blog</p>\n"},{"title":"关于","date":"2023-07-15T01:31:31.000Z","_content":"\n<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，也会更加注重内容的排版布局\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果某篇文章对你有些帮助，那我的目的就达到了","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2023-07-15 09:31:31\n---\n\n<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，也会更加注重内容的排版布局\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果某篇文章对你有些帮助，那我的目的就达到了","updated":"2023-07-25T13:19:14.801Z","path":"about/index.html","comments":1,"layout":"page","_id":"clkqz2ipr00026wuj6hgjfwms","content":"<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，也会更加注重内容的排版布局\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果某篇文章对你有些帮助，那我的目的就达到了","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，也会更加注重内容的排版布局\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果某篇文章对你有些帮助，那我的目的就达到了"},{"title":"tags","date":"2023-07-15T01:31:31.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-07-15 09:31:31\ntype: \"tags\"\n---\n","updated":"2023-07-25T13:19:14.845Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clkqz2ipt00066wujdr8qfum0","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"_content":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","source":"css/custom.css","raw":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","date":"2023-07-25T13:19:14.845Z","updated":"2023-07-25T13:19:14.845Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"clkqz2ipu00076wujen1sb6i5","content":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","site":{"data":{}},"cover":false,"excerpt":"","more":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}"},{"title":"categories","date":"2023-07-14T17:44:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-07-15 01:44:20\ntype: \"categories\"\n---\n","updated":"2023-07-25T13:19:14.802Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clkqz2ipu00086wuj9giu8pof","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"juc","date":"2023-07-14T16:00:00.000Z","abbrlink":42310,"_content":"# 1、java多线程基本概念\n## 1.1、进程和线程\n\n1. **进程**\n- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 \n- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 \n- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） \n\n2. **线程**\n- 一个进程之内可以分为一到多个线程。 \n- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 \n- **Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器**\n## 1.2、并发和并行\n并发：线程轮流使用CPU\n并行：多核cpu下，多个核同时调度运行线程\n\n## 1.3、多线程的应用\n### 1.3.1、异步调用\n比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 \n### 1.3.2、提升效率\n充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。\n```java\n计算 1 花费 10 ms\n计算 2 花费 11 ms\n计算 3 花费 9 ms\n汇总需要 1 ms\n```\n\n- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms \n- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms \n\n> 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n\n# 2、java线程\n## 2.1、线程的创建\n### 2.1.1、直接使用Thread\n```java\n// 创建线程对象\nThread t = new Thread() {\n    public void run() {\n        // 要执行的任务\n    }\n};\n// 启动线程\nt.start();\n```\n### 2.1.2、使用 Runnable 配合 Thread \n```java\nRunnable runnable = new Runnable() {\n    public void run(){\n        // 要执行的任务\n    }\n};\n// 创建线程对象\nThread t = new Thread( runnable );\n// 启动线程\nt.start();\n```\njava8可用lambda精简\n```java\n// 创建任务对象\nRunnable task2 = () -> log.debug(\"hello\");\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nThread t2 = new Thread(task2, \"t2\");\nt2.start();\n```\n### 2.1.3、FutureTask 配合 Thread \nFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\n\n```java\n// 创建任务对象\nFutureTask<Integer> task3 = new FutureTask<>(() -> {\n    log.debug(\"hello\");\n    return 100;\n});\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nnew Thread(task3, \"t3\").start();\n\n// 主线程阻塞，同步等待 task 执行完毕的结果\nInteger result = task3.get();\nlog.debug(\"结果是:{}\", result);\n```\n## 2.2、查看进程线程\n### 2.2.1、windows\n\n1. tasklist 查看进程 \n2. taskkill 杀死进程 \n3. netstat -ano|findstr 8080 根据端口查看进程\n### 2.2.2、linux\n\n1. ps -fe 查看所有进程 \n2. kill 杀死进程\n3.  top -Hp <PID> 查看某个进程（PID）的所有线程 \n4. netstat -nlp|grep 8080 根据端口查看进程\n### 2.2.3、JDK\n\n1. jps 命令查看所有 Java 进程\n2.  jstack <PID> 查看某个 Java 进程（PID）的所有线程状态\n3.  jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）\n\n## 2.3、线程运行原理\n\n1. **线程创建**\n\n每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成\n，栈帧对应着每次方法调用所占内存\n\n2. **上下文切换**\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 \n> 线程的 cpu 时间片用完 \n> 垃圾回收 \n> 有更高优先级的线程需要运行 \n> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 \n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 \n\n##  2.4、start与run\n\n- 直接调用 run 是在主线程中执行了 run，没有启动新的线程 \n- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n\n## 2.5、sleep 与 yield \n\n1. **sleep**\n- 1. 调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞） \n- 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException \n- 3. 睡眠结束后的线程未必会立刻得到执行 \n\n2. **yield**\n- 1. 调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程 \n- 2. 具体的实现依赖于操作系统的任务调度器 \n\n## 2.6、join\njoin：t1调用t2的join方法，会先执行t2，然后执行t1\n如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间\n```java\nstatic int r = 0;\npublic static void main(String[] args) throws InterruptedException {\n    test1();\n}\n\nprivate static void test1() throws InterruptedException {\n    log.debug(\"开始\");\n    Thread t1 = new Thread(() -> {\n        log.debug(\"开始\");\n        sleep(1);\n        log.debug(\"结束\");\n        r = 10;\n    });\n    t1.start();\n    // t1.join();\n    log.debug(\"结果为:{}\", r);\n    log.debug(\"结束\");\n}\n```\n> 如果不加t1.join()结果为0，加上以后结果为1\n\n\n## 2.7、interrupt\n### 2.7.1、打断阻塞状态的线程\nsleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断\n```java\nprivate static void test1() throws InterruptedException {\n    Thread t1 = new Thread(()->{\n        sleep(1);\n    }, \"t1\");\n    t1.start();\n    sleep(0.5);\n    t1.interrupt();\n    log.debug(\" 打断状态: {}\", t1.isInterrupted());\n}\n```\n输出\n```java\njava.lang.InterruptedException: sleep interrupted\n     at java.lang.Thread.sleep(Native Method)\n     at java.lang.Thread.sleep(Thread.java:340)\n     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)\n     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)\n     at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)\n     at java.lang.Thread.run(Thread.java:745)\n21:18:10.374 [main] c.TestInterrupt - 打断状态: false\n```\n### 2.7.2、打断正常运行的线程\n打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）\n```java\nprivate static void test2() throws InterruptedException {\n    Thread t2 = new Thread(()->{\n        while(true) {\n            Thread current = Thread.currentThread();\n            boolean interrupted = current.isInterrupted();\n            if(interrupted) {\n                log.debug(\" 打断状态: {}\", interrupted);\n                break;\n            }\n        }\n    }, \"t2\");\n    t2.start();\n    sleep(0.5);\n    t2.interrupt();\n}\n```\n输出\n```java\n20:57:37.964 [t2] c.TestInterrupt - 打断状态: true \n```\n\n## 2.8、主线程与守护线程\n默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 \n\n例\n```java\nlog.debug(\"开始运行...\");\nThread t1 = new Thread(() -> {\n    log.debug(\"开始运行...\");\n    sleep(2);\n    log.debug(\"运行结束...\");\n}, \"daemon\");\n// 设置该线程为守护线程\nt1.setDaemon(true);\nt1.start();\n\nsleep(1);\nlog.debug(\"运行结束...\");\n```\n输出\n```java\n08:26:38.123 [main] c.TestDaemon - 开始运行... \n08:26:38.213 [daemon] c.TestDaemon - 开始运行... \n08:26:39.215 [main] c.TestDaemon - 运行结束...\n```\n\n> **注意 **\n> - 垃圾回收器线程就是一种守护线程 \n> - Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 \n\n\n## 2.9、线程状态\n| 状态   | 说明 |\n| --- | --- |\n| NEW | 初始状态:线程被创建，但还没有调用start()方法 |\n| RUNNABLE | 运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作\"运行\" |\n| BLOCKED | 阻塞状态:表示线程阻塞于锁 |\n| WAITING | 等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) |\n| TIMEWAITING | 超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的 |\n| TERMINATED | 终止状态:表示当前线程已经执行完毕 |\n\n![线程状态](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg)\n\n\n# 3、共享模型之管程\n管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的\n## 3.1、monitor\nMonitor 被翻译为**监视器**或**管程**\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针\n\n### 3.1.1、Monitor结构\n**结构**：owner  entryList  waitSet\n\n![monitor结构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg)\n\n\n### 3.1.2、Monitor原理\n（1）刚开始monitor中owner为null \n（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程 \n（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞 \n（4）t1执行完会唤醒entrylist中的某个线程（不公平）\n（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n## 3.2、java对象结构\n\n1. **对象头**\n\n包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）\n\n![java对象头](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg)\n\n\n2. **实例数据**\n\n实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息\n\n3. **对齐填充**\n\n对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。\n## 3.3、synchronized升级\n### 3.3.1、偏向锁\n> 使用场景：如果只有一个线程，就不需要每次的申请释放锁\n\n只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 \n### 3.3.2、轻量级锁\n> 使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化\n\n![轻量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg)\n\n\n\n1. 创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象\n2. 让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录\n3. 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁\n4. 如果 cas 失败，有两种情况  \n\n（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 \n（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）\n\n5. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一\n6. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 \n\n（1）成功，则解锁成功 \n（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\n### 3.3.3、重量级锁\n> 使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁\n\n![重量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg)\n\n\n1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\n2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 \n\n（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 \n（2）然后自己进入 Monitor 的 EntryList阻塞队列\n\n3. 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）\n\n> 调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n### 3.3.4、自旋锁\n重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)\n\n## 3.4、wait/notify\nOwner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争\n\n### 3.4.1、sleep和wait的区别？\n\n1.  sleep 是 Thread 方法，而 wait 是 Object 的方法 \n2.  sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 \n3.  sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 \n\n## 3.5、park/unpark\n它们是 LockSupport 类中的方法\n```java\n// 暂停当前线程\nLockSupport.park(); \n// 恢复某个线程的运行\nLockSupport.unpark(暂停线程对象)\n```\n\n### 3.5.1、与 Object 的 wait & notify 相比 \n\n- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\n- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 \n- park & unpark 可以先 unpark，而 wait & notify 不能先 notify \n\n### 3.5.2、原理\n每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex \n\n核心部分是counter，我们可以理解为一个标记位。\n当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。\n当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。\n## 3.6、死锁\n多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁\n### 3.6.1、死锁的必要条件\n\n1. 互斥条件：一个资源一次只能被一个进程使用\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放\n3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺\n4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系\n### 3.6.2、死锁的实现\n```java\n/**\n * 实现一个死锁\n * 如果把lock(target, owner);放到上面则不会死锁\n */\npublic class DeadLock {\n    public static void main(String[] args) throws InterruptedException {\n        final Object owner = new Object();\n        final Object target = new Object();\n        //开启一个新线程\n        new Thread(() -> {\n            try {\n                lock(owner, target);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        //主线程\n        lock(target, owner);\n    }\n    public static void lock(Object owner, Object target) throws InterruptedException {\n        synchronized (owner) {\n            Thread.sleep(1000);\n            synchronized (target) {\n                System.out.println(\"success\");\n            }\n        }\n    }\n}\n```\n### 3.6.3、定位死锁\n检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁\n### 3.6.4、哲学家就餐问题\n\n![哲学家就餐问题](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg)\n\n\n有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 \n\n1. 筷子类\n\n```java\nclass Chopstick {\n    String name;\n    \n    public Chopstick(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return \"筷子{\" + name + '}';\n    }\n}\n```\n\n2. 哲学家类\n\n```java\nclass Philosopher extends Thread {\n    Chopstick left;\n    Chopstick right;\n    \n    public Philosopher(String name, Chopstick left, Chopstick right) {\n        super(name);\n        this.left = left;\n        this.right = right;\n    }\n    \n    private void eat() {\n        log.debug(\"eating...\");\n        Sleeper.sleep(1);\n    }\n    \n    @Override\n    public void run() {\n        while (true) {\n            // 获得左手筷子\n            synchronized (left) {\n                // 获得右手筷子\n                synchronized (right) {\n                    // 吃饭\n                    eat();\n                }\n                // 放下右手筷子\n            }\n            // 放下左手筷子\n        }\n    }\n}\n```\n\n3. 就餐\n\n```java\nChopstick c1 = new Chopstick(\"1\");\nChopstick c2 = new Chopstick(\"2\");\nChopstick c3 = new Chopstick(\"3\");\nChopstick c4 = new Chopstick(\"4\");\nChopstick c5 = new Chopstick(\"5\");\n\nnew Philosopher(\"苏格拉底\", c1, c2).start();\nnew Philosopher(\"柏拉图\", c2, c3).start();\nnew Philosopher(\"亚里士多德\", c3, c4).start();\nnew Philosopher(\"赫拉克利特\", c4, c5).start();\nnew Philosopher(\"阿基米德\", c5, c1).start();\n```\n## 3.7、活锁\n两个线程互相改变对方的结束条件导致谁也无法结束\n> eg：共享变量count为10000, t1线程while count > 0, count-- ;t2线程while count < 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行\n\n\n## 3.8、**ReentrantLock**\n相对于 synchronized 它具备如下特点 \n\n1. 可中断 \n2. 可以设置超时时间 \n3. 可以设置为公平锁 （默认不公平）\n4. 支持多个条件变量 \n\n与 synchronized 一样，都支持可重入 \n# 4、共享模型之内存\n## 4.1、java内存模型（jmm）\nJava内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本\n## 4.2、线程安全性的三个体现\n**原子性**：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）\n**可见性**：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）\n**有序性**：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）\n# 5、共享模型之无锁\n## 5.1、CAS\n### 5.1.1、CAS基本概念\nCAS是所有原子类的底层原理，乐观锁主要采用CAS算法。\nCAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。\n> 1. CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性\n> 2. CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果\n\n\n### 5.1.2、CAS问题\n多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。\n\n**解决方案：**\n使用AtomicStampReference \nAtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验\n\n## 5.2、volatile\n### 5.2.1、如何保证可见性和有序性\n\n1. **保证可见性（缓存一致性协议MESI）**\n\n首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用**MESI协议**保证缓存一致性。\n如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu**总线嗅探机制**监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值\n\n> **M 修改** (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中\n**E 独享、互斥** (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。\n**S 共享** (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态\n**I 无效** (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态\n\n\n> 涉及到的指令\nlock(锁定)：将一个变量标识为被一个线程独占状态\nstore(存储)：作用于工作内存的变量,将变量传输到主内存中\nwrite(写入)：将store入主内存的变量,放入到主内存的变量中\n\n\n2. **保证有序性（禁止指令重排优化）**\n\n多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的\n内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序\n\n## 5.3、原子类\n| 类型   | 具体类 |\n| --- | --- |\n| Atomic 基本类型原子类   | AtomicInteger AtomicLong AtomicBoolean |\n| AtomicArray 数组类型原子类 | AtomicIntegerArray  AtomicLongArray AtomicReferenceArray |\n| AtomicReference 引用类型原子类 | AtomicReference AtomicStampedReference AtomicMarkableReference |\n| AtomicFieldUpdate 升级类型原子类 | AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater |\n\n\n# 6、共享模式之工具\n## 6.1、线程池\n### 6.1.1、**ThreadPoolExecutor**\n\n1. **构造方法**\n\n通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建\n\n> 1. corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。\n> 2. maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。\n> 3. keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。\n> 4. unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n> 5. workQueue：缓存队列，用来存放等待被执行的任务。\n> 6. threadFactory 线程工厂\n> 7. handler：拒绝策略\n（1）abortPolicy：抛出异常（默认）\n（2）discardPolicy：放弃本次任务\n（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代\n（4）callerrunPolicy：让调用者运行任务\n\n\n2. **工作原理**\n\n如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n如果当前线程池中正在执行任务的的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；\n如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；\n如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理\n### 6.1.2、Executors类中提供的工厂方法\n根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池\n\n1. **newFixedThreadPool**\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n> 特点：\n> - 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 \n> - 阻塞队列是无界的，可以放任意数量的任务 \n> \n评价：\n> 适用于任务量已知，相对耗时的任务\n\n\n2. **newCachedThreadPool**\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n> 特点 \n> - 核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 \n>    - 全部都是救急线程（60s 后可以回收）\n>    - 救急线程可以无限创建 \n> - 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）\n> \n评价：\n> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程\n> 适合任务数比较密集，但每个任务执行时间较短的情况\n\n\n3. newSingleThreadExecutor\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n使用场景： \n希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。\n任务执行完毕，这唯一的线程也不会被释放。 \n\n### 6.1.3、创建多大的线程池\n\n- 过小会导致程序不能充分地利用系统资源、容易导致饥饿 \n- 过大会导致更多的线程上下文切换，影响性能\n\n1. **CPU 密集型运算 **\n\n通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 \n\n2. **I/O密集型**\n\nCPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 \n经验公式如下 ：\n`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间` \n\n## 6.2、锁\n### 6.2.1、AQS\n\n1. 基本概念\n\nAbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...\n\n2. 原理 \n\n它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）\n\n3. 实现\n\n自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n> **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的\n\n### 6.2.2、ReentrantLock\n**实现原理**\n\n1. 首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能\n2. 它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法\n3. 加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列\n4. 持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）\n\n**条件变量——Condition**\nCondition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程\n### 6.2.3、**ReentrantReadWriteLock**\n#### 4.2.3.1、ReentrantReadWriteLock基本概念\nReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用\n#### 4.2.3.2、锁获取过程\n\n1. 获取读锁\n\n如果写锁没有被另一个线程持有，则获取读锁并立即返回。     \n \t如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。\n\n4. 获取写入锁\n\n如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *\n如果当前线程持有写锁，则将写锁计数 +1，然后返回\n如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。\n\n#### 4.2.3.3、常见问题\n\n1. **读锁和写锁的可重入性**\n\n在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加\n\n2. **当前线程获取锁失败，被阻塞的后续操作是什么？**\n\n获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁\n\n3. **锁降级是怎么降级的？**\n\n在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）\n\n## 6.3、工具\n### 6.3.1、Semaphore\n\n1. **概念**\n\nSemaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）\n```java\npublic class DataSourcePool {\n \n    private final CopyOnWriteArrayList<Connection> list;\n    \n    //用到了信号量\n    private final Semaphore semaphore;\n \n    public DataSourcePool(int size) throws SQLException {\n        list = new CopyOnWriteArrayList<>();\n        semaphore = new Semaphore(size);\n        for (int i=0;i<size;i++){\n            Connection connection = DriverManager.getConnection(\"url\");\n            list.add(connection);\n        }\n    }\n    \n    //使用同步方法获取\n    public synchronized Connection getConnection() throws InterruptedException {\n        //先将当前信号量-1，如果为0，将阻塞\n        semaphore.acquire();\n        return list.remove(0);\n    }\n \n    public synchronized void  close(Connection connection){\n        //信号量+1\n        semaphore.release();\n        list.add(connection);\n    }\n}\n```\n\n2. **原理**\n\nSemaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n\n1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。\n2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state=state-1。state<0,令牌数量不足，加入阻塞队列。>=0则获取成功\n3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state=state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程\n### 6.3.2、CountdownLatch\n\n1. **概念**\n\nCountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n    ExecutorService service = Executors.newFixedThreadPool(4);\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(()->{\n        try {\n            log.debug(\"waiting...\");\n            latch.await();\n            log.debug(\"wait end...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n    \n}\n```\n```java\n18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting... \n18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2 \n18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end...\n```\n\n2. **原理**\n\nCountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n1、初始化CountDownLatch实际就是设置了AQS的state为计数的值\n2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值\n3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试\n\n3. **和join的区别？**\n\nCountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成\n\n### 6.3.3、CyclicBarrier\n\n1. **概念**\n\nCyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行\n实现王者荣耀10个人都加载完才开始游戏\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        int count = 10;\n        CyclicBarrier cb = new CyclicBarrier(count, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"全部加载完毕\");\n            }\n        });\n        ExecutorService executorService = Executors.newFixedThreadPool(count);\n        for (int x = 0; x < count; x++) {\n            executorService.execute(new Worker(cb));\n        }\n    }\n}\n\nclass Worker extends Thread {\n    CyclicBarrier cyclicBarrier;\n    public Worker(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" 已加载完\");\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java\npool-1-thread-1 已加载完\npool-1-thread-5 已加载完\npool-1-thread-4 已加载完\npool-1-thread-3 已加载完\npool-1-thread-6 已加载完\npool-1-thread-2 已加载完\npool-1-thread-7 已加载完\npool-1-thread-8 已加载完\npool-1-thread-9 已加载完\npool-1-thread-10 已加载完\n全部加载完毕\n\n```\n\n2. **原理**\n\n1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count\n2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；\n3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；\n4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；\n5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。\n\n## 6.4、线程安全集合类\n### 6.4.1、概述\n\t\t\t\t\t\t  \n线程安全实现类有三类：\n\n1. 遗留的线程安全集合如 Hashtable ， Vector \n2. 使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）\n\n>    - Collections.synchronizedCollection \n>    - Collections.synchronizedList \n>    - Collections.synchronizedMap \n>    - Collections.synchronizedSet \n>    - Collections.synchronizedNavigableMap \n>    - Collections.synchronizedNavigableSet\n>    - Collections.synchronizedSortedMap \n>    - Collections.synchronizedSortedSet \n\n4. JUC下的安全集合: Blocking、CopyOnWrite、Concurrent \n\n> - Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)\n> - CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)\n> - Concurrent 类型的容器 （内部很多操作使用cas优化）\n>    - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 \n>    - 弱一致性 \n>       - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 \n>       - 求大小弱一致性，size 操作未必是 100% 准确 \n>       - 读取弱一致性 \n\n> 遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历\n\n### 6.4.2、concurrentHashMap\n**JDK1.8前**\nConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。\n\n元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部\n\n锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数\n\n\n> ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表\n\n\n**JDK1.8**\n\n在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全\n\n1. 初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 \n2. 插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 \n3. 扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 \n4. 查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。\n\n\n\n### 6.4.3、BlockingQueue\n主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue \n\n1. 区别\n\n（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表\n（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）\n（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现\n\n### 6.4.4、ConcurrentLinkedQueue \nConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）\n\n### 6.4.5、CopyOnWriteArrayList\n\n1. 首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行\n2. 写数据时会加ReentLocak锁，防止并发写入丢失数据的问题\n3. 写操作结束后会把原数组指向新数组\n4. CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景\n\n\n","source":"_posts/JUC.md","raw":"---\ntitle: juc\ndate: 2023/07/15\ncategories:\n  - coding\ntags:\n  - juc\n  - 多线程\n  - 并发编程\nabbrlink: 42310\n---\n# 1、java多线程基本概念\n## 1.1、进程和线程\n\n1. **进程**\n- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 \n- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 \n- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） \n\n2. **线程**\n- 一个进程之内可以分为一到多个线程。 \n- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 \n- **Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器**\n## 1.2、并发和并行\n并发：线程轮流使用CPU\n并行：多核cpu下，多个核同时调度运行线程\n\n## 1.3、多线程的应用\n### 1.3.1、异步调用\n比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 \n### 1.3.2、提升效率\n充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。\n```java\n计算 1 花费 10 ms\n计算 2 花费 11 ms\n计算 3 花费 9 ms\n汇总需要 1 ms\n```\n\n- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms \n- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms \n\n> 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n\n# 2、java线程\n## 2.1、线程的创建\n### 2.1.1、直接使用Thread\n```java\n// 创建线程对象\nThread t = new Thread() {\n    public void run() {\n        // 要执行的任务\n    }\n};\n// 启动线程\nt.start();\n```\n### 2.1.2、使用 Runnable 配合 Thread \n```java\nRunnable runnable = new Runnable() {\n    public void run(){\n        // 要执行的任务\n    }\n};\n// 创建线程对象\nThread t = new Thread( runnable );\n// 启动线程\nt.start();\n```\njava8可用lambda精简\n```java\n// 创建任务对象\nRunnable task2 = () -> log.debug(\"hello\");\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nThread t2 = new Thread(task2, \"t2\");\nt2.start();\n```\n### 2.1.3、FutureTask 配合 Thread \nFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\n\n```java\n// 创建任务对象\nFutureTask<Integer> task3 = new FutureTask<>(() -> {\n    log.debug(\"hello\");\n    return 100;\n});\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nnew Thread(task3, \"t3\").start();\n\n// 主线程阻塞，同步等待 task 执行完毕的结果\nInteger result = task3.get();\nlog.debug(\"结果是:{}\", result);\n```\n## 2.2、查看进程线程\n### 2.2.1、windows\n\n1. tasklist 查看进程 \n2. taskkill 杀死进程 \n3. netstat -ano|findstr 8080 根据端口查看进程\n### 2.2.2、linux\n\n1. ps -fe 查看所有进程 \n2. kill 杀死进程\n3.  top -Hp <PID> 查看某个进程（PID）的所有线程 \n4. netstat -nlp|grep 8080 根据端口查看进程\n### 2.2.3、JDK\n\n1. jps 命令查看所有 Java 进程\n2.  jstack <PID> 查看某个 Java 进程（PID）的所有线程状态\n3.  jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）\n\n## 2.3、线程运行原理\n\n1. **线程创建**\n\n每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成\n，栈帧对应着每次方法调用所占内存\n\n2. **上下文切换**\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 \n> 线程的 cpu 时间片用完 \n> 垃圾回收 \n> 有更高优先级的线程需要运行 \n> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 \n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 \n\n##  2.4、start与run\n\n- 直接调用 run 是在主线程中执行了 run，没有启动新的线程 \n- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n\n## 2.5、sleep 与 yield \n\n1. **sleep**\n- 1. 调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞） \n- 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException \n- 3. 睡眠结束后的线程未必会立刻得到执行 \n\n2. **yield**\n- 1. 调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程 \n- 2. 具体的实现依赖于操作系统的任务调度器 \n\n## 2.6、join\njoin：t1调用t2的join方法，会先执行t2，然后执行t1\n如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间\n```java\nstatic int r = 0;\npublic static void main(String[] args) throws InterruptedException {\n    test1();\n}\n\nprivate static void test1() throws InterruptedException {\n    log.debug(\"开始\");\n    Thread t1 = new Thread(() -> {\n        log.debug(\"开始\");\n        sleep(1);\n        log.debug(\"结束\");\n        r = 10;\n    });\n    t1.start();\n    // t1.join();\n    log.debug(\"结果为:{}\", r);\n    log.debug(\"结束\");\n}\n```\n> 如果不加t1.join()结果为0，加上以后结果为1\n\n\n## 2.7、interrupt\n### 2.7.1、打断阻塞状态的线程\nsleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断\n```java\nprivate static void test1() throws InterruptedException {\n    Thread t1 = new Thread(()->{\n        sleep(1);\n    }, \"t1\");\n    t1.start();\n    sleep(0.5);\n    t1.interrupt();\n    log.debug(\" 打断状态: {}\", t1.isInterrupted());\n}\n```\n输出\n```java\njava.lang.InterruptedException: sleep interrupted\n     at java.lang.Thread.sleep(Native Method)\n     at java.lang.Thread.sleep(Thread.java:340)\n     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)\n     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)\n     at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)\n     at java.lang.Thread.run(Thread.java:745)\n21:18:10.374 [main] c.TestInterrupt - 打断状态: false\n```\n### 2.7.2、打断正常运行的线程\n打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）\n```java\nprivate static void test2() throws InterruptedException {\n    Thread t2 = new Thread(()->{\n        while(true) {\n            Thread current = Thread.currentThread();\n            boolean interrupted = current.isInterrupted();\n            if(interrupted) {\n                log.debug(\" 打断状态: {}\", interrupted);\n                break;\n            }\n        }\n    }, \"t2\");\n    t2.start();\n    sleep(0.5);\n    t2.interrupt();\n}\n```\n输出\n```java\n20:57:37.964 [t2] c.TestInterrupt - 打断状态: true \n```\n\n## 2.8、主线程与守护线程\n默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 \n\n例\n```java\nlog.debug(\"开始运行...\");\nThread t1 = new Thread(() -> {\n    log.debug(\"开始运行...\");\n    sleep(2);\n    log.debug(\"运行结束...\");\n}, \"daemon\");\n// 设置该线程为守护线程\nt1.setDaemon(true);\nt1.start();\n\nsleep(1);\nlog.debug(\"运行结束...\");\n```\n输出\n```java\n08:26:38.123 [main] c.TestDaemon - 开始运行... \n08:26:38.213 [daemon] c.TestDaemon - 开始运行... \n08:26:39.215 [main] c.TestDaemon - 运行结束...\n```\n\n> **注意 **\n> - 垃圾回收器线程就是一种守护线程 \n> - Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 \n\n\n## 2.9、线程状态\n| 状态   | 说明 |\n| --- | --- |\n| NEW | 初始状态:线程被创建，但还没有调用start()方法 |\n| RUNNABLE | 运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作\"运行\" |\n| BLOCKED | 阻塞状态:表示线程阻塞于锁 |\n| WAITING | 等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) |\n| TIMEWAITING | 超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的 |\n| TERMINATED | 终止状态:表示当前线程已经执行完毕 |\n\n![线程状态](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg)\n\n\n# 3、共享模型之管程\n管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的\n## 3.1、monitor\nMonitor 被翻译为**监视器**或**管程**\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针\n\n### 3.1.1、Monitor结构\n**结构**：owner  entryList  waitSet\n\n![monitor结构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg)\n\n\n### 3.1.2、Monitor原理\n（1）刚开始monitor中owner为null \n（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程 \n（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞 \n（4）t1执行完会唤醒entrylist中的某个线程（不公平）\n（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n## 3.2、java对象结构\n\n1. **对象头**\n\n包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）\n\n![java对象头](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg)\n\n\n2. **实例数据**\n\n实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息\n\n3. **对齐填充**\n\n对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。\n## 3.3、synchronized升级\n### 3.3.1、偏向锁\n> 使用场景：如果只有一个线程，就不需要每次的申请释放锁\n\n只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 \n### 3.3.2、轻量级锁\n> 使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化\n\n![轻量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg)\n\n\n\n1. 创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象\n2. 让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录\n3. 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁\n4. 如果 cas 失败，有两种情况  \n\n（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 \n（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）\n\n5. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一\n6. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 \n\n（1）成功，则解锁成功 \n（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\n### 3.3.3、重量级锁\n> 使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁\n\n![重量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg)\n\n\n1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\n2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 \n\n（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 \n（2）然后自己进入 Monitor 的 EntryList阻塞队列\n\n3. 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）\n\n> 调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n### 3.3.4、自旋锁\n重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)\n\n## 3.4、wait/notify\nOwner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争\n\n### 3.4.1、sleep和wait的区别？\n\n1.  sleep 是 Thread 方法，而 wait 是 Object 的方法 \n2.  sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 \n3.  sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 \n\n## 3.5、park/unpark\n它们是 LockSupport 类中的方法\n```java\n// 暂停当前线程\nLockSupport.park(); \n// 恢复某个线程的运行\nLockSupport.unpark(暂停线程对象)\n```\n\n### 3.5.1、与 Object 的 wait & notify 相比 \n\n- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\n- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 \n- park & unpark 可以先 unpark，而 wait & notify 不能先 notify \n\n### 3.5.2、原理\n每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex \n\n核心部分是counter，我们可以理解为一个标记位。\n当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。\n当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。\n## 3.6、死锁\n多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁\n### 3.6.1、死锁的必要条件\n\n1. 互斥条件：一个资源一次只能被一个进程使用\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放\n3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺\n4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系\n### 3.6.2、死锁的实现\n```java\n/**\n * 实现一个死锁\n * 如果把lock(target, owner);放到上面则不会死锁\n */\npublic class DeadLock {\n    public static void main(String[] args) throws InterruptedException {\n        final Object owner = new Object();\n        final Object target = new Object();\n        //开启一个新线程\n        new Thread(() -> {\n            try {\n                lock(owner, target);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        //主线程\n        lock(target, owner);\n    }\n    public static void lock(Object owner, Object target) throws InterruptedException {\n        synchronized (owner) {\n            Thread.sleep(1000);\n            synchronized (target) {\n                System.out.println(\"success\");\n            }\n        }\n    }\n}\n```\n### 3.6.3、定位死锁\n检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁\n### 3.6.4、哲学家就餐问题\n\n![哲学家就餐问题](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg)\n\n\n有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 \n\n1. 筷子类\n\n```java\nclass Chopstick {\n    String name;\n    \n    public Chopstick(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return \"筷子{\" + name + '}';\n    }\n}\n```\n\n2. 哲学家类\n\n```java\nclass Philosopher extends Thread {\n    Chopstick left;\n    Chopstick right;\n    \n    public Philosopher(String name, Chopstick left, Chopstick right) {\n        super(name);\n        this.left = left;\n        this.right = right;\n    }\n    \n    private void eat() {\n        log.debug(\"eating...\");\n        Sleeper.sleep(1);\n    }\n    \n    @Override\n    public void run() {\n        while (true) {\n            // 获得左手筷子\n            synchronized (left) {\n                // 获得右手筷子\n                synchronized (right) {\n                    // 吃饭\n                    eat();\n                }\n                // 放下右手筷子\n            }\n            // 放下左手筷子\n        }\n    }\n}\n```\n\n3. 就餐\n\n```java\nChopstick c1 = new Chopstick(\"1\");\nChopstick c2 = new Chopstick(\"2\");\nChopstick c3 = new Chopstick(\"3\");\nChopstick c4 = new Chopstick(\"4\");\nChopstick c5 = new Chopstick(\"5\");\n\nnew Philosopher(\"苏格拉底\", c1, c2).start();\nnew Philosopher(\"柏拉图\", c2, c3).start();\nnew Philosopher(\"亚里士多德\", c3, c4).start();\nnew Philosopher(\"赫拉克利特\", c4, c5).start();\nnew Philosopher(\"阿基米德\", c5, c1).start();\n```\n## 3.7、活锁\n两个线程互相改变对方的结束条件导致谁也无法结束\n> eg：共享变量count为10000, t1线程while count > 0, count-- ;t2线程while count < 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行\n\n\n## 3.8、**ReentrantLock**\n相对于 synchronized 它具备如下特点 \n\n1. 可中断 \n2. 可以设置超时时间 \n3. 可以设置为公平锁 （默认不公平）\n4. 支持多个条件变量 \n\n与 synchronized 一样，都支持可重入 \n# 4、共享模型之内存\n## 4.1、java内存模型（jmm）\nJava内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本\n## 4.2、线程安全性的三个体现\n**原子性**：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）\n**可见性**：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）\n**有序性**：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）\n# 5、共享模型之无锁\n## 5.1、CAS\n### 5.1.1、CAS基本概念\nCAS是所有原子类的底层原理，乐观锁主要采用CAS算法。\nCAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。\n> 1. CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性\n> 2. CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果\n\n\n### 5.1.2、CAS问题\n多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。\n\n**解决方案：**\n使用AtomicStampReference \nAtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验\n\n## 5.2、volatile\n### 5.2.1、如何保证可见性和有序性\n\n1. **保证可见性（缓存一致性协议MESI）**\n\n首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用**MESI协议**保证缓存一致性。\n如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu**总线嗅探机制**监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值\n\n> **M 修改** (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中\n**E 独享、互斥** (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。\n**S 共享** (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态\n**I 无效** (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态\n\n\n> 涉及到的指令\nlock(锁定)：将一个变量标识为被一个线程独占状态\nstore(存储)：作用于工作内存的变量,将变量传输到主内存中\nwrite(写入)：将store入主内存的变量,放入到主内存的变量中\n\n\n2. **保证有序性（禁止指令重排优化）**\n\n多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的\n内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序\n\n## 5.3、原子类\n| 类型   | 具体类 |\n| --- | --- |\n| Atomic 基本类型原子类   | AtomicInteger AtomicLong AtomicBoolean |\n| AtomicArray 数组类型原子类 | AtomicIntegerArray  AtomicLongArray AtomicReferenceArray |\n| AtomicReference 引用类型原子类 | AtomicReference AtomicStampedReference AtomicMarkableReference |\n| AtomicFieldUpdate 升级类型原子类 | AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater |\n\n\n# 6、共享模式之工具\n## 6.1、线程池\n### 6.1.1、**ThreadPoolExecutor**\n\n1. **构造方法**\n\n通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建\n\n> 1. corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。\n> 2. maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。\n> 3. keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。\n> 4. unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n> 5. workQueue：缓存队列，用来存放等待被执行的任务。\n> 6. threadFactory 线程工厂\n> 7. handler：拒绝策略\n（1）abortPolicy：抛出异常（默认）\n（2）discardPolicy：放弃本次任务\n（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代\n（4）callerrunPolicy：让调用者运行任务\n\n\n2. **工作原理**\n\n如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n如果当前线程池中正在执行任务的的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；\n如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；\n如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理\n### 6.1.2、Executors类中提供的工厂方法\n根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池\n\n1. **newFixedThreadPool**\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n> 特点：\n> - 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 \n> - 阻塞队列是无界的，可以放任意数量的任务 \n> \n评价：\n> 适用于任务量已知，相对耗时的任务\n\n\n2. **newCachedThreadPool**\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n> 特点 \n> - 核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 \n>    - 全部都是救急线程（60s 后可以回收）\n>    - 救急线程可以无限创建 \n> - 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）\n> \n评价：\n> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程\n> 适合任务数比较密集，但每个任务执行时间较短的情况\n\n\n3. newSingleThreadExecutor\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n使用场景： \n希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。\n任务执行完毕，这唯一的线程也不会被释放。 \n\n### 6.1.3、创建多大的线程池\n\n- 过小会导致程序不能充分地利用系统资源、容易导致饥饿 \n- 过大会导致更多的线程上下文切换，影响性能\n\n1. **CPU 密集型运算 **\n\n通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 \n\n2. **I/O密集型**\n\nCPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 \n经验公式如下 ：\n`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间` \n\n## 6.2、锁\n### 6.2.1、AQS\n\n1. 基本概念\n\nAbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...\n\n2. 原理 \n\n它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）\n\n3. 实现\n\n自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n> **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的\n\n### 6.2.2、ReentrantLock\n**实现原理**\n\n1. 首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能\n2. 它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法\n3. 加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列\n4. 持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）\n\n**条件变量——Condition**\nCondition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程\n### 6.2.3、**ReentrantReadWriteLock**\n#### 4.2.3.1、ReentrantReadWriteLock基本概念\nReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用\n#### 4.2.3.2、锁获取过程\n\n1. 获取读锁\n\n如果写锁没有被另一个线程持有，则获取读锁并立即返回。     \n \t如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。\n\n4. 获取写入锁\n\n如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *\n如果当前线程持有写锁，则将写锁计数 +1，然后返回\n如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。\n\n#### 4.2.3.3、常见问题\n\n1. **读锁和写锁的可重入性**\n\n在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加\n\n2. **当前线程获取锁失败，被阻塞的后续操作是什么？**\n\n获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁\n\n3. **锁降级是怎么降级的？**\n\n在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）\n\n## 6.3、工具\n### 6.3.1、Semaphore\n\n1. **概念**\n\nSemaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）\n```java\npublic class DataSourcePool {\n \n    private final CopyOnWriteArrayList<Connection> list;\n    \n    //用到了信号量\n    private final Semaphore semaphore;\n \n    public DataSourcePool(int size) throws SQLException {\n        list = new CopyOnWriteArrayList<>();\n        semaphore = new Semaphore(size);\n        for (int i=0;i<size;i++){\n            Connection connection = DriverManager.getConnection(\"url\");\n            list.add(connection);\n        }\n    }\n    \n    //使用同步方法获取\n    public synchronized Connection getConnection() throws InterruptedException {\n        //先将当前信号量-1，如果为0，将阻塞\n        semaphore.acquire();\n        return list.remove(0);\n    }\n \n    public synchronized void  close(Connection connection){\n        //信号量+1\n        semaphore.release();\n        list.add(connection);\n    }\n}\n```\n\n2. **原理**\n\nSemaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n\n1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。\n2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state=state-1。state<0,令牌数量不足，加入阻塞队列。>=0则获取成功\n3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state=state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程\n### 6.3.2、CountdownLatch\n\n1. **概念**\n\nCountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n    ExecutorService service = Executors.newFixedThreadPool(4);\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(()->{\n        try {\n            log.debug(\"waiting...\");\n            latch.await();\n            log.debug(\"wait end...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n    \n}\n```\n```java\n18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting... \n18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2 \n18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end...\n```\n\n2. **原理**\n\nCountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n1、初始化CountDownLatch实际就是设置了AQS的state为计数的值\n2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值\n3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试\n\n3. **和join的区别？**\n\nCountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成\n\n### 6.3.3、CyclicBarrier\n\n1. **概念**\n\nCyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行\n实现王者荣耀10个人都加载完才开始游戏\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        int count = 10;\n        CyclicBarrier cb = new CyclicBarrier(count, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"全部加载完毕\");\n            }\n        });\n        ExecutorService executorService = Executors.newFixedThreadPool(count);\n        for (int x = 0; x < count; x++) {\n            executorService.execute(new Worker(cb));\n        }\n    }\n}\n\nclass Worker extends Thread {\n    CyclicBarrier cyclicBarrier;\n    public Worker(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" 已加载完\");\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java\npool-1-thread-1 已加载完\npool-1-thread-5 已加载完\npool-1-thread-4 已加载完\npool-1-thread-3 已加载完\npool-1-thread-6 已加载完\npool-1-thread-2 已加载完\npool-1-thread-7 已加载完\npool-1-thread-8 已加载完\npool-1-thread-9 已加载完\npool-1-thread-10 已加载完\n全部加载完毕\n\n```\n\n2. **原理**\n\n1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count\n2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；\n3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；\n4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；\n5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。\n\n## 6.4、线程安全集合类\n### 6.4.1、概述\n\t\t\t\t\t\t  \n线程安全实现类有三类：\n\n1. 遗留的线程安全集合如 Hashtable ， Vector \n2. 使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）\n\n>    - Collections.synchronizedCollection \n>    - Collections.synchronizedList \n>    - Collections.synchronizedMap \n>    - Collections.synchronizedSet \n>    - Collections.synchronizedNavigableMap \n>    - Collections.synchronizedNavigableSet\n>    - Collections.synchronizedSortedMap \n>    - Collections.synchronizedSortedSet \n\n4. JUC下的安全集合: Blocking、CopyOnWrite、Concurrent \n\n> - Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)\n> - CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)\n> - Concurrent 类型的容器 （内部很多操作使用cas优化）\n>    - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 \n>    - 弱一致性 \n>       - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 \n>       - 求大小弱一致性，size 操作未必是 100% 准确 \n>       - 读取弱一致性 \n\n> 遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历\n\n### 6.4.2、concurrentHashMap\n**JDK1.8前**\nConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。\n\n元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部\n\n锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数\n\n\n> ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表\n\n\n**JDK1.8**\n\n在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全\n\n1. 初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 \n2. 插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 \n3. 扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 \n4. 查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。\n\n\n\n### 6.4.3、BlockingQueue\n主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue \n\n1. 区别\n\n（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表\n（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）\n（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现\n\n### 6.4.4、ConcurrentLinkedQueue \nConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）\n\n### 6.4.5、CopyOnWriteArrayList\n\n1. 首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行\n2. 写数据时会加ReentLocak锁，防止并发写入丢失数据的问题\n3. 写操作结束后会把原数组指向新数组\n4. CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景\n\n\n","slug":"JUC","published":1,"updated":"2023-07-25T13:19:14.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkqz2ipo00016wujfu6w1t53","content":"<h1 id=\"1、java多线程基本概念\"><a href=\"#1、java多线程基本概念\" class=\"headerlink\" title=\"1、java多线程基本概念\"></a>1、java多线程基本概念</h1><h2 id=\"1-1、进程和线程\"><a href=\"#1-1、进程和线程\" class=\"headerlink\" title=\"1.1、进程和线程\"></a>1.1、进程和线程</h2><ol>\n<li><strong>进程</strong></li>\n</ol>\n<ul>\n<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li>\n<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>\n<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>\n</ul>\n<ol start=\"2\">\n<li><strong>线程</strong></li>\n</ol>\n<ul>\n<li>一个进程之内可以分为一到多个线程。 </li>\n<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li>\n<li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li>\n</ul>\n<h2 id=\"1-2、并发和并行\"><a href=\"#1-2、并发和并行\" class=\"headerlink\" title=\"1.2、并发和并行\"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p>\n<h2 id=\"1-3、多线程的应用\"><a href=\"#1-3、多线程的应用\" class=\"headerlink\" title=\"1.3、多线程的应用\"></a>1.3、多线程的应用</h2><h3 id=\"1-3-1、异步调用\"><a href=\"#1-3-1、异步调用\" class=\"headerlink\" title=\"1.3.1、异步调用\"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p>\n<h3 id=\"1-3-2、提升效率\"><a href=\"#1-3-2、提升效率\" class=\"headerlink\" title=\"1.3.2、提升效率\"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算 <span class=\"number\">1</span> 花费 <span class=\"number\">10</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">2</span> 花费 <span class=\"number\">11</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">3</span> 花费 <span class=\"number\">9</span> ms</span><br><span class=\"line\">汇总需要 <span class=\"number\">1</span> ms</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li>\n<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms</li>\n</ul>\n<blockquote>\n<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>\n</blockquote>\n<h1 id=\"2、java线程\"><a href=\"#2、java线程\" class=\"headerlink\" title=\"2、java线程\"></a>2、java线程</h1><h2 id=\"2-1、线程的创建\"><a href=\"#2-1、线程的创建\" class=\"headerlink\" title=\"2.1、线程的创建\"></a>2.1、线程的创建</h2><h3 id=\"2-1-1、直接使用Thread\"><a href=\"#2-1-1、直接使用Thread\" class=\"headerlink\" title=\"2.1.1、直接使用Thread\"></a>2.1.1、直接使用Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、使用-Runnable-配合-Thread\"><a href=\"#2-1-2、使用-Runnable-配合-Thread\" class=\"headerlink\" title=\"2.1.2、使用 Runnable 配合 Thread\"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>( runnable );</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<p>java8可用lambda精简</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">task2</span> <span class=\"operator\">=</span> () -&gt; log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task2, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">t2.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3、FutureTask-配合-Thread\"><a href=\"#2-1-3、FutureTask-配合-Thread\" class=\"headerlink\" title=\"2.1.3、FutureTask 配合 Thread\"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\">FutureTask&lt;Integer&gt; task3 = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task3, <span class=\"string\">&quot;t3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> task3.get();</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、查看进程线程\"><a href=\"#2-2、查看进程线程\" class=\"headerlink\" title=\"2.2、查看进程线程\"></a>2.2、查看进程线程</h2><h3 id=\"2-2-1、windows\"><a href=\"#2-2-1、windows\" class=\"headerlink\" title=\"2.2.1、windows\"></a>2.2.1、windows</h3><ol>\n<li>tasklist 查看进程 </li>\n<li>taskkill 杀死进程 </li>\n<li>netstat -ano|findstr 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-2、linux\"><a href=\"#2-2-2、linux\" class=\"headerlink\" title=\"2.2.2、linux\"></a>2.2.2、linux</h3><ol>\n<li>ps -fe 查看所有进程 </li>\n<li>kill 杀死进程</li>\n<li>top -Hp <PID> 查看某个进程（PID）的所有线程 </li>\n<li>netstat -nlp|grep 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-3、JDK\"><a href=\"#2-2-3、JDK\" class=\"headerlink\" title=\"2.2.3、JDK\"></a>2.2.3、JDK</h3><ol>\n<li>jps 命令查看所有 Java 进程</li>\n<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>\n<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>\n</ol>\n<h2 id=\"2-3、线程运行原理\"><a href=\"#2-3、线程运行原理\" class=\"headerlink\" title=\"2.3、线程运行原理\"></a>2.3、线程运行原理</h2><ol>\n<li><strong>线程创建</strong></li>\n</ol>\n<p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成<br>，栈帧对应着每次方法调用所占内存</p>\n<ol start=\"2\">\n<li><strong>上下文切换</strong></li>\n</ol>\n<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p>\n<blockquote>\n<p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p>\n</blockquote>\n<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p>\n<h2 id=\"2-4、start与run\"><a href=\"#2-4、start与run\" class=\"headerlink\" title=\"2.4、start与run\"></a>2.4、start与run</h2><ul>\n<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>\n<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>\n</ul>\n<h2 id=\"2-5、sleep-与-yield\"><a href=\"#2-5、sleep-与-yield\" class=\"headerlink\" title=\"2.5、sleep 与 yield\"></a>2.5、sleep 与 yield</h2><ol>\n<li><strong>sleep</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>睡眠结束后的线程未必会立刻得到执行</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>yield</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>具体的实现依赖于操作系统的任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-6、join\"><a href=\"#2-6、join\" class=\"headerlink\" title=\"2.6、join\"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    test1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">        r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"comment\">// t1.join();</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不加t1.join()结果为0，加上以后结果为1</p>\n</blockquote>\n<h2 id=\"2-7、interrupt\"><a href=\"#2-7、interrupt\" class=\"headerlink\" title=\"2.7、interrupt\"></a>2.7、interrupt</h2><h3 id=\"2-7-1、打断阻塞状态的线程\"><a href=\"#2-7-1、打断阻塞状态的线程\" class=\"headerlink\" title=\"2.7.1、打断阻塞状态的线程\"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t1.interrupt();</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">     at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">     at java.lang.Thread.sleep(Thread.java:<span class=\"number\">340</span>)</span><br><span class=\"line\">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class=\"number\">386</span>)</span><br><span class=\"line\">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class=\"number\">3</span>(TestInterrupt.java:<span class=\"number\">59</span>)</span><br><span class=\"line\">     at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">18</span>:<span class=\"number\">10.374</span> [main] c.TestInterrupt - 打断状态: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-2、打断正常运行的线程\"><a href=\"#2-7-2、打断正常运行的线程\" class=\"headerlink\" title=\"2.7.2、打断正常运行的线程\"></a>2.7.2、打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> current.isInterrupted();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(interrupted) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t2.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class=\"literal\">true</span> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8、主线程与守护线程\"><a href=\"#2-8、主线程与守护线程\" class=\"headerlink\" title=\"2.8、主线程与守护线程\"></a>2.8、主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </p>\n<p>例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;daemon&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置该线程为守护线程</span></span><br><span class=\"line\">t1.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>**注意 **</p>\n<ul>\n<li>垃圾回收器线程就是一种守护线程 </li>\n<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>\n</ul>\n</blockquote>\n<h2 id=\"2-9、线程状态\"><a href=\"#2-9、线程状态\" class=\"headerlink\" title=\"2.9、线程状态\"></a>2.9、线程状态</h2><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NEW</td>\n<td>初始状态:线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>阻塞状态:表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td>WAITING</td>\n<td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>\n</tr>\n<tr>\n<td>TIMEWAITING</td>\n<td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>终止状态:表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg\" alt=\"线程状态\"></p>\n<h1 id=\"3、共享模型之管程\"><a href=\"#3、共享模型之管程\" class=\"headerlink\" title=\"3、共享模型之管程\"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p>\n<h2 id=\"3-1、monitor\"><a href=\"#3-1、monitor\" class=\"headerlink\" title=\"3.1、monitor\"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>\n<h3 id=\"3-1-1、Monitor结构\"><a href=\"#3-1-1、Monitor结构\" class=\"headerlink\" title=\"3.1.1、Monitor结构\"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg\" alt=\"monitor结构\"></p>\n<h3 id=\"3-1-2、Monitor原理\"><a href=\"#3-1-2、Monitor原理\" class=\"headerlink\" title=\"3.1.2、Monitor原理\"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n<h2 id=\"3-2、java对象结构\"><a href=\"#3-2、java对象结构\" class=\"headerlink\" title=\"3.2、java对象结构\"></a>3.2、java对象结构</h2><ol>\n<li><strong>对象头</strong></li>\n</ol>\n<p>包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg\" alt=\"java对象头\"></p>\n<ol start=\"2\">\n<li><strong>实例数据</strong></li>\n</ol>\n<p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p>\n<ol start=\"3\">\n<li><strong>对齐填充</strong></li>\n</ol>\n<p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>\n<h2 id=\"3-3、synchronized升级\"><a href=\"#3-3、synchronized升级\" class=\"headerlink\" title=\"3.3、synchronized升级\"></a>3.3、synchronized升级</h2><h3 id=\"3-3-1、偏向锁\"><a href=\"#3-3-1、偏向锁\" class=\"headerlink\" title=\"3.3.1、偏向锁\"></a>3.3.1、偏向锁</h3><blockquote>\n<p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p>\n</blockquote>\n<p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>\n<h3 id=\"3-3-2、轻量级锁\"><a href=\"#3-3-2、轻量级锁\" class=\"headerlink\" title=\"3.3.2、轻量级锁\"></a>3.3.2、轻量级锁</h3><blockquote>\n<p>使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg\" alt=\"轻量级锁\"></p>\n<ol>\n<li>创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象</li>\n<li>让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>\n<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>\n<li>如果 cas 失败，有两种情况</li>\n</ol>\n<p>（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程<br>（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）</p>\n<ol start=\"5\">\n<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>\n<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</li>\n</ol>\n<p>（1）成功，则解锁成功<br>（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>\n<h3 id=\"3-3-3、重量级锁\"><a href=\"#3-3-3、重量级锁\" class=\"headerlink\" title=\"3.3.3、重量级锁\"></a>3.3.3、重量级锁</h3><blockquote>\n<p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg\" alt=\"重量级锁\"></p>\n<ol>\n<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>\n<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</li>\n</ol>\n<p>（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<br>（2）然后自己进入 Monitor 的 EntryList阻塞队列</p>\n<ol start=\"3\">\n<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）</li>\n</ol>\n<blockquote>\n<p>调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n</blockquote>\n<h3 id=\"3-3-4、自旋锁\"><a href=\"#3-3-4、自旋锁\" class=\"headerlink\" title=\"3.3.4、自旋锁\"></a>3.3.4、自旋锁</h3><p>重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)</p>\n<h2 id=\"3-4、wait-notify\"><a href=\"#3-4、wait-notify\" class=\"headerlink\" title=\"3.4、wait&#x2F;notify\"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p>\n<h3 id=\"3-4-1、sleep和wait的区别？\"><a href=\"#3-4-1、sleep和wait的区别？\" class=\"headerlink\" title=\"3.4.1、sleep和wait的区别？\"></a>3.4.1、sleep和wait的区别？</h3><ol>\n<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>\n<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>\n<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>\n</ol>\n<h2 id=\"3-5、park-unpark\"><a href=\"#3-5、park-unpark\" class=\"headerlink\" title=\"3.5、park&#x2F;unpark\"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂停当前线程</span></span><br><span class=\"line\">LockSupport.park(); </span><br><span class=\"line\"><span class=\"comment\">// 恢复某个线程的运行</span></span><br><span class=\"line\">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-1、与-Object-的-wait-notify-相比\"><a href=\"#3-5-1、与-Object-的-wait-notify-相比\" class=\"headerlink\" title=\"3.5.1、与 Object 的 wait &amp; notify 相比\"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul>\n<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>\n<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>\n<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>\n</ul>\n<h3 id=\"3-5-2、原理\"><a href=\"#3-5-2、原理\" class=\"headerlink\" title=\"3.5.2、原理\"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p>\n<p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p>\n<h2 id=\"3-6、死锁\"><a href=\"#3-6、死锁\" class=\"headerlink\" title=\"3.6、死锁\"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p>\n<h3 id=\"3-6-1、死锁的必要条件\"><a href=\"#3-6-1、死锁的必要条件\" class=\"headerlink\" title=\"3.6.1、死锁的必要条件\"></a>3.6.1、死锁的必要条件</h3><ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h3 id=\"3-6-2、死锁的实现\"><a href=\"#3-6-2、死锁的实现\" class=\"headerlink\" title=\"3.6.2、死锁的实现\"></a>3.6.2、死锁的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">owner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"comment\">//开启一个新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                lock(owner, target);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"comment\">//主线程</span></span><br><span class=\"line\">        lock(target, owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">(Object owner, Object target)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (owner) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (target) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;success&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-3、定位死锁\"><a href=\"#3-6-3、定位死锁\" class=\"headerlink\" title=\"3.6.3、定位死锁\"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p>\n<h3 id=\"3-6-4、哲学家就餐问题\"><a href=\"#3-6-4、哲学家就餐问题\" class=\"headerlink\" title=\"3.6.4、哲学家就餐问题\"></a>3.6.4、哲学家就餐问题</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg\" alt=\"哲学家就餐问题\"></p>\n<p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p>\n<ol>\n<li>筷子类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chopstick</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Chopstick</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;筷子&#123;&quot;</span> + name + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>哲学家类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Philosopher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    Chopstick left;</span><br><span class=\"line\">    Chopstick right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Philosopher</span><span class=\"params\">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;eating...&quot;</span>);</span><br><span class=\"line\">        Sleeper.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得左手筷子</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (left) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获得右手筷子</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (right) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">                    eat();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 放下右手筷子</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 放下左手筷子</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>就餐</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c5</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、活锁\"><a href=\"#3-7、活锁\" class=\"headerlink\" title=\"3.7、活锁\"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p>\n<blockquote>\n<p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p>\n</blockquote>\n<h2 id=\"3-8、ReentrantLock\"><a href=\"#3-8、ReentrantLock\" class=\"headerlink\" title=\"3.8、ReentrantLock\"></a>3.8、<strong>ReentrantLock</strong></h2><p>相对于 synchronized 它具备如下特点 </p>\n<ol>\n<li>可中断 </li>\n<li>可以设置超时时间 </li>\n<li>可以设置为公平锁 （默认不公平）</li>\n<li>支持多个条件变量</li>\n</ol>\n<p>与 synchronized 一样，都支持可重入 </p>\n<h1 id=\"4、共享模型之内存\"><a href=\"#4、共享模型之内存\" class=\"headerlink\" title=\"4、共享模型之内存\"></a>4、共享模型之内存</h1><h2 id=\"4-1、java内存模型（jmm）\"><a href=\"#4-1、java内存模型（jmm）\" class=\"headerlink\" title=\"4.1、java内存模型（jmm）\"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p>\n<h2 id=\"4-2、线程安全性的三个体现\"><a href=\"#4-2、线程安全性的三个体现\" class=\"headerlink\" title=\"4.2、线程安全性的三个体现\"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）<br><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）<br><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）</p>\n<h1 id=\"5、共享模型之无锁\"><a href=\"#5、共享模型之无锁\" class=\"headerlink\" title=\"5、共享模型之无锁\"></a>5、共享模型之无锁</h1><h2 id=\"5-1、CAS\"><a href=\"#5-1、CAS\" class=\"headerlink\" title=\"5.1、CAS\"></a>5.1、CAS</h2><h3 id=\"5-1-1、CAS基本概念\"><a href=\"#5-1-1、CAS基本概念\" class=\"headerlink\" title=\"5.1.1、CAS基本概念\"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>\n<blockquote>\n<ol>\n<li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li>\n<li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li>\n</ol>\n</blockquote>\n<h3 id=\"5-1-2、CAS问题\"><a href=\"#5-1-2、CAS问题\" class=\"headerlink\" title=\"5.1.2、CAS问题\"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p>\n<p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p>\n<h2 id=\"5-2、volatile\"><a href=\"#5-2、volatile\" class=\"headerlink\" title=\"5.2、volatile\"></a>5.2、volatile</h2><h3 id=\"5-2-1、如何保证可见性和有序性\"><a href=\"#5-2-1、如何保证可见性和有序性\" class=\"headerlink\" title=\"5.2.1、如何保证可见性和有序性\"></a>5.2.1、如何保证可见性和有序性</h3><ol>\n<li><strong>保证可见性（缓存一致性协议MESI）</strong></li>\n</ol>\n<p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p>\n<blockquote>\n<p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p>\n</blockquote>\n<blockquote>\n<p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>保证有序性（禁止指令重排优化）</strong></li>\n</ol>\n<p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p>\n<h2 id=\"5-3、原子类\"><a href=\"#5-3、原子类\" class=\"headerlink\" title=\"5.3、原子类\"></a>5.3、原子类</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>具体类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic 基本类型原子类</td>\n<td>AtomicInteger AtomicLong AtomicBoolean</td>\n</tr>\n<tr>\n<td>AtomicArray 数组类型原子类</td>\n<td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td>\n</tr>\n<tr>\n<td>AtomicReference 引用类型原子类</td>\n<td>AtomicReference AtomicStampedReference AtomicMarkableReference</td>\n</tr>\n<tr>\n<td>AtomicFieldUpdate 升级类型原子类</td>\n<td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td>\n</tr>\n</tbody></table>\n<h1 id=\"6、共享模式之工具\"><a href=\"#6、共享模式之工具\" class=\"headerlink\" title=\"6、共享模式之工具\"></a>6、共享模式之工具</h1><h2 id=\"6-1、线程池\"><a href=\"#6-1、线程池\" class=\"headerlink\" title=\"6.1、线程池\"></a>6.1、线程池</h2><h3 id=\"6-1-1、ThreadPoolExecutor\"><a href=\"#6-1-1、ThreadPoolExecutor\" class=\"headerlink\" title=\"6.1.1、ThreadPoolExecutor\"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol>\n<li><strong>构造方法</strong></li>\n</ol>\n<p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p>\n<blockquote>\n<ol>\n<li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li>\n<li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li>\n<li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li>\n<li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>\n<li>workQueue：缓存队列，用来存放等待被执行的任务。</li>\n<li>threadFactory 线程工厂</li>\n<li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>\n<h3 id=\"6-1-2、Executors类中提供的工厂方法\"><a href=\"#6-1-2、Executors类中提供的工厂方法\" class=\"headerlink\" title=\"6.1.2、Executors类中提供的工厂方法\"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p>\n<ol>\n<li><strong>newFixedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newFixedThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点：</p>\n<ul>\n<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>\n<li>阻塞队列是无界的，可以放任意数量的任务</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>适用于任务量已知，相对耗时的任务</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>newCachedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newCachedThreadPool</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点 </p>\n<ul>\n<li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul>\n<li>全部都是救急线程（60s 后可以回收）</li>\n<li>救急线程可以无限创建</li>\n</ul>\n</li>\n<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p>\n</blockquote>\n<ol start=\"3\">\n<li>newSingleThreadExecutor</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newSingleThreadExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\">        (<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。 </p>\n<h3 id=\"6-1-3、创建多大的线程池\"><a href=\"#6-1-3、创建多大的线程池\" class=\"headerlink\" title=\"6.1.3、创建多大的线程池\"></a>6.1.3、创建多大的线程池</h3><ul>\n<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>\n<li>过大会导致更多的线程上下文切换，影响性能</li>\n</ul>\n<ol>\n<li>**CPU 密集型运算 **</li>\n</ol>\n<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>\n<ol start=\"2\">\n<li><strong>I&#x2F;O密集型</strong></li>\n</ol>\n<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>\n<h2 id=\"6-2、锁\"><a href=\"#6-2、锁\" class=\"headerlink\" title=\"6.2、锁\"></a>6.2、锁</h2><h3 id=\"6-2-1、AQS\"><a href=\"#6-2-1、AQS\" class=\"headerlink\" title=\"6.2.1、AQS\"></a>6.2.1、AQS</h3><ol>\n<li>基本概念</li>\n</ol>\n<p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p>\n<ol start=\"2\">\n<li>原理</li>\n</ol>\n<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>\n<blockquote>\n<p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>\n</blockquote>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p>\n<h3 id=\"6-2-2、ReentrantLock\"><a href=\"#6-2-2、ReentrantLock\" class=\"headerlink\" title=\"6.2.2、ReentrantLock\"></a>6.2.2、ReentrantLock</h3><p><strong>实现原理</strong></p>\n<ol>\n<li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li>\n<li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li>\n<li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li>\n<li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li>\n</ol>\n<p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p>\n<h3 id=\"6-2-3、ReentrantReadWriteLock\"><a href=\"#6-2-3、ReentrantReadWriteLock\" class=\"headerlink\" title=\"6.2.3、ReentrantReadWriteLock\"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id=\"4-2-3-1、ReentrantReadWriteLock基本概念\"><a href=\"#4-2-3-1、ReentrantReadWriteLock基本概念\" class=\"headerlink\" title=\"4.2.3.1、ReentrantReadWriteLock基本概念\"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p>\n<h4 id=\"4-2-3-2、锁获取过程\"><a href=\"#4-2-3-2、锁获取过程\" class=\"headerlink\" title=\"4.2.3.2、锁获取过程\"></a>4.2.3.2、锁获取过程</h4><ol>\n<li>获取读锁</li>\n</ol>\n<p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>     如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。</p>\n<ol start=\"4\">\n<li>获取写入锁</li>\n</ol>\n<p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p>\n<h4 id=\"4-2-3-3、常见问题\"><a href=\"#4-2-3-3、常见问题\" class=\"headerlink\" title=\"4.2.3.3、常见问题\"></a>4.2.3.3、常见问题</h4><ol>\n<li><strong>读锁和写锁的可重入性</strong></li>\n</ol>\n<p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p>\n<ol start=\"2\">\n<li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li>\n</ol>\n<p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p>\n<ol start=\"3\">\n<li><strong>锁降级是怎么降级的？</strong></li>\n</ol>\n<p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p>\n<h2 id=\"6-3、工具\"><a href=\"#6-3、工具\" class=\"headerlink\" title=\"6.3、工具\"></a>6.3、工具</h2><h3 id=\"6-3-1、Semaphore\"><a href=\"#6-3-1、Semaphore\" class=\"headerlink\" title=\"6.3.1、Semaphore\"></a>6.3.1、Semaphore</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourcePool</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//用到了信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DataSourcePool</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">        list = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        semaphore = <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">            list.add(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用同步方法获取</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class=\"line\">        semaphore.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">close</span><span class=\"params\">(Connection connection)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//信号量+1</span></span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">        list.add(connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p>\n<p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p>\n<h3 id=\"6-3-2、CountdownLatch\"><a href=\"#6-3-2、CountdownLatch\" class=\"headerlink\" title=\"6.3.2、CountdownLatch\"></a>6.3.2、CountdownLatch</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ExecutorService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1.5</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;wait end...&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - waiting... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">26.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - end..<span class=\"number\">.2</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.335</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - end..<span class=\"number\">.1</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - end..<span class=\"number\">.0</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - wait end...</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p>\n<ol start=\"3\">\n<li><strong>和join的区别？</strong></li>\n</ol>\n<p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p>\n<h3 id=\"6-3-3、CyclicBarrier\"><a href=\"#6-3-3、CyclicBarrier\" class=\"headerlink\" title=\"6.3.3、CyclicBarrier\"></a>6.3.3、CyclicBarrier</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(count, <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;全部加载完毕&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; x &lt; count; x++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(cb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    CyclicBarrier cyclicBarrier;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已加载完&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            cyclicBarrier.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">6</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">7</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">8</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">9</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">10</span> 已加载完</span><br><span class=\"line\">全部加载完毕</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p>\n<h2 id=\"6-4、线程安全集合类\"><a href=\"#6-4、线程安全集合类\" class=\"headerlink\" title=\"6.4、线程安全集合类\"></a>6.4、线程安全集合类</h2><h3 id=\"6-4-1、概述\"><a href=\"#6-4-1、概述\" class=\"headerlink\" title=\"6.4.1、概述\"></a>6.4.1、概述</h3><p>线程安全实现类有三类：</p>\n<ol>\n<li>遗留的线程安全集合如 Hashtable ， Vector </li>\n<li>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</li>\n</ol>\n<blockquote>\n<ul>\n<li>Collections.synchronizedCollection </li>\n<li>Collections.synchronizedList </li>\n<li>Collections.synchronizedMap </li>\n<li>Collections.synchronizedSet </li>\n<li>Collections.synchronizedNavigableMap </li>\n<li>Collections.synchronizedNavigableSet</li>\n<li>Collections.synchronizedSortedMap </li>\n<li>Collections.synchronizedSortedSet</li>\n</ul>\n</blockquote>\n<ol start=\"4\">\n<li>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent</li>\n</ol>\n<blockquote>\n<ul>\n<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li>\n<li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li>\n<li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul>\n<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>\n<li>弱一致性 <ul>\n<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li>\n<li>求大小弱一致性，size 操作未必是 100% 准确 </li>\n<li>读取弱一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p>\n</blockquote>\n<h3 id=\"6-4-2、concurrentHashMap\"><a href=\"#6-4-2、concurrentHashMap\" class=\"headerlink\" title=\"6.4.2、concurrentHashMap\"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p>\n<p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p>\n<p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p>\n<blockquote>\n<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p>\n</blockquote>\n<p><strong>JDK1.8</strong></p>\n<p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p>\n<ol>\n<li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li>\n<li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li>\n<li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li>\n<li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li>\n</ol>\n<h3 id=\"6-4-3、BlockingQueue\"><a href=\"#6-4-3、BlockingQueue\" class=\"headerlink\" title=\"6.4.3、BlockingQueue\"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p>\n<ol>\n<li>区别</li>\n</ol>\n<p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p>\n<h3 id=\"6-4-4、ConcurrentLinkedQueue\"><a href=\"#6-4-4、ConcurrentLinkedQueue\" class=\"headerlink\" title=\"6.4.4、ConcurrentLinkedQueue\"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p>\n<h3 id=\"6-4-5、CopyOnWriteArrayList\"><a href=\"#6-4-5、CopyOnWriteArrayList\" class=\"headerlink\" title=\"6.4.5、CopyOnWriteArrayList\"></a>6.4.5、CopyOnWriteArrayList</h3><ol>\n<li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li>\n<li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li>\n<li>写操作结束后会把原数组指向新数组</li>\n<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、java多线程基本概念\"><a href=\"#1、java多线程基本概念\" class=\"headerlink\" title=\"1、java多线程基本概念\"></a>1、java多线程基本概念</h1><h2 id=\"1-1、进程和线程\"><a href=\"#1-1、进程和线程\" class=\"headerlink\" title=\"1.1、进程和线程\"></a>1.1、进程和线程</h2><ol>\n<li><strong>进程</strong></li>\n</ol>\n<ul>\n<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li>\n<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>\n<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>\n</ul>\n<ol start=\"2\">\n<li><strong>线程</strong></li>\n</ol>\n<ul>\n<li>一个进程之内可以分为一到多个线程。 </li>\n<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li>\n<li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li>\n</ul>\n<h2 id=\"1-2、并发和并行\"><a href=\"#1-2、并发和并行\" class=\"headerlink\" title=\"1.2、并发和并行\"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p>\n<h2 id=\"1-3、多线程的应用\"><a href=\"#1-3、多线程的应用\" class=\"headerlink\" title=\"1.3、多线程的应用\"></a>1.3、多线程的应用</h2><h3 id=\"1-3-1、异步调用\"><a href=\"#1-3-1、异步调用\" class=\"headerlink\" title=\"1.3.1、异步调用\"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p>\n<h3 id=\"1-3-2、提升效率\"><a href=\"#1-3-2、提升效率\" class=\"headerlink\" title=\"1.3.2、提升效率\"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算 <span class=\"number\">1</span> 花费 <span class=\"number\">10</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">2</span> 花费 <span class=\"number\">11</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">3</span> 花费 <span class=\"number\">9</span> ms</span><br><span class=\"line\">汇总需要 <span class=\"number\">1</span> ms</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li>\n<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms</li>\n</ul>\n<blockquote>\n<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>\n</blockquote>\n<h1 id=\"2、java线程\"><a href=\"#2、java线程\" class=\"headerlink\" title=\"2、java线程\"></a>2、java线程</h1><h2 id=\"2-1、线程的创建\"><a href=\"#2-1、线程的创建\" class=\"headerlink\" title=\"2.1、线程的创建\"></a>2.1、线程的创建</h2><h3 id=\"2-1-1、直接使用Thread\"><a href=\"#2-1-1、直接使用Thread\" class=\"headerlink\" title=\"2.1.1、直接使用Thread\"></a>2.1.1、直接使用Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、使用-Runnable-配合-Thread\"><a href=\"#2-1-2、使用-Runnable-配合-Thread\" class=\"headerlink\" title=\"2.1.2、使用 Runnable 配合 Thread\"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>( runnable );</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<p>java8可用lambda精简</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">task2</span> <span class=\"operator\">=</span> () -&gt; log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task2, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">t2.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3、FutureTask-配合-Thread\"><a href=\"#2-1-3、FutureTask-配合-Thread\" class=\"headerlink\" title=\"2.1.3、FutureTask 配合 Thread\"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\">FutureTask&lt;Integer&gt; task3 = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task3, <span class=\"string\">&quot;t3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> task3.get();</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、查看进程线程\"><a href=\"#2-2、查看进程线程\" class=\"headerlink\" title=\"2.2、查看进程线程\"></a>2.2、查看进程线程</h2><h3 id=\"2-2-1、windows\"><a href=\"#2-2-1、windows\" class=\"headerlink\" title=\"2.2.1、windows\"></a>2.2.1、windows</h3><ol>\n<li>tasklist 查看进程 </li>\n<li>taskkill 杀死进程 </li>\n<li>netstat -ano|findstr 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-2、linux\"><a href=\"#2-2-2、linux\" class=\"headerlink\" title=\"2.2.2、linux\"></a>2.2.2、linux</h3><ol>\n<li>ps -fe 查看所有进程 </li>\n<li>kill 杀死进程</li>\n<li>top -Hp <PID> 查看某个进程（PID）的所有线程 </li>\n<li>netstat -nlp|grep 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-3、JDK\"><a href=\"#2-2-3、JDK\" class=\"headerlink\" title=\"2.2.3、JDK\"></a>2.2.3、JDK</h3><ol>\n<li>jps 命令查看所有 Java 进程</li>\n<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>\n<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>\n</ol>\n<h2 id=\"2-3、线程运行原理\"><a href=\"#2-3、线程运行原理\" class=\"headerlink\" title=\"2.3、线程运行原理\"></a>2.3、线程运行原理</h2><ol>\n<li><strong>线程创建</strong></li>\n</ol>\n<p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成<br>，栈帧对应着每次方法调用所占内存</p>\n<ol start=\"2\">\n<li><strong>上下文切换</strong></li>\n</ol>\n<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p>\n<blockquote>\n<p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p>\n</blockquote>\n<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p>\n<h2 id=\"2-4、start与run\"><a href=\"#2-4、start与run\" class=\"headerlink\" title=\"2.4、start与run\"></a>2.4、start与run</h2><ul>\n<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>\n<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>\n</ul>\n<h2 id=\"2-5、sleep-与-yield\"><a href=\"#2-5、sleep-与-yield\" class=\"headerlink\" title=\"2.5、sleep 与 yield\"></a>2.5、sleep 与 yield</h2><ol>\n<li><strong>sleep</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>睡眠结束后的线程未必会立刻得到执行</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>yield</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>具体的实现依赖于操作系统的任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-6、join\"><a href=\"#2-6、join\" class=\"headerlink\" title=\"2.6、join\"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    test1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">        r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"comment\">// t1.join();</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不加t1.join()结果为0，加上以后结果为1</p>\n</blockquote>\n<h2 id=\"2-7、interrupt\"><a href=\"#2-7、interrupt\" class=\"headerlink\" title=\"2.7、interrupt\"></a>2.7、interrupt</h2><h3 id=\"2-7-1、打断阻塞状态的线程\"><a href=\"#2-7-1、打断阻塞状态的线程\" class=\"headerlink\" title=\"2.7.1、打断阻塞状态的线程\"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t1.interrupt();</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">     at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">     at java.lang.Thread.sleep(Thread.java:<span class=\"number\">340</span>)</span><br><span class=\"line\">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class=\"number\">386</span>)</span><br><span class=\"line\">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class=\"number\">3</span>(TestInterrupt.java:<span class=\"number\">59</span>)</span><br><span class=\"line\">     at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">18</span>:<span class=\"number\">10.374</span> [main] c.TestInterrupt - 打断状态: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-2、打断正常运行的线程\"><a href=\"#2-7-2、打断正常运行的线程\" class=\"headerlink\" title=\"2.7.2、打断正常运行的线程\"></a>2.7.2、打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> current.isInterrupted();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(interrupted) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t2.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class=\"literal\">true</span> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8、主线程与守护线程\"><a href=\"#2-8、主线程与守护线程\" class=\"headerlink\" title=\"2.8、主线程与守护线程\"></a>2.8、主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </p>\n<p>例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;daemon&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置该线程为守护线程</span></span><br><span class=\"line\">t1.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>**注意 **</p>\n<ul>\n<li>垃圾回收器线程就是一种守护线程 </li>\n<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>\n</ul>\n</blockquote>\n<h2 id=\"2-9、线程状态\"><a href=\"#2-9、线程状态\" class=\"headerlink\" title=\"2.9、线程状态\"></a>2.9、线程状态</h2><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NEW</td>\n<td>初始状态:线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>阻塞状态:表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td>WAITING</td>\n<td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>\n</tr>\n<tr>\n<td>TIMEWAITING</td>\n<td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>终止状态:表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg\" alt=\"线程状态\"></p>\n<h1 id=\"3、共享模型之管程\"><a href=\"#3、共享模型之管程\" class=\"headerlink\" title=\"3、共享模型之管程\"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p>\n<h2 id=\"3-1、monitor\"><a href=\"#3-1、monitor\" class=\"headerlink\" title=\"3.1、monitor\"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>\n<h3 id=\"3-1-1、Monitor结构\"><a href=\"#3-1-1、Monitor结构\" class=\"headerlink\" title=\"3.1.1、Monitor结构\"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg\" alt=\"monitor结构\"></p>\n<h3 id=\"3-1-2、Monitor原理\"><a href=\"#3-1-2、Monitor原理\" class=\"headerlink\" title=\"3.1.2、Monitor原理\"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n<h2 id=\"3-2、java对象结构\"><a href=\"#3-2、java对象结构\" class=\"headerlink\" title=\"3.2、java对象结构\"></a>3.2、java对象结构</h2><ol>\n<li><strong>对象头</strong></li>\n</ol>\n<p>包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg\" alt=\"java对象头\"></p>\n<ol start=\"2\">\n<li><strong>实例数据</strong></li>\n</ol>\n<p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p>\n<ol start=\"3\">\n<li><strong>对齐填充</strong></li>\n</ol>\n<p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>\n<h2 id=\"3-3、synchronized升级\"><a href=\"#3-3、synchronized升级\" class=\"headerlink\" title=\"3.3、synchronized升级\"></a>3.3、synchronized升级</h2><h3 id=\"3-3-1、偏向锁\"><a href=\"#3-3-1、偏向锁\" class=\"headerlink\" title=\"3.3.1、偏向锁\"></a>3.3.1、偏向锁</h3><blockquote>\n<p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p>\n</blockquote>\n<p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>\n<h3 id=\"3-3-2、轻量级锁\"><a href=\"#3-3-2、轻量级锁\" class=\"headerlink\" title=\"3.3.2、轻量级锁\"></a>3.3.2、轻量级锁</h3><blockquote>\n<p>使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg\" alt=\"轻量级锁\"></p>\n<ol>\n<li>创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象</li>\n<li>让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>\n<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>\n<li>如果 cas 失败，有两种情况</li>\n</ol>\n<p>（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程<br>（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）</p>\n<ol start=\"5\">\n<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>\n<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</li>\n</ol>\n<p>（1）成功，则解锁成功<br>（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>\n<h3 id=\"3-3-3、重量级锁\"><a href=\"#3-3-3、重量级锁\" class=\"headerlink\" title=\"3.3.3、重量级锁\"></a>3.3.3、重量级锁</h3><blockquote>\n<p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg\" alt=\"重量级锁\"></p>\n<ol>\n<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>\n<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</li>\n</ol>\n<p>（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<br>（2）然后自己进入 Monitor 的 EntryList阻塞队列</p>\n<ol start=\"3\">\n<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）</li>\n</ol>\n<blockquote>\n<p>调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n</blockquote>\n<h3 id=\"3-3-4、自旋锁\"><a href=\"#3-3-4、自旋锁\" class=\"headerlink\" title=\"3.3.4、自旋锁\"></a>3.3.4、自旋锁</h3><p>重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)</p>\n<h2 id=\"3-4、wait-notify\"><a href=\"#3-4、wait-notify\" class=\"headerlink\" title=\"3.4、wait&#x2F;notify\"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p>\n<h3 id=\"3-4-1、sleep和wait的区别？\"><a href=\"#3-4-1、sleep和wait的区别？\" class=\"headerlink\" title=\"3.4.1、sleep和wait的区别？\"></a>3.4.1、sleep和wait的区别？</h3><ol>\n<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>\n<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>\n<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>\n</ol>\n<h2 id=\"3-5、park-unpark\"><a href=\"#3-5、park-unpark\" class=\"headerlink\" title=\"3.5、park&#x2F;unpark\"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂停当前线程</span></span><br><span class=\"line\">LockSupport.park(); </span><br><span class=\"line\"><span class=\"comment\">// 恢复某个线程的运行</span></span><br><span class=\"line\">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-1、与-Object-的-wait-notify-相比\"><a href=\"#3-5-1、与-Object-的-wait-notify-相比\" class=\"headerlink\" title=\"3.5.1、与 Object 的 wait &amp; notify 相比\"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul>\n<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>\n<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>\n<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>\n</ul>\n<h3 id=\"3-5-2、原理\"><a href=\"#3-5-2、原理\" class=\"headerlink\" title=\"3.5.2、原理\"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p>\n<p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p>\n<h2 id=\"3-6、死锁\"><a href=\"#3-6、死锁\" class=\"headerlink\" title=\"3.6、死锁\"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p>\n<h3 id=\"3-6-1、死锁的必要条件\"><a href=\"#3-6-1、死锁的必要条件\" class=\"headerlink\" title=\"3.6.1、死锁的必要条件\"></a>3.6.1、死锁的必要条件</h3><ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h3 id=\"3-6-2、死锁的实现\"><a href=\"#3-6-2、死锁的实现\" class=\"headerlink\" title=\"3.6.2、死锁的实现\"></a>3.6.2、死锁的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">owner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"comment\">//开启一个新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                lock(owner, target);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"comment\">//主线程</span></span><br><span class=\"line\">        lock(target, owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">(Object owner, Object target)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (owner) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (target) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;success&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-3、定位死锁\"><a href=\"#3-6-3、定位死锁\" class=\"headerlink\" title=\"3.6.3、定位死锁\"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p>\n<h3 id=\"3-6-4、哲学家就餐问题\"><a href=\"#3-6-4、哲学家就餐问题\" class=\"headerlink\" title=\"3.6.4、哲学家就餐问题\"></a>3.6.4、哲学家就餐问题</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg\" alt=\"哲学家就餐问题\"></p>\n<p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p>\n<ol>\n<li>筷子类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chopstick</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Chopstick</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;筷子&#123;&quot;</span> + name + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>哲学家类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Philosopher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    Chopstick left;</span><br><span class=\"line\">    Chopstick right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Philosopher</span><span class=\"params\">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;eating...&quot;</span>);</span><br><span class=\"line\">        Sleeper.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得左手筷子</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (left) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获得右手筷子</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (right) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">                    eat();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 放下右手筷子</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 放下左手筷子</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>就餐</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c5</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、活锁\"><a href=\"#3-7、活锁\" class=\"headerlink\" title=\"3.7、活锁\"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p>\n<blockquote>\n<p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p>\n</blockquote>\n<h2 id=\"3-8、ReentrantLock\"><a href=\"#3-8、ReentrantLock\" class=\"headerlink\" title=\"3.8、ReentrantLock\"></a>3.8、<strong>ReentrantLock</strong></h2><p>相对于 synchronized 它具备如下特点 </p>\n<ol>\n<li>可中断 </li>\n<li>可以设置超时时间 </li>\n<li>可以设置为公平锁 （默认不公平）</li>\n<li>支持多个条件变量</li>\n</ol>\n<p>与 synchronized 一样，都支持可重入 </p>\n<h1 id=\"4、共享模型之内存\"><a href=\"#4、共享模型之内存\" class=\"headerlink\" title=\"4、共享模型之内存\"></a>4、共享模型之内存</h1><h2 id=\"4-1、java内存模型（jmm）\"><a href=\"#4-1、java内存模型（jmm）\" class=\"headerlink\" title=\"4.1、java内存模型（jmm）\"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p>\n<h2 id=\"4-2、线程安全性的三个体现\"><a href=\"#4-2、线程安全性的三个体现\" class=\"headerlink\" title=\"4.2、线程安全性的三个体现\"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）<br><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）<br><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）</p>\n<h1 id=\"5、共享模型之无锁\"><a href=\"#5、共享模型之无锁\" class=\"headerlink\" title=\"5、共享模型之无锁\"></a>5、共享模型之无锁</h1><h2 id=\"5-1、CAS\"><a href=\"#5-1、CAS\" class=\"headerlink\" title=\"5.1、CAS\"></a>5.1、CAS</h2><h3 id=\"5-1-1、CAS基本概念\"><a href=\"#5-1-1、CAS基本概念\" class=\"headerlink\" title=\"5.1.1、CAS基本概念\"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>\n<blockquote>\n<ol>\n<li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li>\n<li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li>\n</ol>\n</blockquote>\n<h3 id=\"5-1-2、CAS问题\"><a href=\"#5-1-2、CAS问题\" class=\"headerlink\" title=\"5.1.2、CAS问题\"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p>\n<p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p>\n<h2 id=\"5-2、volatile\"><a href=\"#5-2、volatile\" class=\"headerlink\" title=\"5.2、volatile\"></a>5.2、volatile</h2><h3 id=\"5-2-1、如何保证可见性和有序性\"><a href=\"#5-2-1、如何保证可见性和有序性\" class=\"headerlink\" title=\"5.2.1、如何保证可见性和有序性\"></a>5.2.1、如何保证可见性和有序性</h3><ol>\n<li><strong>保证可见性（缓存一致性协议MESI）</strong></li>\n</ol>\n<p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p>\n<blockquote>\n<p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p>\n</blockquote>\n<blockquote>\n<p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>保证有序性（禁止指令重排优化）</strong></li>\n</ol>\n<p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p>\n<h2 id=\"5-3、原子类\"><a href=\"#5-3、原子类\" class=\"headerlink\" title=\"5.3、原子类\"></a>5.3、原子类</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>具体类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic 基本类型原子类</td>\n<td>AtomicInteger AtomicLong AtomicBoolean</td>\n</tr>\n<tr>\n<td>AtomicArray 数组类型原子类</td>\n<td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td>\n</tr>\n<tr>\n<td>AtomicReference 引用类型原子类</td>\n<td>AtomicReference AtomicStampedReference AtomicMarkableReference</td>\n</tr>\n<tr>\n<td>AtomicFieldUpdate 升级类型原子类</td>\n<td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td>\n</tr>\n</tbody></table>\n<h1 id=\"6、共享模式之工具\"><a href=\"#6、共享模式之工具\" class=\"headerlink\" title=\"6、共享模式之工具\"></a>6、共享模式之工具</h1><h2 id=\"6-1、线程池\"><a href=\"#6-1、线程池\" class=\"headerlink\" title=\"6.1、线程池\"></a>6.1、线程池</h2><h3 id=\"6-1-1、ThreadPoolExecutor\"><a href=\"#6-1-1、ThreadPoolExecutor\" class=\"headerlink\" title=\"6.1.1、ThreadPoolExecutor\"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol>\n<li><strong>构造方法</strong></li>\n</ol>\n<p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p>\n<blockquote>\n<ol>\n<li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li>\n<li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li>\n<li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li>\n<li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>\n<li>workQueue：缓存队列，用来存放等待被执行的任务。</li>\n<li>threadFactory 线程工厂</li>\n<li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>\n<h3 id=\"6-1-2、Executors类中提供的工厂方法\"><a href=\"#6-1-2、Executors类中提供的工厂方法\" class=\"headerlink\" title=\"6.1.2、Executors类中提供的工厂方法\"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p>\n<ol>\n<li><strong>newFixedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newFixedThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点：</p>\n<ul>\n<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>\n<li>阻塞队列是无界的，可以放任意数量的任务</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>适用于任务量已知，相对耗时的任务</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>newCachedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newCachedThreadPool</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点 </p>\n<ul>\n<li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul>\n<li>全部都是救急线程（60s 后可以回收）</li>\n<li>救急线程可以无限创建</li>\n</ul>\n</li>\n<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p>\n</blockquote>\n<ol start=\"3\">\n<li>newSingleThreadExecutor</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newSingleThreadExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\">        (<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。 </p>\n<h3 id=\"6-1-3、创建多大的线程池\"><a href=\"#6-1-3、创建多大的线程池\" class=\"headerlink\" title=\"6.1.3、创建多大的线程池\"></a>6.1.3、创建多大的线程池</h3><ul>\n<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>\n<li>过大会导致更多的线程上下文切换，影响性能</li>\n</ul>\n<ol>\n<li>**CPU 密集型运算 **</li>\n</ol>\n<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>\n<ol start=\"2\">\n<li><strong>I&#x2F;O密集型</strong></li>\n</ol>\n<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>\n<h2 id=\"6-2、锁\"><a href=\"#6-2、锁\" class=\"headerlink\" title=\"6.2、锁\"></a>6.2、锁</h2><h3 id=\"6-2-1、AQS\"><a href=\"#6-2-1、AQS\" class=\"headerlink\" title=\"6.2.1、AQS\"></a>6.2.1、AQS</h3><ol>\n<li>基本概念</li>\n</ol>\n<p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p>\n<ol start=\"2\">\n<li>原理</li>\n</ol>\n<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>\n<blockquote>\n<p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>\n</blockquote>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p>\n<h3 id=\"6-2-2、ReentrantLock\"><a href=\"#6-2-2、ReentrantLock\" class=\"headerlink\" title=\"6.2.2、ReentrantLock\"></a>6.2.2、ReentrantLock</h3><p><strong>实现原理</strong></p>\n<ol>\n<li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li>\n<li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li>\n<li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li>\n<li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li>\n</ol>\n<p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p>\n<h3 id=\"6-2-3、ReentrantReadWriteLock\"><a href=\"#6-2-3、ReentrantReadWriteLock\" class=\"headerlink\" title=\"6.2.3、ReentrantReadWriteLock\"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id=\"4-2-3-1、ReentrantReadWriteLock基本概念\"><a href=\"#4-2-3-1、ReentrantReadWriteLock基本概念\" class=\"headerlink\" title=\"4.2.3.1、ReentrantReadWriteLock基本概念\"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p>\n<h4 id=\"4-2-3-2、锁获取过程\"><a href=\"#4-2-3-2、锁获取过程\" class=\"headerlink\" title=\"4.2.3.2、锁获取过程\"></a>4.2.3.2、锁获取过程</h4><ol>\n<li>获取读锁</li>\n</ol>\n<p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>     如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。</p>\n<ol start=\"4\">\n<li>获取写入锁</li>\n</ol>\n<p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p>\n<h4 id=\"4-2-3-3、常见问题\"><a href=\"#4-2-3-3、常见问题\" class=\"headerlink\" title=\"4.2.3.3、常见问题\"></a>4.2.3.3、常见问题</h4><ol>\n<li><strong>读锁和写锁的可重入性</strong></li>\n</ol>\n<p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p>\n<ol start=\"2\">\n<li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li>\n</ol>\n<p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p>\n<ol start=\"3\">\n<li><strong>锁降级是怎么降级的？</strong></li>\n</ol>\n<p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p>\n<h2 id=\"6-3、工具\"><a href=\"#6-3、工具\" class=\"headerlink\" title=\"6.3、工具\"></a>6.3、工具</h2><h3 id=\"6-3-1、Semaphore\"><a href=\"#6-3-1、Semaphore\" class=\"headerlink\" title=\"6.3.1、Semaphore\"></a>6.3.1、Semaphore</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourcePool</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//用到了信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DataSourcePool</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">        list = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        semaphore = <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">            list.add(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用同步方法获取</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class=\"line\">        semaphore.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">close</span><span class=\"params\">(Connection connection)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//信号量+1</span></span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">        list.add(connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p>\n<p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p>\n<h3 id=\"6-3-2、CountdownLatch\"><a href=\"#6-3-2、CountdownLatch\" class=\"headerlink\" title=\"6.3.2、CountdownLatch\"></a>6.3.2、CountdownLatch</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ExecutorService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1.5</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;wait end...&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - waiting... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">26.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - end..<span class=\"number\">.2</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.335</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - end..<span class=\"number\">.1</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - end..<span class=\"number\">.0</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - wait end...</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p>\n<ol start=\"3\">\n<li><strong>和join的区别？</strong></li>\n</ol>\n<p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p>\n<h3 id=\"6-3-3、CyclicBarrier\"><a href=\"#6-3-3、CyclicBarrier\" class=\"headerlink\" title=\"6.3.3、CyclicBarrier\"></a>6.3.3、CyclicBarrier</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(count, <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;全部加载完毕&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; x &lt; count; x++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(cb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    CyclicBarrier cyclicBarrier;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已加载完&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            cyclicBarrier.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">6</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">7</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">8</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">9</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">10</span> 已加载完</span><br><span class=\"line\">全部加载完毕</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p>\n<h2 id=\"6-4、线程安全集合类\"><a href=\"#6-4、线程安全集合类\" class=\"headerlink\" title=\"6.4、线程安全集合类\"></a>6.4、线程安全集合类</h2><h3 id=\"6-4-1、概述\"><a href=\"#6-4-1、概述\" class=\"headerlink\" title=\"6.4.1、概述\"></a>6.4.1、概述</h3><p>线程安全实现类有三类：</p>\n<ol>\n<li>遗留的线程安全集合如 Hashtable ， Vector </li>\n<li>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</li>\n</ol>\n<blockquote>\n<ul>\n<li>Collections.synchronizedCollection </li>\n<li>Collections.synchronizedList </li>\n<li>Collections.synchronizedMap </li>\n<li>Collections.synchronizedSet </li>\n<li>Collections.synchronizedNavigableMap </li>\n<li>Collections.synchronizedNavigableSet</li>\n<li>Collections.synchronizedSortedMap </li>\n<li>Collections.synchronizedSortedSet</li>\n</ul>\n</blockquote>\n<ol start=\"4\">\n<li>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent</li>\n</ol>\n<blockquote>\n<ul>\n<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li>\n<li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li>\n<li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul>\n<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>\n<li>弱一致性 <ul>\n<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li>\n<li>求大小弱一致性，size 操作未必是 100% 准确 </li>\n<li>读取弱一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p>\n</blockquote>\n<h3 id=\"6-4-2、concurrentHashMap\"><a href=\"#6-4-2、concurrentHashMap\" class=\"headerlink\" title=\"6.4.2、concurrentHashMap\"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p>\n<p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p>\n<p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p>\n<blockquote>\n<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p>\n</blockquote>\n<p><strong>JDK1.8</strong></p>\n<p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p>\n<ol>\n<li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li>\n<li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li>\n<li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li>\n<li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li>\n</ol>\n<h3 id=\"6-4-3、BlockingQueue\"><a href=\"#6-4-3、BlockingQueue\" class=\"headerlink\" title=\"6.4.3、BlockingQueue\"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p>\n<ol>\n<li>区别</li>\n</ol>\n<p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p>\n<h3 id=\"6-4-4、ConcurrentLinkedQueue\"><a href=\"#6-4-4、ConcurrentLinkedQueue\" class=\"headerlink\" title=\"6.4.4、ConcurrentLinkedQueue\"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p>\n<h3 id=\"6-4-5、CopyOnWriteArrayList\"><a href=\"#6-4-5、CopyOnWriteArrayList\" class=\"headerlink\" title=\"6.4.5、CopyOnWriteArrayList\"></a>6.4.5、CopyOnWriteArrayList</h3><ol>\n<li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li>\n<li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li>\n<li>写操作结束后会把原数组指向新数组</li>\n<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>\n</ol>\n"},{"title":"RabbitMQ","date":"2023-07-23T16:00:00.000Z","abbrlink":33708,"_content":"# 1、基本基础\n## 1.1、mq概念\nMQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信\n## 1.2、mq优缺点\n**优势：**\n（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单\n（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度\n（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  \n\n**劣势：**\n（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用\n（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？\n（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性\n## 1.3、mq产品选型\n\n|指标 | **ActiveMQ** | **RabbitMQ** | **RocketM Q** | **Kafka** |\n| --- | --- | --- | --- | --- |\n| 数据量级（每秒） | 万级 | 万级 | 十万级 | 十万级 |\n| 可靠性 | 低概率丢失 | 0丢失 | 0丢失 | 0丢失 |\n| 可用性 | 主从架构 | 主从架构 | 分布式 | 分布式 |\n| 时效性 | 毫秒 | 微秒 | 毫秒 | 毫秒 |\n\n> 一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。\n\n## 1.4、AMQP协议\n AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是**应用层协议**的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制 1\n\n## 1.5、rabbitMQ安装\n\n1. 安装Eralng，下面链接已提供otp_win64_20.2.exe\n\n链接： [https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg](https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg)\n提取码：x9m7\n\n2. 安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe\n\n链接： [https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg](https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg)\n提取码：h4r3\n\n3. 配置erlang环境变量\n\n![配置erlang环境变量](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png)\n\n\n\n4. 测试erlang\n\n![测试erlang](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png)\n\n\n5. 启动rabbitmq\n\n![启动rabbitmq](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png)\n\n\n6. 访问 [http://127.0.0.1:15672/](http://127.0.0.1:15672/)      guest guest\n\n\n# 2、mq相关概念\n## 2.1、RabbitMQ架构\n![RabbitMQ架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png)\n\n\n（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。\n（2）Connection：连接，应用程序与Server的网络连接，TCP连接。\n（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。\n（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。\n（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。\n（6）Queue：消息队列，用来保存消息，供消费者消费\n（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。\n（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。\n（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”\n\n## 2.2、4种Exchange交换机类型\n### 2.2.1、Direct Exchange（直连交换机）\n\n根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。\n\n![直连交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png)\n\n\n### 2.2.2、Fanout Exchange（广播交换机）\n该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么\n> 如果想让多个消费者消费到数据必须不指定queues，指定交换机\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n\n        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生\n\n        exchange = @Exchange(value = \"business_rrpc_exchange\",type = ExchangeTypes.FANOUT)\n\n))\n\n\n```\n### 2.2.3、Topic Exchange（主题交换机）\n\n将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“\\*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.\\* ” 只会匹配到“abc.def”。\n\n![主题交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png)\n\n\n### 2.2.4、Headers Exchanges（头交换机）\n\n与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()\n\n> 匹配规则x-match有下列两种类型：\nx-match = all ：表示所有的键值对都匹配才能接受到消息\nx-match = any ：表示只要有键值对匹配就能接受到消息\n\n![image (6).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png)\n\n\n## 2.3、工作模式\n### 2.3.1、简单模式\n一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景\n\n![简单模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png)\n\n\n> P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理\n\n\n```java\n// 1. 创建队列\n@Bean\npublic Queue Queue() {\n    return new Queue(\"hello\");\n}\n\n// 2. 生产者\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        amqpTemplate.convertAndSend(\"queue1\", content);\n        return content;\n    }\n}\n\n// 3. 消费者\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(msg);\n    }\n}\n\n```\n\n\n### 2.3.2、工作队列模式\n一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率\n\n> 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度\n\n![工作队列模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png)\n\n\n**实现方式**\n多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息\n```java\n// 增加一个消费者监听同一个队列\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276)\n\n### 2.3.3、发布订阅模式\n一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景\n\n![发布订阅模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png)\n\n\n1. **实现方式**\n\n（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 \n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nFanoutExchange fanoutExchange1() {\n    return new FanoutExchange(\"fanoutExchange1\");\n}\n\n@Bean\nBinding bindingExchangeA(Queue queue1, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue1).to(fanoutExchange1);\n}\n\n@Bean\nBinding bindingExchangeB(Queue queue2, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue2).to(fanoutExchange1);\n}\n```\n\n（2）生产者消费者\n\n```java\n// 生产者：第二个参数是队列名，设置为空\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"\", content);\n        }\n        return content;\n    }\n}\n// 消费者1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer1: \"+msg);\n    }\n}\n// 消费者2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339)\n\n### 2.3.4、路由模式\n一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景\n\n![路由模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png)\n\n**实现方式**\n（1）交换机和队列根据指定路由规则绑定\n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nDirectExchange directExchange1() {\n    return new DirectExchange(\"directExchange1\");\n}\n\n@Bean\nBinding bindingExchangeMessage1(Queue queue1, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue1).to(directExchange1).with(\"routingKey1\");\n}\n\n\n@Bean\nBinding bindingExchangeMessage2(Queue queue2, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue2).to(directExchange1).with(\"routingKey2\");\n}\n```\n\n（2）生产者和消费者\n```java\n// consumer1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue1 consumer1: \"+msg);\n    }\n}\n// consumer2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue2 consumer2: \"+msg);\n    }\n}\n// producer\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"routingKey1\", content);\n        }\n        return content;\n    }\n}\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335)\n\n\n\n## 2.4、死信队列\n“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：\n（1）消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue =false\n（2）消息在队列的存活时间超过设置的生存时间（TTL)时间。\n（3）消息队列的消息数量已经超过最大队列长度。那么该消息将成为“死信”\n“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃\n```java\n//  业务队列配置死信队列参数（声明业务队列A）\n    @Bean(\"businessQueueA\")\n    public Queue businessQueueA(){\n        Map<String, Object> args = new HashMap<>(2);\n//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机\n        args.put(\"x-dead-letter-exchange\", DEAD_LETTER_EXCHANGE);\n//       x-dead-letter-routing-key  这里声明当前队列的死信路由key\n        args.put(\"x-dead-letter-routing-key\", DEAD_LETTER_QUEUEA_ROUTING_KEY);\n        return QueueBuilder.durable(BUSINESS_QUEUEA_NAME).withArguments(args).build();\n    }\n//  声明业务队列绑定关系\n\n    // 声明业务队列A绑定关系\n    @Bean\n    public Binding businessBindingA(@Qualifier(\"businessQueueA\") Queue queue,\n                                    @Qualifier(\"businessExchange\") FanoutExchange exchange){\n        return BindingBuilder.bind(queue).to(exchange);\n    }\n```\n### 2.4.1、实现方式\n\n1. 交换机，队列配置\n```java\n@Configuration\npublic class RabbitConfig {\n\t/**\n     * 声明死信交换机\n     */\n    @Bean\n    public DirectExchange dlxExchange() {\n        return new DirectExchange(\"dlxExchange\");\n    }\n    /**\n     * 声明死信队列\n     */\n    @Bean\n    public Queue dlxQueue() {\n        return new Queue(\"dlxQueue\");\n    }\n    /**\n     * 绑定死信队列到死信交换机\n     */\n    @Bean\n    public Binding binding() {\n        return BindingBuilder.bind(dlxQueue())\n                .to(dlxExchange())\n                .with(\"dlxRoutingKey\");\n    }\n\n    /**\n     * 普通队列绑定死信即可\n     */\n    @Bean\n    Queue normalQueue(){\n        Map<String,Object> map = new HashMap<>();\n        map.put(\"x-dead-letter-exchange\",\"dlxExchange\");\n        map.put(\"x-dead-letter-routing-key\", \"dlxRoutingKey\");\n        return new Queue(\"normalQueue\",true,false,false,map);\n    }\n\n    @Bean\n    DirectExchange normalExchange(){\n        return new DirectExchange(\"normalExchange\");\n    }\n\n    @Bean\n    Binding normalBindingExchange(){\n        return BindingBuilder.bind( normalQueue()).to(normalExchange()).with(\"normalRoutingKey\");\n    }\n}\n```\n\n2. 生产者和消费者（过期进入死信队列）\n```java\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        // 设置消息过期时间为3s\n        amqpTemplate.convertAndSend(\"normalExchange\", \"normalRoutingKey\", content,message -> {\n            message.getMessageProperties().setExpiration(\"3000\");\n            return message;\n        });\n        return content;\n    }\n}\n\n@Component\npublic class Consumer1 {\n    // 将正常消费者注掉，过期后进入死信队列\n//    @RabbitListener(queues = \"normalQueue\")\n//    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n//        System.out.println(\"正常队列收到消息时间为:\"+LocalDateTime.now()+\",收到的消息内容为:\"+ msg);\n//        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n//    }\n\n@RabbitListener(queues = \"dlxQueue\")\npublic void myDealy(String msg, Message message, Channel channel) throws IOException {\n    System.out.println(\"死信收到消息时间为:\"+LocalDateTime.now()+\",收到的消息内容为:\"+ msg);\n    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n}\n}\n```\n\n3. 方式2，手动拒绝进入死信队列\n```java\n// 生产者正常发消息\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        // 设置消息过期时间为3s\n        amqpTemplate.convertAndSend(\"normalExchange\", \"normalRoutingKey\", content);\n        return content;\n    }\n}\n\n@Component\npublic class Consumer1 {\n    // 正常队列拒绝消息basicNack，并且第三个参数requeue设置为false，禁止重新入队\n    @RabbitListener(queues = \"normalQueue\")\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"正常队列收到消息时间为:\"+LocalDateTime.now()+\",收到的消息内容为:\"+ msg);\n        channel.basicNack(message.getMessageProperties().getDeliveryTag(), false,false);\n    }\n\n    @RabbitListener(queues = \"dlxQueue\")\n    public void myDealy(String msg, Message message, Channel channel) throws IOException {\n        System.out.println(\"死信收到消息时间为:\"+LocalDateTime.now()+\",收到的消息内容为:\"+ msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n\n```\n## 3.1、保证消息传递的可靠性\nRabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消息确认。\n投递可靠性：**confirm确认模式**（producer——>exchange）和**return退回模式**（exchange——>queue）\n消息确认：ack消费者确认，表示消费者收到消息后的确认方式\n### 3.1.1、confirm确认模式\n消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)\n\n1. 在配置文件中开启消息确认模式\n```java\n# SIMPLE       禁用发布确认模式，是默认值\n# CORRELATED   发布消息成功到交换器或失败后 会触发回调方法\n# NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用 \n               rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 \n               发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 \n               返回false则会关闭channel，则接下来无法发送消息到broker;\n \nspring.rabbitmq.publisher-confirm-type=CORRELATED\n```\n\n2.  通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理\n```java\n@Component\npublic class RabbitConfirmConfig implements RabbitTemplate.ConfirmCallback {\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n \n        if (!ack) {\n            # 根据具体的业务进行相应的处理\n            System.out.println(\"【交换机】 生产者消息确认失败了====\" + cause);\n        } else {\n            System.out.println(\"【交换机】 生产者消息确认成功====\");\n        }\n    }\n}\n```\n\n3. 对rabbitTemplate进行设置\n```java\n@Configuration\npublic class RabbitConfig {\n \n    @Autowired\n    private RabbitConfirmConfig rabbitConfirmConfig;\n \n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n \n    @PostConstruct\n    public void initRabbitTemplate(){    \n        rabbitTemplate.setConfirmCallback(rabbitConfirmConfig);\n    }\n}\n```\n### 3.1.2、return退回模式\n\n消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）\n\n1. 在配置文件中开启消息异常重新入队\n```java\n# 确保消息发送失败后可以重新返回到队列中\n# 也可以通过 rabbitTemplate.setMandatory(true) 来设置\nspring.rabbitmq.publisher-returns=true\n```\n\n2. 通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理\n```java\n@Component\npublic class RabbitReturnConfig implements RabbitTemplate.ReturnCallback {\n    @Override\n    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {\n        // 根据具体的业务对异常进行处理，自行判断是否消息可以丢弃\n        if (AMQP.NO_ROUTE == replyCode){\n            System.out.println(\"【队列】 交换机路由到队列失败====\" + message);\n        }\n    }\n}\n```\n\n3. 对rabbitTemplate的 returnback 进行设置\n```java\n@Configuration\npublic class RabbitConfig {\n    @Autowired\n    RabbitReturnConfig rabbitReturnConfig;\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @PostConstruct\n    public void initRabbitTemplate(){\n        rabbitTemplate.setReturnCallback(rabbitReturnConfig);\n    }\n}\n\n```\n### 3.1.3、消费者端ack机制\n消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除\n\n1. rabbitmq默认的是自动ack，无需添加其他配置\n\n若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。\n若消费过程中出现异常，则超过ack心跳时间，会触发重试消费\n\n2. 手动ack\n\n开启方式简单，只需要放开此配置即可\n```java\nacknowledge-mode: manual # 设置消费端手动 ack\n```\n\t消费者类\n```java\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        try {\n            int i = 10/0;\n            // 消费成功后ack\n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n        }catch (Exception e){\n            // 消费失败后ack\n            //注意：参数三若设置为true，会出现死循环\n            channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);\n\t\t\t/*\n            if (message.getMessageProperties().getRedelivered()) {//判断是否已经重试过\n                log.error(\"消息已重复处理失败,拒绝再次接收...\");\n                channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); // 拒绝消息\n            } else {\n                log.error(\"消息即将再次返回队列处理...\");\n                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);\n            }\n\t\t\t*/\n        }\n    }\n}\n```\n> 1、basicAck\n> void basicAck(long deliveryTag, boolean multiple) :表示成功确认，使用此回执方法后，消息会被rabbitmq broker 删除。\n> （1）deliveryTag：表示消息投递序号，每次消费消息或者消息重新投递后，deliveryTag都会增加。手动消息确认模式下，我们可以对指定deliveryTag的消息进行ack、nack、reject等操作。\n> （2）multiple：是否批量确认，值为 true 则会一次性 ack所有小于当前消息 deliveryTag 的消息。\n> (举个栗子： 假设我先发送三条消息deliveryTag分别是5、6、7，可它们都没有被确认，当我发第四条消息此时deliveryTag为8，multiple设置为 true，会将5、6、7、8的消息全部进行确认)\n> \n> 2、basicNack\n> void basicNack(long deliveryTag, boolean multiple, boolean requeue)表示失败确认，一般在消费消息业务异常时用到此方法，可以将消息重新投递入队列\n> （1）deliveryTag：表示消息投递序号。\n> （2）multiple：是否批量确认。\n> （3）requeue：值为 true 消息将重新入队列。\n\n\n## 3.2、消息持久化机制\n持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：\n\n1. Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。\n2. Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。\n3. 消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。\n\n>  注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可\n\n### 3.2.1、交换机持久化\n在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true\n```java\n// autoDelete:当所有绑定队列都不在使用时，是否自动 删除\npublic DirectExchange(String name, boolean durable, boolean autoDelete) {\n        super(name, durable, autoDelete);\n}\n\n```\n### 3.2.2、队列持久化\n申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true\n```java\n// exclusive:排他队列，声明了exclusive属性的队列只对首次声明它的连接可见，并且在连接断开时自动删除\n// autoDelete:当所有消费客户端连接断开后，是否自动删除 \npublic Queue(String name, boolean durable, boolean exclusive, boolean autoDelete) {\n        this(name, durable, exclusive, autoDelete, (Map)null);\n}\n```\n## 3.3、避免消息重复消费\n### 3.3.1、消息重复发送的场景\n消息消费成功，事务已经提交，ack时，机器宕机，导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者；相当于锁库存被消费了两遍，即库存扣了两遍；\n\n### 3.3.2、解决方案\n保证消费者的幂等性\n如何保证幂等性？\n\n1. 使用代码的逻辑判断，判断消息状态是否已经被消费过了\n> 使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。\n\n2. 使用token，要申请，一次有效性。\n> 在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）\n\n\n## 3.4、避免消息积压问题\n### 3.4.1、消息积压场景\n消费者宕机/消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压\n### 3.4.2、解决方案\n\n1. 上线更多的消费者（如：库存服务），进行正常消费\n2. 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。\n\n## 3.5、保证消息的顺序性\n### 3.5.1、消息顺序错乱场景\n生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。\n\n### 3.5.2、解决方案\n思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的\n","source":"_posts/RabbitMQ.md","raw":"---\ntitle: RabbitMQ\ndate: 2023/07/24\ncategories:\n  - coding\ntags:\n  - RabbitMQ\n  - 消息队列\nabbrlink: 33708\n---\n# 1、基本基础\n## 1.1、mq概念\nMQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信\n## 1.2、mq优缺点\n**优势：**\n（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单\n（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度\n（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  \n\n**劣势：**\n（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用\n（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？\n（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性\n## 1.3、mq产品选型\n\n|指标 | **ActiveMQ** | **RabbitMQ** | **RocketM Q** | **Kafka** |\n| --- | --- | --- | --- | --- |\n| 数据量级（每秒） | 万级 | 万级 | 十万级 | 十万级 |\n| 可靠性 | 低概率丢失 | 0丢失 | 0丢失 | 0丢失 |\n| 可用性 | 主从架构 | 主从架构 | 分布式 | 分布式 |\n| 时效性 | 毫秒 | 微秒 | 毫秒 | 毫秒 |\n\n> 一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。\n\n## 1.4、AMQP协议\n AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是**应用层协议**的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制 1\n\n## 1.5、rabbitMQ安装\n\n1. 安装Eralng，下面链接已提供otp_win64_20.2.exe\n\n链接： [https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg](https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg)\n提取码：x9m7\n\n2. 安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe\n\n链接： [https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg](https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg)\n提取码：h4r3\n\n3. 配置erlang环境变量\n\n![配置erlang环境变量](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png)\n\n\n\n4. 测试erlang\n\n![测试erlang](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png)\n\n\n5. 启动rabbitmq\n\n![启动rabbitmq](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png)\n\n\n6. 访问 [http://127.0.0.1:15672/](http://127.0.0.1:15672/)      guest guest\n\n\n# 2、mq相关概念\n## 2.1、RabbitMQ架构\n![RabbitMQ架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png)\n\n\n（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。\n（2）Connection：连接，应用程序与Server的网络连接，TCP连接。\n（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。\n（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。\n（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。\n（6）Queue：消息队列，用来保存消息，供消费者消费\n（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。\n（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。\n（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”\n\n## 2.2、4种Exchange交换机类型\n### 2.2.1、Direct Exchange（直连交换机）\n\n根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。\n\n![直连交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png)\n\n\n### 2.2.2、Fanout Exchange（广播交换机）\n该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么\n> 如果想让多个消费者消费到数据必须不指定queues，指定交换机\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n\n        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生\n\n        exchange = @Exchange(value = \"business_rrpc_exchange\",type = ExchangeTypes.FANOUT)\n\n))\n\n\n```\n### 2.2.3、Topic Exchange（主题交换机）\n\n将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“\\*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.\\* ” 只会匹配到“abc.def”。\n\n![主题交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png)\n\n\n### 2.2.4、Headers Exchanges（头交换机）\n\n与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()\n\n> 匹配规则x-match有下列两种类型：\nx-match = all ：表示所有的键值对都匹配才能接受到消息\nx-match = any ：表示只要有键值对匹配就能接受到消息\n\n![image (6).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png)\n\n\n## 2.3、工作模式\n### 2.3.1、简单模式\n一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景\n\n![简单模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png)\n\n\n> P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理\n\n\n```java\n// 1. 创建队列\n@Bean\npublic Queue Queue() {\n    return new Queue(\"hello\");\n}\n\n// 2. 生产者\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        amqpTemplate.convertAndSend(\"queue1\", content);\n        return content;\n    }\n}\n\n// 3. 消费者\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(msg);\n    }\n}\n\n```\n\n\n### 2.3.2、工作队列模式\n一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率\n\n> 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度\n\n![工作队列模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png)\n\n\n**实现方式**\n多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息\n```java\n// 增加一个消费者监听同一个队列\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276)\n\n### 2.3.3、发布订阅模式\n一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景\n\n![发布订阅模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png)\n\n\n1. **实现方式**\n\n（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 \n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nFanoutExchange fanoutExchange1() {\n    return new FanoutExchange(\"fanoutExchange1\");\n}\n\n@Bean\nBinding bindingExchangeA(Queue queue1, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue1).to(fanoutExchange1);\n}\n\n@Bean\nBinding bindingExchangeB(Queue queue2, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue2).to(fanoutExchange1);\n}\n```\n\n（2）生产者消费者\n\n```java\n// 生产者：第二个参数是队列名，设置为空\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"\", content);\n        }\n        return content;\n    }\n}\n// 消费者1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer1: \"+msg);\n    }\n}\n// 消费者2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339)\n\n### 2.3.4、路由模式\n一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景\n\n![路由模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png)\n\n**实现方式**\n（1）交换机和队列根据指定路由规则绑定\n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nDirectExchange directExchange1() {\n    return new DirectExchange(\"directExchange1\");\n}\n\n@Bean\nBinding bindingExchangeMessage1(Queue queue1, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue1).to(directExchange1).with(\"routingKey1\");\n}\n\n\n@Bean\nBinding bindingExchangeMessage2(Queue queue2, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue2).to(directExchange1).with(\"routingKey2\");\n}\n```\n\n（2）生产者和消费者\n```java\n// consumer1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue1 consumer1: \"+msg);\n    }\n}\n// consumer2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue2 consumer2: \"+msg);\n    }\n}\n// producer\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"routingKey1\", content);\n        }\n        return content;\n    }\n}\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335)\n\n\n\n## 2.4、死信队列\n“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：\n（1）消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue =false\n（2）消息在队列的存活时间超过设置的生存时间（TTL)时间。\n（3）消息队列的消息数量已经超过最大队列长度。那么该消息将成为“死信”\n“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃\n```java\n//  业务队列配置死信队列参数（声明业务队列A）\n    @Bean(\"businessQueueA\")\n    public Queue businessQueueA(){\n        Map<String, Object> args = new HashMap<>(2);\n//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机\n        args.put(\"x-dead-letter-exchange\", DEAD_LETTER_EXCHANGE);\n//       x-dead-letter-routing-key  这里声明当前队列的死信路由key\n        args.put(\"x-dead-letter-routing-key\", DEAD_LETTER_QUEUEA_ROUTING_KEY);\n        return QueueBuilder.durable(BUSINESS_QUEUEA_NAME).withArguments(args).build();\n    }\n//  声明业务队列绑定关系\n\n    // 声明业务队列A绑定关系\n    @Bean\n    public Binding businessBindingA(@Qualifier(\"businessQueueA\") Queue queue,\n                                    @Qualifier(\"businessExchange\") FanoutExchange exchange){\n        return BindingBuilder.bind(queue).to(exchange);\n    }\n```\n### 2.4.1、实现方式\n\n1. 交换机，队列配置\n```java\n@Configuration\npublic class RabbitConfig {\n\t/**\n     * 声明死信交换机\n     */\n    @Bean\n    public DirectExchange dlxExchange() {\n        return new DirectExchange(\"dlxExchange\");\n    }\n    /**\n     * 声明死信队列\n     */\n    @Bean\n    public Queue dlxQueue() {\n        return new Queue(\"dlxQueue\");\n    }\n    /**\n     * 绑定死信队列到死信交换机\n     */\n    @Bean\n    public Binding binding() {\n        return BindingBuilder.bind(dlxQueue())\n                .to(dlxExchange())\n                .with(\"dlxRoutingKey\");\n    }\n\n    /**\n     * 普通队列绑定死信即可\n     */\n    @Bean\n    Queue normalQueue(){\n        Map<String,Object> map = new HashMap<>();\n        map.put(\"x-dead-letter-exchange\",\"dlxExchange\");\n        map.put(\"x-dead-letter-routing-key\", \"dlxRoutingKey\");\n        return new Queue(\"normalQueue\",true,false,false,map);\n    }\n\n    @Bean\n    DirectExchange normalExchange(){\n        return new DirectExchange(\"normalExchange\");\n    }\n\n    @Bean\n    Binding normalBindingExchange(){\n        return BindingBuilder.bind( normalQueue()).to(normalExchange()).with(\"normalRoutingKey\");\n    }\n}\n```\n\n2. 生产者和消费者（过期进入死信队列）\n```java\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        // 设置消息过期时间为3s\n        amqpTemplate.convertAndSend(\"normalExchange\", \"normalRoutingKey\", content,message -> {\n            message.getMessageProperties().setExpiration(\"3000\");\n            return message;\n        });\n        return content;\n    }\n}\n\n@Component\npublic class Consumer1 {\n    // 将正常消费者注掉，过期后进入死信队列\n//    @RabbitListener(queues = \"normalQueue\")\n//    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n//        System.out.println(\"正常队列收到消息时间为:\"+LocalDateTime.now()+\",收到的消息内容为:\"+ msg);\n//        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n//    }\n\n@RabbitListener(queues = \"dlxQueue\")\npublic void myDealy(String msg, Message message, Channel channel) throws IOException {\n    System.out.println(\"死信收到消息时间为:\"+LocalDateTime.now()+\",收到的消息内容为:\"+ msg);\n    channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n}\n}\n```\n\n3. 方式2，手动拒绝进入死信队列\n```java\n// 生产者正常发消息\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        // 设置消息过期时间为3s\n        amqpTemplate.convertAndSend(\"normalExchange\", \"normalRoutingKey\", content);\n        return content;\n    }\n}\n\n@Component\npublic class Consumer1 {\n    // 正常队列拒绝消息basicNack，并且第三个参数requeue设置为false，禁止重新入队\n    @RabbitListener(queues = \"normalQueue\")\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"正常队列收到消息时间为:\"+LocalDateTime.now()+\",收到的消息内容为:\"+ msg);\n        channel.basicNack(message.getMessageProperties().getDeliveryTag(), false,false);\n    }\n\n    @RabbitListener(queues = \"dlxQueue\")\n    public void myDealy(String msg, Message message, Channel channel) throws IOException {\n        System.out.println(\"死信收到消息时间为:\"+LocalDateTime.now()+\",收到的消息内容为:\"+ msg);\n        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n    }\n}\n\n```\n## 3.1、保证消息传递的可靠性\nRabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消息确认。\n投递可靠性：**confirm确认模式**（producer——>exchange）和**return退回模式**（exchange——>queue）\n消息确认：ack消费者确认，表示消费者收到消息后的确认方式\n### 3.1.1、confirm确认模式\n消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)\n\n1. 在配置文件中开启消息确认模式\n```java\n# SIMPLE       禁用发布确认模式，是默认值\n# CORRELATED   发布消息成功到交换器或失败后 会触发回调方法\n# NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用 \n               rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 \n               发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 \n               返回false则会关闭channel，则接下来无法发送消息到broker;\n \nspring.rabbitmq.publisher-confirm-type=CORRELATED\n```\n\n2.  通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理\n```java\n@Component\npublic class RabbitConfirmConfig implements RabbitTemplate.ConfirmCallback {\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n \n        if (!ack) {\n            # 根据具体的业务进行相应的处理\n            System.out.println(\"【交换机】 生产者消息确认失败了====\" + cause);\n        } else {\n            System.out.println(\"【交换机】 生产者消息确认成功====\");\n        }\n    }\n}\n```\n\n3. 对rabbitTemplate进行设置\n```java\n@Configuration\npublic class RabbitConfig {\n \n    @Autowired\n    private RabbitConfirmConfig rabbitConfirmConfig;\n \n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n \n    @PostConstruct\n    public void initRabbitTemplate(){    \n        rabbitTemplate.setConfirmCallback(rabbitConfirmConfig);\n    }\n}\n```\n### 3.1.2、return退回模式\n\n消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）\n\n1. 在配置文件中开启消息异常重新入队\n```java\n# 确保消息发送失败后可以重新返回到队列中\n# 也可以通过 rabbitTemplate.setMandatory(true) 来设置\nspring.rabbitmq.publisher-returns=true\n```\n\n2. 通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理\n```java\n@Component\npublic class RabbitReturnConfig implements RabbitTemplate.ReturnCallback {\n    @Override\n    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {\n        // 根据具体的业务对异常进行处理，自行判断是否消息可以丢弃\n        if (AMQP.NO_ROUTE == replyCode){\n            System.out.println(\"【队列】 交换机路由到队列失败====\" + message);\n        }\n    }\n}\n```\n\n3. 对rabbitTemplate的 returnback 进行设置\n```java\n@Configuration\npublic class RabbitConfig {\n    @Autowired\n    RabbitReturnConfig rabbitReturnConfig;\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @PostConstruct\n    public void initRabbitTemplate(){\n        rabbitTemplate.setReturnCallback(rabbitReturnConfig);\n    }\n}\n\n```\n### 3.1.3、消费者端ack机制\n消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除\n\n1. rabbitmq默认的是自动ack，无需添加其他配置\n\n若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。\n若消费过程中出现异常，则超过ack心跳时间，会触发重试消费\n\n2. 手动ack\n\n开启方式简单，只需要放开此配置即可\n```java\nacknowledge-mode: manual # 设置消费端手动 ack\n```\n\t消费者类\n```java\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        try {\n            int i = 10/0;\n            // 消费成功后ack\n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n        }catch (Exception e){\n            // 消费失败后ack\n            //注意：参数三若设置为true，会出现死循环\n            channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);\n\t\t\t/*\n            if (message.getMessageProperties().getRedelivered()) {//判断是否已经重试过\n                log.error(\"消息已重复处理失败,拒绝再次接收...\");\n                channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); // 拒绝消息\n            } else {\n                log.error(\"消息即将再次返回队列处理...\");\n                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);\n            }\n\t\t\t*/\n        }\n    }\n}\n```\n> 1、basicAck\n> void basicAck(long deliveryTag, boolean multiple) :表示成功确认，使用此回执方法后，消息会被rabbitmq broker 删除。\n> （1）deliveryTag：表示消息投递序号，每次消费消息或者消息重新投递后，deliveryTag都会增加。手动消息确认模式下，我们可以对指定deliveryTag的消息进行ack、nack、reject等操作。\n> （2）multiple：是否批量确认，值为 true 则会一次性 ack所有小于当前消息 deliveryTag 的消息。\n> (举个栗子： 假设我先发送三条消息deliveryTag分别是5、6、7，可它们都没有被确认，当我发第四条消息此时deliveryTag为8，multiple设置为 true，会将5、6、7、8的消息全部进行确认)\n> \n> 2、basicNack\n> void basicNack(long deliveryTag, boolean multiple, boolean requeue)表示失败确认，一般在消费消息业务异常时用到此方法，可以将消息重新投递入队列\n> （1）deliveryTag：表示消息投递序号。\n> （2）multiple：是否批量确认。\n> （3）requeue：值为 true 消息将重新入队列。\n\n\n## 3.2、消息持久化机制\n持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：\n\n1. Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。\n2. Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。\n3. 消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。\n\n>  注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可\n\n### 3.2.1、交换机持久化\n在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true\n```java\n// autoDelete:当所有绑定队列都不在使用时，是否自动 删除\npublic DirectExchange(String name, boolean durable, boolean autoDelete) {\n        super(name, durable, autoDelete);\n}\n\n```\n### 3.2.2、队列持久化\n申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true\n```java\n// exclusive:排他队列，声明了exclusive属性的队列只对首次声明它的连接可见，并且在连接断开时自动删除\n// autoDelete:当所有消费客户端连接断开后，是否自动删除 \npublic Queue(String name, boolean durable, boolean exclusive, boolean autoDelete) {\n        this(name, durable, exclusive, autoDelete, (Map)null);\n}\n```\n## 3.3、避免消息重复消费\n### 3.3.1、消息重复发送的场景\n消息消费成功，事务已经提交，ack时，机器宕机，导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者；相当于锁库存被消费了两遍，即库存扣了两遍；\n\n### 3.3.2、解决方案\n保证消费者的幂等性\n如何保证幂等性？\n\n1. 使用代码的逻辑判断，判断消息状态是否已经被消费过了\n> 使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。\n\n2. 使用token，要申请，一次有效性。\n> 在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）\n\n\n## 3.4、避免消息积压问题\n### 3.4.1、消息积压场景\n消费者宕机/消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压\n### 3.4.2、解决方案\n\n1. 上线更多的消费者（如：库存服务），进行正常消费\n2. 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。\n\n## 3.5、保证消息的顺序性\n### 3.5.1、消息顺序错乱场景\n生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。\n\n### 3.5.2、解决方案\n思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的\n","slug":"RabbitMQ","published":1,"updated":"2023-07-25T13:19:14.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkqz2ipr00036wujakd1hodm","content":"<h1 id=\"1、基本基础\"><a href=\"#1、基本基础\" class=\"headerlink\" title=\"1、基本基础\"></a>1、基本基础</h1><h2 id=\"1-1、mq概念\"><a href=\"#1-1、mq概念\" class=\"headerlink\" title=\"1.1、mq概念\"></a>1.1、mq概念</h2><p>MQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信</p>\n<h2 id=\"1-2、mq优缺点\"><a href=\"#1-2、mq优缺点\" class=\"headerlink\" title=\"1.2、mq优缺点\"></a>1.2、mq优缺点</h2><p><strong>优势：</strong><br>（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单<br>（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度<br>（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  </p>\n<p><strong>劣势：</strong><br>（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用<br>（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？<br>（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性</p>\n<h2 id=\"1-3、mq产品选型\"><a href=\"#1-3、mq产品选型\" class=\"headerlink\" title=\"1.3、mq产品选型\"></a>1.3、mq产品选型</h2><table>\n<thead>\n<tr>\n<th>指标</th>\n<th><strong>ActiveMQ</strong></th>\n<th><strong>RabbitMQ</strong></th>\n<th><strong>RocketM Q</strong></th>\n<th><strong>Kafka</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据量级（每秒）</td>\n<td>万级</td>\n<td>万级</td>\n<td>十万级</td>\n<td>十万级</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>低概率丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>主从架构</td>\n<td>主从架构</td>\n<td>分布式</td>\n<td>分布式</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>毫秒</td>\n<td>微秒</td>\n<td>毫秒</td>\n<td>毫秒</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。</p>\n</blockquote>\n<h2 id=\"1-4、AMQP协议\"><a href=\"#1-4、AMQP协议\" class=\"headerlink\" title=\"1.4、AMQP协议\"></a>1.4、AMQP协议</h2><p> AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是<strong>应用层协议</strong>的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制 1</p>\n<h2 id=\"1-5、rabbitMQ安装\"><a href=\"#1-5、rabbitMQ安装\" class=\"headerlink\" title=\"1.5、rabbitMQ安装\"></a>1.5、rabbitMQ安装</h2><ol>\n<li>安装Eralng，下面链接已提供otp_win64_20.2.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg\">https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg</a><br>提取码：x9m7</p>\n<ol start=\"2\">\n<li>安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg\">https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg</a><br>提取码：h4r3</p>\n<ol start=\"3\">\n<li>配置erlang环境变量</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png\" alt=\"配置erlang环境变量\"></p>\n<ol start=\"4\">\n<li>测试erlang</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png\" alt=\"测试erlang\"></p>\n<ol start=\"5\">\n<li>启动rabbitmq</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png\" alt=\"启动rabbitmq\"></p>\n<ol start=\"6\">\n<li>访问 <a href=\"http://127.0.0.1:15672/\">http://127.0.0.1:15672/</a>      guest guest</li>\n</ol>\n<h1 id=\"2、mq相关概念\"><a href=\"#2、mq相关概念\" class=\"headerlink\" title=\"2、mq相关概念\"></a>2、mq相关概念</h1><h2 id=\"2-1、RabbitMQ架构\"><a href=\"#2-1、RabbitMQ架构\" class=\"headerlink\" title=\"2.1、RabbitMQ架构\"></a>2.1、RabbitMQ架构</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png\" alt=\"RabbitMQ架构\"></p>\n<p>（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。<br>（2）Connection：连接，应用程序与Server的网络连接，TCP连接。<br>（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。<br>（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。<br>（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。<br>（6）Queue：消息队列，用来保存消息，供消费者消费<br>（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。<br>（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。<br>（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”</p>\n<h2 id=\"2-2、4种Exchange交换机类型\"><a href=\"#2-2、4种Exchange交换机类型\" class=\"headerlink\" title=\"2.2、4种Exchange交换机类型\"></a>2.2、4种Exchange交换机类型</h2><h3 id=\"2-2-1、Direct-Exchange（直连交换机）\"><a href=\"#2-2-1、Direct-Exchange（直连交换机）\" class=\"headerlink\" title=\"2.2.1、Direct Exchange（直连交换机）\"></a>2.2.1、Direct Exchange（直连交换机）</h3><p>根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png\" alt=\"直连交换机\"></p>\n<h3 id=\"2-2-2、Fanout-Exchange（广播交换机）\"><a href=\"#2-2-2、Fanout-Exchange（广播交换机）\" class=\"headerlink\" title=\"2.2.2、Fanout Exchange（广播交换机）\"></a>2.2.2、Fanout Exchange（广播交换机）</h3><p>该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么</p>\n<blockquote>\n<p>如果想让多个消费者消费到数据必须不指定queues，指定交换机</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(value = &quot;business_rrpc_exchange&quot;,type = ExchangeTypes.FANOUT)</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-3、Topic-Exchange（主题交换机）\"><a href=\"#2-2-3、Topic-Exchange（主题交换机）\" class=\"headerlink\" title=\"2.2.3、Topic Exchange（主题交换机）\"></a>2.2.3、Topic Exchange（主题交换机）</h3><p>将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.* ” 只会匹配到“abc.def”。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png\" alt=\"主题交换机\"></p>\n<h3 id=\"2-2-4、Headers-Exchanges（头交换机）\"><a href=\"#2-2-4、Headers-Exchanges（头交换机）\" class=\"headerlink\" title=\"2.2.4、Headers Exchanges（头交换机）\"></a>2.2.4、Headers Exchanges（头交换机）</h3><p>与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()</p>\n<blockquote>\n<p>匹配规则x-match有下列两种类型：<br>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息<br>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png\" alt=\"image (6).png\"></p>\n<h2 id=\"2-3、工作模式\"><a href=\"#2-3、工作模式\" class=\"headerlink\" title=\"2.3、工作模式\"></a>2.3、工作模式</h2><h3 id=\"2-3-1、简单模式\"><a href=\"#2-3-1、简单模式\" class=\"headerlink\" title=\"2.3.1、简单模式\"></a>2.3.1、简单模式</h3><p>一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png\" alt=\"简单模式\"></p>\n<blockquote>\n<p>P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建队列</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">Queue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 生产者</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;queue1&quot;</span>, content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 消费者</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-3-2、工作队列模式\"><a href=\"#2-3-2、工作队列模式\" class=\"headerlink\" title=\"2.3.2、工作队列模式\"></a>2.3.2、工作队列模式</h3><p>一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率</p>\n<blockquote>\n<p>对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png\" alt=\"工作队列模式\"></p>\n<p><strong>实现方式</strong><br>多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 增加一个消费者监听同一个队列</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276\" alt=\"image.png\"></p>\n<h3 id=\"2-3-3、发布订阅模式\"><a href=\"#2-3-3、发布订阅模式\" class=\"headerlink\" title=\"2.3.3、发布订阅模式\"></a>2.3.3、发布订阅模式</h3><p>一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png\" alt=\"发布订阅模式\"></p>\n<ol>\n<li><strong>实现方式</strong></li>\n</ol>\n<p>（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">FanoutExchange <span class=\"title function_\">fanoutExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FanoutExchange</span>(<span class=\"string\">&quot;fanoutExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeA</span><span class=\"params\">(Queue queue1, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeB</span><span class=\"params\">(Queue queue2, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者：第二个参数是队列名，设置为空</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339\" alt=\"image.png\"></p>\n<h3 id=\"2-3-4、路由模式\"><a href=\"#2-3-4、路由模式\" class=\"headerlink\" title=\"2.3.4、路由模式\"></a>2.3.4、路由模式</h3><p>一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png\" alt=\"路由模式\"></p>\n<p><strong>实现方式</strong><br>（1）交换机和队列根据指定路由规则绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">DirectExchange <span class=\"title function_\">directExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;directExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage1</span><span class=\"params\">(Queue queue1, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(directExchange1).with(<span class=\"string\">&quot;routingKey1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage2</span><span class=\"params\">(Queue queue2, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(directExchange1).with(<span class=\"string\">&quot;routingKey2&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者和消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue1 consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue2 consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// producer</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;routingKey1&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335\" alt=\"image.png\"></p>\n<h2 id=\"2-4、死信队列\"><a href=\"#2-4、死信队列\" class=\"headerlink\" title=\"2.4、死信队列\"></a>2.4、死信队列</h2><p>“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：<br>（1）消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue &#x3D;false<br>（2）消息在队列的存活时间超过设置的生存时间（TTL)时间。<br>（3）消息队列的消息数量已经超过最大队列长度。那么该消息将成为“死信”<br>“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  业务队列配置死信队列参数（声明业务队列A）</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;businessQueueA&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">businessQueueA</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\"><span class=\"comment\">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(BUSINESS_QUEUEA_NAME).withArguments(args).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//  声明业务队列绑定关系</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明业务队列A绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">businessBindingA</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;businessQueueA&quot;)</span> Queue queue,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"meta\">@Qualifier(&quot;businessExchange&quot;)</span> FanoutExchange exchange)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-1、实现方式\"><a href=\"#2-4-1、实现方式\" class=\"headerlink\" title=\"2.4.1、实现方式\"></a>2.4.1、实现方式</h3><ol>\n<li><p>交换机，队列配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 声明死信交换机</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">dlxExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;dlxExchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 声明死信队列</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">dlxQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;dlxQueue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 绑定死信队列到死信交换机</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">binding</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(dlxQueue())</span><br><span class=\"line\">                .to(dlxExchange())</span><br><span class=\"line\">                .with(<span class=\"string\">&quot;dlxRoutingKey&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通队列绑定死信即可</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    Queue <span class=\"title function_\">normalQueue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>,<span class=\"string\">&quot;dlxExchange&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;dlxRoutingKey&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;normalQueue&quot;</span>,<span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>,map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    DirectExchange <span class=\"title function_\">normalExchange</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;normalExchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    Binding <span class=\"title function_\">normalBindingExchange</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind( normalQueue()).to(normalExchange()).with(<span class=\"string\">&quot;normalRoutingKey&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生产者和消费者（过期进入死信队列）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 设置消息过期时间为3s</span></span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;normalExchange&quot;</span>, <span class=\"string\">&quot;normalRoutingKey&quot;</span>, content,message -&gt; &#123;</span><br><span class=\"line\">            message.getMessageProperties().setExpiration(<span class=\"string\">&quot;3000&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将正常消费者注掉，过期后进入死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//    @RabbitListener(queues = &quot;normalQueue&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//    public void getMsg(String msg, Channel channel, Message message) throws IOException &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;正常队列收到消息时间为:&quot;+LocalDateTime.now()+&quot;,收到的消息内容为:&quot;+ msg);</span></span><br><span class=\"line\"><span class=\"comment\">//        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;dlxQueue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myDealy</span><span class=\"params\">(String msg, Message message, Channel channel)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;死信收到消息时间为:&quot;</span>+LocalDateTime.now()+<span class=\"string\">&quot;,收到的消息内容为:&quot;</span>+ msg);</span><br><span class=\"line\">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方式2，手动拒绝进入死信队列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者正常发消息</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 设置消息过期时间为3s</span></span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;normalExchange&quot;</span>, <span class=\"string\">&quot;normalRoutingKey&quot;</span>, content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 正常队列拒绝消息basicNack，并且第三个参数requeue设置为false，禁止重新入队</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;normalQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;正常队列收到消息时间为:&quot;</span>+LocalDateTime.now()+<span class=\"string\">&quot;,收到的消息内容为:&quot;</span>+ msg);</span><br><span class=\"line\">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;dlxQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myDealy</span><span class=\"params\">(String msg, Message message, Channel channel)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;死信收到消息时间为:&quot;</span>+LocalDateTime.now()+<span class=\"string\">&quot;,收到的消息内容为:&quot;</span>+ msg);</span><br><span class=\"line\">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"3-1、保证消息传递的可靠性\"><a href=\"#3-1、保证消息传递的可靠性\" class=\"headerlink\" title=\"3.1、保证消息传递的可靠性\"></a>3.1、保证消息传递的可靠性</h2><p>RabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消息确认。<br>投递可靠性：<strong>confirm确认模式</strong>（producer——&gt;exchange）和<strong>return退回模式</strong>（exchange——&gt;queue）<br>消息确认：ack消费者确认，表示消费者收到消息后的确认方式</p>\n<h3 id=\"3-1-1、confirm确认模式\"><a href=\"#3-1-1、confirm确认模式\" class=\"headerlink\" title=\"3.1.1、confirm确认模式\"></a>3.1.1、confirm确认模式</h3><p>消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)</p>\n<ol>\n<li><p>在配置文件中开启消息确认模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SIMPLE       禁用发布确认模式，是默认值</span><br><span class=\"line\"># CORRELATED   发布消息成功到交换器或失败后 会触发回调方法</span><br><span class=\"line\"># NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用 </span><br><span class=\"line\">               rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 </span><br><span class=\"line\">               发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 </span><br><span class=\"line\">               返回<span class=\"literal\">false</span>则会关闭channel，则接下来无法发送消息到broker;</span><br><span class=\"line\"> </span><br><span class=\"line\">spring.rabbitmq.publisher-confirm-type=CORRELATED</span><br></pre></td></tr></table></figure>\n</li>\n<li><p> 通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfirmConfig</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"type\">boolean</span> ack, String cause)</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ack) &#123;</span><br><span class=\"line\">            # 根据具体的业务进行相应的处理</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;【交换机】 生产者消息确认失败了====&quot;</span> + cause);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;【交换机】 生产者消息确认成功====&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对rabbitTemplate进行设置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitConfirmConfig rabbitConfirmConfig;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initRabbitTemplate</span><span class=\"params\">()</span>&#123;    </span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(rabbitConfirmConfig);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"3-1-2、return退回模式\"><a href=\"#3-1-2、return退回模式\" class=\"headerlink\" title=\"3.1.2、return退回模式\"></a>3.1.2、return退回模式</h3><p>消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）</p>\n<ol>\n<li><p>在配置文件中开启消息异常重新入队</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 确保消息发送失败后可以重新返回到队列中</span><br><span class=\"line\"># 也可以通过 rabbitTemplate.setMandatory(<span class=\"literal\">true</span>) 来设置</span><br><span class=\"line\">spring.rabbitmq.publisher-returns=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitReturnConfig</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RabbitTemplate</span>.ReturnCallback &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"type\">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据具体的业务对异常进行处理，自行判断是否消息可以丢弃</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (AMQP.NO_ROUTE == replyCode)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;【队列】 交换机路由到队列失败====&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对rabbitTemplate的 returnback 进行设置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RabbitReturnConfig rabbitReturnConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initRabbitTemplate</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(rabbitReturnConfig);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"3-1-3、消费者端ack机制\"><a href=\"#3-1-3、消费者端ack机制\" class=\"headerlink\" title=\"3.1.3、消费者端ack机制\"></a>3.1.3、消费者端ack机制</h3><p>消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除</p>\n<ol>\n<li>rabbitmq默认的是自动ack，无需添加其他配置</li>\n</ol>\n<p>若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。<br>若消费过程中出现异常，则超过ack心跳时间，会触发重试消费</p>\n<ol start=\"2\">\n<li>手动ack</li>\n</ol>\n<p>开启方式简单，只需要放开此配置即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acknowledge-mode: manual # 设置消费端手动 ack</span><br></pre></td></tr></table></figure>\n<pre><code>消费者类\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>/<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 消费成功后ack</span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 消费失败后ack</span></span><br><span class=\"line\">            <span class=\"comment\">//注意：参数三若设置为true，会出现死循环</span></span><br><span class=\"line\">            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class=\"literal\">false</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            if (message.getMessageProperties().getRedelivered()) &#123;//判断是否已经重试过</span></span><br><span class=\"line\"><span class=\"comment\">                log.error(&quot;消息已重复处理失败,拒绝再次接收...&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); // 拒绝消息</span></span><br><span class=\"line\"><span class=\"comment\">            &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                log.error(&quot;消息即将再次返回队列处理...&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>1、basicAck<br>void basicAck(long deliveryTag, boolean multiple) :表示成功确认，使用此回执方法后，消息会被rabbitmq broker 删除。<br>（1）deliveryTag：表示消息投递序号，每次消费消息或者消息重新投递后，deliveryTag都会增加。手动消息确认模式下，我们可以对指定deliveryTag的消息进行ack、nack、reject等操作。<br>（2）multiple：是否批量确认，值为 true 则会一次性 ack所有小于当前消息 deliveryTag 的消息。<br>(举个栗子： 假设我先发送三条消息deliveryTag分别是5、6、7，可它们都没有被确认，当我发第四条消息此时deliveryTag为8，multiple设置为 true，会将5、6、7、8的消息全部进行确认)</p>\n<p>2、basicNack<br>void basicNack(long deliveryTag, boolean multiple, boolean requeue)表示失败确认，一般在消费消息业务异常时用到此方法，可以将消息重新投递入队列<br>（1）deliveryTag：表示消息投递序号。<br>（2）multiple：是否批量确认。<br>（3）requeue：值为 true 消息将重新入队列。</p>\n</blockquote>\n<h2 id=\"3-2、消息持久化机制\"><a href=\"#3-2、消息持久化机制\" class=\"headerlink\" title=\"3.2、消息持久化机制\"></a>3.2、消息持久化机制</h2><p>持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：</p>\n<ol>\n<li>Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。</li>\n<li>Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。</li>\n<li>消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。</li>\n</ol>\n<blockquote>\n<p> 注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可</p>\n</blockquote>\n<h3 id=\"3-2-1、交换机持久化\"><a href=\"#3-2-1、交换机持久化\" class=\"headerlink\" title=\"3.2.1、交换机持久化\"></a>3.2.1、交换机持久化</h3><p>在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// autoDelete:当所有绑定队列都不在使用时，是否自动 删除</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DirectExchange</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, durable, autoDelete);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-2、队列持久化\"><a href=\"#3-2-2、队列持久化\" class=\"headerlink\" title=\"3.2.2、队列持久化\"></a>3.2.2、队列持久化</h3><p>申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// exclusive:排他队列，声明了exclusive属性的队列只对首次声明它的连接可见，并且在连接断开时自动删除</span></span><br><span class=\"line\"><span class=\"comment\">// autoDelete:当所有消费客户端连接断开后，是否自动删除 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Queue</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> exclusive, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(name, durable, exclusive, autoDelete, (Map)<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3、避免消息重复消费\"><a href=\"#3-3、避免消息重复消费\" class=\"headerlink\" title=\"3.3、避免消息重复消费\"></a>3.3、避免消息重复消费</h2><h3 id=\"3-3-1、消息重复发送的场景\"><a href=\"#3-3-1、消息重复发送的场景\" class=\"headerlink\" title=\"3.3.1、消息重复发送的场景\"></a>3.3.1、消息重复发送的场景</h3><p>消息消费成功，事务已经提交，ack时，机器宕机，导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者；相当于锁库存被消费了两遍，即库存扣了两遍；</p>\n<h3 id=\"3-3-2、解决方案\"><a href=\"#3-3-2、解决方案\" class=\"headerlink\" title=\"3.3.2、解决方案\"></a>3.3.2、解决方案</h3><p>保证消费者的幂等性<br>如何保证幂等性？</p>\n<ol>\n<li><p>使用代码的逻辑判断，判断消息状态是否已经被消费过了</p>\n<blockquote>\n<p>使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。</p>\n</blockquote>\n</li>\n<li><p>使用token，要申请，一次有效性。</p>\n<blockquote>\n<p>在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"3-4、避免消息积压问题\"><a href=\"#3-4、避免消息积压问题\" class=\"headerlink\" title=\"3.4、避免消息积压问题\"></a>3.4、避免消息积压问题</h2><h3 id=\"3-4-1、消息积压场景\"><a href=\"#3-4-1、消息积压场景\" class=\"headerlink\" title=\"3.4.1、消息积压场景\"></a>3.4.1、消息积压场景</h3><p>消费者宕机&#x2F;消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压</p>\n<h3 id=\"3-4-2、解决方案\"><a href=\"#3-4-2、解决方案\" class=\"headerlink\" title=\"3.4.2、解决方案\"></a>3.4.2、解决方案</h3><ol>\n<li>上线更多的消费者（如：库存服务），进行正常消费</li>\n<li>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。</li>\n</ol>\n<h2 id=\"3-5、保证消息的顺序性\"><a href=\"#3-5、保证消息的顺序性\" class=\"headerlink\" title=\"3.5、保证消息的顺序性\"></a>3.5、保证消息的顺序性</h2><h3 id=\"3-5-1、消息顺序错乱场景\"><a href=\"#3-5-1、消息顺序错乱场景\" class=\"headerlink\" title=\"3.5.1、消息顺序错乱场景\"></a>3.5.1、消息顺序错乱场景</h3><p>生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。</p>\n<h3 id=\"3-5-2、解决方案\"><a href=\"#3-5-2、解决方案\" class=\"headerlink\" title=\"3.5.2、解决方案\"></a>3.5.2、解决方案</h3><p>思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、基本基础\"><a href=\"#1、基本基础\" class=\"headerlink\" title=\"1、基本基础\"></a>1、基本基础</h1><h2 id=\"1-1、mq概念\"><a href=\"#1-1、mq概念\" class=\"headerlink\" title=\"1.1、mq概念\"></a>1.1、mq概念</h2><p>MQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信</p>\n<h2 id=\"1-2、mq优缺点\"><a href=\"#1-2、mq优缺点\" class=\"headerlink\" title=\"1.2、mq优缺点\"></a>1.2、mq优缺点</h2><p><strong>优势：</strong><br>（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单<br>（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度<br>（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  </p>\n<p><strong>劣势：</strong><br>（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用<br>（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？<br>（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性</p>\n<h2 id=\"1-3、mq产品选型\"><a href=\"#1-3、mq产品选型\" class=\"headerlink\" title=\"1.3、mq产品选型\"></a>1.3、mq产品选型</h2><table>\n<thead>\n<tr>\n<th>指标</th>\n<th><strong>ActiveMQ</strong></th>\n<th><strong>RabbitMQ</strong></th>\n<th><strong>RocketM Q</strong></th>\n<th><strong>Kafka</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据量级（每秒）</td>\n<td>万级</td>\n<td>万级</td>\n<td>十万级</td>\n<td>十万级</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>低概率丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>主从架构</td>\n<td>主从架构</td>\n<td>分布式</td>\n<td>分布式</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>毫秒</td>\n<td>微秒</td>\n<td>毫秒</td>\n<td>毫秒</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。</p>\n</blockquote>\n<h2 id=\"1-4、AMQP协议\"><a href=\"#1-4、AMQP协议\" class=\"headerlink\" title=\"1.4、AMQP协议\"></a>1.4、AMQP协议</h2><p> AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是<strong>应用层协议</strong>的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制 1</p>\n<h2 id=\"1-5、rabbitMQ安装\"><a href=\"#1-5、rabbitMQ安装\" class=\"headerlink\" title=\"1.5、rabbitMQ安装\"></a>1.5、rabbitMQ安装</h2><ol>\n<li>安装Eralng，下面链接已提供otp_win64_20.2.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg\">https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg</a><br>提取码：x9m7</p>\n<ol start=\"2\">\n<li>安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg\">https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg</a><br>提取码：h4r3</p>\n<ol start=\"3\">\n<li>配置erlang环境变量</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png\" alt=\"配置erlang环境变量\"></p>\n<ol start=\"4\">\n<li>测试erlang</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png\" alt=\"测试erlang\"></p>\n<ol start=\"5\">\n<li>启动rabbitmq</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png\" alt=\"启动rabbitmq\"></p>\n<ol start=\"6\">\n<li>访问 <a href=\"http://127.0.0.1:15672/\">http://127.0.0.1:15672/</a>      guest guest</li>\n</ol>\n<h1 id=\"2、mq相关概念\"><a href=\"#2、mq相关概念\" class=\"headerlink\" title=\"2、mq相关概念\"></a>2、mq相关概念</h1><h2 id=\"2-1、RabbitMQ架构\"><a href=\"#2-1、RabbitMQ架构\" class=\"headerlink\" title=\"2.1、RabbitMQ架构\"></a>2.1、RabbitMQ架构</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png\" alt=\"RabbitMQ架构\"></p>\n<p>（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。<br>（2）Connection：连接，应用程序与Server的网络连接，TCP连接。<br>（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。<br>（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。<br>（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。<br>（6）Queue：消息队列，用来保存消息，供消费者消费<br>（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。<br>（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。<br>（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”</p>\n<h2 id=\"2-2、4种Exchange交换机类型\"><a href=\"#2-2、4种Exchange交换机类型\" class=\"headerlink\" title=\"2.2、4种Exchange交换机类型\"></a>2.2、4种Exchange交换机类型</h2><h3 id=\"2-2-1、Direct-Exchange（直连交换机）\"><a href=\"#2-2-1、Direct-Exchange（直连交换机）\" class=\"headerlink\" title=\"2.2.1、Direct Exchange（直连交换机）\"></a>2.2.1、Direct Exchange（直连交换机）</h3><p>根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png\" alt=\"直连交换机\"></p>\n<h3 id=\"2-2-2、Fanout-Exchange（广播交换机）\"><a href=\"#2-2-2、Fanout-Exchange（广播交换机）\" class=\"headerlink\" title=\"2.2.2、Fanout Exchange（广播交换机）\"></a>2.2.2、Fanout Exchange（广播交换机）</h3><p>该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么</p>\n<blockquote>\n<p>如果想让多个消费者消费到数据必须不指定queues，指定交换机</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(value = &quot;business_rrpc_exchange&quot;,type = ExchangeTypes.FANOUT)</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-3、Topic-Exchange（主题交换机）\"><a href=\"#2-2-3、Topic-Exchange（主题交换机）\" class=\"headerlink\" title=\"2.2.3、Topic Exchange（主题交换机）\"></a>2.2.3、Topic Exchange（主题交换机）</h3><p>将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.* ” 只会匹配到“abc.def”。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png\" alt=\"主题交换机\"></p>\n<h3 id=\"2-2-4、Headers-Exchanges（头交换机）\"><a href=\"#2-2-4、Headers-Exchanges（头交换机）\" class=\"headerlink\" title=\"2.2.4、Headers Exchanges（头交换机）\"></a>2.2.4、Headers Exchanges（头交换机）</h3><p>与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()</p>\n<blockquote>\n<p>匹配规则x-match有下列两种类型：<br>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息<br>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png\" alt=\"image (6).png\"></p>\n<h2 id=\"2-3、工作模式\"><a href=\"#2-3、工作模式\" class=\"headerlink\" title=\"2.3、工作模式\"></a>2.3、工作模式</h2><h3 id=\"2-3-1、简单模式\"><a href=\"#2-3-1、简单模式\" class=\"headerlink\" title=\"2.3.1、简单模式\"></a>2.3.1、简单模式</h3><p>一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png\" alt=\"简单模式\"></p>\n<blockquote>\n<p>P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建队列</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">Queue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 生产者</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;queue1&quot;</span>, content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 消费者</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-3-2、工作队列模式\"><a href=\"#2-3-2、工作队列模式\" class=\"headerlink\" title=\"2.3.2、工作队列模式\"></a>2.3.2、工作队列模式</h3><p>一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率</p>\n<blockquote>\n<p>对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png\" alt=\"工作队列模式\"></p>\n<p><strong>实现方式</strong><br>多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 增加一个消费者监听同一个队列</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276\" alt=\"image.png\"></p>\n<h3 id=\"2-3-3、发布订阅模式\"><a href=\"#2-3-3、发布订阅模式\" class=\"headerlink\" title=\"2.3.3、发布订阅模式\"></a>2.3.3、发布订阅模式</h3><p>一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png\" alt=\"发布订阅模式\"></p>\n<ol>\n<li><strong>实现方式</strong></li>\n</ol>\n<p>（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">FanoutExchange <span class=\"title function_\">fanoutExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FanoutExchange</span>(<span class=\"string\">&quot;fanoutExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeA</span><span class=\"params\">(Queue queue1, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeB</span><span class=\"params\">(Queue queue2, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者：第二个参数是队列名，设置为空</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339\" alt=\"image.png\"></p>\n<h3 id=\"2-3-4、路由模式\"><a href=\"#2-3-4、路由模式\" class=\"headerlink\" title=\"2.3.4、路由模式\"></a>2.3.4、路由模式</h3><p>一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png\" alt=\"路由模式\"></p>\n<p><strong>实现方式</strong><br>（1）交换机和队列根据指定路由规则绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">DirectExchange <span class=\"title function_\">directExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;directExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage1</span><span class=\"params\">(Queue queue1, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(directExchange1).with(<span class=\"string\">&quot;routingKey1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage2</span><span class=\"params\">(Queue queue2, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(directExchange1).with(<span class=\"string\">&quot;routingKey2&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者和消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue1 consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue2 consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// producer</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;routingKey1&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335\" alt=\"image.png\"></p>\n<h2 id=\"2-4、死信队列\"><a href=\"#2-4、死信队列\" class=\"headerlink\" title=\"2.4、死信队列\"></a>2.4、死信队列</h2><p>“死信”是RabbitMQ中的一种消息机制，当你在消费消息时，如果队列里的消息出现以下情况：<br>（1）消息被否定确认，使用 channel.basicNack 或 channel.basicReject ，并且此时requeue &#x3D;false<br>（2）消息在队列的存活时间超过设置的生存时间（TTL)时间。<br>（3）消息队列的消息数量已经超过最大队列长度。那么该消息将成为“死信”<br>“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  业务队列配置死信队列参数（声明业务队列A）</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean(&quot;businessQueueA&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">businessQueueA</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Map&lt;String, Object&gt; args = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">//       x-dead-letter-exchange    这里声明当前队列绑定的死信交换机</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>, DEAD_LETTER_EXCHANGE);</span><br><span class=\"line\"><span class=\"comment\">//       x-dead-letter-routing-key  这里声明当前队列的死信路由key</span></span><br><span class=\"line\">        args.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, DEAD_LETTER_QUEUEA_ROUTING_KEY);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> QueueBuilder.durable(BUSINESS_QUEUEA_NAME).withArguments(args).build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//  声明业务队列绑定关系</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 声明业务队列A绑定关系</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">businessBindingA</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;businessQueueA&quot;)</span> Queue queue,</span></span><br><span class=\"line\"><span class=\"params\">                                    <span class=\"meta\">@Qualifier(&quot;businessExchange&quot;)</span> FanoutExchange exchange)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(queue).to(exchange);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-4-1、实现方式\"><a href=\"#2-4-1、实现方式\" class=\"headerlink\" title=\"2.4.1、实现方式\"></a>2.4.1、实现方式</h3><ol>\n<li><p>交换机，队列配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 声明死信交换机</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> DirectExchange <span class=\"title function_\">dlxExchange</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;dlxExchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 声明死信队列</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Queue <span class=\"title function_\">dlxQueue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;dlxQueue&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 绑定死信队列到死信交换机</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Binding <span class=\"title function_\">binding</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind(dlxQueue())</span><br><span class=\"line\">                .to(dlxExchange())</span><br><span class=\"line\">                .with(<span class=\"string\">&quot;dlxRoutingKey&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通队列绑定死信即可</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    Queue <span class=\"title function_\">normalQueue</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        Map&lt;String,Object&gt; map = <span class=\"keyword\">new</span> <span class=\"title class_\">HashMap</span>&lt;&gt;();</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-exchange&quot;</span>,<span class=\"string\">&quot;dlxExchange&quot;</span>);</span><br><span class=\"line\">        map.put(<span class=\"string\">&quot;x-dead-letter-routing-key&quot;</span>, <span class=\"string\">&quot;dlxRoutingKey&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;normalQueue&quot;</span>,<span class=\"literal\">true</span>,<span class=\"literal\">false</span>,<span class=\"literal\">false</span>,map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    DirectExchange <span class=\"title function_\">normalExchange</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;normalExchange&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    Binding <span class=\"title function_\">normalBindingExchange</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> BindingBuilder.bind( normalQueue()).to(normalExchange()).with(<span class=\"string\">&quot;normalRoutingKey&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>生产者和消费者（过期进入死信队列）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 设置消息过期时间为3s</span></span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;normalExchange&quot;</span>, <span class=\"string\">&quot;normalRoutingKey&quot;</span>, content,message -&gt; &#123;</span><br><span class=\"line\">            message.getMessageProperties().setExpiration(<span class=\"string\">&quot;3000&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> message;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将正常消费者注掉，过期后进入死信队列</span></span><br><span class=\"line\"><span class=\"comment\">//    @RabbitListener(queues = &quot;normalQueue&quot;)</span></span><br><span class=\"line\"><span class=\"comment\">//    public void getMsg(String msg, Channel channel, Message message) throws IOException &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(&quot;正常队列收到消息时间为:&quot;+LocalDateTime.now()+&quot;,收到的消息内容为:&quot;+ msg);</span></span><br><span class=\"line\"><span class=\"comment\">//        channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);</span></span><br><span class=\"line\"><span class=\"comment\">//    &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RabbitListener(queues = &quot;dlxQueue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myDealy</span><span class=\"params\">(String msg, Message message, Channel channel)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;死信收到消息时间为:&quot;</span>+LocalDateTime.now()+<span class=\"string\">&quot;,收到的消息内容为:&quot;</span>+ msg);</span><br><span class=\"line\">    channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>方式2，手动拒绝进入死信队列</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者正常发消息</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 设置消息过期时间为3s</span></span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;normalExchange&quot;</span>, <span class=\"string\">&quot;normalRoutingKey&quot;</span>, content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 正常队列拒绝消息basicNack，并且第三个参数requeue设置为false，禁止重新入队</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;normalQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;正常队列收到消息时间为:&quot;</span>+LocalDateTime.now()+<span class=\"string\">&quot;,收到的消息内容为:&quot;</span>+ msg);</span><br><span class=\"line\">        channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;dlxQueue&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myDealy</span><span class=\"params\">(String msg, Message message, Channel channel)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;死信收到消息时间为:&quot;</span>+LocalDateTime.now()+<span class=\"string\">&quot;,收到的消息内容为:&quot;</span>+ msg);</span><br><span class=\"line\">        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"3-1、保证消息传递的可靠性\"><a href=\"#3-1、保证消息传递的可靠性\" class=\"headerlink\" title=\"3.1、保证消息传递的可靠性\"></a>3.1、保证消息传递的可靠性</h2><p>RabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消息确认。<br>投递可靠性：<strong>confirm确认模式</strong>（producer——&gt;exchange）和<strong>return退回模式</strong>（exchange——&gt;queue）<br>消息确认：ack消费者确认，表示消费者收到消息后的确认方式</p>\n<h3 id=\"3-1-1、confirm确认模式\"><a href=\"#3-1-1、confirm确认模式\" class=\"headerlink\" title=\"3.1.1、confirm确认模式\"></a>3.1.1、confirm确认模式</h3><p>消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)</p>\n<ol>\n<li><p>在配置文件中开启消息确认模式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># SIMPLE       禁用发布确认模式，是默认值</span><br><span class=\"line\"># CORRELATED   发布消息成功到交换器或失败后 会触发回调方法</span><br><span class=\"line\"># NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用 </span><br><span class=\"line\">               rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 </span><br><span class=\"line\">               发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 </span><br><span class=\"line\">               返回<span class=\"literal\">false</span>则会关闭channel，则接下来无法发送消息到broker;</span><br><span class=\"line\"> </span><br><span class=\"line\">spring.rabbitmq.publisher-confirm-type=CORRELATED</span><br></pre></td></tr></table></figure>\n</li>\n<li><p> 通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfirmConfig</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RabbitTemplate</span>.ConfirmCallback &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"type\">boolean</span> ack, String cause)</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!ack) &#123;</span><br><span class=\"line\">            # 根据具体的业务进行相应的处理</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;【交换机】 生产者消息确认失败了====&quot;</span> + cause);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;【交换机】 生产者消息确认成功====&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对rabbitTemplate进行设置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitConfirmConfig rabbitConfirmConfig;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initRabbitTemplate</span><span class=\"params\">()</span>&#123;    </span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(rabbitConfirmConfig);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"3-1-2、return退回模式\"><a href=\"#3-1-2、return退回模式\" class=\"headerlink\" title=\"3.1.2、return退回模式\"></a>3.1.2、return退回模式</h3><p>消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）</p>\n<ol>\n<li><p>在配置文件中开启消息异常重新入队</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 确保消息发送失败后可以重新返回到队列中</span><br><span class=\"line\"># 也可以通过 rabbitTemplate.setMandatory(<span class=\"literal\">true</span>) 来设置</span><br><span class=\"line\">spring.rabbitmq.publisher-returns=<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>通过实现 RabbitTemplate.ConfirmCallback 类来对消息发送结果进行处理</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitReturnConfig</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">RabbitTemplate</span>.ReturnCallback &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"type\">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 根据具体的业务对异常进行处理，自行判断是否消息可以丢弃</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (AMQP.NO_ROUTE == replyCode)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;【队列】 交换机路由到队列失败====&quot;</span> + message);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对rabbitTemplate的 returnback 进行设置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RabbitReturnConfig rabbitReturnConfig;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RabbitTemplate rabbitTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@PostConstruct</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">initRabbitTemplate</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(rabbitReturnConfig);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"3-1-3、消费者端ack机制\"><a href=\"#3-1-3、消费者端ack机制\" class=\"headerlink\" title=\"3.1.3、消费者端ack机制\"></a>3.1.3、消费者端ack机制</h3><p>消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除</p>\n<ol>\n<li>rabbitmq默认的是自动ack，无需添加其他配置</li>\n</ol>\n<p>若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。<br>若消费过程中出现异常，则超过ack心跳时间，会触发重试消费</p>\n<ol start=\"2\">\n<li>手动ack</li>\n</ol>\n<p>开启方式简单，只需要放开此配置即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acknowledge-mode: manual # 设置消费端手动 ack</span><br></pre></td></tr></table></figure>\n<pre><code>消费者类\n</code></pre>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>/<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 消费成功后ack</span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 消费失败后ack</span></span><br><span class=\"line\">            <span class=\"comment\">//注意：参数三若设置为true，会出现死循环</span></span><br><span class=\"line\">            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class=\"literal\">false</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t\t<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">            if (message.getMessageProperties().getRedelivered()) &#123;//判断是否已经重试过</span></span><br><span class=\"line\"><span class=\"comment\">                log.error(&quot;消息已重复处理失败,拒绝再次接收...&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); // 拒绝消息</span></span><br><span class=\"line\"><span class=\"comment\">            &#125; else &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                log.error(&quot;消息即将再次返回队列处理...&quot;);</span></span><br><span class=\"line\"><span class=\"comment\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t*/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>1、basicAck<br>void basicAck(long deliveryTag, boolean multiple) :表示成功确认，使用此回执方法后，消息会被rabbitmq broker 删除。<br>（1）deliveryTag：表示消息投递序号，每次消费消息或者消息重新投递后，deliveryTag都会增加。手动消息确认模式下，我们可以对指定deliveryTag的消息进行ack、nack、reject等操作。<br>（2）multiple：是否批量确认，值为 true 则会一次性 ack所有小于当前消息 deliveryTag 的消息。<br>(举个栗子： 假设我先发送三条消息deliveryTag分别是5、6、7，可它们都没有被确认，当我发第四条消息此时deliveryTag为8，multiple设置为 true，会将5、6、7、8的消息全部进行确认)</p>\n<p>2、basicNack<br>void basicNack(long deliveryTag, boolean multiple, boolean requeue)表示失败确认，一般在消费消息业务异常时用到此方法，可以将消息重新投递入队列<br>（1）deliveryTag：表示消息投递序号。<br>（2）multiple：是否批量确认。<br>（3）requeue：值为 true 消息将重新入队列。</p>\n</blockquote>\n<h2 id=\"3-2、消息持久化机制\"><a href=\"#3-2、消息持久化机制\" class=\"headerlink\" title=\"3.2、消息持久化机制\"></a>3.2、消息持久化机制</h2><p>持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：</p>\n<ol>\n<li>Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。</li>\n<li>Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。</li>\n<li>消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。</li>\n</ol>\n<blockquote>\n<p> 注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可</p>\n</blockquote>\n<h3 id=\"3-2-1、交换机持久化\"><a href=\"#3-2-1、交换机持久化\" class=\"headerlink\" title=\"3.2.1、交换机持久化\"></a>3.2.1、交换机持久化</h3><p>在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// autoDelete:当所有绑定队列都不在使用时，是否自动 删除</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DirectExchange</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, durable, autoDelete);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-2-2、队列持久化\"><a href=\"#3-2-2、队列持久化\" class=\"headerlink\" title=\"3.2.2、队列持久化\"></a>3.2.2、队列持久化</h3><p>申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// exclusive:排他队列，声明了exclusive属性的队列只对首次声明它的连接可见，并且在连接断开时自动删除</span></span><br><span class=\"line\"><span class=\"comment\">// autoDelete:当所有消费客户端连接断开后，是否自动删除 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Queue</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> exclusive, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(name, durable, exclusive, autoDelete, (Map)<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3、避免消息重复消费\"><a href=\"#3-3、避免消息重复消费\" class=\"headerlink\" title=\"3.3、避免消息重复消费\"></a>3.3、避免消息重复消费</h2><h3 id=\"3-3-1、消息重复发送的场景\"><a href=\"#3-3-1、消息重复发送的场景\" class=\"headerlink\" title=\"3.3.1、消息重复发送的场景\"></a>3.3.1、消息重复发送的场景</h3><p>消息消费成功，事务已经提交，ack时，机器宕机，导致没有ack成功，Broker的消息重新由unack变为ready，并发送给其他消费者；相当于锁库存被消费了两遍，即库存扣了两遍；</p>\n<h3 id=\"3-3-2、解决方案\"><a href=\"#3-3-2、解决方案\" class=\"headerlink\" title=\"3.3.2、解决方案\"></a>3.3.2、解决方案</h3><p>保证消费者的幂等性<br>如何保证幂等性？</p>\n<ol>\n<li><p>使用代码的逻辑判断，判断消息状态是否已经被消费过了</p>\n<blockquote>\n<p>使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。</p>\n</blockquote>\n</li>\n<li><p>使用token，要申请，一次有效性。</p>\n<blockquote>\n<p>在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"3-4、避免消息积压问题\"><a href=\"#3-4、避免消息积压问题\" class=\"headerlink\" title=\"3.4、避免消息积压问题\"></a>3.4、避免消息积压问题</h2><h3 id=\"3-4-1、消息积压场景\"><a href=\"#3-4-1、消息积压场景\" class=\"headerlink\" title=\"3.4.1、消息积压场景\"></a>3.4.1、消息积压场景</h3><p>消费者宕机&#x2F;消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压</p>\n<h3 id=\"3-4-2、解决方案\"><a href=\"#3-4-2、解决方案\" class=\"headerlink\" title=\"3.4.2、解决方案\"></a>3.4.2、解决方案</h3><ol>\n<li>上线更多的消费者（如：库存服务），进行正常消费</li>\n<li>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。</li>\n</ol>\n<h2 id=\"3-5、保证消息的顺序性\"><a href=\"#3-5、保证消息的顺序性\" class=\"headerlink\" title=\"3.5、保证消息的顺序性\"></a>3.5、保证消息的顺序性</h2><h3 id=\"3-5-1、消息顺序错乱场景\"><a href=\"#3-5-1、消息顺序错乱场景\" class=\"headerlink\" title=\"3.5.1、消息顺序错乱场景\"></a>3.5.1、消息顺序错乱场景</h3><p>生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。</p>\n<h3 id=\"3-5-2、解决方案\"><a href=\"#3-5-2、解决方案\" class=\"headerlink\" title=\"3.5.2、解决方案\"></a>3.5.2、解决方案</h3><p>思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的</p>\n"},{"title":"spring","date":"2023-07-21T16:00:00.000Z","abbrlink":9964,"_content":"# 1、前置内容\n## 1.1、EJB的问题\n它是一个重量级的框架，体现在：\n\n1. 运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源\n2. 代码移植性差\n## 1.2、什么是spring\nspring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式\n\n- 轻量级\n\n> 1. 对于运行环境没有额外要求（tomcat jetty weblogic等都可以）\n> 2. 代码一致性高（不需要实现额外接口）\n\n\n- javaEE解决方案\n\n> 包含了java web开发中 controller service dao层的解决方案\n\n\n- 整合设计模式\n\n> 工厂\n> 代理\n> 模板\n> 策略\n\n## 1.3、工厂设计模式\n### 1.3.1、什么是工厂设计模式\n```markdown\n1. 概念：通过工厂类创建对象\n2. 好处：解耦合\n   问题：不利于代码维护\n```\n### 1.3.2、通用工厂的设计（简单工厂+反射）\n```java\n// 工厂类\npublic class BeanFactory{\n    private static Properties env = new Properties();\n    static {\n        InputStream inputStream = BeanFactory.class.getResourceAsStream(\"/applicationContext.properties\");\n        try {\n            env.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static Object getBean(String key){\n        Object ret = null;\n        try{\n           Class clazz = Class.forName(env.getProperty(\"userBean\"));\n           ret = clazz.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return ret;\n    }\n}\n```\n# 2、spring IOC\n## 2.1、第一个spring程序\n### 2.1.1、核心API\n\n- ApplicationContext\n\n```markdown\n1. 作用：屏蔽实现的差异\n\n2. 好处：解耦合\n\n3. 接口类型：\n非web环境：ClassPathXmlApplicationContext\nweb环境：XmlWebApplicationContext（需要导入spring-webmvc）\n\n4. 重量级资源\napplicationContext工厂的对象占用大量内存\n不会频繁的创建，一个应用程序只会创建一个工厂对象\n所以applicationContext工厂一定是线程安全的\n```\n### 2.1.2、程序开发\n\n1. 引入依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.4.RELEASE</version>\n        </dependency>\n```\n\n2. 创建配置文件\n\nnew - xmlConfiguration File - spring config\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"person\" class=\"bean.Person\"/>\n</beans>\n```\n\n3. 通过工厂获取实例\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        Person person = (Person)ctx.getBean(\"person\");\n        System.out.println(person);\n    }\n}\n```\n\n### 2.1.3、思考\n\n1. 使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化\n\n2. 在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）\n\n\n## 2.2、spring与日志框架整合\nspring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息\n\n![日志框架](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png)\n\n\n- spring如何整合日志框架？\n\n> spring 1,2,3 早期都是jcl\nspring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2\n\n当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j\n1. pom\n\n```xml\n\t\t<!--日志门面-->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.7.25</version>\n        </dependency>\n        <!--log4j-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n```\n\n2. log4j.properties\n\n```properties\n### 配置根\nlog4j.rootLogger = debug, console\n\n### 配置输出到控制台\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern =  %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n```\n## 2.3、注入\n### 2.3.1、什么是注入？\n通过spring工厂及配置文件，为所创建对象的成员变量赋值\n\n### 2.3.2、为什么需要注入？\n之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合\n\n### 2.3.3、如何进行注入？\n#### 2.3.3.1、属性（field ）注入\n所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）\n\n```java\n@Autowired\nprivate Svc svc;\n```\n\n#### 2.3.3.2、setter注入\n通过对应变量的`setXXX()`方法以及在方法上面使用注解，来完成依赖注入。比如：\n```java\nprivate Helper helper;\n\n@Autowired\npublic void setHelper(Helper helper) {\n    this.helper = helper;\n}\n```\n#### 2.3.3.3、构造方法注入\n将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：\n```java\nprivate final Svc svc;\n\n@Autowired\npublic HelpService(@Qualifier(\"svcB\") Svc svc) {\n    this.svc = svc;\n}\n```\n\n## 2.4、spring对象的生命周期\n### 2.4.1、spring bean的生命周期\n\n![spring bean生命周期](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png)\n\n\n1. 实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。\n2. 属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中\n3. 回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。\n\n> Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。\n> 但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  \n\n1. 初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器\n2. 使用（In Use）：在初始化完成之后，Bean就可以被使用了。\n3. 销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用\n\n\n# 3、spring AOP\n\n## 3.1、spring动态代理\n### 3.1.1、spring动态代理概念\n\n1. 概念：通过代理类为目标类增加额外功能\n2. 好处：利于目标类的维护\n### 3.1.2、搭建开发环境\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>5.1.14.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjrt</artifactId>\n            <version>1.8.8</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.3</version>\n        </dependency>\n```\n### 3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\n\n1. 创建目标对象\n\n```java\npublic class UserServiceImpl implements UserService{\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n<bean id=\"userService\" class=\"service.UserServiceImpl\"></bean>\n```\n\n2. 额外功能\n\nMethodBeforeAdvice接口\n\n\n```java\npublic class Before implements MethodBeforeAdvice {\n    // 参数： 目标方法 目标方法参数 目标对象\n    public void before(Method method, Object[] objects, Object o) throws Throwable {\n        System.out.println(\"--method before advice log--\");\n    }\n}\n\n<bean id=\"before\" class=\"dynamic.Before\"></bean>\n```\n\n3. 定义切入点\n\n 切入点：额外功能加入的位置(方法)\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n    </aop:config>\n```\n\n4. 组装（2 3步整合）\n\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n        <!--组装：目的把切入点和额外功能进行整合-->\n        <aop:advisor advice-ref=\"before\" pointcut-ref=\"pc\"/>\n    </aop:config>\n```\n\n5. 测试\n\n```java\n    public static void main(String[] args) {\n        //目的：获得spring工厂创建的动态代理对象并进行调用\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        /**\n         * 1. spring的工厂通过原始对象的id值获得的是代理对象\n         * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储\n         */\n        UserService userService = (UserService)ctx.getBean(\"userService\");\n        userService.login();\n    }\n```\n### 3.1.4、思考\n\n1. spring创建的动态代理类在哪里？\n\n```java\nspring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失\n\n动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题\n\n```\n\n2. 动态字节码技术？\n\n```java\n通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失\n```\n### 3.1.5、额外功能详解\nMethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前\nMethodInterceptor 前，后，抛出异常 都可以运行\n所以我们实战中用到的更多的还是MethodInterceptor \n```java\npublic class Around  implements MethodInterceptor {\n    //methodInvocation : 额外功能所增加给的那个原始方法\n    public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n        System.out.println(\"--目标方法之前额外功能--\");\n        //原始方法执行\n        Object proceed = null;\n        try {\n            proceed = methodInvocation.proceed();\n        } catch (Throwable throwable){\n            System.out.println(\"--目标方法抛出异常额外功能--\");\n            throwable.printStackTrace();\n        }\n        System.out.println(\"--目标方法之后额外功能--\");\n        return proceed;\n    }\n}\n```\n> MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）\n\n### 3.1.6、切入点详解\n#### 3.1.6.1、切入点表达式\n\n\n```java\n<aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n\nexecution() ：切入点函数\n* *(..)：切入点表达式\n\n第一个* ：修饰符 返回值\n第二个* ：方法名(包+类+方法 or 直接方法)\n()：参数表 \n..：对于参数没有要求\n```\n\n- 定义login方法且login方法有两个字符串类型的参数作为切入点\n\n```java\n* login(String,String)\n```\n\n- 定义login方法且login方法有第一个参数必须为String作为切入点\n\n```java\n* login(String,..)\n```\n\n- kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）\n\n```java\n* com.kaka.UserServiceImpl.login(..)\n```\n\n- kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）\n\n```java\n* com.kaka..*.*()\n    \n    其中的..*代表当前包及其子包\n    如果是.*代表当前包\n```\n\n- 任意包下UserServiceImpl类作为切入点（类切入点表达式）\n\n```java\n* *..UserServiceImpl.*(..)\n  \n    其中的*..代表层级为1级或多级的包\n    如果是*.UserService 只能查找第一层级下的类\n```\n#### 3.1.6.2、切入点函数\n切入点函数：用于执行切入点表达式\n\n1. execution\n\n```java\n作用：最为重要的切入点函数，功能最全\n\t  执行方法切入点表达式 类切入点表达式 包切入点表达式\nexecution执行切入点表达式，书写麻烦\n注意：其他的切入点函数简化execution书写复杂度，功能上完全一致\n\n```\n\n2. args\n\n```java\n作用：主要用于函数（方法）参数的匹配\n方法参数必须是两个字符串类型的参数\n\nargs(String,String)\n等同于 execution(* *(String,String))\n```\n\n3. within\n\n```java\n作用：主要用于进行类，包切入点表达式的匹配\n\nwithin(*..UserServiceImpl)\n等同于execution(* *..UserServiceImpl.*(..))\n```\n\n4. @annotation\n\n```java\n作用：@annotation表示标注了某个注解的所有方法\n\n// 修饰的对象范围\n@Target(ElementType.METHOD)\n// 注解生命周期  SOURCE < CLASS < RUNTIME\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Log {\n}\n\npublic class UserServiceImpl implements UserService{\n    @Log\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n\n<aop:pointcut id=\"pc\" expression=\"@annotation(bean.Log)\"/>\n```\n#### 3.1.6.3、切入点函数的逻辑运算\n\n1. and与操作\n\n```java\n案例：login 同时 参数 两个字符串\n\nexecution(* login(..)) and args(String,String)\n等同于 execution(* login(String,String))    \n    \n注意：与操作不能用于同种类型的切入点函数\n```\n\n2. or或操作\n\n```java\n案例：register方法和login方法作为切入点\n\nexecution(* login(..)) or execution(* register(..))\n```\n## 3.2、AOP编程\n### 3.2.1、基本概念\n\n\n```java\n1. AOP：面向切面编程\n   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建\n\n2. OOP：面向对象编程\n   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建\n   \n3. POP：面向过程编程\n   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建\n \n```\n12.2、切面名词解释\n\n> 切面 = 切入点 + 额外功能\n\n多个额外功能相同的方法所代表的点连起来就是一个面\n\n![aop切面](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png)\n\n\n### 3.2.2、AOP底层实现原理\n#### 3.2.2.1、核心问题\n\n\n> 1. aop如何创建动态代理类（动态字节码技术）\n> 2. 如何实现通过原始对象的id值，获得的是代理对象\n\n\n### 3.2.3、动态代理类的创建\n#### 3.2.3.1、JDK动态代理\n\n- Proxy.newProxyInstancec：\n\n- 编码实现\n\n```java\npublic class TestJDKProxy {\n    /**\n     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以\n     2. JDK8.x 前必须加 final\n     final UserService userService = new UserServiceImpl();\n     */\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserServiceImpl();\n\n        // 2. JDK 动态代理\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(\"---- proxy log ----\");\n                // 原始方法运行\n                Object ret = method.invoke(userService, args);\n                return ret;\n            }\n        };\n        UserService userServiceProxy = (UserService) Proxy.\n                newProxyInstance(TestJDKProxy.class.getClassLoader(),\n                                userService.getClass().getInterfaces(),\n                                handler);\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n\n        userServiceProxy.register(new User());\n    }\n}\n```\n#### 3.2.3.2、CGLib动态代理\n\n- CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）\n\n> 在原始类没有实现接口的情况下cglib是一种很好的实现方式\n\n- cglib原理\n\n```java\npublic class TestCglib {\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserService();\n\n        /*\n         2. 通过 cglib 方式创建动态代理对象\n         对比 jdk 动态代理 ---> Proxy.newProxyInstance(classLoader, interface, invocationHandler);\n\n         Enhancer.setClassLoader()\n         Enhancer.setSuperClass()\n         Enhancer.setCallBack() ---> MethodInterceptor(cglib)\n         Enhancer.createProxy() ---> 创建代理对象\n         */\n        Enhancer enhancer = new Enhancer();\n\n        enhancer.setClassLoader(TestCglib.class.getClassLoader());\n        enhancer.setSuperclass(userService.getClass());\n\n        MethodInterceptor interceptor = new MethodInterceptor() {\n            @Override\n            public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n                System.out.println(\"--- cglib log ----\");\n                Object ret = method.invoke(userService, args); // 执行原始方法\n                return ret;\n            }\n        };\n\n        enhancer.setCallback(interceptor);\n        UserService userServiceProxy = (UserService) enhancer.create();\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n        userServiceProxy.register(new User());\n    }\n}\n```\n 总结：\n\n1. JDK 动态代理\nProxy.newProxyInstance：通过接口创建代理的实现类\n2. Cglib 动态代理\nEnhancer：通过继承父类创建的代理类\n\n### 3.2.4、基于注解的AOP编程\n#### 3.2.4.1、开发步骤\n\n1. 原始功能\n\n包含原始功能和实现类等\n\n2. 额外功能+切入点+组装切面\n\n```java\n/*\n    1. 额外功能\n        public class MyAround implements MethodInterceptor {\n            public Object invoke(MethodInvocation invocation) {\n                Object ret = invocation.invoke();\n                return ret;\n            }\n        }\n        <bean id=\"around\" class=\"com.yusael.dynamic.Around\"/>\n\n    2. 切入点\n        <aop:config>\n            <aop:pointcut id=\"pc\" expression=\"execution(* login(..)))\"/>\n            <aop:advisor advice-ref=\"around\" pointcut-ref=\"pc\"/>\n        </aop:config>\n */\n\n@Aspect\npublic class MyAspect {\n    @Around(\"execution(* login(..))\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n\n```\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <bean id=\"userService\" class=\"com.yusael.aspect.UserServiceImpl\"/>\n    <!--\n        切面:\n            1. 额外功能\n            2. 切入点\n            3. 组装切面\n    -->\n    <bean id=\"around\" class=\"com.yusael.aspect.MyAspect\"/>\n    <!--告知 Spring 基于注解进行 AOP 编程-->\n    <aop:aspectj-autoproxy/>\n\n</beans>\n\n```\n\n3. 切入点复用\n\n切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。\n\t通过这种方式定义切入点表达式，后续更加有利于切入点复用\n```java\n@Aspect\npublic class MyAspect {\n\n    @Pointcut(\"execution(* login(..))\")\n    public void myPoincut() {}\n\n    @Around(value = \"myPoincut()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n    @Around(value = \"myPoincut()\")\n    public Object around1(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect transaction ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n```\n#### 3.2.4.2、动态代理创建方式\n\nAOP 底层实现 2 种代理创建方式：\n\n1. JDK：通过 **实现接口，做新的实现类** 创建代理对象\n2. Cglib：通过 **继承父类，做新的子类** 创建代理对象\n\n**默认情况 AOP 编程 底层应用 JDK动态代理创建方式**\n```java\n<!-- 动态代理模式切换为cglib -->\n<aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n```\n\n# 4、spring 持久层\n## 4.1、spring与mybatis整合\n\n1. 引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-jdbc</artifactId>\n  <version>5.2.6.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis-spring</artifactId>\n  <version>2.0.4</version>\n</dependency>\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.1.12</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>5.1.43</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>3.5.4</version>\n</dependency>\n```\n\n2. spring配置文件\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <!--连接池-->\n        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n            <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n            <property name=\"url\" value=\"jdbc:mysql://localhost:3306/yus?useSSL=false\"/>\n            <property name=\"username\" value=\"root\"/>\n            <property name=\"password\" value=\"1234\"/>\n        </bean>\n\n        <!--创建SqlSessionFactory SqlSessionFactoryBean-->\n        <bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n            <property name=\"dataSource\" ref=\"dataSource\"/>\n            <property name=\"typeAliasesPackage\" value=\"com.yusael.entity\"/>\n            <property name=\"mapperLocations\">\n                <list>\n                    <value>classpath:com.yusael.dao/*Mapper.xml</value>\n                </list>\n            </property>\n        </bean>\n\n        <!--创建DAO对象 MapperScannerConfigure-->\n        <bean id=\"scanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n            <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactoryBean\"/>\n            <property name=\"basePackage\" value=\"com.yusael.dao\"/>\n        </bean>\n</beans>\n```\n\n3. 测试\n\n```java\n@Test\npublic void test() {\n    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n    UserDAO userDAO = (UserDAO) ctx.getBean(\"userDAO\");\n\n    User user = new User();\n    user.setName(\"xiaojr\");\n    user.setPassword(\"999999\");\n\n    userDAO.save(user);\n}\n```\n## 4.2、关于事务提交的疑问\n\n**问题**：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？\n\n> Mybatis 提供的连接池对象 —> 创建 Connection\n> Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。\n> Druid（C3P0、DBCP）作为连接池 —> 创建 Connection\n> Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。\n\n\n**答案**：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。\n\n**注意**：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题\n\n## 4.3、spring事务处理\n### 4.3.1、事务基本概念\n\n1. 什么是事务？\n\n事务时保证业务操作完整性的一种**数据库机制**\n\n2. 事务的四大特性？\n\nA 原子性\tC 一致性 I 隔离性\tD 持久性\n\n3. 如何控制事务？\n\n**JDBC：**\nConnection.setAutoCommit(false);\nConnection.commit();\nConnection.rollback();\n**Mybatis：**\nMybatis 自动开启事务\nsqlSession.commit();，底层还是调用的 Connection\nsqlSession.rollback();，底层还是调用的 Connection\n> 结论：控制事务的底层，都是通过 Connection 对象完成的\n\n### 4.3.2、spring控制事务的开发\nspring是通过aop的方式进行事务开发\n**增强功能：**原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法\n\n**切入点：**@Transactional （1）作用于类上（2）作用域方法。<\n\n**组装切面：**tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/> 自动扫描所有的@Transactional注解\n\n1. 搭建开发环境\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-tx</artifactId>\n\t<version>5.2.6.RELEASE</version>\n</dependency>\n```\n\n2. 编码\n\n```xml\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/>\n```\n进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib\n```xml\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\" proxy-target-class=\"true\"/>\n```\n### 4.3.3、事务的属性\n5个：隔离属性，传播属性，只读属性，超时属性，异常属性\n```markdown\n@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）\n```\n#### 4.3.3.1、隔离属性\n\n##### 4.3.3.1.1、并发问题&解决方案？\n**（1）脏读**：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象\n> eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了\n\n```java\n// 隔离级别：读已提交\n@Transaction(isolation=Isolation.READ_COMMITTED)\n```\n\n**（2）不可重复读**：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象\n> eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了\n> 注意：1.不是脏读 2.在一个事务中\n\n```java\n// 隔离级别：可重复读\n@Transaction(isolation=Isolation.REPEATABLE_READ)\n```\n> 本质：一把行锁（对数据库表的某一行加锁）\n\n\n\n**（3）幻读**：一个事务中，多次对**整表**进行**查询统计**，但是**结果不一样**，会在本事务中产生数据不一致的问题\n> 查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致\n\n```java\n// 隔离级别：序列化\n@Transaction(isolation=Isolation.SERIALIZABLE)\n```\n\n> 本质：表锁（对数据库某个表加锁）\n\n##### 4.3.3.1.2、安全与效率对比：\n\n- 并发安全：SERIALIZABLE > READ_ONLY > READ_COMMITTED\n- 运行效率：READ_COMMITTED > READ_ONLY > SERIALIZABLE\n\n##### 4.3.3.1.3、数据库默认隔离属性\nmysql：可重复读（REPEATABLE_READ）\nOracle：读已提交（READ_COMMITTED）\n\n#### 4.3.3.2、传播属性\n##### 4.3.3.2.1、基本概念\n传播属性：描述了事务解决 嵌套 问题 的特征\n**事务的嵌套**：指的是一个大的事务中，包含了若干个小的事务。\n**事务嵌套产生的问题**： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）\n\n##### 4.3.3.2.2、传播属性的值及用法\n| 传播属性的值 | 外部不存在事务 | 外部存在事务 | 用法 | 备注 |\n| --- | --- | --- | --- | --- |\n| REQUIRED | 开启新的事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.REQUIRED) | 增、删、改方法（保证了肯定会有事务的存在） |\n| REQUIRES_NEW | 开启新的事务 | 挂起外部事务，创建新的事务 | @Transactional(propagation = Propagation.REQUIRES_NEW) | 日志记录方法中（保证外部事务异常时能正常的记录日志） |\n| SUPPORTS | 不开启事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.SUPPORTS) | 查询方法 |\n| NOT_SUPPORTED | 不开启事务 | 挂起外部事务| @Transactional(propagation = Propagation.NOT_SUPPORTED) | 极其不常用 |\n| NEVER | 不开启事务 | 抛出异常 | @Transactional(propagation = Propagation.NEVER) | 极其不常用 |\n| MANDATORY（强制的） | 抛出异常 | 融合到外部事物中 | @Transactional(propagation = Propagation.MANDATORY) | 极其不常用 |\n\nSpring 中**传播属性的默认值**是：REQUIRED\n\n推荐传播属性的使用方式：\n\n- 增删改 方法：使用默认值 REQUIRED\n- 查询 方法：显示指定传播属性的值为 SUPPORTS\n\n\n#### 4.2.2.3、只读属性\n针对于 **只进行查询操作的业务方法**，可以加入只读属性，提高运行效率。\n默认值：false\n```java\n@Transactional(readOnly = true)\n```\n#### 4.2.2.4、超时属性\n指定了事务等待的最长时间。\n\n1. 为什么事务会进行等待？\n\n当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。\n\n2. 等待时间，单位是 秒\n3. 如何使用：@Transactional(timeout = 2)\n4. 超时属性的默认值：-1\n\n-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）\n\n#### 4.2.2.5、异常属性\nSpring 事务处理过程中：\n\n- 默认对于 RuntimeException 及其子类，采用 **回滚** 的策略。\n- 默认对于 对于其他类型的异常，采用 **提交** 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）\n\n```java\n@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)\n\n@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)\n```\n\n\n# 5、spring mvc\nspring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 \n\n## 5.1、父子容器关系\n1. Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）\n2. Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等\n3. Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）\n4. 调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止\n\n\n## 5.2、为什么要划分父子容器\n1. 分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）\n2. 性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能\n\n## 5.3、springBoot舍弃了父子容器的概念\n\nSpringBoot只有一个容器。\nSpring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署\n\n\n# 6、注解编程\n## 6.1、spring基础注解（spring2.X）\n### 6.1.1、对象创建相关\n#### 6.1.1.1、@Component\n\n1. 作用：替换原有Spring配置文件中的 <bean> 标签\n- id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO --> userDAO）\n- class 属性：通过反射获得的 class 的内容\n2. 细节：如何显式指定工厂创建对象的 id 值\n\n```java\n@Component(\"u\")\n```\n#### 6.1.1.2、@Repository、@Service、@Contoller\n@Repository、@Service、@Controller 都是 @Component 的 **衍生注解**。\n本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；\n它们的存在是为了：**更加准确的表达一个类型的作用**\n\n#### 6.1.1.3、@Scope\n作用：控制简单对象创建次数\n注意：不添加 @Scope，Spring 提供默认值 singleton\n```java\n// 创建单例对象\n@Component\n@Scope(\"singleton\")\npublic class Customer {}\n\n// 创建多例对象\n@Component\n@Scope(\"prototype\")\npublic class Customer {}\n```\n#### 6.1.1.4、@Lazy\n作用：延迟创建单实例对象\n注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象\n```java\n@Component\n@Lazy\npublic class Account {\n    public Account() {\n        System.out.println(\"Account.Account\");\n    }\n}\n```\n#### 6.1.1.5、@PostConstruct、@PreDestroy\n初始化相关方法： @PostConstruct\n```java\nInitializingBean\n<bean init-method=\"\"/>\n```\n销毁方法：@PreDestory\n```java\nDisposableBean\n<bean destory-method=\"\"/>\n```\n### 6.1.2、注入相关注解\n#### 6.1.2.1、@Autowired（用户自定义类型）\n\n1. @Autowired 注解 **基于类型进行注入** [推荐]：\n- 注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）\n\n```java\n@Autowired\nprivate UserDAO userDAO;\n```\n\n2. @Autowired、@Qualifier 注解联合实现 **基于名字进行注入** [了解]\n- 注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同\n\n```java\n@Autowired\n@Qualifier(\"userDAOImpl\")\nprivate UserDAO userDAO;\n```\n\n3. @Autowired 注解放置位置：\n- 放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）\n- **直接放置在成员变量上**，Spring 通过反射直接对成员变量进行赋值\n\n4. JSR提供的@Resource注解\n\n> JavaEE 规范中类似功能的注解：\n> - JSR250 提供的 @Resource(name=\"xxx\") **基于名字进行注入**\n等价于 @Autowired 与 @Qualifier 联合实现的效果\n注意：@Resource 注解如果名字没有配对成功，会继续 **按照类型进行注入**\n\n#### 6.1.2.2、@value、@PropertySource（JDK 类型）\n\n1. @value 注解的基本使用（xml配置）：\n\n```java\n1. 设置xxx.properties \n   id = 10\n   name = suns\n2. Spring的工厂读取这个配置文件 \n   <context:property-placeholder location=\"\"/>\n3. 代码中进行注入\n   属性 @Value(\"${key}\")\n\n```\n\n2. 使用 @PropertySource 取代 xml配置\n\n```java\n@Configuration\n@PropertySource(\"classpath:/init.properties\")\npublic class AppConfig1 {\n\n\t@Value(\"${id}\")\n\tprivate Integer id;\n\t@Value(\"${name}\")\n\tprivate String name;\n\t\n\t@Bean\n\tpublic Customer customer() {\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setId(id);\n\t\tcustomer.setName(name);\n\t\treturn customer;\n\t}\n}\n\n```\n\n3. @value 注解使用细节：\n- @Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null\n- @Value 注解 + Properties 这种方式，不能注入集合类型\nSpring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)\n## \n## 6.2、spring的高级注解（spring3.X及以上）\n### 6.2.1、@Configuration（配置bean）\n\n1. Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件\n2. 使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：\n\n```xml\n方法1: 指定配置bean的Class\nApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n\n方法2: 指定配置bean所在的路径(某个包及其子包)\nApplicationContext ctx = new AnnotationConfigApplicationContext(\"com.yusael\");\n```\n### 6.2.2、@Bean\n@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <bean 标签\n> **简单对象**：直接能够通过 new 方式创建的对象\n> - User、UserService、UserDAO\n> \n**复杂对象**：不能通过 new 的方式直接创建的对象\n> - Connection、SqlSessionFactory\n\n```java\n@Configuration\npublic class AppConfig{\n  // 简单对象\n\t@Bean\n  public Customer customer() {\n    Customer customer = new Customer();\n    return customer;\n  }\n\n  // 复杂对象\n  @Bean\n  public Connection conn1() {\n    Connection conn = null;\n    try {\n      ConnectionFactoryBean factoryBean = new ConnectionFactoryBean();\n      conn = factoryBean.getObject();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    return conn;\n  }\n}\n```\n### 6.2.3、@ComponentScan\n@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <context:component-scan> 标签\n目的：进行相关注解的扫描（@Component、@Value、@Autowired …)\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.yusael.scan\",\n               excludeFilters = {@ComponentScan.Filter(type= FilterType.ANNOTATION, value={Service.class}),\n                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = \"*..User1\")})\npublic class AppConfig2 {\n}\n```\n\n","source":"_posts/spring.md","raw":"---\ntitle: spring\ndate: 2023/07/22\ncategories:\n  - coding\ntags:\n  - spring\nabbrlink: 9964\n---\n# 1、前置内容\n## 1.1、EJB的问题\n它是一个重量级的框架，体现在：\n\n1. 运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源\n2. 代码移植性差\n## 1.2、什么是spring\nspring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式\n\n- 轻量级\n\n> 1. 对于运行环境没有额外要求（tomcat jetty weblogic等都可以）\n> 2. 代码一致性高（不需要实现额外接口）\n\n\n- javaEE解决方案\n\n> 包含了java web开发中 controller service dao层的解决方案\n\n\n- 整合设计模式\n\n> 工厂\n> 代理\n> 模板\n> 策略\n\n## 1.3、工厂设计模式\n### 1.3.1、什么是工厂设计模式\n```markdown\n1. 概念：通过工厂类创建对象\n2. 好处：解耦合\n   问题：不利于代码维护\n```\n### 1.3.2、通用工厂的设计（简单工厂+反射）\n```java\n// 工厂类\npublic class BeanFactory{\n    private static Properties env = new Properties();\n    static {\n        InputStream inputStream = BeanFactory.class.getResourceAsStream(\"/applicationContext.properties\");\n        try {\n            env.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static Object getBean(String key){\n        Object ret = null;\n        try{\n           Class clazz = Class.forName(env.getProperty(\"userBean\"));\n           ret = clazz.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return ret;\n    }\n}\n```\n# 2、spring IOC\n## 2.1、第一个spring程序\n### 2.1.1、核心API\n\n- ApplicationContext\n\n```markdown\n1. 作用：屏蔽实现的差异\n\n2. 好处：解耦合\n\n3. 接口类型：\n非web环境：ClassPathXmlApplicationContext\nweb环境：XmlWebApplicationContext（需要导入spring-webmvc）\n\n4. 重量级资源\napplicationContext工厂的对象占用大量内存\n不会频繁的创建，一个应用程序只会创建一个工厂对象\n所以applicationContext工厂一定是线程安全的\n```\n### 2.1.2、程序开发\n\n1. 引入依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.4.RELEASE</version>\n        </dependency>\n```\n\n2. 创建配置文件\n\nnew - xmlConfiguration File - spring config\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"person\" class=\"bean.Person\"/>\n</beans>\n```\n\n3. 通过工厂获取实例\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        Person person = (Person)ctx.getBean(\"person\");\n        System.out.println(person);\n    }\n}\n```\n\n### 2.1.3、思考\n\n1. 使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化\n\n2. 在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）\n\n\n## 2.2、spring与日志框架整合\nspring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息\n\n![日志框架](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png)\n\n\n- spring如何整合日志框架？\n\n> spring 1,2,3 早期都是jcl\nspring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2\n\n当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j\n1. pom\n\n```xml\n\t\t<!--日志门面-->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.7.25</version>\n        </dependency>\n        <!--log4j-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n```\n\n2. log4j.properties\n\n```properties\n### 配置根\nlog4j.rootLogger = debug, console\n\n### 配置输出到控制台\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern =  %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n```\n## 2.3、注入\n### 2.3.1、什么是注入？\n通过spring工厂及配置文件，为所创建对象的成员变量赋值\n\n### 2.3.2、为什么需要注入？\n之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合\n\n### 2.3.3、如何进行注入？\n#### 2.3.3.1、属性（field ）注入\n所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）\n\n```java\n@Autowired\nprivate Svc svc;\n```\n\n#### 2.3.3.2、setter注入\n通过对应变量的`setXXX()`方法以及在方法上面使用注解，来完成依赖注入。比如：\n```java\nprivate Helper helper;\n\n@Autowired\npublic void setHelper(Helper helper) {\n    this.helper = helper;\n}\n```\n#### 2.3.3.3、构造方法注入\n将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：\n```java\nprivate final Svc svc;\n\n@Autowired\npublic HelpService(@Qualifier(\"svcB\") Svc svc) {\n    this.svc = svc;\n}\n```\n\n## 2.4、spring对象的生命周期\n### 2.4.1、spring bean的生命周期\n\n![spring bean生命周期](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png)\n\n\n1. 实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。\n2. 属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中\n3. 回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。\n\n> Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。\n> 但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  \n\n1. 初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器\n2. 使用（In Use）：在初始化完成之后，Bean就可以被使用了。\n3. 销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用\n\n\n# 3、spring AOP\n\n## 3.1、spring动态代理\n### 3.1.1、spring动态代理概念\n\n1. 概念：通过代理类为目标类增加额外功能\n2. 好处：利于目标类的维护\n### 3.1.2、搭建开发环境\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>5.1.14.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjrt</artifactId>\n            <version>1.8.8</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.3</version>\n        </dependency>\n```\n### 3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\n\n1. 创建目标对象\n\n```java\npublic class UserServiceImpl implements UserService{\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n<bean id=\"userService\" class=\"service.UserServiceImpl\"></bean>\n```\n\n2. 额外功能\n\nMethodBeforeAdvice接口\n\n\n```java\npublic class Before implements MethodBeforeAdvice {\n    // 参数： 目标方法 目标方法参数 目标对象\n    public void before(Method method, Object[] objects, Object o) throws Throwable {\n        System.out.println(\"--method before advice log--\");\n    }\n}\n\n<bean id=\"before\" class=\"dynamic.Before\"></bean>\n```\n\n3. 定义切入点\n\n 切入点：额外功能加入的位置(方法)\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n    </aop:config>\n```\n\n4. 组装（2 3步整合）\n\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n        <!--组装：目的把切入点和额外功能进行整合-->\n        <aop:advisor advice-ref=\"before\" pointcut-ref=\"pc\"/>\n    </aop:config>\n```\n\n5. 测试\n\n```java\n    public static void main(String[] args) {\n        //目的：获得spring工厂创建的动态代理对象并进行调用\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        /**\n         * 1. spring的工厂通过原始对象的id值获得的是代理对象\n         * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储\n         */\n        UserService userService = (UserService)ctx.getBean(\"userService\");\n        userService.login();\n    }\n```\n### 3.1.4、思考\n\n1. spring创建的动态代理类在哪里？\n\n```java\nspring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失\n\n动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题\n\n```\n\n2. 动态字节码技术？\n\n```java\n通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失\n```\n### 3.1.5、额外功能详解\nMethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前\nMethodInterceptor 前，后，抛出异常 都可以运行\n所以我们实战中用到的更多的还是MethodInterceptor \n```java\npublic class Around  implements MethodInterceptor {\n    //methodInvocation : 额外功能所增加给的那个原始方法\n    public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n        System.out.println(\"--目标方法之前额外功能--\");\n        //原始方法执行\n        Object proceed = null;\n        try {\n            proceed = methodInvocation.proceed();\n        } catch (Throwable throwable){\n            System.out.println(\"--目标方法抛出异常额外功能--\");\n            throwable.printStackTrace();\n        }\n        System.out.println(\"--目标方法之后额外功能--\");\n        return proceed;\n    }\n}\n```\n> MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）\n\n### 3.1.6、切入点详解\n#### 3.1.6.1、切入点表达式\n\n\n```java\n<aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n\nexecution() ：切入点函数\n* *(..)：切入点表达式\n\n第一个* ：修饰符 返回值\n第二个* ：方法名(包+类+方法 or 直接方法)\n()：参数表 \n..：对于参数没有要求\n```\n\n- 定义login方法且login方法有两个字符串类型的参数作为切入点\n\n```java\n* login(String,String)\n```\n\n- 定义login方法且login方法有第一个参数必须为String作为切入点\n\n```java\n* login(String,..)\n```\n\n- kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）\n\n```java\n* com.kaka.UserServiceImpl.login(..)\n```\n\n- kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）\n\n```java\n* com.kaka..*.*()\n    \n    其中的..*代表当前包及其子包\n    如果是.*代表当前包\n```\n\n- 任意包下UserServiceImpl类作为切入点（类切入点表达式）\n\n```java\n* *..UserServiceImpl.*(..)\n  \n    其中的*..代表层级为1级或多级的包\n    如果是*.UserService 只能查找第一层级下的类\n```\n#### 3.1.6.2、切入点函数\n切入点函数：用于执行切入点表达式\n\n1. execution\n\n```java\n作用：最为重要的切入点函数，功能最全\n\t  执行方法切入点表达式 类切入点表达式 包切入点表达式\nexecution执行切入点表达式，书写麻烦\n注意：其他的切入点函数简化execution书写复杂度，功能上完全一致\n\n```\n\n2. args\n\n```java\n作用：主要用于函数（方法）参数的匹配\n方法参数必须是两个字符串类型的参数\n\nargs(String,String)\n等同于 execution(* *(String,String))\n```\n\n3. within\n\n```java\n作用：主要用于进行类，包切入点表达式的匹配\n\nwithin(*..UserServiceImpl)\n等同于execution(* *..UserServiceImpl.*(..))\n```\n\n4. @annotation\n\n```java\n作用：@annotation表示标注了某个注解的所有方法\n\n// 修饰的对象范围\n@Target(ElementType.METHOD)\n// 注解生命周期  SOURCE < CLASS < RUNTIME\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Log {\n}\n\npublic class UserServiceImpl implements UserService{\n    @Log\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n\n<aop:pointcut id=\"pc\" expression=\"@annotation(bean.Log)\"/>\n```\n#### 3.1.6.3、切入点函数的逻辑运算\n\n1. and与操作\n\n```java\n案例：login 同时 参数 两个字符串\n\nexecution(* login(..)) and args(String,String)\n等同于 execution(* login(String,String))    \n    \n注意：与操作不能用于同种类型的切入点函数\n```\n\n2. or或操作\n\n```java\n案例：register方法和login方法作为切入点\n\nexecution(* login(..)) or execution(* register(..))\n```\n## 3.2、AOP编程\n### 3.2.1、基本概念\n\n\n```java\n1. AOP：面向切面编程\n   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建\n\n2. OOP：面向对象编程\n   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建\n   \n3. POP：面向过程编程\n   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建\n \n```\n12.2、切面名词解释\n\n> 切面 = 切入点 + 额外功能\n\n多个额外功能相同的方法所代表的点连起来就是一个面\n\n![aop切面](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png)\n\n\n### 3.2.2、AOP底层实现原理\n#### 3.2.2.1、核心问题\n\n\n> 1. aop如何创建动态代理类（动态字节码技术）\n> 2. 如何实现通过原始对象的id值，获得的是代理对象\n\n\n### 3.2.3、动态代理类的创建\n#### 3.2.3.1、JDK动态代理\n\n- Proxy.newProxyInstancec：\n\n- 编码实现\n\n```java\npublic class TestJDKProxy {\n    /**\n     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以\n     2. JDK8.x 前必须加 final\n     final UserService userService = new UserServiceImpl();\n     */\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserServiceImpl();\n\n        // 2. JDK 动态代理\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(\"---- proxy log ----\");\n                // 原始方法运行\n                Object ret = method.invoke(userService, args);\n                return ret;\n            }\n        };\n        UserService userServiceProxy = (UserService) Proxy.\n                newProxyInstance(TestJDKProxy.class.getClassLoader(),\n                                userService.getClass().getInterfaces(),\n                                handler);\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n\n        userServiceProxy.register(new User());\n    }\n}\n```\n#### 3.2.3.2、CGLib动态代理\n\n- CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）\n\n> 在原始类没有实现接口的情况下cglib是一种很好的实现方式\n\n- cglib原理\n\n```java\npublic class TestCglib {\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserService();\n\n        /*\n         2. 通过 cglib 方式创建动态代理对象\n         对比 jdk 动态代理 ---> Proxy.newProxyInstance(classLoader, interface, invocationHandler);\n\n         Enhancer.setClassLoader()\n         Enhancer.setSuperClass()\n         Enhancer.setCallBack() ---> MethodInterceptor(cglib)\n         Enhancer.createProxy() ---> 创建代理对象\n         */\n        Enhancer enhancer = new Enhancer();\n\n        enhancer.setClassLoader(TestCglib.class.getClassLoader());\n        enhancer.setSuperclass(userService.getClass());\n\n        MethodInterceptor interceptor = new MethodInterceptor() {\n            @Override\n            public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n                System.out.println(\"--- cglib log ----\");\n                Object ret = method.invoke(userService, args); // 执行原始方法\n                return ret;\n            }\n        };\n\n        enhancer.setCallback(interceptor);\n        UserService userServiceProxy = (UserService) enhancer.create();\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n        userServiceProxy.register(new User());\n    }\n}\n```\n 总结：\n\n1. JDK 动态代理\nProxy.newProxyInstance：通过接口创建代理的实现类\n2. Cglib 动态代理\nEnhancer：通过继承父类创建的代理类\n\n### 3.2.4、基于注解的AOP编程\n#### 3.2.4.1、开发步骤\n\n1. 原始功能\n\n包含原始功能和实现类等\n\n2. 额外功能+切入点+组装切面\n\n```java\n/*\n    1. 额外功能\n        public class MyAround implements MethodInterceptor {\n            public Object invoke(MethodInvocation invocation) {\n                Object ret = invocation.invoke();\n                return ret;\n            }\n        }\n        <bean id=\"around\" class=\"com.yusael.dynamic.Around\"/>\n\n    2. 切入点\n        <aop:config>\n            <aop:pointcut id=\"pc\" expression=\"execution(* login(..)))\"/>\n            <aop:advisor advice-ref=\"around\" pointcut-ref=\"pc\"/>\n        </aop:config>\n */\n\n@Aspect\npublic class MyAspect {\n    @Around(\"execution(* login(..))\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n\n```\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <bean id=\"userService\" class=\"com.yusael.aspect.UserServiceImpl\"/>\n    <!--\n        切面:\n            1. 额外功能\n            2. 切入点\n            3. 组装切面\n    -->\n    <bean id=\"around\" class=\"com.yusael.aspect.MyAspect\"/>\n    <!--告知 Spring 基于注解进行 AOP 编程-->\n    <aop:aspectj-autoproxy/>\n\n</beans>\n\n```\n\n3. 切入点复用\n\n切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。\n\t通过这种方式定义切入点表达式，后续更加有利于切入点复用\n```java\n@Aspect\npublic class MyAspect {\n\n    @Pointcut(\"execution(* login(..))\")\n    public void myPoincut() {}\n\n    @Around(value = \"myPoincut()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n    @Around(value = \"myPoincut()\")\n    public Object around1(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect transaction ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n```\n#### 3.2.4.2、动态代理创建方式\n\nAOP 底层实现 2 种代理创建方式：\n\n1. JDK：通过 **实现接口，做新的实现类** 创建代理对象\n2. Cglib：通过 **继承父类，做新的子类** 创建代理对象\n\n**默认情况 AOP 编程 底层应用 JDK动态代理创建方式**\n```java\n<!-- 动态代理模式切换为cglib -->\n<aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n```\n\n# 4、spring 持久层\n## 4.1、spring与mybatis整合\n\n1. 引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-jdbc</artifactId>\n  <version>5.2.6.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis-spring</artifactId>\n  <version>2.0.4</version>\n</dependency>\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.1.12</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>5.1.43</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>3.5.4</version>\n</dependency>\n```\n\n2. spring配置文件\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <!--连接池-->\n        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n            <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n            <property name=\"url\" value=\"jdbc:mysql://localhost:3306/yus?useSSL=false\"/>\n            <property name=\"username\" value=\"root\"/>\n            <property name=\"password\" value=\"1234\"/>\n        </bean>\n\n        <!--创建SqlSessionFactory SqlSessionFactoryBean-->\n        <bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n            <property name=\"dataSource\" ref=\"dataSource\"/>\n            <property name=\"typeAliasesPackage\" value=\"com.yusael.entity\"/>\n            <property name=\"mapperLocations\">\n                <list>\n                    <value>classpath:com.yusael.dao/*Mapper.xml</value>\n                </list>\n            </property>\n        </bean>\n\n        <!--创建DAO对象 MapperScannerConfigure-->\n        <bean id=\"scanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n            <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactoryBean\"/>\n            <property name=\"basePackage\" value=\"com.yusael.dao\"/>\n        </bean>\n</beans>\n```\n\n3. 测试\n\n```java\n@Test\npublic void test() {\n    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n    UserDAO userDAO = (UserDAO) ctx.getBean(\"userDAO\");\n\n    User user = new User();\n    user.setName(\"xiaojr\");\n    user.setPassword(\"999999\");\n\n    userDAO.save(user);\n}\n```\n## 4.2、关于事务提交的疑问\n\n**问题**：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？\n\n> Mybatis 提供的连接池对象 —> 创建 Connection\n> Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。\n> Druid（C3P0、DBCP）作为连接池 —> 创建 Connection\n> Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。\n\n\n**答案**：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。\n\n**注意**：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题\n\n## 4.3、spring事务处理\n### 4.3.1、事务基本概念\n\n1. 什么是事务？\n\n事务时保证业务操作完整性的一种**数据库机制**\n\n2. 事务的四大特性？\n\nA 原子性\tC 一致性 I 隔离性\tD 持久性\n\n3. 如何控制事务？\n\n**JDBC：**\nConnection.setAutoCommit(false);\nConnection.commit();\nConnection.rollback();\n**Mybatis：**\nMybatis 自动开启事务\nsqlSession.commit();，底层还是调用的 Connection\nsqlSession.rollback();，底层还是调用的 Connection\n> 结论：控制事务的底层，都是通过 Connection 对象完成的\n\n### 4.3.2、spring控制事务的开发\nspring是通过aop的方式进行事务开发\n**增强功能：**原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法\n\n**切入点：**@Transactional （1）作用于类上（2）作用域方法。<\n\n**组装切面：**tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/> 自动扫描所有的@Transactional注解\n\n1. 搭建开发环境\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-tx</artifactId>\n\t<version>5.2.6.RELEASE</version>\n</dependency>\n```\n\n2. 编码\n\n```xml\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/>\n```\n进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib\n```xml\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\" proxy-target-class=\"true\"/>\n```\n### 4.3.3、事务的属性\n5个：隔离属性，传播属性，只读属性，超时属性，异常属性\n```markdown\n@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）\n```\n#### 4.3.3.1、隔离属性\n\n##### 4.3.3.1.1、并发问题&解决方案？\n**（1）脏读**：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象\n> eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了\n\n```java\n// 隔离级别：读已提交\n@Transaction(isolation=Isolation.READ_COMMITTED)\n```\n\n**（2）不可重复读**：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象\n> eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了\n> 注意：1.不是脏读 2.在一个事务中\n\n```java\n// 隔离级别：可重复读\n@Transaction(isolation=Isolation.REPEATABLE_READ)\n```\n> 本质：一把行锁（对数据库表的某一行加锁）\n\n\n\n**（3）幻读**：一个事务中，多次对**整表**进行**查询统计**，但是**结果不一样**，会在本事务中产生数据不一致的问题\n> 查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致\n\n```java\n// 隔离级别：序列化\n@Transaction(isolation=Isolation.SERIALIZABLE)\n```\n\n> 本质：表锁（对数据库某个表加锁）\n\n##### 4.3.3.1.2、安全与效率对比：\n\n- 并发安全：SERIALIZABLE > READ_ONLY > READ_COMMITTED\n- 运行效率：READ_COMMITTED > READ_ONLY > SERIALIZABLE\n\n##### 4.3.3.1.3、数据库默认隔离属性\nmysql：可重复读（REPEATABLE_READ）\nOracle：读已提交（READ_COMMITTED）\n\n#### 4.3.3.2、传播属性\n##### 4.3.3.2.1、基本概念\n传播属性：描述了事务解决 嵌套 问题 的特征\n**事务的嵌套**：指的是一个大的事务中，包含了若干个小的事务。\n**事务嵌套产生的问题**： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）\n\n##### 4.3.3.2.2、传播属性的值及用法\n| 传播属性的值 | 外部不存在事务 | 外部存在事务 | 用法 | 备注 |\n| --- | --- | --- | --- | --- |\n| REQUIRED | 开启新的事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.REQUIRED) | 增、删、改方法（保证了肯定会有事务的存在） |\n| REQUIRES_NEW | 开启新的事务 | 挂起外部事务，创建新的事务 | @Transactional(propagation = Propagation.REQUIRES_NEW) | 日志记录方法中（保证外部事务异常时能正常的记录日志） |\n| SUPPORTS | 不开启事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.SUPPORTS) | 查询方法 |\n| NOT_SUPPORTED | 不开启事务 | 挂起外部事务| @Transactional(propagation = Propagation.NOT_SUPPORTED) | 极其不常用 |\n| NEVER | 不开启事务 | 抛出异常 | @Transactional(propagation = Propagation.NEVER) | 极其不常用 |\n| MANDATORY（强制的） | 抛出异常 | 融合到外部事物中 | @Transactional(propagation = Propagation.MANDATORY) | 极其不常用 |\n\nSpring 中**传播属性的默认值**是：REQUIRED\n\n推荐传播属性的使用方式：\n\n- 增删改 方法：使用默认值 REQUIRED\n- 查询 方法：显示指定传播属性的值为 SUPPORTS\n\n\n#### 4.2.2.3、只读属性\n针对于 **只进行查询操作的业务方法**，可以加入只读属性，提高运行效率。\n默认值：false\n```java\n@Transactional(readOnly = true)\n```\n#### 4.2.2.4、超时属性\n指定了事务等待的最长时间。\n\n1. 为什么事务会进行等待？\n\n当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。\n\n2. 等待时间，单位是 秒\n3. 如何使用：@Transactional(timeout = 2)\n4. 超时属性的默认值：-1\n\n-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）\n\n#### 4.2.2.5、异常属性\nSpring 事务处理过程中：\n\n- 默认对于 RuntimeException 及其子类，采用 **回滚** 的策略。\n- 默认对于 对于其他类型的异常，采用 **提交** 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）\n\n```java\n@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)\n\n@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)\n```\n\n\n# 5、spring mvc\nspring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 \n\n## 5.1、父子容器关系\n1. Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）\n2. Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等\n3. Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）\n4. 调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止\n\n\n## 5.2、为什么要划分父子容器\n1. 分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）\n2. 性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能\n\n## 5.3、springBoot舍弃了父子容器的概念\n\nSpringBoot只有一个容器。\nSpring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署\n\n\n# 6、注解编程\n## 6.1、spring基础注解（spring2.X）\n### 6.1.1、对象创建相关\n#### 6.1.1.1、@Component\n\n1. 作用：替换原有Spring配置文件中的 <bean> 标签\n- id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO --> userDAO）\n- class 属性：通过反射获得的 class 的内容\n2. 细节：如何显式指定工厂创建对象的 id 值\n\n```java\n@Component(\"u\")\n```\n#### 6.1.1.2、@Repository、@Service、@Contoller\n@Repository、@Service、@Controller 都是 @Component 的 **衍生注解**。\n本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；\n它们的存在是为了：**更加准确的表达一个类型的作用**\n\n#### 6.1.1.3、@Scope\n作用：控制简单对象创建次数\n注意：不添加 @Scope，Spring 提供默认值 singleton\n```java\n// 创建单例对象\n@Component\n@Scope(\"singleton\")\npublic class Customer {}\n\n// 创建多例对象\n@Component\n@Scope(\"prototype\")\npublic class Customer {}\n```\n#### 6.1.1.4、@Lazy\n作用：延迟创建单实例对象\n注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象\n```java\n@Component\n@Lazy\npublic class Account {\n    public Account() {\n        System.out.println(\"Account.Account\");\n    }\n}\n```\n#### 6.1.1.5、@PostConstruct、@PreDestroy\n初始化相关方法： @PostConstruct\n```java\nInitializingBean\n<bean init-method=\"\"/>\n```\n销毁方法：@PreDestory\n```java\nDisposableBean\n<bean destory-method=\"\"/>\n```\n### 6.1.2、注入相关注解\n#### 6.1.2.1、@Autowired（用户自定义类型）\n\n1. @Autowired 注解 **基于类型进行注入** [推荐]：\n- 注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）\n\n```java\n@Autowired\nprivate UserDAO userDAO;\n```\n\n2. @Autowired、@Qualifier 注解联合实现 **基于名字进行注入** [了解]\n- 注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同\n\n```java\n@Autowired\n@Qualifier(\"userDAOImpl\")\nprivate UserDAO userDAO;\n```\n\n3. @Autowired 注解放置位置：\n- 放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）\n- **直接放置在成员变量上**，Spring 通过反射直接对成员变量进行赋值\n\n4. JSR提供的@Resource注解\n\n> JavaEE 规范中类似功能的注解：\n> - JSR250 提供的 @Resource(name=\"xxx\") **基于名字进行注入**\n等价于 @Autowired 与 @Qualifier 联合实现的效果\n注意：@Resource 注解如果名字没有配对成功，会继续 **按照类型进行注入**\n\n#### 6.1.2.2、@value、@PropertySource（JDK 类型）\n\n1. @value 注解的基本使用（xml配置）：\n\n```java\n1. 设置xxx.properties \n   id = 10\n   name = suns\n2. Spring的工厂读取这个配置文件 \n   <context:property-placeholder location=\"\"/>\n3. 代码中进行注入\n   属性 @Value(\"${key}\")\n\n```\n\n2. 使用 @PropertySource 取代 xml配置\n\n```java\n@Configuration\n@PropertySource(\"classpath:/init.properties\")\npublic class AppConfig1 {\n\n\t@Value(\"${id}\")\n\tprivate Integer id;\n\t@Value(\"${name}\")\n\tprivate String name;\n\t\n\t@Bean\n\tpublic Customer customer() {\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setId(id);\n\t\tcustomer.setName(name);\n\t\treturn customer;\n\t}\n}\n\n```\n\n3. @value 注解使用细节：\n- @Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null\n- @Value 注解 + Properties 这种方式，不能注入集合类型\nSpring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)\n## \n## 6.2、spring的高级注解（spring3.X及以上）\n### 6.2.1、@Configuration（配置bean）\n\n1. Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件\n2. 使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：\n\n```xml\n方法1: 指定配置bean的Class\nApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n\n方法2: 指定配置bean所在的路径(某个包及其子包)\nApplicationContext ctx = new AnnotationConfigApplicationContext(\"com.yusael\");\n```\n### 6.2.2、@Bean\n@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <bean 标签\n> **简单对象**：直接能够通过 new 方式创建的对象\n> - User、UserService、UserDAO\n> \n**复杂对象**：不能通过 new 的方式直接创建的对象\n> - Connection、SqlSessionFactory\n\n```java\n@Configuration\npublic class AppConfig{\n  // 简单对象\n\t@Bean\n  public Customer customer() {\n    Customer customer = new Customer();\n    return customer;\n  }\n\n  // 复杂对象\n  @Bean\n  public Connection conn1() {\n    Connection conn = null;\n    try {\n      ConnectionFactoryBean factoryBean = new ConnectionFactoryBean();\n      conn = factoryBean.getObject();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    return conn;\n  }\n}\n```\n### 6.2.3、@ComponentScan\n@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <context:component-scan> 标签\n目的：进行相关注解的扫描（@Component、@Value、@Autowired …)\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.yusael.scan\",\n               excludeFilters = {@ComponentScan.Filter(type= FilterType.ANNOTATION, value={Service.class}),\n                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = \"*..User1\")})\npublic class AppConfig2 {\n}\n```\n\n","slug":"spring","published":1,"updated":"2023-07-25T13:19:14.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkqz2ipy000l6wuj0n09fuct","content":"<h1 id=\"1、前置内容\"><a href=\"#1、前置内容\" class=\"headerlink\" title=\"1、前置内容\"></a>1、前置内容</h1><h2 id=\"1-1、EJB的问题\"><a href=\"#1-1、EJB的问题\" class=\"headerlink\" title=\"1.1、EJB的问题\"></a>1.1、EJB的问题</h2><p>它是一个重量级的框架，体现在：</p>\n<ol>\n<li>运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源</li>\n<li>代码移植性差</li>\n</ol>\n<h2 id=\"1-2、什么是spring\"><a href=\"#1-2、什么是spring\" class=\"headerlink\" title=\"1.2、什么是spring\"></a>1.2、什么是spring</h2><p>spring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式</p>\n<ul>\n<li>轻量级</li>\n</ul>\n<blockquote>\n<ol>\n<li>对于运行环境没有额外要求（tomcat jetty weblogic等都可以）</li>\n<li>代码一致性高（不需要实现额外接口）</li>\n</ol>\n</blockquote>\n<ul>\n<li>javaEE解决方案</li>\n</ul>\n<blockquote>\n<p>包含了java web开发中 controller service dao层的解决方案</p>\n</blockquote>\n<ul>\n<li>整合设计模式</li>\n</ul>\n<blockquote>\n<p>工厂<br>代理<br>模板<br>策略</p>\n</blockquote>\n<h2 id=\"1-3、工厂设计模式\"><a href=\"#1-3、工厂设计模式\" class=\"headerlink\" title=\"1.3、工厂设计模式\"></a>1.3、工厂设计模式</h2><h3 id=\"1-3-1、什么是工厂设计模式\"><a href=\"#1-3-1、什么是工厂设计模式\" class=\"headerlink\" title=\"1.3.1、什么是工厂设计模式\"></a>1.3.1、什么是工厂设计模式</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 概念：通过工厂类创建对象</span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\">   问题：不利于代码维护</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-2、通用工厂的设计（简单工厂-反射）\"><a href=\"#1-3-2、通用工厂的设计（简单工厂-反射）\" class=\"headerlink\" title=\"1.3.2、通用工厂的设计（简单工厂+反射）\"></a>1.3.2、通用工厂的设计（简单工厂+反射）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Properties</span> <span class=\"variable\">env</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> BeanFactory.class.getResourceAsStream(<span class=\"string\">&quot;/applicationContext.properties&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            env.load(inputStream);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(env.getProperty(<span class=\"string\">&quot;userBean&quot;</span>));</span><br><span class=\"line\">           ret = clazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、spring-IOC\"><a href=\"#2、spring-IOC\" class=\"headerlink\" title=\"2、spring IOC\"></a>2、spring IOC</h1><h2 id=\"2-1、第一个spring程序\"><a href=\"#2-1、第一个spring程序\" class=\"headerlink\" title=\"2.1、第一个spring程序\"></a>2.1、第一个spring程序</h2><h3 id=\"2-1-1、核心API\"><a href=\"#2-1-1、核心API\" class=\"headerlink\" title=\"2.1.1、核心API\"></a>2.1.1、核心API</h3><ul>\n<li>ApplicationContext</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 作用：屏蔽实现的差异</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">3.</span> 接口类型：</span><br><span class=\"line\">非web环境：ClassPathXmlApplicationContext</span><br><span class=\"line\">web环境：XmlWebApplicationContext（需要导入spring-webmvc）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">4.</span> 重量级资源</span><br><span class=\"line\">applicationContext工厂的对象占用大量内存</span><br><span class=\"line\">不会频繁的创建，一个应用程序只会创建一个工厂对象</span><br><span class=\"line\">所以applicationContext工厂一定是线程安全的</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、程序开发\"><a href=\"#2-1-2、程序开发\" class=\"headerlink\" title=\"2.1.2、程序开发\"></a>2.1.2、程序开发</h3><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建配置文件</li>\n</ol>\n<p>new - xmlConfiguration File - spring config</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;person&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;bean.Person&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过工厂获取实例</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person)ctx.getBean(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">        System.out.println(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-3、思考\"><a href=\"#2-1-3、思考\" class=\"headerlink\" title=\"2.1.3、思考\"></a>2.1.3、思考</h3><ol>\n<li><p>使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化</p>\n</li>\n<li><p>在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）</p>\n</li>\n</ol>\n<h2 id=\"2-2、spring与日志框架整合\"><a href=\"#2-2、spring与日志框架整合\" class=\"headerlink\" title=\"2.2、spring与日志框架整合\"></a>2.2、spring与日志框架整合</h2><p>spring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png\" alt=\"日志框架\"></p>\n<ul>\n<li>spring如何整合日志框架？</li>\n</ul>\n<blockquote>\n<p>spring 1,2,3 早期都是jcl<br>spring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2</p>\n</blockquote>\n<p>当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j</p>\n<ol>\n<li>pom</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--日志门面--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.25<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--log4j--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.17<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>log4j.properties</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 配置根</span></span><br><span class=\"line\"><span class=\"attr\">log4j.rootLogger</span> = <span class=\"string\">debug, console</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### 配置输出到控制台</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console</span> = <span class=\"string\">org.apache.log4j.ConsoleAppender</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.Target</span> = <span class=\"string\">System.out</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout</span> = <span class=\"string\">org.apache.log4j.PatternLayout</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout.ConversionPattern</span> =  <span class=\"string\">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3、注入\"><a href=\"#2-3、注入\" class=\"headerlink\" title=\"2.3、注入\"></a>2.3、注入</h2><h3 id=\"2-3-1、什么是注入？\"><a href=\"#2-3-1、什么是注入？\" class=\"headerlink\" title=\"2.3.1、什么是注入？\"></a>2.3.1、什么是注入？</h3><p>通过spring工厂及配置文件，为所创建对象的成员变量赋值</p>\n<h3 id=\"2-3-2、为什么需要注入？\"><a href=\"#2-3-2、为什么需要注入？\" class=\"headerlink\" title=\"2.3.2、为什么需要注入？\"></a>2.3.2、为什么需要注入？</h3><p>之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合</p>\n<h3 id=\"2-3-3、如何进行注入？\"><a href=\"#2-3-3、如何进行注入？\" class=\"headerlink\" title=\"2.3.3、如何进行注入？\"></a>2.3.3、如何进行注入？</h3><h4 id=\"2-3-3-1、属性（field-）注入\"><a href=\"#2-3-3-1、属性（field-）注入\" class=\"headerlink\" title=\"2.3.3.1、属性（field ）注入\"></a>2.3.3.1、属性（field ）注入</h4><p>所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Svc svc;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-2、setter注入\"><a href=\"#2-3-3-2、setter注入\" class=\"headerlink\" title=\"2.3.3.2、setter注入\"></a>2.3.3.2、setter注入</h4><p>通过对应变量的<code>setXXX()</code>方法以及在方法上面使用注解，来完成依赖注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Helper helper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHelper</span><span class=\"params\">(Helper helper)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.helper = helper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-3-3、构造方法注入\"><a href=\"#2-3-3-3、构造方法注入\" class=\"headerlink\" title=\"2.3.3.3、构造方法注入\"></a>2.3.3.3、构造方法注入</h4><p>将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Svc svc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HelpService</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;svcB&quot;)</span> Svc svc)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.svc = svc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4、spring对象的生命周期\"><a href=\"#2-4、spring对象的生命周期\" class=\"headerlink\" title=\"2.4、spring对象的生命周期\"></a>2.4、spring对象的生命周期</h2><h3 id=\"2-4-1、spring-bean的生命周期\"><a href=\"#2-4-1、spring-bean的生命周期\" class=\"headerlink\" title=\"2.4.1、spring bean的生命周期\"></a>2.4.1、spring bean的生命周期</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png\" alt=\"spring bean生命周期\"></p>\n<ol>\n<li>实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。</li>\n<li>属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中</li>\n<li>回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。</li>\n</ol>\n<blockquote>\n<p>Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。<br>但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  </p>\n</blockquote>\n<ol>\n<li>初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器</li>\n<li>使用（In Use）：在初始化完成之后，Bean就可以被使用了。</li>\n<li>销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用</li>\n</ol>\n<h1 id=\"3、spring-AOP\"><a href=\"#3、spring-AOP\" class=\"headerlink\" title=\"3、spring AOP\"></a>3、spring AOP</h1><h2 id=\"3-1、spring动态代理\"><a href=\"#3-1、spring动态代理\" class=\"headerlink\" title=\"3.1、spring动态代理\"></a>3.1、spring动态代理</h2><h3 id=\"3-1-1、spring动态代理概念\"><a href=\"#3-1-1、spring动态代理概念\" class=\"headerlink\" title=\"3.1.1、spring动态代理概念\"></a>3.1.1、spring动态代理概念</h3><ol>\n<li>概念：通过代理类为目标类增加额外功能</li>\n<li>好处：利于目标类的维护</li>\n</ol>\n<h3 id=\"3-1-2、搭建开发环境\"><a href=\"#3-1-2、搭建开发环境\" class=\"headerlink\" title=\"3.1.2、搭建开发环境\"></a>3.1.2、搭建开发环境</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.14.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.8<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\"><a href=\"#3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\" class=\"headerlink\" title=\"3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\"></a>3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）</h3><ol>\n<li>创建目标对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;userService&quot;</span> class=<span class=\"string\">&quot;service.UserServiceImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>额外功能</li>\n</ol>\n<p>MethodBeforeAdvice接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Before</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodBeforeAdvice</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数： 目标方法 目标方法参数 目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(Method method, Object[] objects, Object o)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--method before advice log--&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;before&quot;</span> class=<span class=\"string\">&quot;dynamic.Before&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>定义切入点</li>\n</ol>\n<p> 切入点：额外功能加入的位置(方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>组装（2 3步整合）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">    &lt;!--组装：目的把切入点和额外功能进行整合--&gt;</span><br><span class=\"line\">    &lt;aop:advisor advice-ref=<span class=\"string\">&quot;before&quot;</span> pointcut-ref=<span class=\"string\">&quot;pc&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//目的：获得spring工厂创建的动态代理对象并进行调用</span></span><br><span class=\"line\">    <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. spring的工厂通过原始对象的id值获得的是代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> (UserService)ctx.getBean(<span class=\"string\">&quot;userService&quot;</span>);</span><br><span class=\"line\">    userService.login();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-4、思考\"><a href=\"#3-1-4、思考\" class=\"headerlink\" title=\"3.1.4、思考\"></a>3.1.4、思考</h3><ol>\n<li>spring创建的动态代理类在哪里？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失</span><br><span class=\"line\"></span><br><span class=\"line\">动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>动态字节码技术？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-5、额外功能详解\"><a href=\"#3-1-5、额外功能详解\" class=\"headerlink\" title=\"3.1.5、额外功能详解\"></a>3.1.5、额外功能详解</h3><p>MethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前<br>MethodInterceptor 前，后，抛出异常 都可以运行<br>所以我们实战中用到的更多的还是MethodInterceptor </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Around</span>  <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//methodInvocation : 额外功能所增加给的那个原始方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(MethodInvocation methodInvocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之前额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//原始方法执行</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">proceed</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            proceed = methodInvocation.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;--目标方法抛出异常额外功能--&quot;</span>);</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之后额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proceed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）</p>\n</blockquote>\n<h3 id=\"3-1-6、切入点详解\"><a href=\"#3-1-6、切入点详解\" class=\"headerlink\" title=\"3.1.6、切入点详解\"></a>3.1.6、切入点详解</h3><h4 id=\"3-1-6-1、切入点表达式\"><a href=\"#3-1-6-1、切入点表达式\" class=\"headerlink\" title=\"3.1.6.1、切入点表达式\"></a>3.1.6.1、切入点表达式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">execution() ：切入点函数</span><br><span class=\"line\">* *(..)：切入点表达式</span><br><span class=\"line\"></span><br><span class=\"line\">第一个* ：修饰符 返回值</span><br><span class=\"line\">第二个* ：方法名(包+类+方法 or 直接方法)</span><br><span class=\"line\">()：参数表 </span><br><span class=\"line\">..：对于参数没有要求</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有两个字符串类型的参数作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,String)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有第一个参数必须为String作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka.UserServiceImpl.login(..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka..*.*()</span><br><span class=\"line\">    </span><br><span class=\"line\">    其中的..*代表当前包及其子包</span><br><span class=\"line\">    如果是.*代表当前包</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任意包下UserServiceImpl类作为切入点（类切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* *..UserServiceImpl.*(..)</span><br><span class=\"line\">  </span><br><span class=\"line\">    其中的*..代表层级为<span class=\"number\">1</span>级或多级的包</span><br><span class=\"line\">    如果是*.UserService 只能查找第一层级下的类</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-2、切入点函数\"><a href=\"#3-1-6-2、切入点函数\" class=\"headerlink\" title=\"3.1.6.2、切入点函数\"></a>3.1.6.2、切入点函数</h4><p>切入点函数：用于执行切入点表达式</p>\n<ol>\n<li>execution</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：最为重要的切入点函数，功能最全</span><br><span class=\"line\">\t  执行方法切入点表达式 类切入点表达式 包切入点表达式</span><br><span class=\"line\">execution执行切入点表达式，书写麻烦</span><br><span class=\"line\">注意：其他的切入点函数简化execution书写复杂度，功能上完全一致</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>args</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于函数（方法）参数的匹配</span><br><span class=\"line\">方法参数必须是两个字符串类型的参数</span><br><span class=\"line\"></span><br><span class=\"line\">args(String,String)</span><br><span class=\"line\">等同于 execution(* *(String,String))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>within</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于进行类，包切入点表达式的匹配</span><br><span class=\"line\"></span><br><span class=\"line\">within(*..UserServiceImpl)</span><br><span class=\"line\">等同于execution(* *..UserServiceImpl.*(..))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>@annotation</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：<span class=\"meta\">@annotation</span>表示标注了某个注解的所有方法</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修饰的对象范围</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"comment\">// 注解生命周期  SOURCE &lt; CLASS &lt; RUNTIME</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Log &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Log</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;@annotation(bean.Log)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-3、切入点函数的逻辑运算\"><a href=\"#3-1-6-3、切入点函数的逻辑运算\" class=\"headerlink\" title=\"3.1.6.3、切入点函数的逻辑运算\"></a>3.1.6.3、切入点函数的逻辑运算</h4><ol>\n<li>and与操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：login 同时 参数 两个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) and <span class=\"title function_\">args</span><span class=\"params\">(String,String)</span></span><br><span class=\"line\">等同于 execution(* login(String,String))    </span><br><span class=\"line\">    </span><br><span class=\"line\">注意：与操作不能用于同种类型的切入点函数</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>or或操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：register方法和login方法作为切入点</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) or <span class=\"title function_\">execution</span><span class=\"params\">(* register(..)</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2、AOP编程\"><a href=\"#3-2、AOP编程\" class=\"headerlink\" title=\"3.2、AOP编程\"></a>3.2、AOP编程</h2><h3 id=\"3-2-1、基本概念\"><a href=\"#3-2-1、基本概念\" class=\"headerlink\" title=\"3.2.1、基本概念\"></a>3.2.1、基本概念</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> AOP：面向切面编程</span><br><span class=\"line\">   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> OOP：面向对象编程</span><br><span class=\"line\">   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"number\">3.</span> POP：面向过程编程</span><br><span class=\"line\">   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>12.2、切面名词解释</p>\n<blockquote>\n<p>切面 &#x3D; 切入点 + 额外功能</p>\n</blockquote>\n<p>多个额外功能相同的方法所代表的点连起来就是一个面</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png\" alt=\"aop切面\"></p>\n<h3 id=\"3-2-2、AOP底层实现原理\"><a href=\"#3-2-2、AOP底层实现原理\" class=\"headerlink\" title=\"3.2.2、AOP底层实现原理\"></a>3.2.2、AOP底层实现原理</h3><h4 id=\"3-2-2-1、核心问题\"><a href=\"#3-2-2-1、核心问题\" class=\"headerlink\" title=\"3.2.2.1、核心问题\"></a>3.2.2.1、核心问题</h4><blockquote>\n<ol>\n<li>aop如何创建动态代理类（动态字节码技术）</li>\n<li>如何实现通过原始对象的id值，获得的是代理对象</li>\n</ol>\n</blockquote>\n<h3 id=\"3-2-3、动态代理类的创建\"><a href=\"#3-2-3、动态代理类的创建\" class=\"headerlink\" title=\"3.2.3、动态代理类的创建\"></a>3.2.3、动态代理类的创建</h3><h4 id=\"3-2-3-1、JDK动态代理\"><a href=\"#3-2-3-1、JDK动态代理\" class=\"headerlink\" title=\"3.2.3.1、JDK动态代理\"></a>3.2.3.1、JDK动态代理</h4><ul>\n<li><p>Proxy.newProxyInstancec：</p>\n</li>\n<li><p>编码实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestJDKProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以</span></span><br><span class=\"line\"><span class=\"comment\">     2. JDK8.x 前必须加 final</span></span><br><span class=\"line\"><span class=\"comment\">     final UserService userService = new UserServiceImpl();</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. JDK 动态代理</span></span><br><span class=\"line\">        <span class=\"type\">InvocationHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;---- proxy log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 原始方法运行</span></span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) Proxy.</span><br><span class=\"line\">                newProxyInstance(TestJDKProxy.class.getClassLoader(),</span><br><span class=\"line\">                                userService.getClass().getInterfaces(),</span><br><span class=\"line\">                                handler);</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-2、CGLib动态代理\"><a href=\"#3-2-3-2、CGLib动态代理\" class=\"headerlink\" title=\"3.2.3.2、CGLib动态代理\"></a>3.2.3.2、CGLib动态代理</h4><ul>\n<li>CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）</li>\n</ul>\n<blockquote>\n<p>在原始类没有实现接口的情况下cglib是一种很好的实现方式</p>\n</blockquote>\n<ul>\n<li>cglib原理</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCglib</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         2. 通过 cglib 方式创建动态代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setClassLoader()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setSuperClass()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib)</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.createProxy() ---&gt; 创建代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setClassLoader(TestCglib.class.getClassLoader());</span><br><span class=\"line\">        enhancer.setSuperclass(userService.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">MethodInterceptor</span> <span class=\"variable\">interceptor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MethodInterceptor</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;--- cglib log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args); <span class=\"comment\">// 执行原始方法</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setCallback(interceptor);</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) enhancer.create();</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 总结：</p>\n<ol>\n<li>JDK 动态代理<br>Proxy.newProxyInstance：通过接口创建代理的实现类</li>\n<li>Cglib 动态代理<br>Enhancer：通过继承父类创建的代理类</li>\n</ol>\n<h3 id=\"3-2-4、基于注解的AOP编程\"><a href=\"#3-2-4、基于注解的AOP编程\" class=\"headerlink\" title=\"3.2.4、基于注解的AOP编程\"></a>3.2.4、基于注解的AOP编程</h3><h4 id=\"3-2-4-1、开发步骤\"><a href=\"#3-2-4-1、开发步骤\" class=\"headerlink\" title=\"3.2.4.1、开发步骤\"></a>3.2.4.1、开发步骤</h4><ol>\n<li>原始功能</li>\n</ol>\n<p>包含原始功能和实现类等</p>\n<ol start=\"2\">\n<li>额外功能+切入点+组装切面</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">        public class MyAround implements MethodInterceptor &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            public Object invoke(MethodInvocation invocation) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                Object ret = invocation.invoke();</span></span><br><span class=\"line\"><span class=\"comment\">                return ret;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;bean id=&quot;around&quot; class=&quot;com.yusael.dynamic.Around&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)))&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:advisor advice-ref=&quot;around&quot; pointcut-ref=&quot;pc&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;/aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        切面:</span></span><br><span class=\"line\"><span class=\"comment\">            1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">            2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">            3. 组装切面</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;around&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.MyAspect&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--告知 Spring 基于注解进行 AOP 编程--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>切入点复用</li>\n</ol>\n<p>切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。<br>    通过这种方式定义切入点表达式，后续更加有利于切入点复用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myPoincut</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around1</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect transaction ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-4-2、动态代理创建方式\"><a href=\"#3-2-4-2、动态代理创建方式\" class=\"headerlink\" title=\"3.2.4.2、动态代理创建方式\"></a>3.2.4.2、动态代理创建方式</h4><p>AOP 底层实现 2 种代理创建方式：</p>\n<ol>\n<li>JDK：通过 <strong>实现接口，做新的实现类</strong> 创建代理对象</li>\n<li>Cglib：通过 <strong>继承父类，做新的子类</strong> 创建代理对象</li>\n</ol>\n<p><strong>默认情况 AOP 编程 底层应用 JDK动态代理创建方式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 动态代理模式切换为cglib --&gt;</span><br><span class=\"line\">&lt;aop:aspectj-autoproxy proxy-target-class=<span class=\"string\">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、spring-持久层\"><a href=\"#4、spring-持久层\" class=\"headerlink\" title=\"4、spring 持久层\"></a>4、spring 持久层</h1><h2 id=\"4-1、spring与mybatis整合\"><a href=\"#4-1、spring与mybatis整合\" class=\"headerlink\" title=\"4.1、spring与mybatis整合\"></a>4.1、spring与mybatis整合</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>druid<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.43<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>spring配置文件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--连接池--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1234&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;typeAliasesPackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.entity&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapperLocations&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;scanner&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sqlSessionFactoryBeanName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;basePackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.dao&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">UserDAO</span> <span class=\"variable\">userDAO</span> <span class=\"operator\">=</span> (UserDAO) ctx.getBean(<span class=\"string\">&quot;userDAO&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">    user.setName(<span class=\"string\">&quot;xiaojr&quot;</span>);</span><br><span class=\"line\">    user.setPassword(<span class=\"string\">&quot;999999&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    userDAO.save(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2、关于事务提交的疑问\"><a href=\"#4-2、关于事务提交的疑问\" class=\"headerlink\" title=\"4.2、关于事务提交的疑问\"></a>4.2、关于事务提交的疑问</h2><p><strong>问题</strong>：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？</p>\n<blockquote>\n<p>Mybatis 提供的连接池对象 —&gt; 创建 Connection<br>Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。<br>Druid（C3P0、DBCP）作为连接池 —&gt; 创建 Connection<br>Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。</p>\n</blockquote>\n<p><strong>答案</strong>：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。</p>\n<p><strong>注意</strong>：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题</p>\n<h2 id=\"4-3、spring事务处理\"><a href=\"#4-3、spring事务处理\" class=\"headerlink\" title=\"4.3、spring事务处理\"></a>4.3、spring事务处理</h2><h3 id=\"4-3-1、事务基本概念\"><a href=\"#4-3-1、事务基本概念\" class=\"headerlink\" title=\"4.3.1、事务基本概念\"></a>4.3.1、事务基本概念</h3><ol>\n<li>什么是事务？</li>\n</ol>\n<p>事务时保证业务操作完整性的一种<strong>数据库机制</strong></p>\n<ol start=\"2\">\n<li>事务的四大特性？</li>\n</ol>\n<p>A 原子性\tC 一致性 I 隔离性\tD 持久性</p>\n<ol start=\"3\">\n<li>如何控制事务？</li>\n</ol>\n<p><strong>JDBC：</strong><br>Connection.setAutoCommit(false);<br>Connection.commit();<br>Connection.rollback();<br><strong>Mybatis：</strong><br>Mybatis 自动开启事务<br>sqlSession.commit();，底层还是调用的 Connection<br>sqlSession.rollback();，底层还是调用的 Connection</p>\n<blockquote>\n<p>结论：控制事务的底层，都是通过 Connection 对象完成的</p>\n</blockquote>\n<h3 id=\"4-3-2、spring控制事务的开发\"><a href=\"#4-3-2、spring控制事务的开发\" class=\"headerlink\" title=\"4.3.2、spring控制事务的开发\"></a>4.3.2、spring控制事务的开发</h3><p>spring是通过aop的方式进行事务开发<br><strong>增强功能：</strong>原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法</p>\n<p><strong>切入点：</strong>@Transactional （1）作用于类上（2）作用域方法。&lt;</p>\n<p><strong>组装切面：</strong>tx:annotation-driven transaction-manager&#x3D;”dataSourceTransactionManager”&#x2F;&gt; 自动扫描所有的@Transactional注解</p>\n<ol>\n<li>搭建开发环境</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-tx<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-3、事务的属性\"><a href=\"#4-3-3、事务的属性\" class=\"headerlink\" title=\"4.3.3、事务的属性\"></a>4.3.3、事务的属性</h3><p>5个：隔离属性，传播属性，只读属性，超时属性，异常属性</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-3-1、隔离属性\"><a href=\"#4-3-3-1、隔离属性\" class=\"headerlink\" title=\"4.3.3.1、隔离属性\"></a>4.3.3.1、隔离属性</h4><h5 id=\"4-3-3-1-1、并发问题-解决方案？\"><a href=\"#4-3-3-1-1、并发问题-解决方案？\" class=\"headerlink\" title=\"4.3.3.1.1、并发问题&amp;解决方案？\"></a>4.3.3.1.1、并发问题&amp;解决方案？</h5><p><strong>（1）脏读</strong>：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：读已提交</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）不可重复读</strong>：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了<br>注意：1.不是脏读 2.在一个事务中</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：可重复读</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.REPEATABLE_READ)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>本质：一把行锁（对数据库表的某一行加锁）</p>\n</blockquote>\n<p><strong>（3）幻读</strong>：一个事务中，多次对<strong>整表</strong>进行<strong>查询统计</strong>，但是<strong>结果不一样</strong>，会在本事务中产生数据不一致的问题</p>\n<blockquote>\n<p>查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：序列化</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.SERIALIZABLE)</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本质：表锁（对数据库某个表加锁）</p>\n</blockquote>\n<h5 id=\"4-3-3-1-2、安全与效率对比：\"><a href=\"#4-3-3-1-2、安全与效率对比：\" class=\"headerlink\" title=\"4.3.3.1.2、安全与效率对比：\"></a>4.3.3.1.2、安全与效率对比：</h5><ul>\n<li>并发安全：SERIALIZABLE &gt; READ_ONLY &gt; READ_COMMITTED</li>\n<li>运行效率：READ_COMMITTED &gt; READ_ONLY &gt; SERIALIZABLE</li>\n</ul>\n<h5 id=\"4-3-3-1-3、数据库默认隔离属性\"><a href=\"#4-3-3-1-3、数据库默认隔离属性\" class=\"headerlink\" title=\"4.3.3.1.3、数据库默认隔离属性\"></a>4.3.3.1.3、数据库默认隔离属性</h5><p>mysql：可重复读（REPEATABLE_READ）<br>Oracle：读已提交（READ_COMMITTED）</p>\n<h4 id=\"4-3-3-2、传播属性\"><a href=\"#4-3-3-2、传播属性\" class=\"headerlink\" title=\"4.3.3.2、传播属性\"></a>4.3.3.2、传播属性</h4><h5 id=\"4-3-3-2-1、基本概念\"><a href=\"#4-3-3-2-1、基本概念\" class=\"headerlink\" title=\"4.3.3.2.1、基本概念\"></a>4.3.3.2.1、基本概念</h5><p>传播属性：描述了事务解决 嵌套 问题 的特征<br><strong>事务的嵌套</strong>：指的是一个大的事务中，包含了若干个小的事务。<br><strong>事务嵌套产生的问题</strong>： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）</p>\n<h5 id=\"4-3-3-2-2、传播属性的值及用法\"><a href=\"#4-3-3-2-2、传播属性的值及用法\" class=\"headerlink\" title=\"4.3.3.2.2、传播属性的值及用法\"></a>4.3.3.2.2、传播属性的值及用法</h5><table>\n<thead>\n<tr>\n<th>传播属性的值</th>\n<th>外部不存在事务</th>\n<th>外部存在事务</th>\n<th>用法</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>REQUIRED</td>\n<td>开启新的事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRED)</td>\n<td>增、删、改方法（保证了肯定会有事务的存在）</td>\n</tr>\n<tr>\n<td>REQUIRES_NEW</td>\n<td>开启新的事务</td>\n<td>挂起外部事务，创建新的事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</td>\n<td>日志记录方法中（保证外部事务异常时能正常的记录日志）</td>\n</tr>\n<tr>\n<td>SUPPORTS</td>\n<td>不开启事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.SUPPORTS)</td>\n<td>查询方法</td>\n</tr>\n<tr>\n<td>NOT_SUPPORTED</td>\n<td>不开启事务</td>\n<td>挂起外部事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>NEVER</td>\n<td>不开启事务</td>\n<td>抛出异常</td>\n<td>@Transactional(propagation &#x3D; Propagation.NEVER)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>MANDATORY（强制的）</td>\n<td>抛出异常</td>\n<td>融合到外部事物中</td>\n<td>@Transactional(propagation &#x3D; Propagation.MANDATORY)</td>\n<td>极其不常用</td>\n</tr>\n</tbody></table>\n<p>Spring 中<strong>传播属性的默认值</strong>是：REQUIRED</p>\n<p>推荐传播属性的使用方式：</p>\n<ul>\n<li>增删改 方法：使用默认值 REQUIRED</li>\n<li>查询 方法：显示指定传播属性的值为 SUPPORTS</li>\n</ul>\n<h4 id=\"4-2-2-3、只读属性\"><a href=\"#4-2-2-3、只读属性\" class=\"headerlink\" title=\"4.2.2.3、只读属性\"></a>4.2.2.3、只读属性</h4><p>针对于 <strong>只进行查询操作的业务方法</strong>，可以加入只读属性，提高运行效率。<br>默认值：false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-2-4、超时属性\"><a href=\"#4-2-2-4、超时属性\" class=\"headerlink\" title=\"4.2.2.4、超时属性\"></a>4.2.2.4、超时属性</h4><p>指定了事务等待的最长时间。</p>\n<ol>\n<li>为什么事务会进行等待？</li>\n</ol>\n<p>当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。</p>\n<ol start=\"2\">\n<li>等待时间，单位是 秒</li>\n<li>如何使用：@Transactional(timeout &#x3D; 2)</li>\n<li>超时属性的默认值：-1</li>\n</ol>\n<p>-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）</p>\n<h4 id=\"4-2-2-5、异常属性\"><a href=\"#4-2-2-5、异常属性\" class=\"headerlink\" title=\"4.2.2.5、异常属性\"></a>4.2.2.5、异常属性</h4><p>Spring 事务处理过程中：</p>\n<ul>\n<li>默认对于 RuntimeException 及其子类，采用 <strong>回滚</strong> 的策略。</li>\n<li>默认对于 对于其他类型的异常，采用 <strong>提交</strong> 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"5、spring-mvc\"><a href=\"#5、spring-mvc\" class=\"headerlink\" title=\"5、spring mvc\"></a>5、spring mvc</h1><p>spring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 </p>\n<h2 id=\"5-1、父子容器关系\"><a href=\"#5-1、父子容器关系\" class=\"headerlink\" title=\"5.1、父子容器关系\"></a>5.1、父子容器关系</h2><ol>\n<li>Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）</li>\n<li>Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等</li>\n<li>Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）</li>\n<li>调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止</li>\n</ol>\n<h2 id=\"5-2、为什么要划分父子容器\"><a href=\"#5-2、为什么要划分父子容器\" class=\"headerlink\" title=\"5.2、为什么要划分父子容器\"></a>5.2、为什么要划分父子容器</h2><ol>\n<li>分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）</li>\n<li>性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能</li>\n</ol>\n<h2 id=\"5-3、springBoot舍弃了父子容器的概念\"><a href=\"#5-3、springBoot舍弃了父子容器的概念\" class=\"headerlink\" title=\"5.3、springBoot舍弃了父子容器的概念\"></a>5.3、springBoot舍弃了父子容器的概念</h2><p>SpringBoot只有一个容器。<br>Spring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署</p>\n<h1 id=\"6、注解编程\"><a href=\"#6、注解编程\" class=\"headerlink\" title=\"6、注解编程\"></a>6、注解编程</h1><h2 id=\"6-1、spring基础注解（spring2-X）\"><a href=\"#6-1、spring基础注解（spring2-X）\" class=\"headerlink\" title=\"6.1、spring基础注解（spring2.X）\"></a>6.1、spring基础注解（spring2.X）</h2><h3 id=\"6-1-1、对象创建相关\"><a href=\"#6-1-1、对象创建相关\" class=\"headerlink\" title=\"6.1.1、对象创建相关\"></a>6.1.1、对象创建相关</h3><h4 id=\"6-1-1-1、-Component\"><a href=\"#6-1-1-1、-Component\" class=\"headerlink\" title=\"6.1.1.1、@Component\"></a>6.1.1.1、@Component</h4><ol>\n<li>作用：替换原有Spring配置文件中的 <bean> 标签</li>\n</ol>\n<ul>\n<li>id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO –&gt; userDAO）</li>\n<li>class 属性：通过反射获得的 class 的内容</li>\n</ul>\n<ol start=\"2\">\n<li>细节：如何显式指定工厂创建对象的 id 值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;u&quot;)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-2、-Repository、-Service、-Contoller\"><a href=\"#6-1-1-2、-Repository、-Service、-Contoller\" class=\"headerlink\" title=\"6.1.1.2、@Repository、@Service、@Contoller\"></a>6.1.1.2、@Repository、@Service、@Contoller</h4><p>@Repository、@Service、@Controller 都是 @Component 的 <strong>衍生注解</strong>。<br>本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；<br>它们的存在是为了：<strong>更加准确的表达一个类型的作用</strong></p>\n<h4 id=\"6-1-1-3、-Scope\"><a href=\"#6-1-1-3、-Scope\" class=\"headerlink\" title=\"6.1.1.3、@Scope\"></a>6.1.1.3、@Scope</h4><p>作用：控制简单对象创建次数<br>注意：不添加 @Scope，Spring 提供默认值 singleton</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建单例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;singleton&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建多例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-4、-Lazy\"><a href=\"#6-1-1-4、-Lazy\" class=\"headerlink\" title=\"6.1.1.4、@Lazy\"></a>6.1.1.4、@Lazy</h4><p>作用：延迟创建单实例对象<br>注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Account</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Account</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Account.Account&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-5、-PostConstruct、-PreDestroy\"><a href=\"#6-1-1-5、-PostConstruct、-PreDestroy\" class=\"headerlink\" title=\"6.1.1.5、@PostConstruct、@PreDestroy\"></a>6.1.1.5、@PostConstruct、@PreDestroy</h4><p>初始化相关方法： @PostConstruct</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InitializingBean</span><br><span class=\"line\">&lt;bean init-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>销毁方法：@PreDestory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableBean</span><br><span class=\"line\">&lt;bean destory-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-1-2、注入相关注解\"><a href=\"#6-1-2、注入相关注解\" class=\"headerlink\" title=\"6.1.2、注入相关注解\"></a>6.1.2、注入相关注解</h3><h4 id=\"6-1-2-1、-Autowired（用户自定义类型）\"><a href=\"#6-1-2-1、-Autowired（用户自定义类型）\" class=\"headerlink\" title=\"6.1.2.1、@Autowired（用户自定义类型）\"></a>6.1.2.1、@Autowired（用户自定义类型）</h4><ol>\n<li>@Autowired 注解 <strong>基于类型进行注入</strong> [推荐]：</li>\n</ol>\n<ul>\n<li>注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>@Autowired、@Qualifier 注解联合实现 <strong>基于名字进行注入</strong> [了解]</li>\n</ol>\n<ul>\n<li>注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;userDAOImpl&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@Autowired 注解放置位置：</li>\n</ol>\n<ul>\n<li>放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）</li>\n<li><strong>直接放置在成员变量上</strong>，Spring 通过反射直接对成员变量进行赋值</li>\n</ul>\n<ol start=\"4\">\n<li>JSR提供的@Resource注解</li>\n</ol>\n<blockquote>\n<p>JavaEE 规范中类似功能的注解：</p>\n<ul>\n<li>JSR250 提供的 @Resource(name&#x3D;”xxx”) <strong>基于名字进行注入</strong><br>等价于 @Autowired 与 @Qualifier 联合实现的效果<br>注意：@Resource 注解如果名字没有配对成功，会继续 <strong>按照类型进行注入</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"6-1-2-2、-value、-PropertySource（JDK-类型）\"><a href=\"#6-1-2-2、-value、-PropertySource（JDK-类型）\" class=\"headerlink\" title=\"6.1.2.2、@value、@PropertySource（JDK 类型）\"></a>6.1.2.2、@value、@PropertySource（JDK 类型）</h4><ol>\n<li>@value 注解的基本使用（xml配置）：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 设置xxx.<span class=\"type\">properties</span> </span><br><span class=\"line\">   <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">   name = suns</span><br><span class=\"line\"><span class=\"number\">2.</span> Spring的工厂读取这个配置文件 </span><br><span class=\"line\">   &lt;context:property-placeholder location=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br><span class=\"line\"><span class=\"number\">3.</span> 代码中进行注入</span><br><span class=\"line\">   属性 <span class=\"meta\">@Value(&quot;$&#123;key&#125;&quot;)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 @PropertySource 取代 xml配置</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource(&quot;classpath:/init.properties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;id&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">\t\tcustomer.setId(id);</span><br><span class=\"line\">\t\tcustomer.setName(name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@value 注解使用细节：</li>\n</ol>\n<ul>\n<li>@Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null</li>\n<li>@Value 注解 + Properties 这种方式，不能注入集合类型<br>Spring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"6-2、spring的高级注解（spring3-X及以上）\"><a href=\"#6-2、spring的高级注解（spring3-X及以上）\" class=\"headerlink\" title=\"6.2、spring的高级注解（spring3.X及以上）\"></a>6.2、spring的高级注解（spring3.X及以上）</h2><h3 id=\"6-2-1、-Configuration（配置bean）\"><a href=\"#6-2-1、-Configuration（配置bean）\" class=\"headerlink\" title=\"6.2.1、@Configuration（配置bean）\"></a>6.2.1、@Configuration（配置bean）</h3><ol>\n<li>Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件</li>\n<li>使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法1: 指定配置bean的Class</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\">方法2: 指定配置bean所在的路径(某个包及其子包)</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.yusael&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2、-Bean\"><a href=\"#6-2-2、-Bean\" class=\"headerlink\" title=\"6.2.2、@Bean\"></a>6.2.2、@Bean</h3><p>@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 &lt;bean 标签</p>\n<blockquote>\n<p><strong>简单对象</strong>：直接能够通过 new 方式创建的对象</p>\n<ul>\n<li>User、UserService、UserDAO</li>\n</ul>\n</blockquote>\n<p><strong>复杂对象</strong>：不能通过 new 的方式直接创建的对象</p>\n<blockquote>\n<ul>\n<li>Connection、SqlSessionFactory</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 简单对象</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 复杂对象</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Connection <span class=\"title function_\">conn1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ConnectionFactoryBean</span> <span class=\"variable\">factoryBean</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactoryBean</span>();</span><br><span class=\"line\">      conn = factoryBean.getObject();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-3、-ComponentScan\"><a href=\"#6-2-3、-ComponentScan\" class=\"headerlink\" title=\"6.2.3、@ComponentScan\"></a>6.2.3、@ComponentScan</h3><p>@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <a href=\"context:component-scan\">context:component-scan</a> 标签<br>目的：进行相关注解的扫描（@Component、@Value、@Autowired …)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">               excludeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION, value=&#123;Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = &quot;*..User1&quot;)&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig2</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、前置内容\"><a href=\"#1、前置内容\" class=\"headerlink\" title=\"1、前置内容\"></a>1、前置内容</h1><h2 id=\"1-1、EJB的问题\"><a href=\"#1-1、EJB的问题\" class=\"headerlink\" title=\"1.1、EJB的问题\"></a>1.1、EJB的问题</h2><p>它是一个重量级的框架，体现在：</p>\n<ol>\n<li>运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源</li>\n<li>代码移植性差</li>\n</ol>\n<h2 id=\"1-2、什么是spring\"><a href=\"#1-2、什么是spring\" class=\"headerlink\" title=\"1.2、什么是spring\"></a>1.2、什么是spring</h2><p>spring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式</p>\n<ul>\n<li>轻量级</li>\n</ul>\n<blockquote>\n<ol>\n<li>对于运行环境没有额外要求（tomcat jetty weblogic等都可以）</li>\n<li>代码一致性高（不需要实现额外接口）</li>\n</ol>\n</blockquote>\n<ul>\n<li>javaEE解决方案</li>\n</ul>\n<blockquote>\n<p>包含了java web开发中 controller service dao层的解决方案</p>\n</blockquote>\n<ul>\n<li>整合设计模式</li>\n</ul>\n<blockquote>\n<p>工厂<br>代理<br>模板<br>策略</p>\n</blockquote>\n<h2 id=\"1-3、工厂设计模式\"><a href=\"#1-3、工厂设计模式\" class=\"headerlink\" title=\"1.3、工厂设计模式\"></a>1.3、工厂设计模式</h2><h3 id=\"1-3-1、什么是工厂设计模式\"><a href=\"#1-3-1、什么是工厂设计模式\" class=\"headerlink\" title=\"1.3.1、什么是工厂设计模式\"></a>1.3.1、什么是工厂设计模式</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 概念：通过工厂类创建对象</span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\">   问题：不利于代码维护</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-2、通用工厂的设计（简单工厂-反射）\"><a href=\"#1-3-2、通用工厂的设计（简单工厂-反射）\" class=\"headerlink\" title=\"1.3.2、通用工厂的设计（简单工厂+反射）\"></a>1.3.2、通用工厂的设计（简单工厂+反射）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Properties</span> <span class=\"variable\">env</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> BeanFactory.class.getResourceAsStream(<span class=\"string\">&quot;/applicationContext.properties&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            env.load(inputStream);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(env.getProperty(<span class=\"string\">&quot;userBean&quot;</span>));</span><br><span class=\"line\">           ret = clazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、spring-IOC\"><a href=\"#2、spring-IOC\" class=\"headerlink\" title=\"2、spring IOC\"></a>2、spring IOC</h1><h2 id=\"2-1、第一个spring程序\"><a href=\"#2-1、第一个spring程序\" class=\"headerlink\" title=\"2.1、第一个spring程序\"></a>2.1、第一个spring程序</h2><h3 id=\"2-1-1、核心API\"><a href=\"#2-1-1、核心API\" class=\"headerlink\" title=\"2.1.1、核心API\"></a>2.1.1、核心API</h3><ul>\n<li>ApplicationContext</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 作用：屏蔽实现的差异</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">3.</span> 接口类型：</span><br><span class=\"line\">非web环境：ClassPathXmlApplicationContext</span><br><span class=\"line\">web环境：XmlWebApplicationContext（需要导入spring-webmvc）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">4.</span> 重量级资源</span><br><span class=\"line\">applicationContext工厂的对象占用大量内存</span><br><span class=\"line\">不会频繁的创建，一个应用程序只会创建一个工厂对象</span><br><span class=\"line\">所以applicationContext工厂一定是线程安全的</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、程序开发\"><a href=\"#2-1-2、程序开发\" class=\"headerlink\" title=\"2.1.2、程序开发\"></a>2.1.2、程序开发</h3><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建配置文件</li>\n</ol>\n<p>new - xmlConfiguration File - spring config</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;person&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;bean.Person&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过工厂获取实例</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person)ctx.getBean(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">        System.out.println(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-3、思考\"><a href=\"#2-1-3、思考\" class=\"headerlink\" title=\"2.1.3、思考\"></a>2.1.3、思考</h3><ol>\n<li><p>使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化</p>\n</li>\n<li><p>在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）</p>\n</li>\n</ol>\n<h2 id=\"2-2、spring与日志框架整合\"><a href=\"#2-2、spring与日志框架整合\" class=\"headerlink\" title=\"2.2、spring与日志框架整合\"></a>2.2、spring与日志框架整合</h2><p>spring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png\" alt=\"日志框架\"></p>\n<ul>\n<li>spring如何整合日志框架？</li>\n</ul>\n<blockquote>\n<p>spring 1,2,3 早期都是jcl<br>spring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2</p>\n</blockquote>\n<p>当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j</p>\n<ol>\n<li>pom</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--日志门面--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.25<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--log4j--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.17<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>log4j.properties</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 配置根</span></span><br><span class=\"line\"><span class=\"attr\">log4j.rootLogger</span> = <span class=\"string\">debug, console</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### 配置输出到控制台</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console</span> = <span class=\"string\">org.apache.log4j.ConsoleAppender</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.Target</span> = <span class=\"string\">System.out</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout</span> = <span class=\"string\">org.apache.log4j.PatternLayout</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout.ConversionPattern</span> =  <span class=\"string\">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3、注入\"><a href=\"#2-3、注入\" class=\"headerlink\" title=\"2.3、注入\"></a>2.3、注入</h2><h3 id=\"2-3-1、什么是注入？\"><a href=\"#2-3-1、什么是注入？\" class=\"headerlink\" title=\"2.3.1、什么是注入？\"></a>2.3.1、什么是注入？</h3><p>通过spring工厂及配置文件，为所创建对象的成员变量赋值</p>\n<h3 id=\"2-3-2、为什么需要注入？\"><a href=\"#2-3-2、为什么需要注入？\" class=\"headerlink\" title=\"2.3.2、为什么需要注入？\"></a>2.3.2、为什么需要注入？</h3><p>之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合</p>\n<h3 id=\"2-3-3、如何进行注入？\"><a href=\"#2-3-3、如何进行注入？\" class=\"headerlink\" title=\"2.3.3、如何进行注入？\"></a>2.3.3、如何进行注入？</h3><h4 id=\"2-3-3-1、属性（field-）注入\"><a href=\"#2-3-3-1、属性（field-）注入\" class=\"headerlink\" title=\"2.3.3.1、属性（field ）注入\"></a>2.3.3.1、属性（field ）注入</h4><p>所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Svc svc;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-2、setter注入\"><a href=\"#2-3-3-2、setter注入\" class=\"headerlink\" title=\"2.3.3.2、setter注入\"></a>2.3.3.2、setter注入</h4><p>通过对应变量的<code>setXXX()</code>方法以及在方法上面使用注解，来完成依赖注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Helper helper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHelper</span><span class=\"params\">(Helper helper)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.helper = helper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-3-3、构造方法注入\"><a href=\"#2-3-3-3、构造方法注入\" class=\"headerlink\" title=\"2.3.3.3、构造方法注入\"></a>2.3.3.3、构造方法注入</h4><p>将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Svc svc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HelpService</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;svcB&quot;)</span> Svc svc)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.svc = svc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4、spring对象的生命周期\"><a href=\"#2-4、spring对象的生命周期\" class=\"headerlink\" title=\"2.4、spring对象的生命周期\"></a>2.4、spring对象的生命周期</h2><h3 id=\"2-4-1、spring-bean的生命周期\"><a href=\"#2-4-1、spring-bean的生命周期\" class=\"headerlink\" title=\"2.4.1、spring bean的生命周期\"></a>2.4.1、spring bean的生命周期</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png\" alt=\"spring bean生命周期\"></p>\n<ol>\n<li>实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。</li>\n<li>属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中</li>\n<li>回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。</li>\n</ol>\n<blockquote>\n<p>Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。<br>但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  </p>\n</blockquote>\n<ol>\n<li>初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器</li>\n<li>使用（In Use）：在初始化完成之后，Bean就可以被使用了。</li>\n<li>销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用</li>\n</ol>\n<h1 id=\"3、spring-AOP\"><a href=\"#3、spring-AOP\" class=\"headerlink\" title=\"3、spring AOP\"></a>3、spring AOP</h1><h2 id=\"3-1、spring动态代理\"><a href=\"#3-1、spring动态代理\" class=\"headerlink\" title=\"3.1、spring动态代理\"></a>3.1、spring动态代理</h2><h3 id=\"3-1-1、spring动态代理概念\"><a href=\"#3-1-1、spring动态代理概念\" class=\"headerlink\" title=\"3.1.1、spring动态代理概念\"></a>3.1.1、spring动态代理概念</h3><ol>\n<li>概念：通过代理类为目标类增加额外功能</li>\n<li>好处：利于目标类的维护</li>\n</ol>\n<h3 id=\"3-1-2、搭建开发环境\"><a href=\"#3-1-2、搭建开发环境\" class=\"headerlink\" title=\"3.1.2、搭建开发环境\"></a>3.1.2、搭建开发环境</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.14.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.8<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\"><a href=\"#3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\" class=\"headerlink\" title=\"3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\"></a>3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）</h3><ol>\n<li>创建目标对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;userService&quot;</span> class=<span class=\"string\">&quot;service.UserServiceImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>额外功能</li>\n</ol>\n<p>MethodBeforeAdvice接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Before</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodBeforeAdvice</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数： 目标方法 目标方法参数 目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(Method method, Object[] objects, Object o)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--method before advice log--&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;before&quot;</span> class=<span class=\"string\">&quot;dynamic.Before&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>定义切入点</li>\n</ol>\n<p> 切入点：额外功能加入的位置(方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>组装（2 3步整合）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">    &lt;!--组装：目的把切入点和额外功能进行整合--&gt;</span><br><span class=\"line\">    &lt;aop:advisor advice-ref=<span class=\"string\">&quot;before&quot;</span> pointcut-ref=<span class=\"string\">&quot;pc&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//目的：获得spring工厂创建的动态代理对象并进行调用</span></span><br><span class=\"line\">    <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. spring的工厂通过原始对象的id值获得的是代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> (UserService)ctx.getBean(<span class=\"string\">&quot;userService&quot;</span>);</span><br><span class=\"line\">    userService.login();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-4、思考\"><a href=\"#3-1-4、思考\" class=\"headerlink\" title=\"3.1.4、思考\"></a>3.1.4、思考</h3><ol>\n<li>spring创建的动态代理类在哪里？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失</span><br><span class=\"line\"></span><br><span class=\"line\">动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>动态字节码技术？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-5、额外功能详解\"><a href=\"#3-1-5、额外功能详解\" class=\"headerlink\" title=\"3.1.5、额外功能详解\"></a>3.1.5、额外功能详解</h3><p>MethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前<br>MethodInterceptor 前，后，抛出异常 都可以运行<br>所以我们实战中用到的更多的还是MethodInterceptor </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Around</span>  <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//methodInvocation : 额外功能所增加给的那个原始方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(MethodInvocation methodInvocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之前额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//原始方法执行</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">proceed</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            proceed = methodInvocation.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;--目标方法抛出异常额外功能--&quot;</span>);</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之后额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proceed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）</p>\n</blockquote>\n<h3 id=\"3-1-6、切入点详解\"><a href=\"#3-1-6、切入点详解\" class=\"headerlink\" title=\"3.1.6、切入点详解\"></a>3.1.6、切入点详解</h3><h4 id=\"3-1-6-1、切入点表达式\"><a href=\"#3-1-6-1、切入点表达式\" class=\"headerlink\" title=\"3.1.6.1、切入点表达式\"></a>3.1.6.1、切入点表达式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">execution() ：切入点函数</span><br><span class=\"line\">* *(..)：切入点表达式</span><br><span class=\"line\"></span><br><span class=\"line\">第一个* ：修饰符 返回值</span><br><span class=\"line\">第二个* ：方法名(包+类+方法 or 直接方法)</span><br><span class=\"line\">()：参数表 </span><br><span class=\"line\">..：对于参数没有要求</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有两个字符串类型的参数作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,String)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有第一个参数必须为String作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka.UserServiceImpl.login(..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka..*.*()</span><br><span class=\"line\">    </span><br><span class=\"line\">    其中的..*代表当前包及其子包</span><br><span class=\"line\">    如果是.*代表当前包</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任意包下UserServiceImpl类作为切入点（类切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* *..UserServiceImpl.*(..)</span><br><span class=\"line\">  </span><br><span class=\"line\">    其中的*..代表层级为<span class=\"number\">1</span>级或多级的包</span><br><span class=\"line\">    如果是*.UserService 只能查找第一层级下的类</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-2、切入点函数\"><a href=\"#3-1-6-2、切入点函数\" class=\"headerlink\" title=\"3.1.6.2、切入点函数\"></a>3.1.6.2、切入点函数</h4><p>切入点函数：用于执行切入点表达式</p>\n<ol>\n<li>execution</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：最为重要的切入点函数，功能最全</span><br><span class=\"line\">\t  执行方法切入点表达式 类切入点表达式 包切入点表达式</span><br><span class=\"line\">execution执行切入点表达式，书写麻烦</span><br><span class=\"line\">注意：其他的切入点函数简化execution书写复杂度，功能上完全一致</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>args</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于函数（方法）参数的匹配</span><br><span class=\"line\">方法参数必须是两个字符串类型的参数</span><br><span class=\"line\"></span><br><span class=\"line\">args(String,String)</span><br><span class=\"line\">等同于 execution(* *(String,String))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>within</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于进行类，包切入点表达式的匹配</span><br><span class=\"line\"></span><br><span class=\"line\">within(*..UserServiceImpl)</span><br><span class=\"line\">等同于execution(* *..UserServiceImpl.*(..))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>@annotation</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：<span class=\"meta\">@annotation</span>表示标注了某个注解的所有方法</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修饰的对象范围</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"comment\">// 注解生命周期  SOURCE &lt; CLASS &lt; RUNTIME</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Log &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Log</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;@annotation(bean.Log)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-3、切入点函数的逻辑运算\"><a href=\"#3-1-6-3、切入点函数的逻辑运算\" class=\"headerlink\" title=\"3.1.6.3、切入点函数的逻辑运算\"></a>3.1.6.3、切入点函数的逻辑运算</h4><ol>\n<li>and与操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：login 同时 参数 两个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) and <span class=\"title function_\">args</span><span class=\"params\">(String,String)</span></span><br><span class=\"line\">等同于 execution(* login(String,String))    </span><br><span class=\"line\">    </span><br><span class=\"line\">注意：与操作不能用于同种类型的切入点函数</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>or或操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：register方法和login方法作为切入点</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) or <span class=\"title function_\">execution</span><span class=\"params\">(* register(..)</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2、AOP编程\"><a href=\"#3-2、AOP编程\" class=\"headerlink\" title=\"3.2、AOP编程\"></a>3.2、AOP编程</h2><h3 id=\"3-2-1、基本概念\"><a href=\"#3-2-1、基本概念\" class=\"headerlink\" title=\"3.2.1、基本概念\"></a>3.2.1、基本概念</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> AOP：面向切面编程</span><br><span class=\"line\">   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> OOP：面向对象编程</span><br><span class=\"line\">   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"number\">3.</span> POP：面向过程编程</span><br><span class=\"line\">   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>12.2、切面名词解释</p>\n<blockquote>\n<p>切面 &#x3D; 切入点 + 额外功能</p>\n</blockquote>\n<p>多个额外功能相同的方法所代表的点连起来就是一个面</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png\" alt=\"aop切面\"></p>\n<h3 id=\"3-2-2、AOP底层实现原理\"><a href=\"#3-2-2、AOP底层实现原理\" class=\"headerlink\" title=\"3.2.2、AOP底层实现原理\"></a>3.2.2、AOP底层实现原理</h3><h4 id=\"3-2-2-1、核心问题\"><a href=\"#3-2-2-1、核心问题\" class=\"headerlink\" title=\"3.2.2.1、核心问题\"></a>3.2.2.1、核心问题</h4><blockquote>\n<ol>\n<li>aop如何创建动态代理类（动态字节码技术）</li>\n<li>如何实现通过原始对象的id值，获得的是代理对象</li>\n</ol>\n</blockquote>\n<h3 id=\"3-2-3、动态代理类的创建\"><a href=\"#3-2-3、动态代理类的创建\" class=\"headerlink\" title=\"3.2.3、动态代理类的创建\"></a>3.2.3、动态代理类的创建</h3><h4 id=\"3-2-3-1、JDK动态代理\"><a href=\"#3-2-3-1、JDK动态代理\" class=\"headerlink\" title=\"3.2.3.1、JDK动态代理\"></a>3.2.3.1、JDK动态代理</h4><ul>\n<li><p>Proxy.newProxyInstancec：</p>\n</li>\n<li><p>编码实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestJDKProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以</span></span><br><span class=\"line\"><span class=\"comment\">     2. JDK8.x 前必须加 final</span></span><br><span class=\"line\"><span class=\"comment\">     final UserService userService = new UserServiceImpl();</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. JDK 动态代理</span></span><br><span class=\"line\">        <span class=\"type\">InvocationHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;---- proxy log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 原始方法运行</span></span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) Proxy.</span><br><span class=\"line\">                newProxyInstance(TestJDKProxy.class.getClassLoader(),</span><br><span class=\"line\">                                userService.getClass().getInterfaces(),</span><br><span class=\"line\">                                handler);</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-2、CGLib动态代理\"><a href=\"#3-2-3-2、CGLib动态代理\" class=\"headerlink\" title=\"3.2.3.2、CGLib动态代理\"></a>3.2.3.2、CGLib动态代理</h4><ul>\n<li>CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）</li>\n</ul>\n<blockquote>\n<p>在原始类没有实现接口的情况下cglib是一种很好的实现方式</p>\n</blockquote>\n<ul>\n<li>cglib原理</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCglib</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         2. 通过 cglib 方式创建动态代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setClassLoader()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setSuperClass()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib)</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.createProxy() ---&gt; 创建代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setClassLoader(TestCglib.class.getClassLoader());</span><br><span class=\"line\">        enhancer.setSuperclass(userService.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">MethodInterceptor</span> <span class=\"variable\">interceptor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MethodInterceptor</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;--- cglib log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args); <span class=\"comment\">// 执行原始方法</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setCallback(interceptor);</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) enhancer.create();</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 总结：</p>\n<ol>\n<li>JDK 动态代理<br>Proxy.newProxyInstance：通过接口创建代理的实现类</li>\n<li>Cglib 动态代理<br>Enhancer：通过继承父类创建的代理类</li>\n</ol>\n<h3 id=\"3-2-4、基于注解的AOP编程\"><a href=\"#3-2-4、基于注解的AOP编程\" class=\"headerlink\" title=\"3.2.4、基于注解的AOP编程\"></a>3.2.4、基于注解的AOP编程</h3><h4 id=\"3-2-4-1、开发步骤\"><a href=\"#3-2-4-1、开发步骤\" class=\"headerlink\" title=\"3.2.4.1、开发步骤\"></a>3.2.4.1、开发步骤</h4><ol>\n<li>原始功能</li>\n</ol>\n<p>包含原始功能和实现类等</p>\n<ol start=\"2\">\n<li>额外功能+切入点+组装切面</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">        public class MyAround implements MethodInterceptor &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            public Object invoke(MethodInvocation invocation) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                Object ret = invocation.invoke();</span></span><br><span class=\"line\"><span class=\"comment\">                return ret;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;bean id=&quot;around&quot; class=&quot;com.yusael.dynamic.Around&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)))&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:advisor advice-ref=&quot;around&quot; pointcut-ref=&quot;pc&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;/aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        切面:</span></span><br><span class=\"line\"><span class=\"comment\">            1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">            2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">            3. 组装切面</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;around&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.MyAspect&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--告知 Spring 基于注解进行 AOP 编程--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>切入点复用</li>\n</ol>\n<p>切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。<br>    通过这种方式定义切入点表达式，后续更加有利于切入点复用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myPoincut</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around1</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect transaction ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-4-2、动态代理创建方式\"><a href=\"#3-2-4-2、动态代理创建方式\" class=\"headerlink\" title=\"3.2.4.2、动态代理创建方式\"></a>3.2.4.2、动态代理创建方式</h4><p>AOP 底层实现 2 种代理创建方式：</p>\n<ol>\n<li>JDK：通过 <strong>实现接口，做新的实现类</strong> 创建代理对象</li>\n<li>Cglib：通过 <strong>继承父类，做新的子类</strong> 创建代理对象</li>\n</ol>\n<p><strong>默认情况 AOP 编程 底层应用 JDK动态代理创建方式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 动态代理模式切换为cglib --&gt;</span><br><span class=\"line\">&lt;aop:aspectj-autoproxy proxy-target-class=<span class=\"string\">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、spring-持久层\"><a href=\"#4、spring-持久层\" class=\"headerlink\" title=\"4、spring 持久层\"></a>4、spring 持久层</h1><h2 id=\"4-1、spring与mybatis整合\"><a href=\"#4-1、spring与mybatis整合\" class=\"headerlink\" title=\"4.1、spring与mybatis整合\"></a>4.1、spring与mybatis整合</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>druid<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.43<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>spring配置文件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--连接池--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1234&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;typeAliasesPackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.entity&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapperLocations&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;scanner&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sqlSessionFactoryBeanName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;basePackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.dao&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">UserDAO</span> <span class=\"variable\">userDAO</span> <span class=\"operator\">=</span> (UserDAO) ctx.getBean(<span class=\"string\">&quot;userDAO&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">    user.setName(<span class=\"string\">&quot;xiaojr&quot;</span>);</span><br><span class=\"line\">    user.setPassword(<span class=\"string\">&quot;999999&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    userDAO.save(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2、关于事务提交的疑问\"><a href=\"#4-2、关于事务提交的疑问\" class=\"headerlink\" title=\"4.2、关于事务提交的疑问\"></a>4.2、关于事务提交的疑问</h2><p><strong>问题</strong>：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？</p>\n<blockquote>\n<p>Mybatis 提供的连接池对象 —&gt; 创建 Connection<br>Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。<br>Druid（C3P0、DBCP）作为连接池 —&gt; 创建 Connection<br>Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。</p>\n</blockquote>\n<p><strong>答案</strong>：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。</p>\n<p><strong>注意</strong>：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题</p>\n<h2 id=\"4-3、spring事务处理\"><a href=\"#4-3、spring事务处理\" class=\"headerlink\" title=\"4.3、spring事务处理\"></a>4.3、spring事务处理</h2><h3 id=\"4-3-1、事务基本概念\"><a href=\"#4-3-1、事务基本概念\" class=\"headerlink\" title=\"4.3.1、事务基本概念\"></a>4.3.1、事务基本概念</h3><ol>\n<li>什么是事务？</li>\n</ol>\n<p>事务时保证业务操作完整性的一种<strong>数据库机制</strong></p>\n<ol start=\"2\">\n<li>事务的四大特性？</li>\n</ol>\n<p>A 原子性\tC 一致性 I 隔离性\tD 持久性</p>\n<ol start=\"3\">\n<li>如何控制事务？</li>\n</ol>\n<p><strong>JDBC：</strong><br>Connection.setAutoCommit(false);<br>Connection.commit();<br>Connection.rollback();<br><strong>Mybatis：</strong><br>Mybatis 自动开启事务<br>sqlSession.commit();，底层还是调用的 Connection<br>sqlSession.rollback();，底层还是调用的 Connection</p>\n<blockquote>\n<p>结论：控制事务的底层，都是通过 Connection 对象完成的</p>\n</blockquote>\n<h3 id=\"4-3-2、spring控制事务的开发\"><a href=\"#4-3-2、spring控制事务的开发\" class=\"headerlink\" title=\"4.3.2、spring控制事务的开发\"></a>4.3.2、spring控制事务的开发</h3><p>spring是通过aop的方式进行事务开发<br><strong>增强功能：</strong>原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法</p>\n<p><strong>切入点：</strong>@Transactional （1）作用于类上（2）作用域方法。&lt;</p>\n<p><strong>组装切面：</strong>tx:annotation-driven transaction-manager&#x3D;”dataSourceTransactionManager”&#x2F;&gt; 自动扫描所有的@Transactional注解</p>\n<ol>\n<li>搭建开发环境</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-tx<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-3、事务的属性\"><a href=\"#4-3-3、事务的属性\" class=\"headerlink\" title=\"4.3.3、事务的属性\"></a>4.3.3、事务的属性</h3><p>5个：隔离属性，传播属性，只读属性，超时属性，异常属性</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-3-1、隔离属性\"><a href=\"#4-3-3-1、隔离属性\" class=\"headerlink\" title=\"4.3.3.1、隔离属性\"></a>4.3.3.1、隔离属性</h4><h5 id=\"4-3-3-1-1、并发问题-解决方案？\"><a href=\"#4-3-3-1-1、并发问题-解决方案？\" class=\"headerlink\" title=\"4.3.3.1.1、并发问题&amp;解决方案？\"></a>4.3.3.1.1、并发问题&amp;解决方案？</h5><p><strong>（1）脏读</strong>：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：读已提交</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）不可重复读</strong>：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了<br>注意：1.不是脏读 2.在一个事务中</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：可重复读</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.REPEATABLE_READ)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>本质：一把行锁（对数据库表的某一行加锁）</p>\n</blockquote>\n<p><strong>（3）幻读</strong>：一个事务中，多次对<strong>整表</strong>进行<strong>查询统计</strong>，但是<strong>结果不一样</strong>，会在本事务中产生数据不一致的问题</p>\n<blockquote>\n<p>查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：序列化</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.SERIALIZABLE)</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本质：表锁（对数据库某个表加锁）</p>\n</blockquote>\n<h5 id=\"4-3-3-1-2、安全与效率对比：\"><a href=\"#4-3-3-1-2、安全与效率对比：\" class=\"headerlink\" title=\"4.3.3.1.2、安全与效率对比：\"></a>4.3.3.1.2、安全与效率对比：</h5><ul>\n<li>并发安全：SERIALIZABLE &gt; READ_ONLY &gt; READ_COMMITTED</li>\n<li>运行效率：READ_COMMITTED &gt; READ_ONLY &gt; SERIALIZABLE</li>\n</ul>\n<h5 id=\"4-3-3-1-3、数据库默认隔离属性\"><a href=\"#4-3-3-1-3、数据库默认隔离属性\" class=\"headerlink\" title=\"4.3.3.1.3、数据库默认隔离属性\"></a>4.3.3.1.3、数据库默认隔离属性</h5><p>mysql：可重复读（REPEATABLE_READ）<br>Oracle：读已提交（READ_COMMITTED）</p>\n<h4 id=\"4-3-3-2、传播属性\"><a href=\"#4-3-3-2、传播属性\" class=\"headerlink\" title=\"4.3.3.2、传播属性\"></a>4.3.3.2、传播属性</h4><h5 id=\"4-3-3-2-1、基本概念\"><a href=\"#4-3-3-2-1、基本概念\" class=\"headerlink\" title=\"4.3.3.2.1、基本概念\"></a>4.3.3.2.1、基本概念</h5><p>传播属性：描述了事务解决 嵌套 问题 的特征<br><strong>事务的嵌套</strong>：指的是一个大的事务中，包含了若干个小的事务。<br><strong>事务嵌套产生的问题</strong>： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）</p>\n<h5 id=\"4-3-3-2-2、传播属性的值及用法\"><a href=\"#4-3-3-2-2、传播属性的值及用法\" class=\"headerlink\" title=\"4.3.3.2.2、传播属性的值及用法\"></a>4.3.3.2.2、传播属性的值及用法</h5><table>\n<thead>\n<tr>\n<th>传播属性的值</th>\n<th>外部不存在事务</th>\n<th>外部存在事务</th>\n<th>用法</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>REQUIRED</td>\n<td>开启新的事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRED)</td>\n<td>增、删、改方法（保证了肯定会有事务的存在）</td>\n</tr>\n<tr>\n<td>REQUIRES_NEW</td>\n<td>开启新的事务</td>\n<td>挂起外部事务，创建新的事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</td>\n<td>日志记录方法中（保证外部事务异常时能正常的记录日志）</td>\n</tr>\n<tr>\n<td>SUPPORTS</td>\n<td>不开启事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.SUPPORTS)</td>\n<td>查询方法</td>\n</tr>\n<tr>\n<td>NOT_SUPPORTED</td>\n<td>不开启事务</td>\n<td>挂起外部事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>NEVER</td>\n<td>不开启事务</td>\n<td>抛出异常</td>\n<td>@Transactional(propagation &#x3D; Propagation.NEVER)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>MANDATORY（强制的）</td>\n<td>抛出异常</td>\n<td>融合到外部事物中</td>\n<td>@Transactional(propagation &#x3D; Propagation.MANDATORY)</td>\n<td>极其不常用</td>\n</tr>\n</tbody></table>\n<p>Spring 中<strong>传播属性的默认值</strong>是：REQUIRED</p>\n<p>推荐传播属性的使用方式：</p>\n<ul>\n<li>增删改 方法：使用默认值 REQUIRED</li>\n<li>查询 方法：显示指定传播属性的值为 SUPPORTS</li>\n</ul>\n<h4 id=\"4-2-2-3、只读属性\"><a href=\"#4-2-2-3、只读属性\" class=\"headerlink\" title=\"4.2.2.3、只读属性\"></a>4.2.2.3、只读属性</h4><p>针对于 <strong>只进行查询操作的业务方法</strong>，可以加入只读属性，提高运行效率。<br>默认值：false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-2-4、超时属性\"><a href=\"#4-2-2-4、超时属性\" class=\"headerlink\" title=\"4.2.2.4、超时属性\"></a>4.2.2.4、超时属性</h4><p>指定了事务等待的最长时间。</p>\n<ol>\n<li>为什么事务会进行等待？</li>\n</ol>\n<p>当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。</p>\n<ol start=\"2\">\n<li>等待时间，单位是 秒</li>\n<li>如何使用：@Transactional(timeout &#x3D; 2)</li>\n<li>超时属性的默认值：-1</li>\n</ol>\n<p>-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）</p>\n<h4 id=\"4-2-2-5、异常属性\"><a href=\"#4-2-2-5、异常属性\" class=\"headerlink\" title=\"4.2.2.5、异常属性\"></a>4.2.2.5、异常属性</h4><p>Spring 事务处理过程中：</p>\n<ul>\n<li>默认对于 RuntimeException 及其子类，采用 <strong>回滚</strong> 的策略。</li>\n<li>默认对于 对于其他类型的异常，采用 <strong>提交</strong> 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"5、spring-mvc\"><a href=\"#5、spring-mvc\" class=\"headerlink\" title=\"5、spring mvc\"></a>5、spring mvc</h1><p>spring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 </p>\n<h2 id=\"5-1、父子容器关系\"><a href=\"#5-1、父子容器关系\" class=\"headerlink\" title=\"5.1、父子容器关系\"></a>5.1、父子容器关系</h2><ol>\n<li>Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）</li>\n<li>Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等</li>\n<li>Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）</li>\n<li>调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止</li>\n</ol>\n<h2 id=\"5-2、为什么要划分父子容器\"><a href=\"#5-2、为什么要划分父子容器\" class=\"headerlink\" title=\"5.2、为什么要划分父子容器\"></a>5.2、为什么要划分父子容器</h2><ol>\n<li>分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）</li>\n<li>性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能</li>\n</ol>\n<h2 id=\"5-3、springBoot舍弃了父子容器的概念\"><a href=\"#5-3、springBoot舍弃了父子容器的概念\" class=\"headerlink\" title=\"5.3、springBoot舍弃了父子容器的概念\"></a>5.3、springBoot舍弃了父子容器的概念</h2><p>SpringBoot只有一个容器。<br>Spring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署</p>\n<h1 id=\"6、注解编程\"><a href=\"#6、注解编程\" class=\"headerlink\" title=\"6、注解编程\"></a>6、注解编程</h1><h2 id=\"6-1、spring基础注解（spring2-X）\"><a href=\"#6-1、spring基础注解（spring2-X）\" class=\"headerlink\" title=\"6.1、spring基础注解（spring2.X）\"></a>6.1、spring基础注解（spring2.X）</h2><h3 id=\"6-1-1、对象创建相关\"><a href=\"#6-1-1、对象创建相关\" class=\"headerlink\" title=\"6.1.1、对象创建相关\"></a>6.1.1、对象创建相关</h3><h4 id=\"6-1-1-1、-Component\"><a href=\"#6-1-1-1、-Component\" class=\"headerlink\" title=\"6.1.1.1、@Component\"></a>6.1.1.1、@Component</h4><ol>\n<li>作用：替换原有Spring配置文件中的 <bean> 标签</li>\n</ol>\n<ul>\n<li>id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO –&gt; userDAO）</li>\n<li>class 属性：通过反射获得的 class 的内容</li>\n</ul>\n<ol start=\"2\">\n<li>细节：如何显式指定工厂创建对象的 id 值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;u&quot;)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-2、-Repository、-Service、-Contoller\"><a href=\"#6-1-1-2、-Repository、-Service、-Contoller\" class=\"headerlink\" title=\"6.1.1.2、@Repository、@Service、@Contoller\"></a>6.1.1.2、@Repository、@Service、@Contoller</h4><p>@Repository、@Service、@Controller 都是 @Component 的 <strong>衍生注解</strong>。<br>本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；<br>它们的存在是为了：<strong>更加准确的表达一个类型的作用</strong></p>\n<h4 id=\"6-1-1-3、-Scope\"><a href=\"#6-1-1-3、-Scope\" class=\"headerlink\" title=\"6.1.1.3、@Scope\"></a>6.1.1.3、@Scope</h4><p>作用：控制简单对象创建次数<br>注意：不添加 @Scope，Spring 提供默认值 singleton</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建单例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;singleton&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建多例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-4、-Lazy\"><a href=\"#6-1-1-4、-Lazy\" class=\"headerlink\" title=\"6.1.1.4、@Lazy\"></a>6.1.1.4、@Lazy</h4><p>作用：延迟创建单实例对象<br>注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Account</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Account</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Account.Account&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-5、-PostConstruct、-PreDestroy\"><a href=\"#6-1-1-5、-PostConstruct、-PreDestroy\" class=\"headerlink\" title=\"6.1.1.5、@PostConstruct、@PreDestroy\"></a>6.1.1.5、@PostConstruct、@PreDestroy</h4><p>初始化相关方法： @PostConstruct</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InitializingBean</span><br><span class=\"line\">&lt;bean init-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>销毁方法：@PreDestory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableBean</span><br><span class=\"line\">&lt;bean destory-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-1-2、注入相关注解\"><a href=\"#6-1-2、注入相关注解\" class=\"headerlink\" title=\"6.1.2、注入相关注解\"></a>6.1.2、注入相关注解</h3><h4 id=\"6-1-2-1、-Autowired（用户自定义类型）\"><a href=\"#6-1-2-1、-Autowired（用户自定义类型）\" class=\"headerlink\" title=\"6.1.2.1、@Autowired（用户自定义类型）\"></a>6.1.2.1、@Autowired（用户自定义类型）</h4><ol>\n<li>@Autowired 注解 <strong>基于类型进行注入</strong> [推荐]：</li>\n</ol>\n<ul>\n<li>注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>@Autowired、@Qualifier 注解联合实现 <strong>基于名字进行注入</strong> [了解]</li>\n</ol>\n<ul>\n<li>注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;userDAOImpl&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@Autowired 注解放置位置：</li>\n</ol>\n<ul>\n<li>放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）</li>\n<li><strong>直接放置在成员变量上</strong>，Spring 通过反射直接对成员变量进行赋值</li>\n</ul>\n<ol start=\"4\">\n<li>JSR提供的@Resource注解</li>\n</ol>\n<blockquote>\n<p>JavaEE 规范中类似功能的注解：</p>\n<ul>\n<li>JSR250 提供的 @Resource(name&#x3D;”xxx”) <strong>基于名字进行注入</strong><br>等价于 @Autowired 与 @Qualifier 联合实现的效果<br>注意：@Resource 注解如果名字没有配对成功，会继续 <strong>按照类型进行注入</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"6-1-2-2、-value、-PropertySource（JDK-类型）\"><a href=\"#6-1-2-2、-value、-PropertySource（JDK-类型）\" class=\"headerlink\" title=\"6.1.2.2、@value、@PropertySource（JDK 类型）\"></a>6.1.2.2、@value、@PropertySource（JDK 类型）</h4><ol>\n<li>@value 注解的基本使用（xml配置）：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 设置xxx.<span class=\"type\">properties</span> </span><br><span class=\"line\">   <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">   name = suns</span><br><span class=\"line\"><span class=\"number\">2.</span> Spring的工厂读取这个配置文件 </span><br><span class=\"line\">   &lt;context:property-placeholder location=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br><span class=\"line\"><span class=\"number\">3.</span> 代码中进行注入</span><br><span class=\"line\">   属性 <span class=\"meta\">@Value(&quot;$&#123;key&#125;&quot;)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 @PropertySource 取代 xml配置</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource(&quot;classpath:/init.properties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;id&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">\t\tcustomer.setId(id);</span><br><span class=\"line\">\t\tcustomer.setName(name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@value 注解使用细节：</li>\n</ol>\n<ul>\n<li>@Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null</li>\n<li>@Value 注解 + Properties 这种方式，不能注入集合类型<br>Spring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"6-2、spring的高级注解（spring3-X及以上）\"><a href=\"#6-2、spring的高级注解（spring3-X及以上）\" class=\"headerlink\" title=\"6.2、spring的高级注解（spring3.X及以上）\"></a>6.2、spring的高级注解（spring3.X及以上）</h2><h3 id=\"6-2-1、-Configuration（配置bean）\"><a href=\"#6-2-1、-Configuration（配置bean）\" class=\"headerlink\" title=\"6.2.1、@Configuration（配置bean）\"></a>6.2.1、@Configuration（配置bean）</h3><ol>\n<li>Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件</li>\n<li>使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法1: 指定配置bean的Class</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\">方法2: 指定配置bean所在的路径(某个包及其子包)</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.yusael&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2、-Bean\"><a href=\"#6-2-2、-Bean\" class=\"headerlink\" title=\"6.2.2、@Bean\"></a>6.2.2、@Bean</h3><p>@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 &lt;bean 标签</p>\n<blockquote>\n<p><strong>简单对象</strong>：直接能够通过 new 方式创建的对象</p>\n<ul>\n<li>User、UserService、UserDAO</li>\n</ul>\n</blockquote>\n<p><strong>复杂对象</strong>：不能通过 new 的方式直接创建的对象</p>\n<blockquote>\n<ul>\n<li>Connection、SqlSessionFactory</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 简单对象</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 复杂对象</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Connection <span class=\"title function_\">conn1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ConnectionFactoryBean</span> <span class=\"variable\">factoryBean</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactoryBean</span>();</span><br><span class=\"line\">      conn = factoryBean.getObject();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-3、-ComponentScan\"><a href=\"#6-2-3、-ComponentScan\" class=\"headerlink\" title=\"6.2.3、@ComponentScan\"></a>6.2.3、@ComponentScan</h3><p>@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <a href=\"context:component-scan\">context:component-scan</a> 标签<br>目的：进行相关注解的扫描（@Component、@Value、@Autowired …)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">               excludeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION, value=&#123;Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = &quot;*..User1&quot;)&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig2</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"nginx","date":"2023-07-14T16:00:00.000Z","abbrlink":58122,"_content":"# 1、nginx简介\n## 1.1、nginx概述\nNginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。\n## 1.2、正向代理\nnginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能\n正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【**代理客户端，服务端不知道实际发起请求的客户端**】\n> 例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色\n\n## 1.3、反向代理\n反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【**代理服务端，客户端不知道实际提供服务的服务端**】\n> 例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在\n\n## 1.4、负载均衡\n增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 \n## 1.5、动静分离\n为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力\n> 静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，**但是 tomcat 本身处理静态资源的效率并不高**，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 \n\n\n# 2、nginx安装\n\n1. **安装pcre依赖**\n\n（1）联网下载 pcre 压缩文件依赖：\n```shell\nwget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n```\n（2）解压压缩文件\n```shell\ntar –xvf pcre-8.37.tar.gz\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）查看\n```shell\npcre-config --version\n```\n\n2. **安装安装 openssl 、zlib 、 gcc 依赖**\n\n```shell\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n3. **安装nginx**\n\n（1）解压\n```shell\ntar -xvf nginx-1.12.2.tar.gz\n```\n（2）进入解压后目录，执行config命令\n```shell\n./configure\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）启动nginx\n```shell\n# 进入进入目录 /usr/local/nginx/sbin/nginx\n./nginx\n# 停止\n./nginx -s stop\n# 重启\n./nginx -s reload\n\n```\n\n# 3、nginx配置文件\nNginx配置文件分为三大块：全局块，events块，http块\n\n1. 从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等\n2. events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024\n3. http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等\n\n```shell\n\n#================ 全局快 ==================#\n#定义Nginx运行的用户和用户组\nuser  nginx;\n# 工作进程数，一般配置成和CPU数一样\nworker_processes  auto;\n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log  /var/log/nginx/error.log notice;\n#进程pid文件\npid        /var/run/nginx.pid;\n\n#=============== events块 ================#\nevents {\n    # 标识单个woker进程最大并发数\n    worker_connections  1024;\n}\n\n#=============== http块 =================#\nhttp {\n    #文件扩展名与文件类型映射表\n    include       /etc/nginx/mime.types;\n    #默认文件类型\n    default_type  application/octet-stream;\n    #日志格式设定\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #定义本虚拟主机的访问日志\n    access_log  /var/log/nginx/access.log  main;\n     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载\n    sendfile        on;\n    #长连接超时时间，单位是秒\n    keepalive_timeout  65;\n    #包括多个server块，而每个server块就相当于一个虚拟主机\n    server {\n          listen       80;\n          server_name  localhost;\n          # 对特定地址进行处理，地址定向\n          location / {\n              root   html;\n              index  index.html index.htm;\n          }\n  \n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   html;\n      }\n}\n```\n\n# 4、反向代理实现\n实现效果：输入 http://www.test.com, 自动跳转到百度首页\n\n\n```shell\nserver {\n         listen          80;\n         server_name     www.test.com;  #你的域名\n         location / {\n               proxy_pass          http://www.baidu.com/;  #需要反代的域名\n               proxy_redirect      off;\n               proxy_set_header    X-Real-IP      $remote_addr;\n               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n}\n\n```\n# 5、正向代理实现\n场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题\n场景2：内网机器访问外网，就需要正向代理，类似VPN\n```shell\nserver {\n\tlisten 8090;\n\t\n\tlocation / {\n    # resolver后面填写dns地址，可以多个，将以轮询方式请求\n\t\tresolver 218.85.157.99 218.85.152.99;\n    # resolver_timeout 解析超时时间\n\t\tresolver_timeout 30s;\n    # 代理服务器地址（即要请求的地址）\n\t\tproxy_pass http://$host$request_uri;\n\t}\n\taccess_log /data/httplogs/proxy-$host-aceess.log;\n}\n\n```\n# 6、负载均衡实现\n## 6.1、轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除\n```shell\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    upstream webservers{\n      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n \n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n             #转发到负载服务上\n            proxy_pass http://webservers/api/;\n         }\n    }\n}\n```\n## 6.2、weight\nweight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。\n```shell\n\n    upstream webservers{\n      server  192.168.9.134:8081 weight=8;\n      server  192.168.9.134:8082 weight=2;\n    }\n```\n## 6.3、ip_hash\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\n> 使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题\n\n```shell\n    upstream webservers{\n      ip_hash;\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n```\n## 6.4、fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```shell\nupstream webservers{\n        server 192.168.9.134:8081;\n        server 192.168.9.134:8082;\n        fair;\n}\n```\n## 6.5、url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n> 相同的url会被分配到同一个节点，主要为了提高缓存命中率\n\n```shell\nupstream webservers{\n    hash &request_uri;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n## 6.6、least_conn\n按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况\n```shell\nupstream webservers{\n    least_conn;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n# 7、动静分离\n利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能\n```shell\n#所有js,css相关的静态资源文件的请求由Nginx处理\nlocation ~.*\\.(js|css)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     12h; #过期时间为12小时\n}\n#所有图片等多媒体相关静态资源文件的请求由Nginx处理\nlocation ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     7d; #过期时间为7天\n}\n```\n","source":"_posts/Nginx.md","raw":"---\ntitle: nginx\ndate: 2023/07/15\ncategories:\n  - coding\ntags:\n  - nginx\nabbrlink: 58122\n---\n# 1、nginx简介\n## 1.1、nginx概述\nNginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。\n## 1.2、正向代理\nnginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能\n正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【**代理客户端，服务端不知道实际发起请求的客户端**】\n> 例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色\n\n## 1.3、反向代理\n反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【**代理服务端，客户端不知道实际提供服务的服务端**】\n> 例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在\n\n## 1.4、负载均衡\n增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 \n## 1.5、动静分离\n为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力\n> 静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，**但是 tomcat 本身处理静态资源的效率并不高**，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 \n\n\n# 2、nginx安装\n\n1. **安装pcre依赖**\n\n（1）联网下载 pcre 压缩文件依赖：\n```shell\nwget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n```\n（2）解压压缩文件\n```shell\ntar –xvf pcre-8.37.tar.gz\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）查看\n```shell\npcre-config --version\n```\n\n2. **安装安装 openssl 、zlib 、 gcc 依赖**\n\n```shell\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n3. **安装nginx**\n\n（1）解压\n```shell\ntar -xvf nginx-1.12.2.tar.gz\n```\n（2）进入解压后目录，执行config命令\n```shell\n./configure\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）启动nginx\n```shell\n# 进入进入目录 /usr/local/nginx/sbin/nginx\n./nginx\n# 停止\n./nginx -s stop\n# 重启\n./nginx -s reload\n\n```\n\n# 3、nginx配置文件\nNginx配置文件分为三大块：全局块，events块，http块\n\n1. 从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等\n2. events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024\n3. http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等\n\n```shell\n\n#================ 全局快 ==================#\n#定义Nginx运行的用户和用户组\nuser  nginx;\n# 工作进程数，一般配置成和CPU数一样\nworker_processes  auto;\n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log  /var/log/nginx/error.log notice;\n#进程pid文件\npid        /var/run/nginx.pid;\n\n#=============== events块 ================#\nevents {\n    # 标识单个woker进程最大并发数\n    worker_connections  1024;\n}\n\n#=============== http块 =================#\nhttp {\n    #文件扩展名与文件类型映射表\n    include       /etc/nginx/mime.types;\n    #默认文件类型\n    default_type  application/octet-stream;\n    #日志格式设定\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #定义本虚拟主机的访问日志\n    access_log  /var/log/nginx/access.log  main;\n     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载\n    sendfile        on;\n    #长连接超时时间，单位是秒\n    keepalive_timeout  65;\n    #包括多个server块，而每个server块就相当于一个虚拟主机\n    server {\n          listen       80;\n          server_name  localhost;\n          # 对特定地址进行处理，地址定向\n          location / {\n              root   html;\n              index  index.html index.htm;\n          }\n  \n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   html;\n      }\n}\n```\n\n# 4、反向代理实现\n实现效果：输入 http://www.test.com, 自动跳转到百度首页\n\n\n```shell\nserver {\n         listen          80;\n         server_name     www.test.com;  #你的域名\n         location / {\n               proxy_pass          http://www.baidu.com/;  #需要反代的域名\n               proxy_redirect      off;\n               proxy_set_header    X-Real-IP      $remote_addr;\n               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n}\n\n```\n# 5、正向代理实现\n场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题\n场景2：内网机器访问外网，就需要正向代理，类似VPN\n```shell\nserver {\n\tlisten 8090;\n\t\n\tlocation / {\n    # resolver后面填写dns地址，可以多个，将以轮询方式请求\n\t\tresolver 218.85.157.99 218.85.152.99;\n    # resolver_timeout 解析超时时间\n\t\tresolver_timeout 30s;\n    # 代理服务器地址（即要请求的地址）\n\t\tproxy_pass http://$host$request_uri;\n\t}\n\taccess_log /data/httplogs/proxy-$host-aceess.log;\n}\n\n```\n# 6、负载均衡实现\n## 6.1、轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除\n```shell\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    upstream webservers{\n      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n \n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n             #转发到负载服务上\n            proxy_pass http://webservers/api/;\n         }\n    }\n}\n```\n## 6.2、weight\nweight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。\n```shell\n\n    upstream webservers{\n      server  192.168.9.134:8081 weight=8;\n      server  192.168.9.134:8082 weight=2;\n    }\n```\n## 6.3、ip_hash\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\n> 使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题\n\n```shell\n    upstream webservers{\n      ip_hash;\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n```\n## 6.4、fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```shell\nupstream webservers{\n        server 192.168.9.134:8081;\n        server 192.168.9.134:8082;\n        fair;\n}\n```\n## 6.5、url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n> 相同的url会被分配到同一个节点，主要为了提高缓存命中率\n\n```shell\nupstream webservers{\n    hash &request_uri;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n## 6.6、least_conn\n按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况\n```shell\nupstream webservers{\n    least_conn;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n# 7、动静分离\n利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能\n```shell\n#所有js,css相关的静态资源文件的请求由Nginx处理\nlocation ~.*\\.(js|css)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     12h; #过期时间为12小时\n}\n#所有图片等多媒体相关静态资源文件的请求由Nginx处理\nlocation ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     7d; #过期时间为7天\n}\n```\n","slug":"Nginx","published":1,"updated":"2023-07-25T13:19:14.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkqz2ipy000m6wuj99s3boqi","content":"<h1 id=\"1、nginx简介\"><a href=\"#1、nginx简介\" class=\"headerlink\" title=\"1、nginx简介\"></a>1、nginx简介</h1><h2 id=\"1-1、nginx概述\"><a href=\"#1-1、nginx概述\" class=\"headerlink\" title=\"1.1、nginx概述\"></a>1.1、nginx概述</h2><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。</p>\n<h2 id=\"1-2、正向代理\"><a href=\"#1-2、正向代理\" class=\"headerlink\" title=\"1.2、正向代理\"></a>1.2、正向代理</h2><p>nginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能<br>正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【<strong>代理客户端，服务端不知道实际发起请求的客户端</strong>】</p>\n<blockquote>\n<p>例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色</p>\n</blockquote>\n<h2 id=\"1-3、反向代理\"><a href=\"#1-3、反向代理\" class=\"headerlink\" title=\"1.3、反向代理\"></a>1.3、反向代理</h2><p>反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【<strong>代理服务端，客户端不知道实际提供服务的服务端</strong>】</p>\n<blockquote>\n<p>例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在</p>\n</blockquote>\n<h2 id=\"1-4、负载均衡\"><a href=\"#1-4、负载均衡\" class=\"headerlink\" title=\"1.4、负载均衡\"></a>1.4、负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 </p>\n<h2 id=\"1-5、动静分离\"><a href=\"#1-5、动静分离\" class=\"headerlink\" title=\"1.5、动静分离\"></a>1.5、动静分离</h2><p>为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p>\n<blockquote>\n<p>静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，<strong>但是 tomcat 本身处理静态资源的效率并不高</strong>，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 </p>\n</blockquote>\n<h1 id=\"2、nginx安装\"><a href=\"#2、nginx安装\" class=\"headerlink\" title=\"2、nginx安装\"></a>2、nginx安装</h1><ol>\n<li><strong>安装pcre依赖</strong></li>\n</ol>\n<p>（1）联网下载 pcre 压缩文件依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）解压压缩文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar –xvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcre-config --version</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>安装安装 openssl 、zlib 、 gcc 依赖</strong></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>安装nginx</strong></li>\n</ol>\n<p>（1）解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）进入解压后目录，执行config命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入进入目录 /usr/local/nginx/sbin/nginx</span></span><br><span class=\"line\">./nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止</span></span><br><span class=\"line\">./nginx -s stop</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">./nginx -s reload</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、nginx配置文件\"><a href=\"#3、nginx配置文件\" class=\"headerlink\" title=\"3、nginx配置文件\"></a>3、nginx配置文件</h1><p>Nginx配置文件分为三大块：全局块，events块，http块</p>\n<ol>\n<li>从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等</li>\n<li>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024</li>\n<li>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">================ 全局快 ==================<span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">定义Nginx运行的用户和用户组</span></span><br><span class=\"line\">user  nginx;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作进程数，一般配置成和CPU数一样</span></span><br><span class=\"line\">worker_processes  auto;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class=\"line\">error_log  /var/log/nginx/error.log notice;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">进程pid文件</span></span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== events块 ================<span class=\"comment\">#</span></span></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 标识单个woker进程最大并发数</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== http块 =================<span class=\"comment\">#</span></span></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    #文件扩展名与文件类型映射表</span><br><span class=\"line\">    include       /etc/nginx/mime.types;</span><br><span class=\"line\">    #默认文件类型</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    #日志格式设定</span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\">    #定义本虚拟主机的访问日志</span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\">     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #长连接超时时间，单位是秒</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    #包括多个server块，而每个server块就相当于一个虚拟主机</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">          listen       80;</span><br><span class=\"line\">          server_name  localhost;</span><br><span class=\"line\">          # 对特定地址进行处理，地址定向</span><br><span class=\"line\">          location / &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">              index  index.html index.htm;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">          location = /50x.html &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、反向代理实现\"><a href=\"#4、反向代理实现\" class=\"headerlink\" title=\"4、反向代理实现\"></a>4、反向代理实现</h1><p>实现效果：输入 <a href=\"http://www.test.com/\">http://www.test.com</a>, 自动跳转到百度首页</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">         listen          80;</span><br><span class=\"line\">         server_name     www.test.com;  #你的域名</span><br><span class=\"line\">         location / &#123;</span><br><span class=\"line\">               proxy_pass          http://www.baidu.com/;  #需要反代的域名</span><br><span class=\"line\">               proxy_redirect      off;</span><br><span class=\"line\">               proxy_set_header    X-Real-IP      $remote_addr;</span><br><span class=\"line\">               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"5、正向代理实现\"><a href=\"#5、正向代理实现\" class=\"headerlink\" title=\"5、正向代理实现\"></a>5、正向代理实现</h1><p>场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题<br>场景2：内网机器访问外网，就需要正向代理，类似VPN</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 8090;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">    # resolver后面填写dns地址，可以多个，将以轮询方式请求</span><br><span class=\"line\">\t\tresolver 218.85.157.99 218.85.152.99;</span><br><span class=\"line\">    # resolver_timeout 解析超时时间</span><br><span class=\"line\">\t\tresolver_timeout 30s;</span><br><span class=\"line\">    # 代理服务器地址（即要请求的地址）</span><br><span class=\"line\">\t\tproxy_pass http://$host$request_uri;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taccess_log /data/httplogs/proxy-$host-aceess.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、负载均衡实现\"><a href=\"#6、负载均衡实现\" class=\"headerlink\" title=\"6、负载均衡实现\"></a>6、负载均衡实现</h1><h2 id=\"6-1、轮询（默认）\"><a href=\"#6-1、轮询（默认）\" class=\"headerlink\" title=\"6.1、轮询（默认）\"></a>6.1、轮询（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    upstream webservers&#123;</span><br><span class=\"line\">      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问</span><br><span class=\"line\">      server  192.168.9.134:8081;</span><br><span class=\"line\">      server  192.168.9.134:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">             #转发到负载服务上</span><br><span class=\"line\">            proxy_pass http://webservers/api/;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2、weight\"><a href=\"#6-2、weight\" class=\"headerlink\" title=\"6.2、weight\"></a>6.2、weight</h2><p>weight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  server  192.168.9.134:8081 weight=8;</span><br><span class=\"line\">  server  192.168.9.134:8082 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3、ip-hash\"><a href=\"#6-3、ip-hash\" class=\"headerlink\" title=\"6.3、ip_hash\"></a>6.3、ip_hash</h2><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>\n<blockquote>\n<p>使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server  192.168.9.134:8081;</span><br><span class=\"line\">  server  192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-4、fair\"><a href=\"#6-4、fair\" class=\"headerlink\" title=\"6.4、fair\"></a>6.4、fair</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">        server 192.168.9.134:8081;</span><br><span class=\"line\">        server 192.168.9.134:8082;</span><br><span class=\"line\">        fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、url-hash\"><a href=\"#6-5、url-hash\" class=\"headerlink\" title=\"6.5、url_hash\"></a>6.5、url_hash</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<blockquote>\n<p>相同的url会被分配到同一个节点，主要为了提高缓存命中率</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    hash &amp;request_uri;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-6、least-conn\"><a href=\"#6-6、least-conn\" class=\"headerlink\" title=\"6.6、least_conn\"></a>6.6、least_conn</h2><p>按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、动静分离\"><a href=\"#7、动静分离\" class=\"headerlink\" title=\"7、动静分离\"></a>7、动静分离</h1><p>利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有js,css相关的静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(js|css)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     12h; #过期时间为12小时</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有图片等多媒体相关静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     7d; #过期时间为7天</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、nginx简介\"><a href=\"#1、nginx简介\" class=\"headerlink\" title=\"1、nginx简介\"></a>1、nginx简介</h1><h2 id=\"1-1、nginx概述\"><a href=\"#1-1、nginx概述\" class=\"headerlink\" title=\"1.1、nginx概述\"></a>1.1、nginx概述</h2><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。</p>\n<h2 id=\"1-2、正向代理\"><a href=\"#1-2、正向代理\" class=\"headerlink\" title=\"1.2、正向代理\"></a>1.2、正向代理</h2><p>nginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能<br>正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【<strong>代理客户端，服务端不知道实际发起请求的客户端</strong>】</p>\n<blockquote>\n<p>例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色</p>\n</blockquote>\n<h2 id=\"1-3、反向代理\"><a href=\"#1-3、反向代理\" class=\"headerlink\" title=\"1.3、反向代理\"></a>1.3、反向代理</h2><p>反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【<strong>代理服务端，客户端不知道实际提供服务的服务端</strong>】</p>\n<blockquote>\n<p>例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在</p>\n</blockquote>\n<h2 id=\"1-4、负载均衡\"><a href=\"#1-4、负载均衡\" class=\"headerlink\" title=\"1.4、负载均衡\"></a>1.4、负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 </p>\n<h2 id=\"1-5、动静分离\"><a href=\"#1-5、动静分离\" class=\"headerlink\" title=\"1.5、动静分离\"></a>1.5、动静分离</h2><p>为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p>\n<blockquote>\n<p>静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，<strong>但是 tomcat 本身处理静态资源的效率并不高</strong>，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 </p>\n</blockquote>\n<h1 id=\"2、nginx安装\"><a href=\"#2、nginx安装\" class=\"headerlink\" title=\"2、nginx安装\"></a>2、nginx安装</h1><ol>\n<li><strong>安装pcre依赖</strong></li>\n</ol>\n<p>（1）联网下载 pcre 压缩文件依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）解压压缩文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar –xvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcre-config --version</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>安装安装 openssl 、zlib 、 gcc 依赖</strong></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>安装nginx</strong></li>\n</ol>\n<p>（1）解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）进入解压后目录，执行config命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入进入目录 /usr/local/nginx/sbin/nginx</span></span><br><span class=\"line\">./nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止</span></span><br><span class=\"line\">./nginx -s stop</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">./nginx -s reload</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、nginx配置文件\"><a href=\"#3、nginx配置文件\" class=\"headerlink\" title=\"3、nginx配置文件\"></a>3、nginx配置文件</h1><p>Nginx配置文件分为三大块：全局块，events块，http块</p>\n<ol>\n<li>从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等</li>\n<li>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024</li>\n<li>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">================ 全局快 ==================<span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">定义Nginx运行的用户和用户组</span></span><br><span class=\"line\">user  nginx;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作进程数，一般配置成和CPU数一样</span></span><br><span class=\"line\">worker_processes  auto;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class=\"line\">error_log  /var/log/nginx/error.log notice;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">进程pid文件</span></span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== events块 ================<span class=\"comment\">#</span></span></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 标识单个woker进程最大并发数</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== http块 =================<span class=\"comment\">#</span></span></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    #文件扩展名与文件类型映射表</span><br><span class=\"line\">    include       /etc/nginx/mime.types;</span><br><span class=\"line\">    #默认文件类型</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    #日志格式设定</span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\">    #定义本虚拟主机的访问日志</span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\">     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #长连接超时时间，单位是秒</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    #包括多个server块，而每个server块就相当于一个虚拟主机</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">          listen       80;</span><br><span class=\"line\">          server_name  localhost;</span><br><span class=\"line\">          # 对特定地址进行处理，地址定向</span><br><span class=\"line\">          location / &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">              index  index.html index.htm;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">          location = /50x.html &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、反向代理实现\"><a href=\"#4、反向代理实现\" class=\"headerlink\" title=\"4、反向代理实现\"></a>4、反向代理实现</h1><p>实现效果：输入 <a href=\"http://www.test.com/\">http://www.test.com</a>, 自动跳转到百度首页</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">         listen          80;</span><br><span class=\"line\">         server_name     www.test.com;  #你的域名</span><br><span class=\"line\">         location / &#123;</span><br><span class=\"line\">               proxy_pass          http://www.baidu.com/;  #需要反代的域名</span><br><span class=\"line\">               proxy_redirect      off;</span><br><span class=\"line\">               proxy_set_header    X-Real-IP      $remote_addr;</span><br><span class=\"line\">               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"5、正向代理实现\"><a href=\"#5、正向代理实现\" class=\"headerlink\" title=\"5、正向代理实现\"></a>5、正向代理实现</h1><p>场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题<br>场景2：内网机器访问外网，就需要正向代理，类似VPN</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 8090;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">    # resolver后面填写dns地址，可以多个，将以轮询方式请求</span><br><span class=\"line\">\t\tresolver 218.85.157.99 218.85.152.99;</span><br><span class=\"line\">    # resolver_timeout 解析超时时间</span><br><span class=\"line\">\t\tresolver_timeout 30s;</span><br><span class=\"line\">    # 代理服务器地址（即要请求的地址）</span><br><span class=\"line\">\t\tproxy_pass http://$host$request_uri;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taccess_log /data/httplogs/proxy-$host-aceess.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、负载均衡实现\"><a href=\"#6、负载均衡实现\" class=\"headerlink\" title=\"6、负载均衡实现\"></a>6、负载均衡实现</h1><h2 id=\"6-1、轮询（默认）\"><a href=\"#6-1、轮询（默认）\" class=\"headerlink\" title=\"6.1、轮询（默认）\"></a>6.1、轮询（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    upstream webservers&#123;</span><br><span class=\"line\">      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问</span><br><span class=\"line\">      server  192.168.9.134:8081;</span><br><span class=\"line\">      server  192.168.9.134:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">             #转发到负载服务上</span><br><span class=\"line\">            proxy_pass http://webservers/api/;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2、weight\"><a href=\"#6-2、weight\" class=\"headerlink\" title=\"6.2、weight\"></a>6.2、weight</h2><p>weight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  server  192.168.9.134:8081 weight=8;</span><br><span class=\"line\">  server  192.168.9.134:8082 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3、ip-hash\"><a href=\"#6-3、ip-hash\" class=\"headerlink\" title=\"6.3、ip_hash\"></a>6.3、ip_hash</h2><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>\n<blockquote>\n<p>使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server  192.168.9.134:8081;</span><br><span class=\"line\">  server  192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-4、fair\"><a href=\"#6-4、fair\" class=\"headerlink\" title=\"6.4、fair\"></a>6.4、fair</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">        server 192.168.9.134:8081;</span><br><span class=\"line\">        server 192.168.9.134:8082;</span><br><span class=\"line\">        fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、url-hash\"><a href=\"#6-5、url-hash\" class=\"headerlink\" title=\"6.5、url_hash\"></a>6.5、url_hash</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<blockquote>\n<p>相同的url会被分配到同一个节点，主要为了提高缓存命中率</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    hash &amp;request_uri;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-6、least-conn\"><a href=\"#6-6、least-conn\" class=\"headerlink\" title=\"6.6、least_conn\"></a>6.6、least_conn</h2><p>按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、动静分离\"><a href=\"#7、动静分离\" class=\"headerlink\" title=\"7、动静分离\"></a>7、动静分离</h1><p>利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有js,css相关的静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(js|css)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     12h; #过期时间为12小时</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有图片等多媒体相关静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     7d; #过期时间为7天</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"中国历史年表","date":"2023-07-27T16:00:00.000Z","abbrlink":63398,"_content":"\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>\n\t\t\t\t<strong>朝代</strong>\n\t\t\t</th>\n\t\t\t<th></th>\n\t\t\t<th>\n\t\t\t\t<strong>存在时间</strong>\n\t\t\t</th>\n\t\t\t<th></th>\n\t\t\t<th>\n\t\t\t\t<strong>都城（今）</strong>\n\t\t\t</th>\n\t\t\t<th>\n\t\t\t\t<strong>君主</strong>\n\t\t\t</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>“三皇五帝”说</td>\n\t\t\t<td></td>\n\t\t\t<td>前170万年-前2070年</td>\n\t\t\t<td></td>\n\t\t\t<td>无文字记载</td>\n\t\t\t<td>无文字记载</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>夏朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前2070年-前1600年（470年）</td>\n\t\t\t<td></td>\n\t\t\t<td>河南洛阳</td>\n\t\t\t<td>禹 启 太康 仲康 相  少康 杼 槐 芒 泄 不降 扃 廑 孔甲 皋 发 桀（\n\t\t\t\t<strong>17位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>商朝（殷商）</td>\n\t\t\t<td></td>\n\t\t\t<td>前1600年-前1046年（554年）</td>\n\t\t\t<td></td>\n\t\t\t<td>商丘 洛阳 郑州  安阳</td>\n\t\t\t<td>汤 太丁 外丙 中壬 太甲 沃丁 太庚 小甲 雍己 太戊 中丁 外壬 河亶甲 祖乙 祖辛 沃甲 祖丁 南庚 阳甲 盘庚 小辛 小乙 武丁 祖庚 祖甲 廪辛 康丁 武乙 文丁 帝乙 帝辛（纣）（\n\t\t\t\t<strong>30位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西周王朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前1046年-前771年（275年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安（镐京） 洛阳</td>\n\t\t\t<td>（周武王）姬发 姬诵 姬钊 姬瑕 姬满 姬繄扈 姬囏 姬辟方 姬燮 姬胡 周定公 姬静 （周幽王）姬宫湦（\n\t\t\t\t<strong>13位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td  rowspan=\"2\">东周王朝</td>\n\t\t\t<td>春秋</td>\n\t\t\t<td  rowspan=\"2\">前770年-前256年（515年）</td>\n\t\t\t<td>前770年-前476年（295年）</td>\n\t\t\t<td rowspan=\"2\">洛阳</td>\n\t\t\t<td rowspan=\"2\">（周平王）姬宜臼 姬林 姬佗 姬胡齐 姬阆 姬郑 姬壬臣 姬班 姬瑜 姬夷 姬泄心 姬贵 姬猛 姬匄 姬仁 姬介 姬去疾 姬叔 姬嵬 姬午 姬骄 姬喜 姬扁 姬定 （周赧王）姬延（\n\t\t\t\t<strong>25位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>战国</td>\n\t\t\t<td>前475年-前221年（254年）</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>秦朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前221年-前206年（16年）</td>\n\t\t\t<td></td>\n\t\t\t<td>咸阳 西安</td>\n\t\t\t<td>秦始皇 胡亥 子婴（\n\t\t\t\t<strong>3位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西楚</td>\n\t\t\t<td></td>\n\t\t\t<td>前206年-前202年（5年）</td>\n\t\t\t<td></td>\n\t\t\t<td>徐州</td>\n\t\t\t<td>西楚霸王项羽</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西汉</td>\n\t\t\t<td></td>\n\t\t\t<td>前202—公元8年11月（210年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>（汉高祖）刘邦 刘盈 前少帝 刘弘 刘恒 刘启 刘彻 刘弗陵 刘贺 刘询 刘奭 刘骜 刘欣 刘衎 刘婴（\n\t\t\t\t<strong>15位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>新朝</td>\n\t\t\t<td></td>\n\t\t\t<td>公元8年12月-23年10月（16年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>建兴帝王莽</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>玄汉</td>\n\t\t\t<td></td>\n\t\t\t<td>23年10月-25年（2年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>更始帝刘玄</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>东汉</td>\n\t\t\t<td></td>\n\t\t\t<td>25年-220年（195年）</td>\n\t\t\t<td></td>\n\t\t\t<td>洛阳</td>\n\t\t\t<td>光武帝刘秀 刘庄 \n\t\t\t\t刘炟 刘肇 刘隆 刘祜 刘懿 刘保  刘炳 刘缵 刘志 刘宏 刘辩 刘协（\n\t\t\t\t<strong>14位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"3\">三国</td>\n\t\t\t<td>魏</td>\n\t\t\t<td rowspan=\"3\">220年－280年（60年）</td>\n\t\t\t<td>220年-265年（45年）</td>\n\t\t\t<td>洛阳</td>\n\t\t\t<td>魏文帝曹丕  曹叡  曹芳 曹髦 曹奂（\n\t\t\t\t<strong>5位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>蜀汉</td>\n\t\t\t<td>221年-263年（42年）</td>\n\t\t\t<td>成都</td>\n\t\t\t<td>汉昭烈帝刘备 汉怀帝刘禅 （\n\t\t\t\t<strong>2位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>吴</td>\n\t\t\t<td>222年-280年（58年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>吴大帝孙权 孙亮 孙休 孙皓（\n\t\t\t\t<strong>4位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"2\">晋朝</td>\n\t\t\t<td >西晋</td>\n\t\t\t<td rowspan=\"2\">265—420年（155年）</td>\n\t\t\t<td>265年-316年（51年）</td>\n\t\t\t<td>洛阳 西安</td>\n\t\t\t<td>晋武帝 司马炎 司马衷 司马炽 司马邺 （\n\t\t\t\t<strong>4位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>东晋</td>\n\t\t\t<td>317年-420年（103年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>晋元帝司马睿 司马绍 司马衍 司马岳 司马聃 司马丕 司马奕 司马昱 司马曜 司马德宗 司马德文（\n\t\t\t\t<strong>11位</strong>）\n\t\t\t</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>十六国</td>\n\t\t\t<td>前赵（汉赵）   成汉 前凉    后赵 前燕    前秦 后秦    后燕  西秦   后凉  南凉   南燕  西凉   胡夏 北燕    北凉 冉魏    西燕      西蜀（后蜀）</td>\n\t\t\t<td >304年-439年（135年）</td>\n\t\t\t<td></td>\n\t\t\t<td>（多政权存在）</td>\n\t\t\t<td>（多政权存在）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>南北朝</td>\n\t\t\t<td>南朝·宋</td>\n\t\t\t<td>420年—589年（169年）</td>\n\t\t\t<td>420年-479年（59年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>刘裕</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·齐</td>\n\t\t\t<td></td>\n\t\t\t<td>479年-502年（23年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>萧道成</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·梁</td>\n\t\t\t<td></td>\n\t\t\t<td>502年-557年（55年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>萧衍</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·陈</td>\n\t\t\t<td></td>\n\t\t\t<td>557年-589年（32年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>陈霸先</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北魏</td>\n\t\t\t<td></td>\n\t\t\t<td>386年-534年（148年）</td>\n\t\t\t<td>大同 洛阳</td>\n\t\t\t<td>拓跋珪</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·东魏</td>\n\t\t\t<td></td>\n\t\t\t<td>534年-550年（16年）</td>\n\t\t\t<td>安阳</td>\n\t\t\t<td>元善见</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·西魏</td>\n\t\t\t<td></td>\n\t\t\t<td>535年-557年（22年）</td>\n\t\t\t<td>西安</td>\n\t\t\t<td>元宝炬</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北齐</td>\n\t\t\t<td></td>\n\t\t\t<td>550年-577年（27年）</td>\n\t\t\t<td>安阳</td>\n\t\t\t<td>高洋</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北周</td>\n\t\t\t<td></td>\n\t\t\t<td>557年-581年（24年）</td>\n\t\t\t<td>西安</td>\n\t\t\t<td>宇文觉</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>隋朝</td>\n\t\t\t<td></td>\n\t\t\t<td>581年-618年（38年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安 洛阳</td>\n\t\t\t<td>隋文帝杨坚 杨广 杨侑 杨浩 杨昭 杨侗（\n\t\t\t\t<strong>6位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>唐朝</td>\n\t\t\t<td></td>\n\t\t\t<td>618年-907年（289年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安 洛阳</td>\n\t\t\t<td>李渊 李世民 李治 李显 李旦 武则天 李隆基 李亨 李豫 李适 李诵 李纯 李恒 李昂 李炎 李忱 李漼 李儇 李晔 李祝（\n\t\t\t\t<strong>21位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>五代十国</td>\n\t\t\t<td>后梁 后唐 后晋 后汉 后周 前蜀 后蜀 杨吴 南唐 吴越 闽国 马楚 南汉 南平 北汉</td>\n\t\t\t<td>891年-979年（89年）</td>\n\t\t\t<td></td>\n\t\t\t<td>开封 洛阳</td>\n\t\t\t<td>（多政权存在）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>宋朝</td>\n\t\t\t<td >北宋</td>\n\t\t\t<td rowspan=\"2\">960年-1279年（320年）</td>\n\t\t\t<td>960年-1127年（167年）</td>\n\t\t\t<td>开封</td>\n\t\t\t<td>宋太祖赵匡胤 赵光义 赵恒 赵祯 赵曙 赵顼 赵煦 赵佶 赵桓（\n\t\t\t\t<strong>9位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南宋</td>\n\t\t\t<td>1127年-1279年（152年）</td>\n\t\t\t<td>杭州</td>\n\t\t\t<td>宋高宗赵构 赵昚 赵惇 赵扩 赵昀 赵禥 赵㬎 赵昰 赵昺（\n\t\t\t\t<strong>9位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>辽朝</td>\n\t\t\t<td></td>\n\t\t\t<td>916年-1125年（210年）</td>\n\t\t\t<td></td>\n\t\t\t<td>上京</td>\n\t\t\t<td>耶律阿保机</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西夏</td>\n\t\t\t<td></td>\n\t\t\t<td>1038年-1227年（190年）</td>\n\t\t\t<td></td>\n\t\t\t<td>兴庆</td>\n\t\t\t<td>李元昊</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>金朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1115年-1234年（120年）</td>\n\t\t\t<td></td>\n\t\t\t<td>中都 开封</td>\n\t\t\t<td>完颜阿骨打</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"2\">大理国</td>\n\t\t\t<td>前大理</td>\n\t\t\t<td >937年-1094年（157年）</td>\n\t\t\t<td></td>\n\t\t\t<td rowspan=\"2\">云南大理</td>\n\t\t\t<td rowspan=\"2\">段思平</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>后大理</td>\n\t\t\t<td >1096年-1253年（316年）</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>大蒙古国</td>\n\t\t\t<td></td>\n\t\t\t<td>1206年-1271年（66年）</td>\n\t\t\t<td></td>\n\t\t\t<td>大都</td>\n\t\t\t<td>铁木真 窝阔台 贵由 蒙哥（4位）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>元朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1271年-1368年（97年）</td>\n\t\t\t<td></td>\n\t\t\t<td>大都</td>\n\t\t\t<td>元世祖忽必烈 铁穆耳 海山 爱育黎拔力八达 硕德八剌 也孙铁木儿 阿速吉八 图帖睦尔 和世㻋 懿璘质班 妥懽帖睦尔（\n\t\t\t\t<strong>11位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>明朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1368年-1644年（277年）</td>\n\t\t\t<td></td>\n\t\t\t<td>南京 北京</td>\n\t\t\t<td>明太祖朱元璋 朱允炆 朱棣 朱高炽 朱瞻基 朱祁镇 朱祁钰 朱见深 朱祐樘 朱厚照 朱厚熜 朱载垕 朱翊钧 朱常洛 朱由校 朱由检（\n\t\t\t\t<strong>16位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>清朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1636年-1912年（276年）</td>\n\t\t\t<td></td>\n\t\t\t<td>盛京 北京</td>\n\t\t\t<td>努尔哈赤_天命 皇太极_天聪 福临_顺治 玄烨_康熙  胤禛_雍正  弘历_乾隆  颙琰_嘉庆 旻宁_道光  奕詝_咸丰 载淳_同治  载湉_光绪  溥仪_宣统（\n\t\t\t\t<strong>12位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>中华民国</td>\n\t\t\t<td></td>\n\t\t\t<td>1912年-1949年（38年）</td>\n\t\t\t<td></td>\n\t\t\t<td>北京 南京 重庆</td>\n\t\t\t<td>孙中山 袁世凯 冯国璋 徐世昌 周自齐 高凌霨 曹锟 黄郛 段祺瑞 胡惟德 颜惠庆 杜锡圭 顾维钧 张作霖 汪兆铭 谭延闿 胡汉民 蒋介石 林森 李宗仁（\n\t\t\t\t<strong>20位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>中华人民共和国</td>\n\t\t\t<td></td>\n\t\t\t<td>1949以后</td>\n\t\t\t<td></td>\n\t\t\t<td>北京</td>\n\t\t\t<td>毛泽东 刘少奇 董必武 宋庆龄 朱德  叶剑英 李先念 杨尚昆 江泽民 胡锦涛 习近平</td>\n\t\t</tr>\n\t</tbody>\n</table>\n","source":"_posts/中国历史年表.md","raw":"---\ntitle: 中国历史年表\ndate: 2023/07/28\ncategories:\n  - 历史\ntags:\n  - 中国历史\nabbrlink: 63398\n---\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>\n\t\t\t\t<strong>朝代</strong>\n\t\t\t</th>\n\t\t\t<th></th>\n\t\t\t<th>\n\t\t\t\t<strong>存在时间</strong>\n\t\t\t</th>\n\t\t\t<th></th>\n\t\t\t<th>\n\t\t\t\t<strong>都城（今）</strong>\n\t\t\t</th>\n\t\t\t<th>\n\t\t\t\t<strong>君主</strong>\n\t\t\t</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>“三皇五帝”说</td>\n\t\t\t<td></td>\n\t\t\t<td>前170万年-前2070年</td>\n\t\t\t<td></td>\n\t\t\t<td>无文字记载</td>\n\t\t\t<td>无文字记载</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>夏朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前2070年-前1600年（470年）</td>\n\t\t\t<td></td>\n\t\t\t<td>河南洛阳</td>\n\t\t\t<td>禹 启 太康 仲康 相  少康 杼 槐 芒 泄 不降 扃 廑 孔甲 皋 发 桀（\n\t\t\t\t<strong>17位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>商朝（殷商）</td>\n\t\t\t<td></td>\n\t\t\t<td>前1600年-前1046年（554年）</td>\n\t\t\t<td></td>\n\t\t\t<td>商丘 洛阳 郑州  安阳</td>\n\t\t\t<td>汤 太丁 外丙 中壬 太甲 沃丁 太庚 小甲 雍己 太戊 中丁 外壬 河亶甲 祖乙 祖辛 沃甲 祖丁 南庚 阳甲 盘庚 小辛 小乙 武丁 祖庚 祖甲 廪辛 康丁 武乙 文丁 帝乙 帝辛（纣）（\n\t\t\t\t<strong>30位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西周王朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前1046年-前771年（275年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安（镐京） 洛阳</td>\n\t\t\t<td>（周武王）姬发 姬诵 姬钊 姬瑕 姬满 姬繄扈 姬囏 姬辟方 姬燮 姬胡 周定公 姬静 （周幽王）姬宫湦（\n\t\t\t\t<strong>13位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td  rowspan=\"2\">东周王朝</td>\n\t\t\t<td>春秋</td>\n\t\t\t<td  rowspan=\"2\">前770年-前256年（515年）</td>\n\t\t\t<td>前770年-前476年（295年）</td>\n\t\t\t<td rowspan=\"2\">洛阳</td>\n\t\t\t<td rowspan=\"2\">（周平王）姬宜臼 姬林 姬佗 姬胡齐 姬阆 姬郑 姬壬臣 姬班 姬瑜 姬夷 姬泄心 姬贵 姬猛 姬匄 姬仁 姬介 姬去疾 姬叔 姬嵬 姬午 姬骄 姬喜 姬扁 姬定 （周赧王）姬延（\n\t\t\t\t<strong>25位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>战国</td>\n\t\t\t<td>前475年-前221年（254年）</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>秦朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前221年-前206年（16年）</td>\n\t\t\t<td></td>\n\t\t\t<td>咸阳 西安</td>\n\t\t\t<td>秦始皇 胡亥 子婴（\n\t\t\t\t<strong>3位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西楚</td>\n\t\t\t<td></td>\n\t\t\t<td>前206年-前202年（5年）</td>\n\t\t\t<td></td>\n\t\t\t<td>徐州</td>\n\t\t\t<td>西楚霸王项羽</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西汉</td>\n\t\t\t<td></td>\n\t\t\t<td>前202—公元8年11月（210年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>（汉高祖）刘邦 刘盈 前少帝 刘弘 刘恒 刘启 刘彻 刘弗陵 刘贺 刘询 刘奭 刘骜 刘欣 刘衎 刘婴（\n\t\t\t\t<strong>15位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>新朝</td>\n\t\t\t<td></td>\n\t\t\t<td>公元8年12月-23年10月（16年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>建兴帝王莽</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>玄汉</td>\n\t\t\t<td></td>\n\t\t\t<td>23年10月-25年（2年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>更始帝刘玄</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>东汉</td>\n\t\t\t<td></td>\n\t\t\t<td>25年-220年（195年）</td>\n\t\t\t<td></td>\n\t\t\t<td>洛阳</td>\n\t\t\t<td>光武帝刘秀 刘庄 \n\t\t\t\t刘炟 刘肇 刘隆 刘祜 刘懿 刘保  刘炳 刘缵 刘志 刘宏 刘辩 刘协（\n\t\t\t\t<strong>14位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"3\">三国</td>\n\t\t\t<td>魏</td>\n\t\t\t<td rowspan=\"3\">220年－280年（60年）</td>\n\t\t\t<td>220年-265年（45年）</td>\n\t\t\t<td>洛阳</td>\n\t\t\t<td>魏文帝曹丕  曹叡  曹芳 曹髦 曹奂（\n\t\t\t\t<strong>5位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>蜀汉</td>\n\t\t\t<td>221年-263年（42年）</td>\n\t\t\t<td>成都</td>\n\t\t\t<td>汉昭烈帝刘备 汉怀帝刘禅 （\n\t\t\t\t<strong>2位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>吴</td>\n\t\t\t<td>222年-280年（58年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>吴大帝孙权 孙亮 孙休 孙皓（\n\t\t\t\t<strong>4位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"2\">晋朝</td>\n\t\t\t<td >西晋</td>\n\t\t\t<td rowspan=\"2\">265—420年（155年）</td>\n\t\t\t<td>265年-316年（51年）</td>\n\t\t\t<td>洛阳 西安</td>\n\t\t\t<td>晋武帝 司马炎 司马衷 司马炽 司马邺 （\n\t\t\t\t<strong>4位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>东晋</td>\n\t\t\t<td>317年-420年（103年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>晋元帝司马睿 司马绍 司马衍 司马岳 司马聃 司马丕 司马奕 司马昱 司马曜 司马德宗 司马德文（\n\t\t\t\t<strong>11位</strong>）\n\t\t\t</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>十六国</td>\n\t\t\t<td>前赵（汉赵）   成汉 前凉    后赵 前燕    前秦 后秦    后燕  西秦   后凉  南凉   南燕  西凉   胡夏 北燕    北凉 冉魏    西燕      西蜀（后蜀）</td>\n\t\t\t<td >304年-439年（135年）</td>\n\t\t\t<td></td>\n\t\t\t<td>（多政权存在）</td>\n\t\t\t<td>（多政权存在）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>南北朝</td>\n\t\t\t<td>南朝·宋</td>\n\t\t\t<td>420年—589年（169年）</td>\n\t\t\t<td>420年-479年（59年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>刘裕</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·齐</td>\n\t\t\t<td></td>\n\t\t\t<td>479年-502年（23年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>萧道成</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·梁</td>\n\t\t\t<td></td>\n\t\t\t<td>502年-557年（55年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>萧衍</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·陈</td>\n\t\t\t<td></td>\n\t\t\t<td>557年-589年（32年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>陈霸先</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北魏</td>\n\t\t\t<td></td>\n\t\t\t<td>386年-534年（148年）</td>\n\t\t\t<td>大同 洛阳</td>\n\t\t\t<td>拓跋珪</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·东魏</td>\n\t\t\t<td></td>\n\t\t\t<td>534年-550年（16年）</td>\n\t\t\t<td>安阳</td>\n\t\t\t<td>元善见</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·西魏</td>\n\t\t\t<td></td>\n\t\t\t<td>535年-557年（22年）</td>\n\t\t\t<td>西安</td>\n\t\t\t<td>元宝炬</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北齐</td>\n\t\t\t<td></td>\n\t\t\t<td>550年-577年（27年）</td>\n\t\t\t<td>安阳</td>\n\t\t\t<td>高洋</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北周</td>\n\t\t\t<td></td>\n\t\t\t<td>557年-581年（24年）</td>\n\t\t\t<td>西安</td>\n\t\t\t<td>宇文觉</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>隋朝</td>\n\t\t\t<td></td>\n\t\t\t<td>581年-618年（38年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安 洛阳</td>\n\t\t\t<td>隋文帝杨坚 杨广 杨侑 杨浩 杨昭 杨侗（\n\t\t\t\t<strong>6位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>唐朝</td>\n\t\t\t<td></td>\n\t\t\t<td>618年-907年（289年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安 洛阳</td>\n\t\t\t<td>李渊 李世民 李治 李显 李旦 武则天 李隆基 李亨 李豫 李适 李诵 李纯 李恒 李昂 李炎 李忱 李漼 李儇 李晔 李祝（\n\t\t\t\t<strong>21位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>五代十国</td>\n\t\t\t<td>后梁 后唐 后晋 后汉 后周 前蜀 后蜀 杨吴 南唐 吴越 闽国 马楚 南汉 南平 北汉</td>\n\t\t\t<td>891年-979年（89年）</td>\n\t\t\t<td></td>\n\t\t\t<td>开封 洛阳</td>\n\t\t\t<td>（多政权存在）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>宋朝</td>\n\t\t\t<td >北宋</td>\n\t\t\t<td rowspan=\"2\">960年-1279年（320年）</td>\n\t\t\t<td>960年-1127年（167年）</td>\n\t\t\t<td>开封</td>\n\t\t\t<td>宋太祖赵匡胤 赵光义 赵恒 赵祯 赵曙 赵顼 赵煦 赵佶 赵桓（\n\t\t\t\t<strong>9位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南宋</td>\n\t\t\t<td>1127年-1279年（152年）</td>\n\t\t\t<td>杭州</td>\n\t\t\t<td>宋高宗赵构 赵昚 赵惇 赵扩 赵昀 赵禥 赵㬎 赵昰 赵昺（\n\t\t\t\t<strong>9位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>辽朝</td>\n\t\t\t<td></td>\n\t\t\t<td>916年-1125年（210年）</td>\n\t\t\t<td></td>\n\t\t\t<td>上京</td>\n\t\t\t<td>耶律阿保机</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西夏</td>\n\t\t\t<td></td>\n\t\t\t<td>1038年-1227年（190年）</td>\n\t\t\t<td></td>\n\t\t\t<td>兴庆</td>\n\t\t\t<td>李元昊</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>金朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1115年-1234年（120年）</td>\n\t\t\t<td></td>\n\t\t\t<td>中都 开封</td>\n\t\t\t<td>完颜阿骨打</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"2\">大理国</td>\n\t\t\t<td>前大理</td>\n\t\t\t<td >937年-1094年（157年）</td>\n\t\t\t<td></td>\n\t\t\t<td rowspan=\"2\">云南大理</td>\n\t\t\t<td rowspan=\"2\">段思平</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>后大理</td>\n\t\t\t<td >1096年-1253年（316年）</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>大蒙古国</td>\n\t\t\t<td></td>\n\t\t\t<td>1206年-1271年（66年）</td>\n\t\t\t<td></td>\n\t\t\t<td>大都</td>\n\t\t\t<td>铁木真 窝阔台 贵由 蒙哥（4位）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>元朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1271年-1368年（97年）</td>\n\t\t\t<td></td>\n\t\t\t<td>大都</td>\n\t\t\t<td>元世祖忽必烈 铁穆耳 海山 爱育黎拔力八达 硕德八剌 也孙铁木儿 阿速吉八 图帖睦尔 和世㻋 懿璘质班 妥懽帖睦尔（\n\t\t\t\t<strong>11位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>明朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1368年-1644年（277年）</td>\n\t\t\t<td></td>\n\t\t\t<td>南京 北京</td>\n\t\t\t<td>明太祖朱元璋 朱允炆 朱棣 朱高炽 朱瞻基 朱祁镇 朱祁钰 朱见深 朱祐樘 朱厚照 朱厚熜 朱载垕 朱翊钧 朱常洛 朱由校 朱由检（\n\t\t\t\t<strong>16位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>清朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1636年-1912年（276年）</td>\n\t\t\t<td></td>\n\t\t\t<td>盛京 北京</td>\n\t\t\t<td>努尔哈赤_天命 皇太极_天聪 福临_顺治 玄烨_康熙  胤禛_雍正  弘历_乾隆  颙琰_嘉庆 旻宁_道光  奕詝_咸丰 载淳_同治  载湉_光绪  溥仪_宣统（\n\t\t\t\t<strong>12位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>中华民国</td>\n\t\t\t<td></td>\n\t\t\t<td>1912年-1949年（38年）</td>\n\t\t\t<td></td>\n\t\t\t<td>北京 南京 重庆</td>\n\t\t\t<td>孙中山 袁世凯 冯国璋 徐世昌 周自齐 高凌霨 曹锟 黄郛 段祺瑞 胡惟德 颜惠庆 杜锡圭 顾维钧 张作霖 汪兆铭 谭延闿 胡汉民 蒋介石 林森 李宗仁（\n\t\t\t\t<strong>20位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>中华人民共和国</td>\n\t\t\t<td></td>\n\t\t\t<td>1949以后</td>\n\t\t\t<td></td>\n\t\t\t<td>北京</td>\n\t\t\t<td>毛泽东 刘少奇 董必武 宋庆龄 朱德  叶剑英 李先念 杨尚昆 江泽民 胡锦涛 习近平</td>\n\t\t</tr>\n\t</tbody>\n</table>\n","slug":"中国历史年表","published":1,"updated":"2023-07-28T14:19:33.229Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkqz2ipz000o6wujdlwx2mrl","content":"<table>\n    <thead>\n        <tr>\n            <th>\n                <strong>朝代</strong>\n            </th>\n            <th></th>\n            <th>\n                <strong>存在时间</strong>\n            </th>\n            <th></th>\n            <th>\n                <strong>都城（今）</strong>\n            </th>\n            <th>\n                <strong>君主</strong>\n            </th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>“三皇五帝”说</td>\n            <td></td>\n            <td>前170万年-前2070年</td>\n            <td></td>\n            <td>无文字记载</td>\n            <td>无文字记载</td>\n        </tr>\n        <tr>\n            <td>夏朝</td>\n            <td></td>\n            <td>前2070年-前1600年（470年）</td>\n            <td></td>\n            <td>河南洛阳</td>\n            <td>禹 启 太康 仲康 相  少康 杼 槐 芒 泄 不降 扃 廑 孔甲 皋 发 桀（\n                <strong>17位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>商朝（殷商）</td>\n            <td></td>\n            <td>前1600年-前1046年（554年）</td>\n            <td></td>\n            <td>商丘 洛阳 郑州  安阳</td>\n            <td>汤 太丁 外丙 中壬 太甲 沃丁 太庚 小甲 雍己 太戊 中丁 外壬 河亶甲 祖乙 祖辛 沃甲 祖丁 南庚 阳甲 盘庚 小辛 小乙 武丁 祖庚 祖甲 廪辛 康丁 武乙 文丁 帝乙 帝辛（纣）（\n                <strong>30位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>西周王朝</td>\n            <td></td>\n            <td>前1046年-前771年（275年）</td>\n            <td></td>\n            <td>西安（镐京） 洛阳</td>\n            <td>（周武王）姬发 姬诵 姬钊 姬瑕 姬满 姬繄扈 姬囏 姬辟方 姬燮 姬胡 周定公 姬静 （周幽王）姬宫湦（\n                <strong>13位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td  rowspan=\"2\">东周王朝</td>\n            <td>春秋</td>\n            <td  rowspan=\"2\">前770年-前256年（515年）</td>\n            <td>前770年-前476年（295年）</td>\n            <td rowspan=\"2\">洛阳</td>\n            <td rowspan=\"2\">（周平王）姬宜臼 姬林 姬佗 姬胡齐 姬阆 姬郑 姬壬臣 姬班 姬瑜 姬夷 姬泄心 姬贵 姬猛 姬匄 姬仁 姬介 姬去疾 姬叔 姬嵬 姬午 姬骄 姬喜 姬扁 姬定 （周赧王）姬延（\n                <strong>25位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>战国</td>\n            <td>前475年-前221年（254年）</td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>秦朝</td>\n            <td></td>\n            <td>前221年-前206年（16年）</td>\n            <td></td>\n            <td>咸阳 西安</td>\n            <td>秦始皇 胡亥 子婴（\n                <strong>3位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>西楚</td>\n            <td></td>\n            <td>前206年-前202年（5年）</td>\n            <td></td>\n            <td>徐州</td>\n            <td>西楚霸王项羽</td>\n        </tr>\n        <tr>\n            <td>西汉</td>\n            <td></td>\n            <td>前202—公元8年11月（210年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>（汉高祖）刘邦 刘盈 前少帝 刘弘 刘恒 刘启 刘彻 刘弗陵 刘贺 刘询 刘奭 刘骜 刘欣 刘衎 刘婴（\n                <strong>15位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>新朝</td>\n            <td></td>\n            <td>公元8年12月-23年10月（16年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>建兴帝王莽</td>\n        </tr>\n        <tr>\n            <td>玄汉</td>\n            <td></td>\n            <td>23年10月-25年（2年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>更始帝刘玄</td>\n        </tr>\n        <tr>\n            <td>东汉</td>\n            <td></td>\n            <td>25年-220年（195年）</td>\n            <td></td>\n            <td>洛阳</td>\n            <td>光武帝刘秀 刘庄 \n                刘炟 刘肇 刘隆 刘祜 刘懿 刘保  刘炳 刘缵 刘志 刘宏 刘辩 刘协（\n                <strong>14位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td rowspan=\"3\">三国</td>\n            <td>魏</td>\n            <td rowspan=\"3\">220年－280年（60年）</td>\n            <td>220年-265年（45年）</td>\n            <td>洛阳</td>\n            <td>魏文帝曹丕  曹叡  曹芳 曹髦 曹奂（\n                <strong>5位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>蜀汉</td>\n            <td>221年-263年（42年）</td>\n            <td>成都</td>\n            <td>汉昭烈帝刘备 汉怀帝刘禅 （\n                <strong>2位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>吴</td>\n            <td>222年-280年（58年）</td>\n            <td>南京</td>\n            <td>吴大帝孙权 孙亮 孙休 孙皓（\n                <strong>4位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td rowspan=\"2\">晋朝</td>\n            <td >西晋</td>\n            <td rowspan=\"2\">265—420年（155年）</td>\n            <td>265年-316年（51年）</td>\n            <td>洛阳 西安</td>\n            <td>晋武帝 司马炎 司马衷 司马炽 司马邺 （\n                <strong>4位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>东晋</td>\n            <td>317年-420年（103年）</td>\n            <td>南京</td>\n            <td>晋元帝司马睿 司马绍 司马衍 司马岳 司马聃 司马丕 司马奕 司马昱 司马曜 司马德宗 司马德文（\n                <strong>11位</strong>）\n            </td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>十六国</td>\n            <td>前赵（汉赵）   成汉 前凉    后赵 前燕    前秦 后秦    后燕  西秦   后凉  南凉   南燕  西凉   胡夏 北燕    北凉 冉魏    西燕      西蜀（后蜀）</td>\n            <td >304年-439年（135年）</td>\n            <td></td>\n            <td>（多政权存在）</td>\n            <td>（多政权存在）</td>\n        </tr>\n        <tr>\n            <td>南北朝</td>\n            <td>南朝·宋</td>\n            <td>420年—589年（169年）</td>\n            <td>420年-479年（59年）</td>\n            <td>南京</td>\n            <td>刘裕</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·齐</td>\n            <td></td>\n            <td>479年-502年（23年）</td>\n            <td>南京</td>\n            <td>萧道成</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·梁</td>\n            <td></td>\n            <td>502年-557年（55年）</td>\n            <td>南京</td>\n            <td>萧衍</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·陈</td>\n            <td></td>\n            <td>557年-589年（32年）</td>\n            <td>南京</td>\n            <td>陈霸先</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北魏</td>\n            <td></td>\n            <td>386年-534年（148年）</td>\n            <td>大同 洛阳</td>\n            <td>拓跋珪</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·东魏</td>\n            <td></td>\n            <td>534年-550年（16年）</td>\n            <td>安阳</td>\n            <td>元善见</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·西魏</td>\n            <td></td>\n            <td>535年-557年（22年）</td>\n            <td>西安</td>\n            <td>元宝炬</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北齐</td>\n            <td></td>\n            <td>550年-577年（27年）</td>\n            <td>安阳</td>\n            <td>高洋</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北周</td>\n            <td></td>\n            <td>557年-581年（24年）</td>\n            <td>西安</td>\n            <td>宇文觉</td>\n        </tr>\n        <tr>\n            <td>隋朝</td>\n            <td></td>\n            <td>581年-618年（38年）</td>\n            <td></td>\n            <td>西安 洛阳</td>\n            <td>隋文帝杨坚 杨广 杨侑 杨浩 杨昭 杨侗（\n                <strong>6位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>唐朝</td>\n            <td></td>\n            <td>618年-907年（289年）</td>\n            <td></td>\n            <td>西安 洛阳</td>\n            <td>李渊 李世民 李治 李显 李旦 武则天 李隆基 李亨 李豫 李适 李诵 李纯 李恒 李昂 李炎 李忱 李漼 李儇 李晔 李祝（\n                <strong>21位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>五代十国</td>\n            <td>后梁 后唐 后晋 后汉 后周 前蜀 后蜀 杨吴 南唐 吴越 闽国 马楚 南汉 南平 北汉</td>\n            <td>891年-979年（89年）</td>\n            <td></td>\n            <td>开封 洛阳</td>\n            <td>（多政权存在）</td>\n        </tr>\n        <tr>\n            <td>宋朝</td>\n            <td >北宋</td>\n            <td rowspan=\"2\">960年-1279年（320年）</td>\n            <td>960年-1127年（167年）</td>\n            <td>开封</td>\n            <td>宋太祖赵匡胤 赵光义 赵恒 赵祯 赵曙 赵顼 赵煦 赵佶 赵桓（\n                <strong>9位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南宋</td>\n            <td>1127年-1279年（152年）</td>\n            <td>杭州</td>\n            <td>宋高宗赵构 赵昚 赵惇 赵扩 赵昀 赵禥 赵㬎 赵昰 赵昺（\n                <strong>9位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>辽朝</td>\n            <td></td>\n            <td>916年-1125年（210年）</td>\n            <td></td>\n            <td>上京</td>\n            <td>耶律阿保机</td>\n        </tr>\n        <tr>\n            <td>西夏</td>\n            <td></td>\n            <td>1038年-1227年（190年）</td>\n            <td></td>\n            <td>兴庆</td>\n            <td>李元昊</td>\n        </tr>\n        <tr>\n            <td>金朝</td>\n            <td></td>\n            <td>1115年-1234年（120年）</td>\n            <td></td>\n            <td>中都 开封</td>\n            <td>完颜阿骨打</td>\n        </tr>\n        <tr>\n            <td rowspan=\"2\">大理国</td>\n            <td>前大理</td>\n            <td >937年-1094年（157年）</td>\n            <td></td>\n            <td rowspan=\"2\">云南大理</td>\n            <td rowspan=\"2\">段思平</td>\n        </tr>\n        <tr>\n            <td>后大理</td>\n            <td >1096年-1253年（316年）</td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>大蒙古国</td>\n            <td></td>\n            <td>1206年-1271年（66年）</td>\n            <td></td>\n            <td>大都</td>\n            <td>铁木真 窝阔台 贵由 蒙哥（4位）</td>\n        </tr>\n        <tr>\n            <td>元朝</td>\n            <td></td>\n            <td>1271年-1368年（97年）</td>\n            <td></td>\n            <td>大都</td>\n            <td>元世祖忽必烈 铁穆耳 海山 爱育黎拔力八达 硕德八剌 也孙铁木儿 阿速吉八 图帖睦尔 和世㻋 懿璘质班 妥懽帖睦尔（\n                <strong>11位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>明朝</td>\n            <td></td>\n            <td>1368年-1644年（277年）</td>\n            <td></td>\n            <td>南京 北京</td>\n            <td>明太祖朱元璋 朱允炆 朱棣 朱高炽 朱瞻基 朱祁镇 朱祁钰 朱见深 朱祐樘 朱厚照 朱厚熜 朱载垕 朱翊钧 朱常洛 朱由校 朱由检（\n                <strong>16位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>清朝</td>\n            <td></td>\n            <td>1636年-1912年（276年）</td>\n            <td></td>\n            <td>盛京 北京</td>\n            <td>努尔哈赤_天命 皇太极_天聪 福临_顺治 玄烨_康熙  胤禛_雍正  弘历_乾隆  颙琰_嘉庆 旻宁_道光  奕詝_咸丰 载淳_同治  载湉_光绪  溥仪_宣统（\n                <strong>12位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>中华民国</td>\n            <td></td>\n            <td>1912年-1949年（38年）</td>\n            <td></td>\n            <td>北京 南京 重庆</td>\n            <td>孙中山 袁世凯 冯国璋 徐世昌 周自齐 高凌霨 曹锟 黄郛 段祺瑞 胡惟德 颜惠庆 杜锡圭 顾维钧 张作霖 汪兆铭 谭延闿 胡汉民 蒋介石 林森 李宗仁（\n                <strong>20位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>中华人民共和国</td>\n            <td></td>\n            <td>1949以后</td>\n            <td></td>\n            <td>北京</td>\n            <td>毛泽东 刘少奇 董必武 宋庆龄 朱德  叶剑英 李先念 杨尚昆 江泽民 胡锦涛 习近平</td>\n        </tr>\n    </tbody>\n</table>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<table>\n    <thead>\n        <tr>\n            <th>\n                <strong>朝代</strong>\n            </th>\n            <th></th>\n            <th>\n                <strong>存在时间</strong>\n            </th>\n            <th></th>\n            <th>\n                <strong>都城（今）</strong>\n            </th>\n            <th>\n                <strong>君主</strong>\n            </th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>“三皇五帝”说</td>\n            <td></td>\n            <td>前170万年-前2070年</td>\n            <td></td>\n            <td>无文字记载</td>\n            <td>无文字记载</td>\n        </tr>\n        <tr>\n            <td>夏朝</td>\n            <td></td>\n            <td>前2070年-前1600年（470年）</td>\n            <td></td>\n            <td>河南洛阳</td>\n            <td>禹 启 太康 仲康 相  少康 杼 槐 芒 泄 不降 扃 廑 孔甲 皋 发 桀（\n                <strong>17位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>商朝（殷商）</td>\n            <td></td>\n            <td>前1600年-前1046年（554年）</td>\n            <td></td>\n            <td>商丘 洛阳 郑州  安阳</td>\n            <td>汤 太丁 外丙 中壬 太甲 沃丁 太庚 小甲 雍己 太戊 中丁 外壬 河亶甲 祖乙 祖辛 沃甲 祖丁 南庚 阳甲 盘庚 小辛 小乙 武丁 祖庚 祖甲 廪辛 康丁 武乙 文丁 帝乙 帝辛（纣）（\n                <strong>30位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>西周王朝</td>\n            <td></td>\n            <td>前1046年-前771年（275年）</td>\n            <td></td>\n            <td>西安（镐京） 洛阳</td>\n            <td>（周武王）姬发 姬诵 姬钊 姬瑕 姬满 姬繄扈 姬囏 姬辟方 姬燮 姬胡 周定公 姬静 （周幽王）姬宫湦（\n                <strong>13位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td  rowspan=\"2\">东周王朝</td>\n            <td>春秋</td>\n            <td  rowspan=\"2\">前770年-前256年（515年）</td>\n            <td>前770年-前476年（295年）</td>\n            <td rowspan=\"2\">洛阳</td>\n            <td rowspan=\"2\">（周平王）姬宜臼 姬林 姬佗 姬胡齐 姬阆 姬郑 姬壬臣 姬班 姬瑜 姬夷 姬泄心 姬贵 姬猛 姬匄 姬仁 姬介 姬去疾 姬叔 姬嵬 姬午 姬骄 姬喜 姬扁 姬定 （周赧王）姬延（\n                <strong>25位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>战国</td>\n            <td>前475年-前221年（254年）</td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>秦朝</td>\n            <td></td>\n            <td>前221年-前206年（16年）</td>\n            <td></td>\n            <td>咸阳 西安</td>\n            <td>秦始皇 胡亥 子婴（\n                <strong>3位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>西楚</td>\n            <td></td>\n            <td>前206年-前202年（5年）</td>\n            <td></td>\n            <td>徐州</td>\n            <td>西楚霸王项羽</td>\n        </tr>\n        <tr>\n            <td>西汉</td>\n            <td></td>\n            <td>前202—公元8年11月（210年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>（汉高祖）刘邦 刘盈 前少帝 刘弘 刘恒 刘启 刘彻 刘弗陵 刘贺 刘询 刘奭 刘骜 刘欣 刘衎 刘婴（\n                <strong>15位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>新朝</td>\n            <td></td>\n            <td>公元8年12月-23年10月（16年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>建兴帝王莽</td>\n        </tr>\n        <tr>\n            <td>玄汉</td>\n            <td></td>\n            <td>23年10月-25年（2年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>更始帝刘玄</td>\n        </tr>\n        <tr>\n            <td>东汉</td>\n            <td></td>\n            <td>25年-220年（195年）</td>\n            <td></td>\n            <td>洛阳</td>\n            <td>光武帝刘秀 刘庄 \n                刘炟 刘肇 刘隆 刘祜 刘懿 刘保  刘炳 刘缵 刘志 刘宏 刘辩 刘协（\n                <strong>14位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td rowspan=\"3\">三国</td>\n            <td>魏</td>\n            <td rowspan=\"3\">220年－280年（60年）</td>\n            <td>220年-265年（45年）</td>\n            <td>洛阳</td>\n            <td>魏文帝曹丕  曹叡  曹芳 曹髦 曹奂（\n                <strong>5位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>蜀汉</td>\n            <td>221年-263年（42年）</td>\n            <td>成都</td>\n            <td>汉昭烈帝刘备 汉怀帝刘禅 （\n                <strong>2位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>吴</td>\n            <td>222年-280年（58年）</td>\n            <td>南京</td>\n            <td>吴大帝孙权 孙亮 孙休 孙皓（\n                <strong>4位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td rowspan=\"2\">晋朝</td>\n            <td >西晋</td>\n            <td rowspan=\"2\">265—420年（155年）</td>\n            <td>265年-316年（51年）</td>\n            <td>洛阳 西安</td>\n            <td>晋武帝 司马炎 司马衷 司马炽 司马邺 （\n                <strong>4位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>东晋</td>\n            <td>317年-420年（103年）</td>\n            <td>南京</td>\n            <td>晋元帝司马睿 司马绍 司马衍 司马岳 司马聃 司马丕 司马奕 司马昱 司马曜 司马德宗 司马德文（\n                <strong>11位</strong>）\n            </td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>十六国</td>\n            <td>前赵（汉赵）   成汉 前凉    后赵 前燕    前秦 后秦    后燕  西秦   后凉  南凉   南燕  西凉   胡夏 北燕    北凉 冉魏    西燕      西蜀（后蜀）</td>\n            <td >304年-439年（135年）</td>\n            <td></td>\n            <td>（多政权存在）</td>\n            <td>（多政权存在）</td>\n        </tr>\n        <tr>\n            <td>南北朝</td>\n            <td>南朝·宋</td>\n            <td>420年—589年（169年）</td>\n            <td>420年-479年（59年）</td>\n            <td>南京</td>\n            <td>刘裕</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·齐</td>\n            <td></td>\n            <td>479年-502年（23年）</td>\n            <td>南京</td>\n            <td>萧道成</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·梁</td>\n            <td></td>\n            <td>502年-557年（55年）</td>\n            <td>南京</td>\n            <td>萧衍</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·陈</td>\n            <td></td>\n            <td>557年-589年（32年）</td>\n            <td>南京</td>\n            <td>陈霸先</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北魏</td>\n            <td></td>\n            <td>386年-534年（148年）</td>\n            <td>大同 洛阳</td>\n            <td>拓跋珪</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·东魏</td>\n            <td></td>\n            <td>534年-550年（16年）</td>\n            <td>安阳</td>\n            <td>元善见</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·西魏</td>\n            <td></td>\n            <td>535年-557年（22年）</td>\n            <td>西安</td>\n            <td>元宝炬</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北齐</td>\n            <td></td>\n            <td>550年-577年（27年）</td>\n            <td>安阳</td>\n            <td>高洋</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北周</td>\n            <td></td>\n            <td>557年-581年（24年）</td>\n            <td>西安</td>\n            <td>宇文觉</td>\n        </tr>\n        <tr>\n            <td>隋朝</td>\n            <td></td>\n            <td>581年-618年（38年）</td>\n            <td></td>\n            <td>西安 洛阳</td>\n            <td>隋文帝杨坚 杨广 杨侑 杨浩 杨昭 杨侗（\n                <strong>6位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>唐朝</td>\n            <td></td>\n            <td>618年-907年（289年）</td>\n            <td></td>\n            <td>西安 洛阳</td>\n            <td>李渊 李世民 李治 李显 李旦 武则天 李隆基 李亨 李豫 李适 李诵 李纯 李恒 李昂 李炎 李忱 李漼 李儇 李晔 李祝（\n                <strong>21位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>五代十国</td>\n            <td>后梁 后唐 后晋 后汉 后周 前蜀 后蜀 杨吴 南唐 吴越 闽国 马楚 南汉 南平 北汉</td>\n            <td>891年-979年（89年）</td>\n            <td></td>\n            <td>开封 洛阳</td>\n            <td>（多政权存在）</td>\n        </tr>\n        <tr>\n            <td>宋朝</td>\n            <td >北宋</td>\n            <td rowspan=\"2\">960年-1279年（320年）</td>\n            <td>960年-1127年（167年）</td>\n            <td>开封</td>\n            <td>宋太祖赵匡胤 赵光义 赵恒 赵祯 赵曙 赵顼 赵煦 赵佶 赵桓（\n                <strong>9位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南宋</td>\n            <td>1127年-1279年（152年）</td>\n            <td>杭州</td>\n            <td>宋高宗赵构 赵昚 赵惇 赵扩 赵昀 赵禥 赵㬎 赵昰 赵昺（\n                <strong>9位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>辽朝</td>\n            <td></td>\n            <td>916年-1125年（210年）</td>\n            <td></td>\n            <td>上京</td>\n            <td>耶律阿保机</td>\n        </tr>\n        <tr>\n            <td>西夏</td>\n            <td></td>\n            <td>1038年-1227年（190年）</td>\n            <td></td>\n            <td>兴庆</td>\n            <td>李元昊</td>\n        </tr>\n        <tr>\n            <td>金朝</td>\n            <td></td>\n            <td>1115年-1234年（120年）</td>\n            <td></td>\n            <td>中都 开封</td>\n            <td>完颜阿骨打</td>\n        </tr>\n        <tr>\n            <td rowspan=\"2\">大理国</td>\n            <td>前大理</td>\n            <td >937年-1094年（157年）</td>\n            <td></td>\n            <td rowspan=\"2\">云南大理</td>\n            <td rowspan=\"2\">段思平</td>\n        </tr>\n        <tr>\n            <td>后大理</td>\n            <td >1096年-1253年（316年）</td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>大蒙古国</td>\n            <td></td>\n            <td>1206年-1271年（66年）</td>\n            <td></td>\n            <td>大都</td>\n            <td>铁木真 窝阔台 贵由 蒙哥（4位）</td>\n        </tr>\n        <tr>\n            <td>元朝</td>\n            <td></td>\n            <td>1271年-1368年（97年）</td>\n            <td></td>\n            <td>大都</td>\n            <td>元世祖忽必烈 铁穆耳 海山 爱育黎拔力八达 硕德八剌 也孙铁木儿 阿速吉八 图帖睦尔 和世㻋 懿璘质班 妥懽帖睦尔（\n                <strong>11位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>明朝</td>\n            <td></td>\n            <td>1368年-1644年（277年）</td>\n            <td></td>\n            <td>南京 北京</td>\n            <td>明太祖朱元璋 朱允炆 朱棣 朱高炽 朱瞻基 朱祁镇 朱祁钰 朱见深 朱祐樘 朱厚照 朱厚熜 朱载垕 朱翊钧 朱常洛 朱由校 朱由检（\n                <strong>16位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>清朝</td>\n            <td></td>\n            <td>1636年-1912年（276年）</td>\n            <td></td>\n            <td>盛京 北京</td>\n            <td>努尔哈赤_天命 皇太极_天聪 福临_顺治 玄烨_康熙  胤禛_雍正  弘历_乾隆  颙琰_嘉庆 旻宁_道光  奕詝_咸丰 载淳_同治  载湉_光绪  溥仪_宣统（\n                <strong>12位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>中华民国</td>\n            <td></td>\n            <td>1912年-1949年（38年）</td>\n            <td></td>\n            <td>北京 南京 重庆</td>\n            <td>孙中山 袁世凯 冯国璋 徐世昌 周自齐 高凌霨 曹锟 黄郛 段祺瑞 胡惟德 颜惠庆 杜锡圭 顾维钧 张作霖 汪兆铭 谭延闿 胡汉民 蒋介石 林森 李宗仁（\n                <strong>20位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>中华人民共和国</td>\n            <td></td>\n            <td>1949以后</td>\n            <td></td>\n            <td>北京</td>\n            <td>毛泽东 刘少奇 董必武 宋庆龄 朱德  叶剑英 李先念 杨尚昆 江泽民 胡锦涛 习近平</td>\n        </tr>\n    </tbody>\n</table>\n"},{"title":"夏","date":"2023-07-30T16:00:00.000Z","_content":"\n# 1、商朝年表\n\n| 序号 | 姓名 | 别名 | 在位时长 | 相关事件 |\n| --- | --- | --- | --- | --- |\n| 1 | 商汤 | 天乙 | 前1600年-前1588年（13年） | 开国君主 鸣条之战 |\n| 2 | 商哀王 | 外丙 | 前1587年-前1586年（2年） |  |\n| 3 | 商懿王 | 仲壬 | 前1585年-前1582年（4年） |  |\n| 4 | 商太宗 | 太甲 | 前1582年-前1570年（13年） |  |\n| 5 | 商昭王 | 沃丁 | 前1570年-前1541年（29年） |  |\n| 6 | 商宣王 | 太庚 | 前1541年-前1516年（25年） |  |\n| 7 | 商敬王 | 小甲 | 前1516年-前1499年（17年） |  商朝始衰|\n| 8 | 商元王 | 雍己 | 前1487年-前1476年（12年） |  诸侯不来朝|\n| 9 | 商中宗 | 太戊 | 前1486年-前1412年（75年） | 小国又纷纷归顺，商朝中兴  |\n| 10 | 商孝成王 | 仲丁 | 前1418年-前1408年（13年） |  |\n| 11 | 商思王 | 外壬 | 前1407年-前1398年 （10年）| 九世之乱 |\n| 12 | 商前平王 | 河檀（dan）甲 | 前1397年-前1389年（9年） | 迁都河南内黄  |\n| 13 | 商穆王 | 祖乙 | 前1388年-前1370年（19年） |  |\n| 14 | 商桓王 | 祖辛 | 前1369年-前1356年（16年） |  |\n| 15 | 商僖（xi）王 | 沃甲 | 前1355年- 前1336年（20年） |  |\n| 16 | 商庄王 | 祖丁 | 前1335年- 前1327年（9年） |  |\n| 17 | 商顷王 | 南庚 | 前1326年-前1321年（6年） | 国都由庇（山东郓城）迁奄（山东曲阜） |\n| 18 | 商悼王 | 阳甲 | 前1321年- 前1314年（8年） |  |\n| 19 | 商世祖 | 盘庚 | 前1313年-前1286年（28年） | 迁都殷（河南安阳） |\n| 20 | 商章王 | 小辛 | 前1285年- 前1272年（14年） |  |\n| 21 | 商惠王 | 小乙 | 前1271年- 前1251年（21年） |  |\n| 22 | 商高宗 | 武丁 | 前1250年- 前1192年（59年） | 武丁中兴 |\n| 23 | 商后平王 | 祖庚 | 前1191年-前1180年（12年） |  |\n| 24 | 商世宗 | 祖甲 | 前1180年-前1160年（20年） |  |\n| 25 | 商甲宗 | 廪（lin）辛 | 前1159年-前1156年（4年） |  |\n| 26 | 商康祖 | 庚丁 | 前1155年- 前1147年（9年） |  |\n| 27 | 商武祖 | 武乙 | 前1147年-前1113年（35年） |  |\n| 28 | 商匡王 | 文丁 | 前1112年-前1102年（11年） |  |\n| 29 | 商德王 | 帝乙 | 前1101年- 前1076年（26年） |  |\n| 30 | 商纣王 | 帝辛 | 前1075年-前1046年（30年） |  |\n\n\n# 2、贤相伊尹\n\n&emsp;&emsp;有莘氏在史书中第二次出场是夏朝末年了,当时东方的商族崛起,夏桀的统治岌岌可危。\n\n&emsp;&emsp;传说,伊尹生于伊水岸边、空桑之中,被有莘国君的厨师收养,得以学习烹饪之术,长大以后,成了烹饪小能手。可聪明的伊尹不甘于在厨房里研究美食,他从烹饪技巧中领悟出了治国之道。\n\n&emsp;&emsp;虽然有莘和夏同族,但伊尹却看透了夏桀的昏庸腐败,预测到夏必为商所取代。趁着有莘公主嫁给商汤的机会,伊尹主动报名,成为陪嫁的厨师被带到商汤面前。\n\n&emsp;&emsp;伊尹以烹调为例（治理国家就像做菜一样，讲究食材的搭配、五味的调和）,向汤说治国之道,建议他以尧舜的方法治理国家,得到了汤的认可,并拜为右相,授以国政。伊尹辅佐商汤灭夏建商,被商汤尊为“**元圣**”。\n\n&emsp;&emsp;太甲继位为王,暴虐成性,伊尹把他囚在商汤陵前的桐宫,让他反省悔过。伊尹自己代理国政,接见诸侯,并常到桐宫教育太甲。三年后,太甲悔过,返善修德,伊尹率领众大臣去桐宫迎太甲回亳都宫殿,重新授给他国政,并作了《太甲训》三篇,褒誉太甲知过迁善。太甲在位三十三年,死后被谥为太宗。太甲的儿子沃丁继位为王,伊尹退出政界,不久病逝,沃丁以天子礼葬伊尹于亳东。\n\n&emsp;&emsp;伊尹一生历事成**汤、外丙、仲壬、太甲、沃丁**五代君主“千古贤相第一人”之称。伊尹还有高超的烹调技术,同时发明了中药汤液疗法,被后世尊为烹饪和中药鼻祖。\n\n&emsp;&emsp;今山东**曹县**有处伊尹墓,这也是天下众多的伊尹墓之一,可见伊尹确实受人尊敬。明代,曹县知县范希正在伊尹墓前重修伊尹祠\n\n","source":"_posts/商.md","raw":"---\ntitle: 夏\ndate: 2023/07/31\ncategories:\n  - 历史\ntags:\n  - 中国历史\n  - 商朝\n---\n\n# 1、商朝年表\n\n| 序号 | 姓名 | 别名 | 在位时长 | 相关事件 |\n| --- | --- | --- | --- | --- |\n| 1 | 商汤 | 天乙 | 前1600年-前1588年（13年） | 开国君主 鸣条之战 |\n| 2 | 商哀王 | 外丙 | 前1587年-前1586年（2年） |  |\n| 3 | 商懿王 | 仲壬 | 前1585年-前1582年（4年） |  |\n| 4 | 商太宗 | 太甲 | 前1582年-前1570年（13年） |  |\n| 5 | 商昭王 | 沃丁 | 前1570年-前1541年（29年） |  |\n| 6 | 商宣王 | 太庚 | 前1541年-前1516年（25年） |  |\n| 7 | 商敬王 | 小甲 | 前1516年-前1499年（17年） |  商朝始衰|\n| 8 | 商元王 | 雍己 | 前1487年-前1476年（12年） |  诸侯不来朝|\n| 9 | 商中宗 | 太戊 | 前1486年-前1412年（75年） | 小国又纷纷归顺，商朝中兴  |\n| 10 | 商孝成王 | 仲丁 | 前1418年-前1408年（13年） |  |\n| 11 | 商思王 | 外壬 | 前1407年-前1398年 （10年）| 九世之乱 |\n| 12 | 商前平王 | 河檀（dan）甲 | 前1397年-前1389年（9年） | 迁都河南内黄  |\n| 13 | 商穆王 | 祖乙 | 前1388年-前1370年（19年） |  |\n| 14 | 商桓王 | 祖辛 | 前1369年-前1356年（16年） |  |\n| 15 | 商僖（xi）王 | 沃甲 | 前1355年- 前1336年（20年） |  |\n| 16 | 商庄王 | 祖丁 | 前1335年- 前1327年（9年） |  |\n| 17 | 商顷王 | 南庚 | 前1326年-前1321年（6年） | 国都由庇（山东郓城）迁奄（山东曲阜） |\n| 18 | 商悼王 | 阳甲 | 前1321年- 前1314年（8年） |  |\n| 19 | 商世祖 | 盘庚 | 前1313年-前1286年（28年） | 迁都殷（河南安阳） |\n| 20 | 商章王 | 小辛 | 前1285年- 前1272年（14年） |  |\n| 21 | 商惠王 | 小乙 | 前1271年- 前1251年（21年） |  |\n| 22 | 商高宗 | 武丁 | 前1250年- 前1192年（59年） | 武丁中兴 |\n| 23 | 商后平王 | 祖庚 | 前1191年-前1180年（12年） |  |\n| 24 | 商世宗 | 祖甲 | 前1180年-前1160年（20年） |  |\n| 25 | 商甲宗 | 廪（lin）辛 | 前1159年-前1156年（4年） |  |\n| 26 | 商康祖 | 庚丁 | 前1155年- 前1147年（9年） |  |\n| 27 | 商武祖 | 武乙 | 前1147年-前1113年（35年） |  |\n| 28 | 商匡王 | 文丁 | 前1112年-前1102年（11年） |  |\n| 29 | 商德王 | 帝乙 | 前1101年- 前1076年（26年） |  |\n| 30 | 商纣王 | 帝辛 | 前1075年-前1046年（30年） |  |\n\n\n# 2、贤相伊尹\n\n&emsp;&emsp;有莘氏在史书中第二次出场是夏朝末年了,当时东方的商族崛起,夏桀的统治岌岌可危。\n\n&emsp;&emsp;传说,伊尹生于伊水岸边、空桑之中,被有莘国君的厨师收养,得以学习烹饪之术,长大以后,成了烹饪小能手。可聪明的伊尹不甘于在厨房里研究美食,他从烹饪技巧中领悟出了治国之道。\n\n&emsp;&emsp;虽然有莘和夏同族,但伊尹却看透了夏桀的昏庸腐败,预测到夏必为商所取代。趁着有莘公主嫁给商汤的机会,伊尹主动报名,成为陪嫁的厨师被带到商汤面前。\n\n&emsp;&emsp;伊尹以烹调为例（治理国家就像做菜一样，讲究食材的搭配、五味的调和）,向汤说治国之道,建议他以尧舜的方法治理国家,得到了汤的认可,并拜为右相,授以国政。伊尹辅佐商汤灭夏建商,被商汤尊为“**元圣**”。\n\n&emsp;&emsp;太甲继位为王,暴虐成性,伊尹把他囚在商汤陵前的桐宫,让他反省悔过。伊尹自己代理国政,接见诸侯,并常到桐宫教育太甲。三年后,太甲悔过,返善修德,伊尹率领众大臣去桐宫迎太甲回亳都宫殿,重新授给他国政,并作了《太甲训》三篇,褒誉太甲知过迁善。太甲在位三十三年,死后被谥为太宗。太甲的儿子沃丁继位为王,伊尹退出政界,不久病逝,沃丁以天子礼葬伊尹于亳东。\n\n&emsp;&emsp;伊尹一生历事成**汤、外丙、仲壬、太甲、沃丁**五代君主“千古贤相第一人”之称。伊尹还有高超的烹调技术,同时发明了中药汤液疗法,被后世尊为烹饪和中药鼻祖。\n\n&emsp;&emsp;今山东**曹县**有处伊尹墓,这也是天下众多的伊尹墓之一,可见伊尹确实受人尊敬。明代,曹县知县范希正在伊尹墓前重修伊尹祠\n\n","slug":"商","published":1,"updated":"2023-07-31T14:32:45.134Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkqz2ipz000p6wuj2a3ibc9o","content":"<h1 id=\"1、商朝年表\"><a href=\"#1、商朝年表\" class=\"headerlink\" title=\"1、商朝年表\"></a>1、商朝年表</h1><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>姓名</th>\n<th>别名</th>\n<th>在位时长</th>\n<th>相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>商汤</td>\n<td>天乙</td>\n<td>前1600年-前1588年（13年）</td>\n<td>开国君主 鸣条之战</td>\n</tr>\n<tr>\n<td>2</td>\n<td>商哀王</td>\n<td>外丙</td>\n<td>前1587年-前1586年（2年）</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>商懿王</td>\n<td>仲壬</td>\n<td>前1585年-前1582年（4年）</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>商太宗</td>\n<td>太甲</td>\n<td>前1582年-前1570年（13年）</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>商昭王</td>\n<td>沃丁</td>\n<td>前1570年-前1541年（29年）</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>商宣王</td>\n<td>太庚</td>\n<td>前1541年-前1516年（25年）</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>商敬王</td>\n<td>小甲</td>\n<td>前1516年-前1499年（17年）</td>\n<td>商朝始衰</td>\n</tr>\n<tr>\n<td>8</td>\n<td>商元王</td>\n<td>雍己</td>\n<td>前1487年-前1476年（12年）</td>\n<td>诸侯不来朝</td>\n</tr>\n<tr>\n<td>9</td>\n<td>商中宗</td>\n<td>太戊</td>\n<td>前1486年-前1412年（75年）</td>\n<td>小国又纷纷归顺，商朝中兴</td>\n</tr>\n<tr>\n<td>10</td>\n<td>商孝成王</td>\n<td>仲丁</td>\n<td>前1418年-前1408年（13年）</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>商思王</td>\n<td>外壬</td>\n<td>前1407年-前1398年 （10年）</td>\n<td>九世之乱</td>\n</tr>\n<tr>\n<td>12</td>\n<td>商前平王</td>\n<td>河檀（dan）甲</td>\n<td>前1397年-前1389年（9年）</td>\n<td>迁都河南内黄</td>\n</tr>\n<tr>\n<td>13</td>\n<td>商穆王</td>\n<td>祖乙</td>\n<td>前1388年-前1370年（19年）</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>商桓王</td>\n<td>祖辛</td>\n<td>前1369年-前1356年（16年）</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>商僖（xi）王</td>\n<td>沃甲</td>\n<td>前1355年- 前1336年（20年）</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>商庄王</td>\n<td>祖丁</td>\n<td>前1335年- 前1327年（9年）</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>商顷王</td>\n<td>南庚</td>\n<td>前1326年-前1321年（6年）</td>\n<td>国都由庇（山东郓城）迁奄（山东曲阜）</td>\n</tr>\n<tr>\n<td>18</td>\n<td>商悼王</td>\n<td>阳甲</td>\n<td>前1321年- 前1314年（8年）</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>商世祖</td>\n<td>盘庚</td>\n<td>前1313年-前1286年（28年）</td>\n<td>迁都殷（河南安阳）</td>\n</tr>\n<tr>\n<td>20</td>\n<td>商章王</td>\n<td>小辛</td>\n<td>前1285年- 前1272年（14年）</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>商惠王</td>\n<td>小乙</td>\n<td>前1271年- 前1251年（21年）</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>商高宗</td>\n<td>武丁</td>\n<td>前1250年- 前1192年（59年）</td>\n<td>武丁中兴</td>\n</tr>\n<tr>\n<td>23</td>\n<td>商后平王</td>\n<td>祖庚</td>\n<td>前1191年-前1180年（12年）</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>商世宗</td>\n<td>祖甲</td>\n<td>前1180年-前1160年（20年）</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>商甲宗</td>\n<td>廪（lin）辛</td>\n<td>前1159年-前1156年（4年）</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>商康祖</td>\n<td>庚丁</td>\n<td>前1155年- 前1147年（9年）</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>商武祖</td>\n<td>武乙</td>\n<td>前1147年-前1113年（35年）</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>商匡王</td>\n<td>文丁</td>\n<td>前1112年-前1102年（11年）</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>商德王</td>\n<td>帝乙</td>\n<td>前1101年- 前1076年（26年）</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>商纣王</td>\n<td>帝辛</td>\n<td>前1075年-前1046年（30年）</td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"2、贤相伊尹\"><a href=\"#2、贤相伊尹\" class=\"headerlink\" title=\"2、贤相伊尹\"></a>2、贤相伊尹</h1><p>&emsp;&emsp;有莘氏在史书中第二次出场是夏朝末年了,当时东方的商族崛起,夏桀的统治岌岌可危。</p>\n<p>&emsp;&emsp;传说,伊尹生于伊水岸边、空桑之中,被有莘国君的厨师收养,得以学习烹饪之术,长大以后,成了烹饪小能手。可聪明的伊尹不甘于在厨房里研究美食,他从烹饪技巧中领悟出了治国之道。</p>\n<p>&emsp;&emsp;虽然有莘和夏同族,但伊尹却看透了夏桀的昏庸腐败,预测到夏必为商所取代。趁着有莘公主嫁给商汤的机会,伊尹主动报名,成为陪嫁的厨师被带到商汤面前。</p>\n<p>&emsp;&emsp;伊尹以烹调为例（治理国家就像做菜一样，讲究食材的搭配、五味的调和）,向汤说治国之道,建议他以尧舜的方法治理国家,得到了汤的认可,并拜为右相,授以国政。伊尹辅佐商汤灭夏建商,被商汤尊为“<strong>元圣</strong>”。</p>\n<p>&emsp;&emsp;太甲继位为王,暴虐成性,伊尹把他囚在商汤陵前的桐宫,让他反省悔过。伊尹自己代理国政,接见诸侯,并常到桐宫教育太甲。三年后,太甲悔过,返善修德,伊尹率领众大臣去桐宫迎太甲回亳都宫殿,重新授给他国政,并作了《太甲训》三篇,褒誉太甲知过迁善。太甲在位三十三年,死后被谥为太宗。太甲的儿子沃丁继位为王,伊尹退出政界,不久病逝,沃丁以天子礼葬伊尹于亳东。</p>\n<p>&emsp;&emsp;伊尹一生历事成<strong>汤、外丙、仲壬、太甲、沃丁</strong>五代君主“千古贤相第一人”之称。伊尹还有高超的烹调技术,同时发明了中药汤液疗法,被后世尊为烹饪和中药鼻祖。</p>\n<p>&emsp;&emsp;今山东<strong>曹县</strong>有处伊尹墓,这也是天下众多的伊尹墓之一,可见伊尹确实受人尊敬。明代,曹县知县范希正在伊尹墓前重修伊尹祠</p>\n","site":{"data":{}},"cover":false,"abbrlink":37674,"excerpt":"","more":"<h1 id=\"1、商朝年表\"><a href=\"#1、商朝年表\" class=\"headerlink\" title=\"1、商朝年表\"></a>1、商朝年表</h1><table>\n<thead>\n<tr>\n<th>序号</th>\n<th>姓名</th>\n<th>别名</th>\n<th>在位时长</th>\n<th>相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>商汤</td>\n<td>天乙</td>\n<td>前1600年-前1588年（13年）</td>\n<td>开国君主 鸣条之战</td>\n</tr>\n<tr>\n<td>2</td>\n<td>商哀王</td>\n<td>外丙</td>\n<td>前1587年-前1586年（2年）</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>商懿王</td>\n<td>仲壬</td>\n<td>前1585年-前1582年（4年）</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>商太宗</td>\n<td>太甲</td>\n<td>前1582年-前1570年（13年）</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>商昭王</td>\n<td>沃丁</td>\n<td>前1570年-前1541年（29年）</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>商宣王</td>\n<td>太庚</td>\n<td>前1541年-前1516年（25年）</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>商敬王</td>\n<td>小甲</td>\n<td>前1516年-前1499年（17年）</td>\n<td>商朝始衰</td>\n</tr>\n<tr>\n<td>8</td>\n<td>商元王</td>\n<td>雍己</td>\n<td>前1487年-前1476年（12年）</td>\n<td>诸侯不来朝</td>\n</tr>\n<tr>\n<td>9</td>\n<td>商中宗</td>\n<td>太戊</td>\n<td>前1486年-前1412年（75年）</td>\n<td>小国又纷纷归顺，商朝中兴</td>\n</tr>\n<tr>\n<td>10</td>\n<td>商孝成王</td>\n<td>仲丁</td>\n<td>前1418年-前1408年（13年）</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>商思王</td>\n<td>外壬</td>\n<td>前1407年-前1398年 （10年）</td>\n<td>九世之乱</td>\n</tr>\n<tr>\n<td>12</td>\n<td>商前平王</td>\n<td>河檀（dan）甲</td>\n<td>前1397年-前1389年（9年）</td>\n<td>迁都河南内黄</td>\n</tr>\n<tr>\n<td>13</td>\n<td>商穆王</td>\n<td>祖乙</td>\n<td>前1388年-前1370年（19年）</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>商桓王</td>\n<td>祖辛</td>\n<td>前1369年-前1356年（16年）</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>商僖（xi）王</td>\n<td>沃甲</td>\n<td>前1355年- 前1336年（20年）</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>商庄王</td>\n<td>祖丁</td>\n<td>前1335年- 前1327年（9年）</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>商顷王</td>\n<td>南庚</td>\n<td>前1326年-前1321年（6年）</td>\n<td>国都由庇（山东郓城）迁奄（山东曲阜）</td>\n</tr>\n<tr>\n<td>18</td>\n<td>商悼王</td>\n<td>阳甲</td>\n<td>前1321年- 前1314年（8年）</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>商世祖</td>\n<td>盘庚</td>\n<td>前1313年-前1286年（28年）</td>\n<td>迁都殷（河南安阳）</td>\n</tr>\n<tr>\n<td>20</td>\n<td>商章王</td>\n<td>小辛</td>\n<td>前1285年- 前1272年（14年）</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>商惠王</td>\n<td>小乙</td>\n<td>前1271年- 前1251年（21年）</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>商高宗</td>\n<td>武丁</td>\n<td>前1250年- 前1192年（59年）</td>\n<td>武丁中兴</td>\n</tr>\n<tr>\n<td>23</td>\n<td>商后平王</td>\n<td>祖庚</td>\n<td>前1191年-前1180年（12年）</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>商世宗</td>\n<td>祖甲</td>\n<td>前1180年-前1160年（20年）</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>商甲宗</td>\n<td>廪（lin）辛</td>\n<td>前1159年-前1156年（4年）</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>商康祖</td>\n<td>庚丁</td>\n<td>前1155年- 前1147年（9年）</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>商武祖</td>\n<td>武乙</td>\n<td>前1147年-前1113年（35年）</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>商匡王</td>\n<td>文丁</td>\n<td>前1112年-前1102年（11年）</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>商德王</td>\n<td>帝乙</td>\n<td>前1101年- 前1076年（26年）</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>商纣王</td>\n<td>帝辛</td>\n<td>前1075年-前1046年（30年）</td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"2、贤相伊尹\"><a href=\"#2、贤相伊尹\" class=\"headerlink\" title=\"2、贤相伊尹\"></a>2、贤相伊尹</h1><p>&emsp;&emsp;有莘氏在史书中第二次出场是夏朝末年了,当时东方的商族崛起,夏桀的统治岌岌可危。</p>\n<p>&emsp;&emsp;传说,伊尹生于伊水岸边、空桑之中,被有莘国君的厨师收养,得以学习烹饪之术,长大以后,成了烹饪小能手。可聪明的伊尹不甘于在厨房里研究美食,他从烹饪技巧中领悟出了治国之道。</p>\n<p>&emsp;&emsp;虽然有莘和夏同族,但伊尹却看透了夏桀的昏庸腐败,预测到夏必为商所取代。趁着有莘公主嫁给商汤的机会,伊尹主动报名,成为陪嫁的厨师被带到商汤面前。</p>\n<p>&emsp;&emsp;伊尹以烹调为例（治理国家就像做菜一样，讲究食材的搭配、五味的调和）,向汤说治国之道,建议他以尧舜的方法治理国家,得到了汤的认可,并拜为右相,授以国政。伊尹辅佐商汤灭夏建商,被商汤尊为“<strong>元圣</strong>”。</p>\n<p>&emsp;&emsp;太甲继位为王,暴虐成性,伊尹把他囚在商汤陵前的桐宫,让他反省悔过。伊尹自己代理国政,接见诸侯,并常到桐宫教育太甲。三年后,太甲悔过,返善修德,伊尹率领众大臣去桐宫迎太甲回亳都宫殿,重新授给他国政,并作了《太甲训》三篇,褒誉太甲知过迁善。太甲在位三十三年,死后被谥为太宗。太甲的儿子沃丁继位为王,伊尹退出政界,不久病逝,沃丁以天子礼葬伊尹于亳东。</p>\n<p>&emsp;&emsp;伊尹一生历事成<strong>汤、外丙、仲壬、太甲、沃丁</strong>五代君主“千古贤相第一人”之称。伊尹还有高超的烹调技术,同时发明了中药汤液疗法,被后世尊为烹饪和中药鼻祖。</p>\n<p>&emsp;&emsp;今山东<strong>曹县</strong>有处伊尹墓,这也是天下众多的伊尹墓之一,可见伊尹确实受人尊敬。明代,曹县知县范希正在伊尹墓前重修伊尹祠</p>\n"},{"title":"springCloud","date":"2023-07-28T16:00:00.000Z","abbrlink":26325,"_content":"#  1、微服务架构\n## 1.1、基本概念\n微服务是一种架构，这种架构是将单个整体应用程序分割成更小的项目关联的独立服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现，这些独立的微服务\n\n## 1.2、为什么要用微服务？\n### 1.2.1、优点\n\n1. 将服务拆分成单一职责的小服务，进行单独部署，服务之间通过网络进行通信\n2. 每个服务应该有自己的管理团队，高度自治\n3. 服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃\n\n### 1.2.2、缺点\n\n1. 开发人员需要处理分布式系统的复杂性\n2. 随着服务的增加，运维的压力也在增大\n3. 服务治理（负载均衡，服务熔断，服务配置管理）和服务监控\n\n## 1.3、架构的演变\n\n### 1.3.1、单一架构（all in one）\n一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(**ORM**)是影响项目开发的关键（mybatis，hibernate）\n\n> 缺点：随着应用功能的增多，代码量越来越大，越来越难维护\n\n\n### 1.3.2、垂直架构（vertical application）\n当访问量逐渐增大，单一应用无法满足需求，我们就需要增加节点来提供系统的访问能力，但是并不是所有的模块都需要进行性能的提高，这时候单体应用架构无法满足我们的需求；我们需要将系统里面的模块进行拆分，这样对于后面的水平扩容是非常友好的；\n![垂直架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307290956007.jpg)\n\n> 优点：系统拆分实现了流量分担，提高了系统并发量\n>    垂直架构中可以针对不同模块进行针对性优化\n>    方便水平扩展，负载均衡，系统容错率提高\n\n> 缺点：垂直架构中相同逻辑代码需要不断的复制，不能复用。每个垂直模块都相当于一个独立的系统\n\n\n### 1.3.3、分布式服务架构（distributed service）\n当垂直应用越来越多，重复的业务代码就会越来越多，并且在垂直架构中应用之间的交互不可避免，此时，为了解决基础代码重复太多、应用之间的调用等问题；我们将重复的代码抽取出来作为独立的服务，对外提供服务；\n> rpc是传输层传输协议，效率比应用层传输要高\n> dubbo采用rpc\n> springcloud采用http，属于应用层传输\n\n> 优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率\n\n> 缺点：服务越来越多，需要管理每个服务的地址，调用关系错综复杂，难以理清依赖关系，服务状态难以管理，无法根据服务情况动态管理\n\n![分布式架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291006525.jpg)\n\n### 1.3.4、SOA架构\n在分布式架构下，当服务越来越多，容量的评估，小服务资源等浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理（根据请求量动态的分配资源）。它一般使用中心化的思想实现，服务的管理和调度都由中央的服务总线（ESB）来负责\n\n### 1.3.4、微服务架构\n微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中每个服务独立，互不影响；（怎么理解粒度更细？：微服务采用去中心化的思想来治理，注册中心只是服务发现的工具，而服务之间的调用，熔断，负载均衡等都是都是由服务自己控制的）\n\n![微服务架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291013480.png)\n\n\n## 1.4、微服务架构解决方案\n\n- **国内阿里系**\n\nspringboot + dubbo + zookeeper\n\n- **spring cloud技术栈**\n\nspring cloud netflix\nspring cloud spring （spring自己封装的微服务解决方案）\nspring cloud alibaba（阿里巴巴解决方案）\n\n## 1.5、SpringCloud概念\n### 1.5.1、基本概念\nSpring Cloud是一个含概多个子项目的微服务开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.Spring Cloud在整合过程中主要是针对Netflix(耐非),alibaba开源组件的封装\n\n### 1.5.2、版本\nspringcloud版本采用伦敦地铁站命名，根据首字母顺序排序 这样设计的目的是为了更好的管理每个springcloud子项目清单，避免了总版本号与子项目版本号混淆\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291014046.png)\n\n\n### 1.5.3、组件\n|  | spring cloud官方 | spring cloud netflix | spring cloud alibaba |\n| --- | --- | --- | --- |\n| 服务注册发现 | - | Eureka | nacos |\n| 分布式配置 | spring cloud config | Archaius | nacos |\n| 服务熔断 | - | Hystrix | Sentinel |\n| 服务调用 | Open Fegin | Fegin | Dubbo RPC |\n| 服务路由 | spring cloud gateway | zuul | dubbo proxy |\n| 分布式消息 | rabbitmq | - | rocketmq |\n| 负载均衡 | - | ribbon | dubbo LB |\n| 分布式事务 | - | - | Seata |\n\n# 2、项目搭建（父工程）\n## 2.1、引入依赖\n\n```xml\n<!--springBoot父项目-->\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>2.2.5.RELEASE</version>\n</parent>\n    <dependencyManagement>\n        <dependencies>\n            <!--springBoot-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter</artifactId>\n            </dependency>\n            <!--springCloud-->\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Hoxton.SR6</version>\n                <!--maven只能有一个parent 所以这里以pom引入父项目-->\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n# 3、eureka（注册中心）\n## 3.1、基本概念\n注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。两个重要的功能：**服务注册**和**服务发现**\n\n## 3.2、常用的注册中心\n\n![常用的注册中心](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291044882.png)\n\n\n## 3.3、eureka角色\n\n- **服务注册中心（server**）：Eureka的服务端应用，提供服务注册和发现功能.\n- **服务提供者（client）**： 启动后向Eureka注册自己信息（地址，提供什么服务）\n\n> 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态\n\n- **服务消费者（client）**：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新\n\n## 3.4、eureka server开发\n搭建eureka server子项目\n### 3.4.1、引入依赖\n\n```xml\n        <!--springBoot-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--eurekaServer-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n```\n### 3.4.2、配置文件\n\n```properties\n# eureka server端口号 （默认就是8761）\nserver.port=8761\n# 指定服务名称\nspring.application.name=EUREKASERVER\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n```\n### 3.4.3、入口类加注解\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n\n```\n## 3.5、eureka client开发\n### 3.5.1、引入依赖\n\n```xml\n<dependencies>\n  <!--eureka client依赖-->\n  <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n  </dependency>\n  <!--springboot依赖-->\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n</dependencies>\n\n```\n### 3.5.2、配置文件\n\n```properties\nserver.port=8989\n# 应用名称\nspring.application.name=EUREKACLIENT\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n### 3.5.3、启动类\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class EurekaClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaClientApplication.class, args);\n    }\n}\n```\n\n## 3.6、eureka自我保护机制 \n### 3.6.1、自我保护机制\n默认情况下，如果eureka server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，eureka server将会移除掉该实例（eureka客户端每隔60秒会发送一次心跳包）\n\n但是当网络分区发生故障，微服务和eureka server之间无法通信，但是微服务本身是正常的，此时不应该移除这个服务，所以就引入了自我保护机制\n\nEureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期\n\n> 自我保护机制清除：\n> （1）心跳次数高于预期值\n> （2）自我保护机制被禁用\n\n### 3.6.2、如何关闭自我保护机制\n\n```properties\neureka:\n  server:\n    #服务端是否开启自我保护机制 （默认true）\n    enable-self-preservation: false\n    # eureka客户端每隔多长时间发一次心跳（单位毫秒，默认是60*1000）即60秒\n    eviction-interval-timer-in-ms: 60000\n```\n## 3.7、eureka server集群\n\n多个注册中心之间相互注册就可搭建eureka server集群\n\n> 服务端：eureka.client.service-url.defaultZone 配置其它的注册中心地址即可\n\n```properties\n# eureka server端口号 （默认就是8761）\nserver.port=8761\n# 指定服务名称\nspring.application.name=EUREKASERVER01\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8762/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n\n# eureka server端口号 \nserver.port=8762\n# 指定服务名称\nspring.application.name=EUREKASERVER02\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n```\n \n> 客户端：所有的注册中心地址都需要指明\n\n```properties\nserver.port=8989\n# 应用名称\nspring.application.name=EUREKACLIENT\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka\n```\n# 4、consul（注册中心）\n## 4.1、简介\nconsul是基于go语言进行开发的服务注册中心，是一个可以直接运行的注册中心工具，不需要像eureka注册中心一样再进行编码。使用起来较为简单\n\n## 4.2、安装\n\n1. 下载 [https://www.consul.io/downloads](https://www.consul.io/downloads)\n2. 解压\n3. 启动服务注册中心（cmd）\n```properties\nconsul agent -dev\n```\n\n4. 访问管理界面：[http://localhost:8500/](http://localhost:8500/)\n\n## 4.3、consul client开发\n\n1. 引入依赖\n\n```xml\n<dependencies>\n        <!--springboot依赖-->\n        <dependency>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--consul客户端组件-->\n        <dependency>\n          <groupId>org.springframework.cloud</groupId>\n          <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n          <!--健康检查依赖 actuator-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n</dependencies>\n\n```\n\n2. 编写配置文件\n\n```properties\nserver.port=8082\nspring.application.name=CONSULCLIENT\n# 向consul server服务注册地址\nspring.cloud.consul.host=localhost\nspring.cloud.consul.port=8500\n# 默认为${spring.application.name}\nspring.cloud.consul.discovery.service-name=CONSULCLIENT\n```\n\n3. 启动类添加注解\n\n```java\n@SpringBootApplication\n// 除了eureka，其它注册中心客户端都可以用该注解\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n\n```\n## 4.4、consul健康检查\n\n![image (10).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291356805.png)\n\n\n1. 默认情况下consul监控健康是开启的，但必须依赖健康监控依赖才能正常响应客户端发来的心跳，否则界面会显示错误，引入健康依赖之后服务正常\n```xml\n<!--健康检查依赖 actuator-->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n# 5、openFeign（服务间通信）\n## 5.1、基于RestTemplate实现调用\n```java\n@RestController\npublic class Client2Controller {\n    @RequestMapping(\"/test\")\n    public String test(){\n        return \"client 2 OK!\";\n    }\n}\n\n@RestController\npublic class ClientController {\n    @RequestMapping(\"/test\")\n    public String test(){\n        RestTemplate restTemplate = new RestTemplate();\n        String result = restTemplate.getForObject(\"http://localhost:8088/test\", String.class);\n        return \"调用client2成功：\"+result;\n    }\n}\n```\n\n## 5.2、基于RestTemplate+Ribbon实现负载均衡调用\nspring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现，通过spring cloud封装，可以让我们轻松的进行客户端负载均衡调用。Ribbon可从注册中心中获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例\n\n1. **编码形式**\n\n```java\n@RestController\npublic class ClientController {\n    @Autowired // 服务注册与发现客户端对象（获取服务列表后需要手动选取）\n    private DiscoveryClient discoveryClient;\n    @Autowired // 具有负载均衡的服务注册与发现客户端对象（根据负载均衡策略自动选取一个）\n    private LoadBalancerClient loadBalancerClient;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        // （1）DiscoveryClient\n        List<ServiceInstance> serviceInstances = discoveryClient.getInstances(\"CONSULCLIENT2\");\n        String result = new RestTemplate().getForObject(serviceInstances.get(0).getUri() + \"/test\", String.class);\n        // （2）LoadBalanceClient\n        ServiceInstance serviceInstances2 = loadBalancerClient.choose(\"CONSULCLIENT2\");\n        String result2 = new RestTemplate().getForObject(serviceInstances2.getUri() + \"/test\", String.class);\n        return \"调用client2成功：\" + result2;\n    }\n}\n```\n\n2. **@LoadBalance注解实现负载均衡**\n\n```java\n@Configuration\npublic class BeanConfig {\n    @Bean\n    @LoadBalanced // 使RestTemplate对象具有ribbon负载均衡特性\n    public RestTemplate restTemplate(){\n        return new RestTemplate();\n    }\n}\n\n@RestController\npublic class ClientController {\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        String result3 = restTemplate.getForObject(\"http://CONSULCLIENT2/test\", String.class);\n        return \"调用client2成功：\" + result3;\n    }\n}\n```\n\n3. **Ribbon负载均衡策略**\n\n| 策略类 | 命名 | 描述 |\n| --- | --- | --- |\n| RoundRobinRule | 轮询策略 | 轮询选择，轮询index，选择index对应位置的Server |\n| RandomRule | 随机策略 | 随机选择server |\n| BestAvailableRule | 最低并发策略 | 选择其中并发链接最低的server |\n| RetryRule | 重试策略 | 其实就是轮询策略的加强版，轮询策略服务不可用时不处理，重试策略会尝试其它节点 |\n| AvailabilityFilteringRule | 可用过滤策略 | 过滤掉一直连接失败的provider和繁忙的provider |\n| ZoneAvoidanceRule | 区域权重策略 | 如果某个ip区域内有一个或多个示例不可达或响应慢，都会降低该ip区域内其它ip被选中的权重 |\n\n4. **负载均衡策略设置**\n\n（1）局部修改\n\n```java\n# 负载均衡策略 provider为调用的服务的名称\n# 格式：服务应用名.ribbon.负载均衡策略名字\nprovider:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\n```\n（2）全局修改\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n\n    // 所有被调用服务均使用该策略\n    @Bean\n    public RandomRule randomRule(){\n        return new RandomRule();\n    }\n}\n```\n## 5.3、基于openFeign实现调用\n### 5.3.1、Feign\n\n\n> Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务\n\n### 5.3.2、openFeign\n\n> OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。\n> OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，\n> 并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务\n\n\n### 5.3.3、openFeign调用\n#### 5.3.3.1、编码\n（1）引入依赖\n\n```xml\n<!--openFeign-->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n（2）启动类开启openFeign的调用\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n```\n（3）创建业务层接口，添加@FeginClient注解声明需要调用的服务\n\n```java\n@FeignClient(\"CONSULCLIENT2\")\npublic interface Client2 {\n    @RequestMapping(\"/test\")\n    String test2();\n}\n```\n（4）调用\n\n```java\n@RestController\npublic class ClientController {\n    @Autowired\n    private Client2 client2;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        String result = client2.test2();\n        return \"调用client2成功：\" + result;\n    }\n}\n```\n#### 5.3.3.2、接口参数传递详解\n> （1）test？name=xxx&age=10  —— @RequestParam(\"name\")\n> （2）test/{id}   ——  @PathVarible(\"id\")\n> （3）test(@RequestBody User user)\n> （4）集合和数组作为参数时封装到VO对象中\n\n#### 5.3.3.3、超时处理\n\n1. 默认超时时间：1s\n2. 修改某个服务的超时时间\n\n```properties\nfeign.client.config.PRODUCTS.connecTimeOut=5000 # 配置指定服务连接超时\nfeign.client.config.PRODUCTS.readTimeOut=5000 # 配置指定服务等待超时\n```\n\n3. 修改所有服务超时时间\n\n```properties\nfeign.client.config.default.connecTimeOut=5000 # 配置服务连接超时\nfeign.client.config.default.readTimeOut=5000 # 配置服务等待超时\n```\n# 6、Hystrix（服务熔断）\n## 6.1、什么是服务雪崩？\n因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象\n\n> （1）程序bug导致服务不可用，或者运行缓慢 \n> （2）缓存击穿，导致调用全部访问某服务，导致down掉 \n> （3）访问量的突然激增\n\n## 6.2、解决服务雪崩（ 熔断 + 降级）\n\n1. **服务熔断**\n\n一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，向调用方返回一个符合预期的的备选响应，而不是长时间等待或抛出异常。所以很多地方把熔断亦称为过载保护\n\n2. **服务降级**\n\n当网站或服务流量突然增加时，为了保证系统核心服务正常运行，有策略的关闭系统中的边缘服务，以保证核心服务的正常运行\n\n3. **熔断降级的关系**\n\n熔断必会出发降级，所以熔断也是降级的一种，区别在于熔断是对调用链路的保护，降级是对系统过载的一种保护\n## 6.3、Hystrix概念\nHystrix是处理分布式系统延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时，异常等。Hystrix能够保证在一个依赖出现问题时，不会导致整体服务失败，避免雪崩效应，提高分布式系统的弹性\n\n## 6.4、编码\n\n1. 所有服务引入Hystrix依赖\n\n```xml\n<!--hystrix-->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n2. 服务提供者\n\n（直接调用服务提供者的方案，是一种服务降级的思想）\n\n```java\n\n// 开启熔断功能\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableHystrix //开启hystrix熔断功能\npublic class ConsulClient2Application {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClient2Application.class,args);\n    }\n}\n\n\n@RestController\npublic class Client2Controller {\n    @RequestMapping(\"/test2\")\n    @HystrixCommand(fallbackMethod = \"demoFallBack\",defaultFallback = \"defaultFallBack\") //熔断之后的处理\n    public String test(Integer id){\n        if (id <= 0){\n            throw new RuntimeException(\"发生异常！\");\n        }\n        return \"client 2:8088 OK!\";\n    }\n\n    public String demoFallBack(Integer id){\n        return \"服务被熔断\";\n    }\n\n    public String defaultFallBack(){\n        return \"服务被熔断(默认)\";\n    }\n}\n\n```\n\n3. 服务消费者\n\n（通过服务消费者调用的方案，服务者完全挂掉时的处理，是一种服务熔断的思想）\n```java\n# 开启openFeign支持服务降级\nfeign.hystrix.enabled=true\n\n@SpringBootApplication\n@EnableDiscoveryClient  // 开启服务注册客户端\n@EnableFeignClients  // 开启openFeign调用\n@EnableHystrix // 开启hystrix熔断功能\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n\n// fallback:指定当服务不可用时，默认的备选处理\n@FeignClient(value = \"CONSULCLIENT2\",fallback = Client2FallBack.class)\npublic interface Client2 {\n    @RequestMapping(\"/test2\")\n    String test2(@RequestParam(\"id\") Integer id);\n}\n\n// \n@Component\npublic class Client2FallBack implements Client2{\n    @Override\n    public String test2(Integer id) {\n        return \"当前服务不可达\";\n    }\n}\n\n\n@RestController\npublic class ClientController {\n    @Autowired\n    private Client2 client2;\n    @RequestMapping(\"/test\")\n    public String test(Integer id) {\n        String result = client2.test2(id);\n        return \"调用client2成功：\" + result;\n    }\n}\n```\n## 6.5、Hystrix服务熔断机制\n### 6.5.1、Hystrix断路器打开的条件\na. 当满足一定阈值的时候（默认10秒内超过20个请求次数）\nb. 当失败率达到一定的时候（默认10秒内超过50%的请求失败）\n\n> 注意：一旦断路开启之后，所有到这个服务请求均不可用，只有在断路关闭之后才可用\n\n### 6.5.2、Hystrix监控流程\n![Hystrix监控流程](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291357597.png)\n\n当服务调用达到两个阈值，会自动开启断路器，在熔断器打开期间，任何到该接口的请求均不可用，同时在断路器打开5s后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果执行成功，断路器彻底关闭，执行失败则重新打开\n\n## 6.6、Hystrix Dashboard（仪表盘）\n\n1. 基本概念\n\nHystrix Dashboard主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题\n\n2. 编码\n\n（1）新建一个 Hystrix Dashboard 工程\n（2）引入依赖\n\n```xml\n<!-- Spring Cloud Hystrix Dashboard -->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n\n```\n（3）启动类开启监控功能\n\n```java\n/** 开启 Hystrix Dashboard 监控功能 */\n@EnableHystrixDashboard\n```\n（4）访问仪表盘界面\n\n> [http://localhost:9000/hystrix](http://localhost:9000/hystrix)\n> 端口为项目的端口号\n\n# 7、zuul（网关）\nZuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。zuul 包含了对请求的**路由**和**过滤**两个最主要的功能。\n\nZuul是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能:\n\n（1）聚合接口使得服务对调用者透明，客户端与后端的耦合度降低\n（2）聚合后台服务，节省流量，提高性能，提升用户体验\n（3）提供安全、流控、过滤、缓存、计费、监控等 API 管理功能\n## 7.1、搭建环境\n创建一个应用，在启动类中添加注解@EnableZuulProxy，声明这是一个网关服务提供者\n\n## 7.2、路由规则配置\n### 7.2.1、URL地址路由\n\n```java\n# 路由规则\nzuul:\n\troutes :\n        # 路由 id 自定义\n        product-service :\n\t\t\tpath: /product-service/**配请求 ur1 的映射路径#\n    \t\turl: http://localhost:7070/ # 映射路径对应的微服务地址\n```\n通配符含义：\n\n| 通配符 | 含义 | 举例 |\n| --- | --- | --- |\n| ？ | 匹配任意单个字符 | /product-service/? |\n| * | 匹配任意数量字符不包括子路径 | /product-service/* |\n| ** | 匹配任意数量字符包括所有子路径 | /product-service/** |\n\n### 7.2.2、服务名称路由\n微服务一般是由几十、上百个服务组成，对于 URL 地址路由的方式，如果对每个服务实例手动指定一个唯一访问地址，这样做显然是不合理的。\nZuul 支持与 Eureka 整合开发，根据 serviceld 自动从注册中心获取服务地并转发清求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而目在添加或移除服务实例时不用修改 Zuul 的路由配置\n\n```java\n路由规则\nZuul\n\troutes:\n\t# 路由 id 自定义\n\t\tproduct-service:\n\t\tpath: /product-service/**#配置请 url 的映射路径\n\t\tserviceId: product-service # 根据 serviceId 自动从注册中心获取服务地址并转发请求\n```\n### 7.2.3、简化路由配置\nZuul 为了方便大家使用，提供了默认路由配置: 路由 id 和 微服务名称 一致，path 默认对应 微服务名称/* ，所以以下配置就没必要再写了。\n\n## 7.3、路由排除\n我们可以通过路由排除设置不允许被访问的资源。允许被访问的资源可以通过路由规则进行设置。\n```java\n# 路由规则\nZuul:\n\t#ignored-patterns: /**/order/** # URL 地址排除，排除所有包含 /order/ 的路径\n\tignored-services: order-service # 服务名称排除，多个服务逗号分隔，'*’排除所有\n```\n## 7.4、路由前缀\n```java\nZuul:\n\tprefix: /api\n```\n## 7.5、网关过滤器\n### 7.5.1、关键名词\n类型: 定义路由流程中应用过滤器的阶段。共 pre、routing、 post、error 4 个类型\n执行顺序: 在同类型中，定义过滤器执行的顺序。比如多个 pre 类型的执行顺序.\n条件: 执行过滤器所需的条件。true 开启，false 关闭.\n动作: 如果符合条件，将执行的动作。具体操作。\n\n### 7.5.2、过滤器类型\n **pre**: 请求被路由到源服务器之前执行的过滤器\n> 身份认证\n> 选路由\n> 请求日志\n\n**routing**: 处理将请求发送到源服务器的过滤器。 \n**post**: 响应从源服务器返回时执行的过滤器\n> 对响应增加 HTTP 头\n> 收集统计和度量指标\n> 将响应以流的方式发送回客户端\n\n**error**:上述阶段中出现错误时执行的过滤器\n\n```java\n@Component \npublic class LoginFilter extends ZuulFilter{ \n    @Override \n    public String filterType() { \n        // 登录校验，肯定是在前置拦截 \n        return \"pre\"; \n    }\n \n    @Override \n    public int filterOrder() { \n        // 顺序设置为1 \n        return 1; \n    }\n \n    @Override \n    public boolean shouldFilter() { \n        // 返回true，代表过滤器生效。 \n        return true; \n    }\n \n    @Override \n    public Object run() throws ZuulException {\n    //处理业务逻辑\n    return null;\n    }    \n}\n```\n## 7.6、网关限流\n这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的\n\n**计数器**：计算单元时间内访问接口的次数，如果达到次数，则限制访问\n\n**漏桶算法**：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃\n\n**令牌桶算法：**\n（1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理;\n（2）根据限流大小，设置按照一定的速率往桶里添加令牌;\n（3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝;\n（4）请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除:\n（5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。\n\n> 令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放回定数量的令牌\n\n### 7.6.1、网关限流\n\n1. 全局限流配置\n\n使用全局限流配置，zuul会对代理的所有服务提供限流保护\n```properties\n# 开启限流保护\nzuul.ratelimit.enabled=true\n# 60s内请求超过3次，服务端就抛出异常，60s后可以恢复正常请求\nzuul.ratelimit.default-policy.limit=3\nzuul.ratelimit.default-policy.refresh-interval=60\n# 针对IP进行限流，不影响其他IP\nzuul.ratelimit.default-policy.type=origin\n```\n\n2. 局部限流配置\n\n使用局部限流配置，zuul仅针对配置的服务提供限流保护\n```properties\n# 开启限流保护\nzuul.ratelimit.enabled=true\n# hystrix-application-client服务60s内请求超过3次，服务抛出异常。\nzuul.ratelimit.policies.hystrix-application-client.limit=3\nzuul.ratelimit.policies.hystrix-application-client.refresh-interval=60\n# 针对IP限流。\nzuul.ratelimit.policies.hystrix-application-client.type=origin\n```\n# 8、sleuth（链路追踪）\n## 8.1、链路追踪\n单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整记录下来.\n## 8.2、sleuth\nSpring Cloud sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，和其他基于日志的追踪系统，例如ELK (Elasticsearch 、 Logstash、Kibana)\nSpring cloud sleuth 提供了以下功能:\n\n- 辩路追踪: 通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。\n- 性能分析 :通过 sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。\n- 数据分析，优化链路 : 对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施.\n- 可视化错误 : 对于程序未捕获的异常，可以配合 Zipkin 查看。\n\n## 8.3、专业术语\n### 8.3.1、span\n基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父ID，以重建在一次追踪过程中不同 Span 之间的关系\n","source":"_posts/springCloud.md","raw":"---\ntitle: springCloud\ndate: 2023/07/29\ncategories:\n  - coding\ntags:\n  - springCloud\n  - 编程基础\nabbrlink: 26325\n---\n#  1、微服务架构\n## 1.1、基本概念\n微服务是一种架构，这种架构是将单个整体应用程序分割成更小的项目关联的独立服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现，这些独立的微服务\n\n## 1.2、为什么要用微服务？\n### 1.2.1、优点\n\n1. 将服务拆分成单一职责的小服务，进行单独部署，服务之间通过网络进行通信\n2. 每个服务应该有自己的管理团队，高度自治\n3. 服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃\n\n### 1.2.2、缺点\n\n1. 开发人员需要处理分布式系统的复杂性\n2. 随着服务的增加，运维的压力也在增大\n3. 服务治理（负载均衡，服务熔断，服务配置管理）和服务监控\n\n## 1.3、架构的演变\n\n### 1.3.1、单一架构（all in one）\n一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(**ORM**)是影响项目开发的关键（mybatis，hibernate）\n\n> 缺点：随着应用功能的增多，代码量越来越大，越来越难维护\n\n\n### 1.3.2、垂直架构（vertical application）\n当访问量逐渐增大，单一应用无法满足需求，我们就需要增加节点来提供系统的访问能力，但是并不是所有的模块都需要进行性能的提高，这时候单体应用架构无法满足我们的需求；我们需要将系统里面的模块进行拆分，这样对于后面的水平扩容是非常友好的；\n![垂直架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307290956007.jpg)\n\n> 优点：系统拆分实现了流量分担，提高了系统并发量\n>    垂直架构中可以针对不同模块进行针对性优化\n>    方便水平扩展，负载均衡，系统容错率提高\n\n> 缺点：垂直架构中相同逻辑代码需要不断的复制，不能复用。每个垂直模块都相当于一个独立的系统\n\n\n### 1.3.3、分布式服务架构（distributed service）\n当垂直应用越来越多，重复的业务代码就会越来越多，并且在垂直架构中应用之间的交互不可避免，此时，为了解决基础代码重复太多、应用之间的调用等问题；我们将重复的代码抽取出来作为独立的服务，对外提供服务；\n> rpc是传输层传输协议，效率比应用层传输要高\n> dubbo采用rpc\n> springcloud采用http，属于应用层传输\n\n> 优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率\n\n> 缺点：服务越来越多，需要管理每个服务的地址，调用关系错综复杂，难以理清依赖关系，服务状态难以管理，无法根据服务情况动态管理\n\n![分布式架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291006525.jpg)\n\n### 1.3.4、SOA架构\n在分布式架构下，当服务越来越多，容量的评估，小服务资源等浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理（根据请求量动态的分配资源）。它一般使用中心化的思想实现，服务的管理和调度都由中央的服务总线（ESB）来负责\n\n### 1.3.4、微服务架构\n微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中每个服务独立，互不影响；（怎么理解粒度更细？：微服务采用去中心化的思想来治理，注册中心只是服务发现的工具，而服务之间的调用，熔断，负载均衡等都是都是由服务自己控制的）\n\n![微服务架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291013480.png)\n\n\n## 1.4、微服务架构解决方案\n\n- **国内阿里系**\n\nspringboot + dubbo + zookeeper\n\n- **spring cloud技术栈**\n\nspring cloud netflix\nspring cloud spring （spring自己封装的微服务解决方案）\nspring cloud alibaba（阿里巴巴解决方案）\n\n## 1.5、SpringCloud概念\n### 1.5.1、基本概念\nSpring Cloud是一个含概多个子项目的微服务开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.Spring Cloud在整合过程中主要是针对Netflix(耐非),alibaba开源组件的封装\n\n### 1.5.2、版本\nspringcloud版本采用伦敦地铁站命名，根据首字母顺序排序 这样设计的目的是为了更好的管理每个springcloud子项目清单，避免了总版本号与子项目版本号混淆\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291014046.png)\n\n\n### 1.5.3、组件\n|  | spring cloud官方 | spring cloud netflix | spring cloud alibaba |\n| --- | --- | --- | --- |\n| 服务注册发现 | - | Eureka | nacos |\n| 分布式配置 | spring cloud config | Archaius | nacos |\n| 服务熔断 | - | Hystrix | Sentinel |\n| 服务调用 | Open Fegin | Fegin | Dubbo RPC |\n| 服务路由 | spring cloud gateway | zuul | dubbo proxy |\n| 分布式消息 | rabbitmq | - | rocketmq |\n| 负载均衡 | - | ribbon | dubbo LB |\n| 分布式事务 | - | - | Seata |\n\n# 2、项目搭建（父工程）\n## 2.1、引入依赖\n\n```xml\n<!--springBoot父项目-->\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>2.2.5.RELEASE</version>\n</parent>\n    <dependencyManagement>\n        <dependencies>\n            <!--springBoot-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter</artifactId>\n            </dependency>\n            <!--springCloud-->\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Hoxton.SR6</version>\n                <!--maven只能有一个parent 所以这里以pom引入父项目-->\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n# 3、eureka（注册中心）\n## 3.1、基本概念\n注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。两个重要的功能：**服务注册**和**服务发现**\n\n## 3.2、常用的注册中心\n\n![常用的注册中心](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291044882.png)\n\n\n## 3.3、eureka角色\n\n- **服务注册中心（server**）：Eureka的服务端应用，提供服务注册和发现功能.\n- **服务提供者（client）**： 启动后向Eureka注册自己信息（地址，提供什么服务）\n\n> 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态\n\n- **服务消费者（client）**：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新\n\n## 3.4、eureka server开发\n搭建eureka server子项目\n### 3.4.1、引入依赖\n\n```xml\n        <!--springBoot-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--eurekaServer-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n```\n### 3.4.2、配置文件\n\n```properties\n# eureka server端口号 （默认就是8761）\nserver.port=8761\n# 指定服务名称\nspring.application.name=EUREKASERVER\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n```\n### 3.4.3、入口类加注解\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n\n```\n## 3.5、eureka client开发\n### 3.5.1、引入依赖\n\n```xml\n<dependencies>\n  <!--eureka client依赖-->\n  <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n  </dependency>\n  <!--springboot依赖-->\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n</dependencies>\n\n```\n### 3.5.2、配置文件\n\n```properties\nserver.port=8989\n# 应用名称\nspring.application.name=EUREKACLIENT\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n### 3.5.3、启动类\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class EurekaClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaClientApplication.class, args);\n    }\n}\n```\n\n## 3.6、eureka自我保护机制 \n### 3.6.1、自我保护机制\n默认情况下，如果eureka server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，eureka server将会移除掉该实例（eureka客户端每隔60秒会发送一次心跳包）\n\n但是当网络分区发生故障，微服务和eureka server之间无法通信，但是微服务本身是正常的，此时不应该移除这个服务，所以就引入了自我保护机制\n\nEureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期\n\n> 自我保护机制清除：\n> （1）心跳次数高于预期值\n> （2）自我保护机制被禁用\n\n### 3.6.2、如何关闭自我保护机制\n\n```properties\neureka:\n  server:\n    #服务端是否开启自我保护机制 （默认true）\n    enable-self-preservation: false\n    # eureka客户端每隔多长时间发一次心跳（单位毫秒，默认是60*1000）即60秒\n    eviction-interval-timer-in-ms: 60000\n```\n## 3.7、eureka server集群\n\n多个注册中心之间相互注册就可搭建eureka server集群\n\n> 服务端：eureka.client.service-url.defaultZone 配置其它的注册中心地址即可\n\n```properties\n# eureka server端口号 （默认就是8761）\nserver.port=8761\n# 指定服务名称\nspring.application.name=EUREKASERVER01\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8762/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n\n# eureka server端口号 \nserver.port=8762\n# 指定服务名称\nspring.application.name=EUREKASERVER02\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n```\n \n> 客户端：所有的注册中心地址都需要指明\n\n```properties\nserver.port=8989\n# 应用名称\nspring.application.name=EUREKACLIENT\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka\n```\n# 4、consul（注册中心）\n## 4.1、简介\nconsul是基于go语言进行开发的服务注册中心，是一个可以直接运行的注册中心工具，不需要像eureka注册中心一样再进行编码。使用起来较为简单\n\n## 4.2、安装\n\n1. 下载 [https://www.consul.io/downloads](https://www.consul.io/downloads)\n2. 解压\n3. 启动服务注册中心（cmd）\n```properties\nconsul agent -dev\n```\n\n4. 访问管理界面：[http://localhost:8500/](http://localhost:8500/)\n\n## 4.3、consul client开发\n\n1. 引入依赖\n\n```xml\n<dependencies>\n        <!--springboot依赖-->\n        <dependency>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--consul客户端组件-->\n        <dependency>\n          <groupId>org.springframework.cloud</groupId>\n          <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n          <!--健康检查依赖 actuator-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n</dependencies>\n\n```\n\n2. 编写配置文件\n\n```properties\nserver.port=8082\nspring.application.name=CONSULCLIENT\n# 向consul server服务注册地址\nspring.cloud.consul.host=localhost\nspring.cloud.consul.port=8500\n# 默认为${spring.application.name}\nspring.cloud.consul.discovery.service-name=CONSULCLIENT\n```\n\n3. 启动类添加注解\n\n```java\n@SpringBootApplication\n// 除了eureka，其它注册中心客户端都可以用该注解\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n\n```\n## 4.4、consul健康检查\n\n![image (10).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291356805.png)\n\n\n1. 默认情况下consul监控健康是开启的，但必须依赖健康监控依赖才能正常响应客户端发来的心跳，否则界面会显示错误，引入健康依赖之后服务正常\n```xml\n<!--健康检查依赖 actuator-->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n# 5、openFeign（服务间通信）\n## 5.1、基于RestTemplate实现调用\n```java\n@RestController\npublic class Client2Controller {\n    @RequestMapping(\"/test\")\n    public String test(){\n        return \"client 2 OK!\";\n    }\n}\n\n@RestController\npublic class ClientController {\n    @RequestMapping(\"/test\")\n    public String test(){\n        RestTemplate restTemplate = new RestTemplate();\n        String result = restTemplate.getForObject(\"http://localhost:8088/test\", String.class);\n        return \"调用client2成功：\"+result;\n    }\n}\n```\n\n## 5.2、基于RestTemplate+Ribbon实现负载均衡调用\nspring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现，通过spring cloud封装，可以让我们轻松的进行客户端负载均衡调用。Ribbon可从注册中心中获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例\n\n1. **编码形式**\n\n```java\n@RestController\npublic class ClientController {\n    @Autowired // 服务注册与发现客户端对象（获取服务列表后需要手动选取）\n    private DiscoveryClient discoveryClient;\n    @Autowired // 具有负载均衡的服务注册与发现客户端对象（根据负载均衡策略自动选取一个）\n    private LoadBalancerClient loadBalancerClient;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        // （1）DiscoveryClient\n        List<ServiceInstance> serviceInstances = discoveryClient.getInstances(\"CONSULCLIENT2\");\n        String result = new RestTemplate().getForObject(serviceInstances.get(0).getUri() + \"/test\", String.class);\n        // （2）LoadBalanceClient\n        ServiceInstance serviceInstances2 = loadBalancerClient.choose(\"CONSULCLIENT2\");\n        String result2 = new RestTemplate().getForObject(serviceInstances2.getUri() + \"/test\", String.class);\n        return \"调用client2成功：\" + result2;\n    }\n}\n```\n\n2. **@LoadBalance注解实现负载均衡**\n\n```java\n@Configuration\npublic class BeanConfig {\n    @Bean\n    @LoadBalanced // 使RestTemplate对象具有ribbon负载均衡特性\n    public RestTemplate restTemplate(){\n        return new RestTemplate();\n    }\n}\n\n@RestController\npublic class ClientController {\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        String result3 = restTemplate.getForObject(\"http://CONSULCLIENT2/test\", String.class);\n        return \"调用client2成功：\" + result3;\n    }\n}\n```\n\n3. **Ribbon负载均衡策略**\n\n| 策略类 | 命名 | 描述 |\n| --- | --- | --- |\n| RoundRobinRule | 轮询策略 | 轮询选择，轮询index，选择index对应位置的Server |\n| RandomRule | 随机策略 | 随机选择server |\n| BestAvailableRule | 最低并发策略 | 选择其中并发链接最低的server |\n| RetryRule | 重试策略 | 其实就是轮询策略的加强版，轮询策略服务不可用时不处理，重试策略会尝试其它节点 |\n| AvailabilityFilteringRule | 可用过滤策略 | 过滤掉一直连接失败的provider和繁忙的provider |\n| ZoneAvoidanceRule | 区域权重策略 | 如果某个ip区域内有一个或多个示例不可达或响应慢，都会降低该ip区域内其它ip被选中的权重 |\n\n4. **负载均衡策略设置**\n\n（1）局部修改\n\n```java\n# 负载均衡策略 provider为调用的服务的名称\n# 格式：服务应用名.ribbon.负载均衡策略名字\nprovider:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\n```\n（2）全局修改\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n\n    // 所有被调用服务均使用该策略\n    @Bean\n    public RandomRule randomRule(){\n        return new RandomRule();\n    }\n}\n```\n## 5.3、基于openFeign实现调用\n### 5.3.1、Feign\n\n\n> Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务\n\n### 5.3.2、openFeign\n\n> OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。\n> OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，\n> 并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务\n\n\n### 5.3.3、openFeign调用\n#### 5.3.3.1、编码\n（1）引入依赖\n\n```xml\n<!--openFeign-->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n（2）启动类开启openFeign的调用\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n```\n（3）创建业务层接口，添加@FeginClient注解声明需要调用的服务\n\n```java\n@FeignClient(\"CONSULCLIENT2\")\npublic interface Client2 {\n    @RequestMapping(\"/test\")\n    String test2();\n}\n```\n（4）调用\n\n```java\n@RestController\npublic class ClientController {\n    @Autowired\n    private Client2 client2;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        String result = client2.test2();\n        return \"调用client2成功：\" + result;\n    }\n}\n```\n#### 5.3.3.2、接口参数传递详解\n> （1）test？name=xxx&age=10  —— @RequestParam(\"name\")\n> （2）test/{id}   ——  @PathVarible(\"id\")\n> （3）test(@RequestBody User user)\n> （4）集合和数组作为参数时封装到VO对象中\n\n#### 5.3.3.3、超时处理\n\n1. 默认超时时间：1s\n2. 修改某个服务的超时时间\n\n```properties\nfeign.client.config.PRODUCTS.connecTimeOut=5000 # 配置指定服务连接超时\nfeign.client.config.PRODUCTS.readTimeOut=5000 # 配置指定服务等待超时\n```\n\n3. 修改所有服务超时时间\n\n```properties\nfeign.client.config.default.connecTimeOut=5000 # 配置服务连接超时\nfeign.client.config.default.readTimeOut=5000 # 配置服务等待超时\n```\n# 6、Hystrix（服务熔断）\n## 6.1、什么是服务雪崩？\n因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象\n\n> （1）程序bug导致服务不可用，或者运行缓慢 \n> （2）缓存击穿，导致调用全部访问某服务，导致down掉 \n> （3）访问量的突然激增\n\n## 6.2、解决服务雪崩（ 熔断 + 降级）\n\n1. **服务熔断**\n\n一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，向调用方返回一个符合预期的的备选响应，而不是长时间等待或抛出异常。所以很多地方把熔断亦称为过载保护\n\n2. **服务降级**\n\n当网站或服务流量突然增加时，为了保证系统核心服务正常运行，有策略的关闭系统中的边缘服务，以保证核心服务的正常运行\n\n3. **熔断降级的关系**\n\n熔断必会出发降级，所以熔断也是降级的一种，区别在于熔断是对调用链路的保护，降级是对系统过载的一种保护\n## 6.3、Hystrix概念\nHystrix是处理分布式系统延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时，异常等。Hystrix能够保证在一个依赖出现问题时，不会导致整体服务失败，避免雪崩效应，提高分布式系统的弹性\n\n## 6.4、编码\n\n1. 所有服务引入Hystrix依赖\n\n```xml\n<!--hystrix-->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n2. 服务提供者\n\n（直接调用服务提供者的方案，是一种服务降级的思想）\n\n```java\n\n// 开启熔断功能\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableHystrix //开启hystrix熔断功能\npublic class ConsulClient2Application {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClient2Application.class,args);\n    }\n}\n\n\n@RestController\npublic class Client2Controller {\n    @RequestMapping(\"/test2\")\n    @HystrixCommand(fallbackMethod = \"demoFallBack\",defaultFallback = \"defaultFallBack\") //熔断之后的处理\n    public String test(Integer id){\n        if (id <= 0){\n            throw new RuntimeException(\"发生异常！\");\n        }\n        return \"client 2:8088 OK!\";\n    }\n\n    public String demoFallBack(Integer id){\n        return \"服务被熔断\";\n    }\n\n    public String defaultFallBack(){\n        return \"服务被熔断(默认)\";\n    }\n}\n\n```\n\n3. 服务消费者\n\n（通过服务消费者调用的方案，服务者完全挂掉时的处理，是一种服务熔断的思想）\n```java\n# 开启openFeign支持服务降级\nfeign.hystrix.enabled=true\n\n@SpringBootApplication\n@EnableDiscoveryClient  // 开启服务注册客户端\n@EnableFeignClients  // 开启openFeign调用\n@EnableHystrix // 开启hystrix熔断功能\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n\n// fallback:指定当服务不可用时，默认的备选处理\n@FeignClient(value = \"CONSULCLIENT2\",fallback = Client2FallBack.class)\npublic interface Client2 {\n    @RequestMapping(\"/test2\")\n    String test2(@RequestParam(\"id\") Integer id);\n}\n\n// \n@Component\npublic class Client2FallBack implements Client2{\n    @Override\n    public String test2(Integer id) {\n        return \"当前服务不可达\";\n    }\n}\n\n\n@RestController\npublic class ClientController {\n    @Autowired\n    private Client2 client2;\n    @RequestMapping(\"/test\")\n    public String test(Integer id) {\n        String result = client2.test2(id);\n        return \"调用client2成功：\" + result;\n    }\n}\n```\n## 6.5、Hystrix服务熔断机制\n### 6.5.1、Hystrix断路器打开的条件\na. 当满足一定阈值的时候（默认10秒内超过20个请求次数）\nb. 当失败率达到一定的时候（默认10秒内超过50%的请求失败）\n\n> 注意：一旦断路开启之后，所有到这个服务请求均不可用，只有在断路关闭之后才可用\n\n### 6.5.2、Hystrix监控流程\n![Hystrix监控流程](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291357597.png)\n\n当服务调用达到两个阈值，会自动开启断路器，在熔断器打开期间，任何到该接口的请求均不可用，同时在断路器打开5s后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果执行成功，断路器彻底关闭，执行失败则重新打开\n\n## 6.6、Hystrix Dashboard（仪表盘）\n\n1. 基本概念\n\nHystrix Dashboard主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题\n\n2. 编码\n\n（1）新建一个 Hystrix Dashboard 工程\n（2）引入依赖\n\n```xml\n<!-- Spring Cloud Hystrix Dashboard -->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n\n```\n（3）启动类开启监控功能\n\n```java\n/** 开启 Hystrix Dashboard 监控功能 */\n@EnableHystrixDashboard\n```\n（4）访问仪表盘界面\n\n> [http://localhost:9000/hystrix](http://localhost:9000/hystrix)\n> 端口为项目的端口号\n\n# 7、zuul（网关）\nZuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。zuul 包含了对请求的**路由**和**过滤**两个最主要的功能。\n\nZuul是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能:\n\n（1）聚合接口使得服务对调用者透明，客户端与后端的耦合度降低\n（2）聚合后台服务，节省流量，提高性能，提升用户体验\n（3）提供安全、流控、过滤、缓存、计费、监控等 API 管理功能\n## 7.1、搭建环境\n创建一个应用，在启动类中添加注解@EnableZuulProxy，声明这是一个网关服务提供者\n\n## 7.2、路由规则配置\n### 7.2.1、URL地址路由\n\n```java\n# 路由规则\nzuul:\n\troutes :\n        # 路由 id 自定义\n        product-service :\n\t\t\tpath: /product-service/**配请求 ur1 的映射路径#\n    \t\turl: http://localhost:7070/ # 映射路径对应的微服务地址\n```\n通配符含义：\n\n| 通配符 | 含义 | 举例 |\n| --- | --- | --- |\n| ？ | 匹配任意单个字符 | /product-service/? |\n| * | 匹配任意数量字符不包括子路径 | /product-service/* |\n| ** | 匹配任意数量字符包括所有子路径 | /product-service/** |\n\n### 7.2.2、服务名称路由\n微服务一般是由几十、上百个服务组成，对于 URL 地址路由的方式，如果对每个服务实例手动指定一个唯一访问地址，这样做显然是不合理的。\nZuul 支持与 Eureka 整合开发，根据 serviceld 自动从注册中心获取服务地并转发清求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而目在添加或移除服务实例时不用修改 Zuul 的路由配置\n\n```java\n路由规则\nZuul\n\troutes:\n\t# 路由 id 自定义\n\t\tproduct-service:\n\t\tpath: /product-service/**#配置请 url 的映射路径\n\t\tserviceId: product-service # 根据 serviceId 自动从注册中心获取服务地址并转发请求\n```\n### 7.2.3、简化路由配置\nZuul 为了方便大家使用，提供了默认路由配置: 路由 id 和 微服务名称 一致，path 默认对应 微服务名称/* ，所以以下配置就没必要再写了。\n\n## 7.3、路由排除\n我们可以通过路由排除设置不允许被访问的资源。允许被访问的资源可以通过路由规则进行设置。\n```java\n# 路由规则\nZuul:\n\t#ignored-patterns: /**/order/** # URL 地址排除，排除所有包含 /order/ 的路径\n\tignored-services: order-service # 服务名称排除，多个服务逗号分隔，'*’排除所有\n```\n## 7.4、路由前缀\n```java\nZuul:\n\tprefix: /api\n```\n## 7.5、网关过滤器\n### 7.5.1、关键名词\n类型: 定义路由流程中应用过滤器的阶段。共 pre、routing、 post、error 4 个类型\n执行顺序: 在同类型中，定义过滤器执行的顺序。比如多个 pre 类型的执行顺序.\n条件: 执行过滤器所需的条件。true 开启，false 关闭.\n动作: 如果符合条件，将执行的动作。具体操作。\n\n### 7.5.2、过滤器类型\n **pre**: 请求被路由到源服务器之前执行的过滤器\n> 身份认证\n> 选路由\n> 请求日志\n\n**routing**: 处理将请求发送到源服务器的过滤器。 \n**post**: 响应从源服务器返回时执行的过滤器\n> 对响应增加 HTTP 头\n> 收集统计和度量指标\n> 将响应以流的方式发送回客户端\n\n**error**:上述阶段中出现错误时执行的过滤器\n\n```java\n@Component \npublic class LoginFilter extends ZuulFilter{ \n    @Override \n    public String filterType() { \n        // 登录校验，肯定是在前置拦截 \n        return \"pre\"; \n    }\n \n    @Override \n    public int filterOrder() { \n        // 顺序设置为1 \n        return 1; \n    }\n \n    @Override \n    public boolean shouldFilter() { \n        // 返回true，代表过滤器生效。 \n        return true; \n    }\n \n    @Override \n    public Object run() throws ZuulException {\n    //处理业务逻辑\n    return null;\n    }    \n}\n```\n## 7.6、网关限流\n这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的\n\n**计数器**：计算单元时间内访问接口的次数，如果达到次数，则限制访问\n\n**漏桶算法**：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃\n\n**令牌桶算法：**\n（1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理;\n（2）根据限流大小，设置按照一定的速率往桶里添加令牌;\n（3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝;\n（4）请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除:\n（5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。\n\n> 令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放回定数量的令牌\n\n### 7.6.1、网关限流\n\n1. 全局限流配置\n\n使用全局限流配置，zuul会对代理的所有服务提供限流保护\n```properties\n# 开启限流保护\nzuul.ratelimit.enabled=true\n# 60s内请求超过3次，服务端就抛出异常，60s后可以恢复正常请求\nzuul.ratelimit.default-policy.limit=3\nzuul.ratelimit.default-policy.refresh-interval=60\n# 针对IP进行限流，不影响其他IP\nzuul.ratelimit.default-policy.type=origin\n```\n\n2. 局部限流配置\n\n使用局部限流配置，zuul仅针对配置的服务提供限流保护\n```properties\n# 开启限流保护\nzuul.ratelimit.enabled=true\n# hystrix-application-client服务60s内请求超过3次，服务抛出异常。\nzuul.ratelimit.policies.hystrix-application-client.limit=3\nzuul.ratelimit.policies.hystrix-application-client.refresh-interval=60\n# 针对IP限流。\nzuul.ratelimit.policies.hystrix-application-client.type=origin\n```\n# 8、sleuth（链路追踪）\n## 8.1、链路追踪\n单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整记录下来.\n## 8.2、sleuth\nSpring Cloud sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，和其他基于日志的追踪系统，例如ELK (Elasticsearch 、 Logstash、Kibana)\nSpring cloud sleuth 提供了以下功能:\n\n- 辩路追踪: 通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。\n- 性能分析 :通过 sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。\n- 数据分析，优化链路 : 对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施.\n- 可视化错误 : 对于程序未捕获的异常，可以配合 Zipkin 查看。\n\n## 8.3、专业术语\n### 8.3.1、span\n基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父ID，以重建在一次追踪过程中不同 Span 之间的关系\n","slug":"springCloud","published":1,"updated":"2023-07-29T06:09:16.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkqz2iq0000s6wujf05mfl1a","content":"<h1 id=\"1、微服务架构\"><a href=\"#1、微服务架构\" class=\"headerlink\" title=\"1、微服务架构\"></a>1、微服务架构</h1><h2 id=\"1-1、基本概念\"><a href=\"#1-1、基本概念\" class=\"headerlink\" title=\"1.1、基本概念\"></a>1.1、基本概念</h2><p>微服务是一种架构，这种架构是将单个整体应用程序分割成更小的项目关联的独立服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现，这些独立的微服务</p>\n<h2 id=\"1-2、为什么要用微服务？\"><a href=\"#1-2、为什么要用微服务？\" class=\"headerlink\" title=\"1.2、为什么要用微服务？\"></a>1.2、为什么要用微服务？</h2><h3 id=\"1-2-1、优点\"><a href=\"#1-2-1、优点\" class=\"headerlink\" title=\"1.2.1、优点\"></a>1.2.1、优点</h3><ol>\n<li>将服务拆分成单一职责的小服务，进行单独部署，服务之间通过网络进行通信</li>\n<li>每个服务应该有自己的管理团队，高度自治</li>\n<li>服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃</li>\n</ol>\n<h3 id=\"1-2-2、缺点\"><a href=\"#1-2-2、缺点\" class=\"headerlink\" title=\"1.2.2、缺点\"></a>1.2.2、缺点</h3><ol>\n<li>开发人员需要处理分布式系统的复杂性</li>\n<li>随着服务的增加，运维的压力也在增大</li>\n<li>服务治理（负载均衡，服务熔断，服务配置管理）和服务监控</li>\n</ol>\n<h2 id=\"1-3、架构的演变\"><a href=\"#1-3、架构的演变\" class=\"headerlink\" title=\"1.3、架构的演变\"></a>1.3、架构的演变</h2><h3 id=\"1-3-1、单一架构（all-in-one）\"><a href=\"#1-3-1、单一架构（all-in-one）\" class=\"headerlink\" title=\"1.3.1、单一架构（all in one）\"></a>1.3.1、单一架构（all in one）</h3><p>一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(<strong>ORM</strong>)是影响项目开发的关键（mybatis，hibernate）</p>\n<blockquote>\n<p>缺点：随着应用功能的增多，代码量越来越大，越来越难维护</p>\n</blockquote>\n<h3 id=\"1-3-2、垂直架构（vertical-application）\"><a href=\"#1-3-2、垂直架构（vertical-application）\" class=\"headerlink\" title=\"1.3.2、垂直架构（vertical application）\"></a>1.3.2、垂直架构（vertical application）</h3><p>当访问量逐渐增大，单一应用无法满足需求，我们就需要增加节点来提供系统的访问能力，但是并不是所有的模块都需要进行性能的提高，这时候单体应用架构无法满足我们的需求；我们需要将系统里面的模块进行拆分，这样对于后面的水平扩容是非常友好的；<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307290956007.jpg\" alt=\"垂直架构\"></p>\n<blockquote>\n<p>优点：系统拆分实现了流量分担，提高了系统并发量<br>   垂直架构中可以针对不同模块进行针对性优化<br>   方便水平扩展，负载均衡，系统容错率提高</p>\n</blockquote>\n<blockquote>\n<p>缺点：垂直架构中相同逻辑代码需要不断的复制，不能复用。每个垂直模块都相当于一个独立的系统</p>\n</blockquote>\n<h3 id=\"1-3-3、分布式服务架构（distributed-service）\"><a href=\"#1-3-3、分布式服务架构（distributed-service）\" class=\"headerlink\" title=\"1.3.3、分布式服务架构（distributed service）\"></a>1.3.3、分布式服务架构（distributed service）</h3><p>当垂直应用越来越多，重复的业务代码就会越来越多，并且在垂直架构中应用之间的交互不可避免，此时，为了解决基础代码重复太多、应用之间的调用等问题；我们将重复的代码抽取出来作为独立的服务，对外提供服务；</p>\n<blockquote>\n<p>rpc是传输层传输协议，效率比应用层传输要高<br>dubbo采用rpc<br>springcloud采用http，属于应用层传输</p>\n</blockquote>\n<blockquote>\n<p>优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</p>\n</blockquote>\n<blockquote>\n<p>缺点：服务越来越多，需要管理每个服务的地址，调用关系错综复杂，难以理清依赖关系，服务状态难以管理，无法根据服务情况动态管理</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291006525.jpg\" alt=\"分布式架构\"></p>\n<h3 id=\"1-3-4、SOA架构\"><a href=\"#1-3-4、SOA架构\" class=\"headerlink\" title=\"1.3.4、SOA架构\"></a>1.3.4、SOA架构</h3><p>在分布式架构下，当服务越来越多，容量的评估，小服务资源等浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理（根据请求量动态的分配资源）。它一般使用中心化的思想实现，服务的管理和调度都由中央的服务总线（ESB）来负责</p>\n<h3 id=\"1-3-4、微服务架构\"><a href=\"#1-3-4、微服务架构\" class=\"headerlink\" title=\"1.3.4、微服务架构\"></a>1.3.4、微服务架构</h3><p>微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中每个服务独立，互不影响；（怎么理解粒度更细？：微服务采用去中心化的思想来治理，注册中心只是服务发现的工具，而服务之间的调用，熔断，负载均衡等都是都是由服务自己控制的）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291013480.png\" alt=\"微服务架构\"></p>\n<h2 id=\"1-4、微服务架构解决方案\"><a href=\"#1-4、微服务架构解决方案\" class=\"headerlink\" title=\"1.4、微服务架构解决方案\"></a>1.4、微服务架构解决方案</h2><ul>\n<li><strong>国内阿里系</strong></li>\n</ul>\n<p>springboot + dubbo + zookeeper</p>\n<ul>\n<li><strong>spring cloud技术栈</strong></li>\n</ul>\n<p>spring cloud netflix<br>spring cloud spring （spring自己封装的微服务解决方案）<br>spring cloud alibaba（阿里巴巴解决方案）</p>\n<h2 id=\"1-5、SpringCloud概念\"><a href=\"#1-5、SpringCloud概念\" class=\"headerlink\" title=\"1.5、SpringCloud概念\"></a>1.5、SpringCloud概念</h2><h3 id=\"1-5-1、基本概念\"><a href=\"#1-5-1、基本概念\" class=\"headerlink\" title=\"1.5.1、基本概念\"></a>1.5.1、基本概念</h3><p>Spring Cloud是一个含概多个子项目的微服务开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.Spring Cloud在整合过程中主要是针对Netflix(耐非),alibaba开源组件的封装</p>\n<h3 id=\"1-5-2、版本\"><a href=\"#1-5-2、版本\" class=\"headerlink\" title=\"1.5.2、版本\"></a>1.5.2、版本</h3><p>springcloud版本采用伦敦地铁站命名，根据首字母顺序排序 这样设计的目的是为了更好的管理每个springcloud子项目清单，避免了总版本号与子项目版本号混淆</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291014046.png\" alt=\"image.png\"></p>\n<h3 id=\"1-5-3、组件\"><a href=\"#1-5-3、组件\" class=\"headerlink\" title=\"1.5.3、组件\"></a>1.5.3、组件</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>spring cloud官方</th>\n<th>spring cloud netflix</th>\n<th>spring cloud alibaba</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务注册发现</td>\n<td>-</td>\n<td>Eureka</td>\n<td>nacos</td>\n</tr>\n<tr>\n<td>分布式配置</td>\n<td>spring cloud config</td>\n<td>Archaius</td>\n<td>nacos</td>\n</tr>\n<tr>\n<td>服务熔断</td>\n<td>-</td>\n<td>Hystrix</td>\n<td>Sentinel</td>\n</tr>\n<tr>\n<td>服务调用</td>\n<td>Open Fegin</td>\n<td>Fegin</td>\n<td>Dubbo RPC</td>\n</tr>\n<tr>\n<td>服务路由</td>\n<td>spring cloud gateway</td>\n<td>zuul</td>\n<td>dubbo proxy</td>\n</tr>\n<tr>\n<td>分布式消息</td>\n<td>rabbitmq</td>\n<td>-</td>\n<td>rocketmq</td>\n</tr>\n<tr>\n<td>负载均衡</td>\n<td>-</td>\n<td>ribbon</td>\n<td>dubbo LB</td>\n</tr>\n<tr>\n<td>分布式事务</td>\n<td>-</td>\n<td>-</td>\n<td>Seata</td>\n</tr>\n</tbody></table>\n<h1 id=\"2、项目搭建（父工程）\"><a href=\"#2、项目搭建（父工程）\" class=\"headerlink\" title=\"2、项目搭建（父工程）\"></a>2、项目搭建（父工程）</h1><h2 id=\"2-1、引入依赖\"><a href=\"#2-1、引入依赖\" class=\"headerlink\" title=\"2.1、引入依赖\"></a>2.1、引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--springBoot父项目--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.5.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--springBoot--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--springCloud--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>Hoxton.SR6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--maven只能有一个parent 所以这里以pom引入父项目--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3、eureka（注册中心）\"><a href=\"#3、eureka（注册中心）\" class=\"headerlink\" title=\"3、eureka（注册中心）\"></a>3、eureka（注册中心）</h1><h2 id=\"3-1、基本概念\"><a href=\"#3-1、基本概念\" class=\"headerlink\" title=\"3.1、基本概念\"></a>3.1、基本概念</h2><p>注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。两个重要的功能：<strong>服务注册</strong>和<strong>服务发现</strong></p>\n<h2 id=\"3-2、常用的注册中心\"><a href=\"#3-2、常用的注册中心\" class=\"headerlink\" title=\"3.2、常用的注册中心\"></a>3.2、常用的注册中心</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291044882.png\" alt=\"常用的注册中心\"></p>\n<h2 id=\"3-3、eureka角色\"><a href=\"#3-3、eureka角色\" class=\"headerlink\" title=\"3.3、eureka角色\"></a>3.3、eureka角色</h2><ul>\n<li><strong>服务注册中心（server</strong>）：Eureka的服务端应用，提供服务注册和发现功能.</li>\n<li><strong>服务提供者（client）</strong>： 启动后向Eureka注册自己信息（地址，提供什么服务）</li>\n</ul>\n<blockquote>\n<p>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</p>\n</blockquote>\n<ul>\n<li><strong>服务消费者（client）</strong>：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li>\n</ul>\n<h2 id=\"3-4、eureka-server开发\"><a href=\"#3-4、eureka-server开发\" class=\"headerlink\" title=\"3.4、eureka server开发\"></a>3.4、eureka server开发</h2><p>搭建eureka server子项目</p>\n<h3 id=\"3-4-1、引入依赖\"><a href=\"#3-4-1、引入依赖\" class=\"headerlink\" title=\"3.4.1、引入依赖\"></a>3.4.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--springBoot--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--eurekaServer--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-2、配置文件\"><a href=\"#3-4-2、配置文件\" class=\"headerlink\" title=\"3.4.2、配置文件\"></a>3.4.2、配置文件</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># eureka server端口号 （默认就是8761）</span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8761</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-3、入口类加注解\"><a href=\"#3-4-3、入口类加注解\" class=\"headerlink\" title=\"3.4.3、入口类加注解\"></a>3.4.3、入口类加注解</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableEurekaServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EurekaServerApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-5、eureka-client开发\"><a href=\"#3-5、eureka-client开发\" class=\"headerlink\" title=\"3.5、eureka client开发\"></a>3.5、eureka client开发</h2><h3 id=\"3-5-1、引入依赖\"><a href=\"#3-5-1、引入依赖\" class=\"headerlink\" title=\"3.5.1、引入依赖\"></a>3.5.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--eureka client依赖--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--springboot依赖--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-2、配置文件\"><a href=\"#3-5-2、配置文件\" class=\"headerlink\" title=\"3.5.2、配置文件\"></a>3.5.2、配置文件</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8989</span></span><br><span class=\"line\"><span class=\"comment\"># 应用名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKACLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-3、启动类\"><a href=\"#3-5-3、启动类\" class=\"headerlink\" title=\"3.5.3、启动类\"></a>3.5.3、启动类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableEurekaClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EurekaClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6、eureka自我保护机制\"><a href=\"#3-6、eureka自我保护机制\" class=\"headerlink\" title=\"3.6、eureka自我保护机制\"></a>3.6、eureka自我保护机制</h2><h3 id=\"3-6-1、自我保护机制\"><a href=\"#3-6-1、自我保护机制\" class=\"headerlink\" title=\"3.6.1、自我保护机制\"></a>3.6.1、自我保护机制</h3><p>默认情况下，如果eureka server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，eureka server将会移除掉该实例（eureka客户端每隔60秒会发送一次心跳包）</p>\n<p>但是当网络分区发生故障，微服务和eureka server之间无法通信，但是微服务本身是正常的，此时不应该移除这个服务，所以就引入了自我保护机制</p>\n<p>Eureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期</p>\n<blockquote>\n<p>自我保护机制清除：<br>（1）心跳次数高于预期值<br>（2）自我保护机制被禁用</p>\n</blockquote>\n<h3 id=\"3-6-2、如何关闭自我保护机制\"><a href=\"#3-6-2、如何关闭自我保护机制\" class=\"headerlink\" title=\"3.6.2、如何关闭自我保护机制\"></a>3.6.2、如何关闭自我保护机制</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">eureka</span>:<span class=\"string\"></span></span><br><span class=\"line\">  <span class=\"attr\">server</span>:<span class=\"string\"></span></span><br><span class=\"line\"><span class=\"comment\">    #服务端是否开启自我保护机制 （默认true）</span></span><br><span class=\"line\">    <span class=\"attr\">enable-self-preservation</span>: <span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\">    # eureka客户端每隔多长时间发一次心跳（单位毫秒，默认是60*1000）即60秒</span></span><br><span class=\"line\">    <span class=\"attr\">eviction-interval-timer-in-ms</span>: <span class=\"string\">60000</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、eureka-server集群\"><a href=\"#3-7、eureka-server集群\" class=\"headerlink\" title=\"3.7、eureka server集群\"></a>3.7、eureka server集群</h2><p>多个注册中心之间相互注册就可搭建eureka server集群</p>\n<blockquote>\n<p>服务端：eureka.client.service-url.defaultZone 配置其它的注册中心地址即可</p>\n</blockquote>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># eureka server端口号 （默认就是8761）</span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8761</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER01</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8762/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"># eureka server端口号 </span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8762</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER02</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>客户端：所有的注册中心地址都需要指明</p>\n</blockquote>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8989</span></span><br><span class=\"line\"><span class=\"comment\"># 应用名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKACLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka,http://localhost:8762/eureka</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"4、consul（注册中心）\"><a href=\"#4、consul（注册中心）\" class=\"headerlink\" title=\"4、consul（注册中心）\"></a>4、consul（注册中心）</h1><h2 id=\"4-1、简介\"><a href=\"#4-1、简介\" class=\"headerlink\" title=\"4.1、简介\"></a>4.1、简介</h2><p>consul是基于go语言进行开发的服务注册中心，是一个可以直接运行的注册中心工具，不需要像eureka注册中心一样再进行编码。使用起来较为简单</p>\n<h2 id=\"4-2、安装\"><a href=\"#4-2、安装\" class=\"headerlink\" title=\"4.2、安装\"></a>4.2、安装</h2><ol>\n<li><p>下载 <a href=\"https://www.consul.io/downloads\">https://www.consul.io/downloads</a></p>\n</li>\n<li><p>解压</p>\n</li>\n<li><p>启动服务注册中心（cmd）</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">consul</span> <span class=\"string\">agent -dev</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问管理界面：<a href=\"http://localhost:8500/\">http://localhost:8500/</a></p>\n</li>\n</ol>\n<h2 id=\"4-3、consul-client开发\"><a href=\"#4-3、consul-client开发\" class=\"headerlink\" title=\"4.3、consul client开发\"></a>4.3、consul client开发</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--springboot依赖--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--consul客户端组件--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"comment\">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写配置文件</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8082</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">CONSULCLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 向consul server服务注册地址</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.port</span>=<span class=\"string\">8500</span></span><br><span class=\"line\"><span class=\"comment\"># 默认为$&#123;spring.application.name&#125;</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.discovery.service-name</span>=<span class=\"string\">CONSULCLIENT</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动类添加注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">// 除了eureka，其它注册中心客户端都可以用该注解</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-4、consul健康检查\"><a href=\"#4-4、consul健康检查\" class=\"headerlink\" title=\"4.4、consul健康检查\"></a>4.4、consul健康检查</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291356805.png\" alt=\"image (10).png\"></p>\n<ol>\n<li>默认情况下consul监控健康是开启的，但必须依赖健康监控依赖才能正常响应客户端发来的心跳，否则界面会显示错误，引入健康依赖之后服务正常<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"5、openFeign（服务间通信）\"><a href=\"#5、openFeign（服务间通信）\" class=\"headerlink\" title=\"5、openFeign（服务间通信）\"></a>5、openFeign（服务间通信）</h1><h2 id=\"5-1、基于RestTemplate实现调用\"><a href=\"#5-1、基于RestTemplate实现调用\" class=\"headerlink\" title=\"5.1、基于RestTemplate实现调用\"></a>5.1、基于RestTemplate实现调用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2Controller</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;client 2 OK!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">RestTemplate</span> <span class=\"variable\">restTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> restTemplate.getForObject(<span class=\"string\">&quot;http://localhost:8088/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span>+result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2、基于RestTemplate-Ribbon实现负载均衡调用\"><a href=\"#5-2、基于RestTemplate-Ribbon实现负载均衡调用\" class=\"headerlink\" title=\"5.2、基于RestTemplate+Ribbon实现负载均衡调用\"></a>5.2、基于RestTemplate+Ribbon实现负载均衡调用</h2><p>spring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现，通过spring cloud封装，可以让我们轻松的进行客户端负载均衡调用。Ribbon可从注册中心中获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例</p>\n<ol>\n<li><strong>编码形式</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">// 服务注册与发现客户端对象（获取服务列表后需要手动选取）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiscoveryClient discoveryClient;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">// 具有负载均衡的服务注册与发现客户端对象（根据负载均衡策略自动选取一个）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// （1）DiscoveryClient</span></span><br><span class=\"line\">        List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(<span class=\"string\">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>().getForObject(serviceInstances.get(<span class=\"number\">0</span>).getUri() + <span class=\"string\">&quot;/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"comment\">// （2）LoadBalanceClient</span></span><br><span class=\"line\">        <span class=\"type\">ServiceInstance</span> <span class=\"variable\">serviceInstances2</span> <span class=\"operator\">=</span> loadBalancerClient.choose(<span class=\"string\">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>().getForObject(serviceInstances2.getUri() + <span class=\"string\">&quot;/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>@LoadBalance注解实现负载均衡</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@LoadBalanced</span> <span class=\"comment\">// 使RestTemplate对象具有ribbon负载均衡特性</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RestTemplate <span class=\"title function_\">restTemplate</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RestTemplate restTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result3</span> <span class=\"operator\">=</span> restTemplate.getForObject(<span class=\"string\">&quot;http://CONSULCLIENT2/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Ribbon负载均衡策略</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>策略类</th>\n<th>命名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RoundRobinRule</td>\n<td>轮询策略</td>\n<td>轮询选择，轮询index，选择index对应位置的Server</td>\n</tr>\n<tr>\n<td>RandomRule</td>\n<td>随机策略</td>\n<td>随机选择server</td>\n</tr>\n<tr>\n<td>BestAvailableRule</td>\n<td>最低并发策略</td>\n<td>选择其中并发链接最低的server</td>\n</tr>\n<tr>\n<td>RetryRule</td>\n<td>重试策略</td>\n<td>其实就是轮询策略的加强版，轮询策略服务不可用时不处理，重试策略会尝试其它节点</td>\n</tr>\n<tr>\n<td>AvailabilityFilteringRule</td>\n<td>可用过滤策略</td>\n<td>过滤掉一直连接失败的provider和繁忙的provider</td>\n</tr>\n<tr>\n<td>ZoneAvoidanceRule</td>\n<td>区域权重策略</td>\n<td>如果某个ip区域内有一个或多个示例不可达或响应慢，都会降低该ip区域内其它ip被选中的权重</td>\n</tr>\n</tbody></table>\n<ol start=\"4\">\n<li><strong>负载均衡策略设置</strong></li>\n</ol>\n<p>（1）局部修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 负载均衡策略 provider为调用的服务的名称</span><br><span class=\"line\"># 格式：服务应用名.ribbon.负载均衡策略名字</span><br><span class=\"line\">provider:</span><br><span class=\"line\">  ribbon:</span><br><span class=\"line\">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure>\n<p>（2）全局修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 所有被调用服务均使用该策略</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RandomRule <span class=\"title function_\">randomRule</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomRule</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-3、基于openFeign实现调用\"><a href=\"#5-3、基于openFeign实现调用\" class=\"headerlink\" title=\"5.3、基于openFeign实现调用\"></a>5.3、基于openFeign实现调用</h2><h3 id=\"5-3-1、Feign\"><a href=\"#5-3-1、Feign\" class=\"headerlink\" title=\"5.3.1、Feign\"></a>5.3.1、Feign</h3><blockquote>\n<p>Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务</p>\n</blockquote>\n<h3 id=\"5-3-2、openFeign\"><a href=\"#5-3-2、openFeign\" class=\"headerlink\" title=\"5.3.2、openFeign\"></a>5.3.2、openFeign</h3><blockquote>\n<p>OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。<br>OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，<br>并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</p>\n</blockquote>\n<h3 id=\"5-3-3、openFeign调用\"><a href=\"#5-3-3、openFeign调用\" class=\"headerlink\" title=\"5.3.3、openFeign调用\"></a>5.3.3、openFeign调用</h3><h4 id=\"5-3-3-1、编码\"><a href=\"#5-3-3-1、编码\" class=\"headerlink\" title=\"5.3.3.1、编码\"></a>5.3.3.1、编码</h4><p>（1）引入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--openFeign--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>（2）启动类开启openFeign的调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"meta\">@EnableFeignClients</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）创建业务层接口，添加@FeginClient注解声明需要调用的服务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FeignClient(&quot;CONSULCLIENT2&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Client2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    String <span class=\"title function_\">test2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（4）调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client2 client2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> client2.test2();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-3-3-2、接口参数传递详解\"><a href=\"#5-3-3-2、接口参数传递详解\" class=\"headerlink\" title=\"5.3.3.2、接口参数传递详解\"></a>5.3.3.2、接口参数传递详解</h4><blockquote>\n<p>（1）test？name&#x3D;xxx&amp;age&#x3D;10  —— @RequestParam(“name”)<br>（2）test&#x2F;{id}   ——  @PathVarible(“id”)<br>（3）test(@RequestBody User user)<br>（4）集合和数组作为参数时封装到VO对象中</p>\n</blockquote>\n<h4 id=\"5-3-3-3、超时处理\"><a href=\"#5-3-3-3、超时处理\" class=\"headerlink\" title=\"5.3.3.3、超时处理\"></a>5.3.3.3、超时处理</h4><ol>\n<li>默认超时时间：1s</li>\n<li>修改某个服务的超时时间</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feign.client.config.PRODUCTS.connecTimeOut</span>=<span class=\"string\">5000 # 配置指定服务连接超时</span></span><br><span class=\"line\"><span class=\"attr\">feign.client.config.PRODUCTS.readTimeOut</span>=<span class=\"string\">5000 # 配置指定服务等待超时</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改所有服务超时时间</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feign.client.config.default.connecTimeOut</span>=<span class=\"string\">5000 # 配置服务连接超时</span></span><br><span class=\"line\"><span class=\"attr\">feign.client.config.default.readTimeOut</span>=<span class=\"string\">5000 # 配置服务等待超时</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、Hystrix（服务熔断）\"><a href=\"#6、Hystrix（服务熔断）\" class=\"headerlink\" title=\"6、Hystrix（服务熔断）\"></a>6、Hystrix（服务熔断）</h1><h2 id=\"6-1、什么是服务雪崩？\"><a href=\"#6-1、什么是服务雪崩？\" class=\"headerlink\" title=\"6.1、什么是服务雪崩？\"></a>6.1、什么是服务雪崩？</h2><p>因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象</p>\n<blockquote>\n<p>（1）程序bug导致服务不可用，或者运行缓慢<br>（2）缓存击穿，导致调用全部访问某服务，导致down掉<br>（3）访问量的突然激增</p>\n</blockquote>\n<h2 id=\"6-2、解决服务雪崩（-熔断-降级）\"><a href=\"#6-2、解决服务雪崩（-熔断-降级）\" class=\"headerlink\" title=\"6.2、解决服务雪崩（ 熔断 + 降级）\"></a>6.2、解决服务雪崩（ 熔断 + 降级）</h2><ol>\n<li><strong>服务熔断</strong></li>\n</ol>\n<p>一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，向调用方返回一个符合预期的的备选响应，而不是长时间等待或抛出异常。所以很多地方把熔断亦称为过载保护</p>\n<ol start=\"2\">\n<li><strong>服务降级</strong></li>\n</ol>\n<p>当网站或服务流量突然增加时，为了保证系统核心服务正常运行，有策略的关闭系统中的边缘服务，以保证核心服务的正常运行</p>\n<ol start=\"3\">\n<li><strong>熔断降级的关系</strong></li>\n</ol>\n<p>熔断必会出发降级，所以熔断也是降级的一种，区别在于熔断是对调用链路的保护，降级是对系统过载的一种保护</p>\n<h2 id=\"6-3、Hystrix概念\"><a href=\"#6-3、Hystrix概念\" class=\"headerlink\" title=\"6.3、Hystrix概念\"></a>6.3、Hystrix概念</h2><p>Hystrix是处理分布式系统延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时，异常等。Hystrix能够保证在一个依赖出现问题时，不会导致整体服务失败，避免雪崩效应，提高分布式系统的弹性</p>\n<h2 id=\"6-4、编码\"><a href=\"#6-4、编码\" class=\"headerlink\" title=\"6.4、编码\"></a>6.4、编码</h2><ol>\n<li>所有服务引入Hystrix依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--hystrix--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>服务提供者</li>\n</ol>\n<p>（直接调用服务提供者的方案，是一种服务降级的思想）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启熔断功能</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span> <span class=\"comment\">//开启hystrix熔断功能</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClient2Application</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClient2Application.class,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2Controller</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand(fallbackMethod = &quot;demoFallBack&quot;,defaultFallback = &quot;defaultFallBack&quot;)</span> <span class=\"comment\">//熔断之后的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(Integer id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;发生异常！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;client 2:8088 OK!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">demoFallBack</span><span class=\"params\">(Integer id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务被熔断&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">defaultFallBack</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务被熔断(默认)&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>服务消费者</li>\n</ol>\n<p>（通过服务消费者调用的方案，服务者完全挂掉时的处理，是一种服务熔断的思想）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启openFeign支持服务降级</span><br><span class=\"line\">feign.hystrix.enabled=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span>  <span class=\"comment\">// 开启服务注册客户端</span></span><br><span class=\"line\"><span class=\"meta\">@EnableFeignClients</span>  <span class=\"comment\">// 开启openFeign调用</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span> <span class=\"comment\">// 开启hystrix熔断功能</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fallback:指定当服务不可用时，默认的备选处理</span></span><br><span class=\"line\"><span class=\"meta\">@FeignClient(value = &quot;CONSULCLIENT2&quot;,fallback = Client2FallBack.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Client2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class=\"line\">    String <span class=\"title function_\">test2</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2FallBack</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Client2</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test2</span><span class=\"params\">(Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;当前服务不可达&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client2 client2;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> client2.test2(id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、Hystrix服务熔断机制\"><a href=\"#6-5、Hystrix服务熔断机制\" class=\"headerlink\" title=\"6.5、Hystrix服务熔断机制\"></a>6.5、Hystrix服务熔断机制</h2><h3 id=\"6-5-1、Hystrix断路器打开的条件\"><a href=\"#6-5-1、Hystrix断路器打开的条件\" class=\"headerlink\" title=\"6.5.1、Hystrix断路器打开的条件\"></a>6.5.1、Hystrix断路器打开的条件</h3><p>a. 当满足一定阈值的时候（默认10秒内超过20个请求次数）<br>b. 当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p>\n<blockquote>\n<p>注意：一旦断路开启之后，所有到这个服务请求均不可用，只有在断路关闭之后才可用</p>\n</blockquote>\n<h3 id=\"6-5-2、Hystrix监控流程\"><a href=\"#6-5-2、Hystrix监控流程\" class=\"headerlink\" title=\"6.5.2、Hystrix监控流程\"></a>6.5.2、Hystrix监控流程</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291357597.png\" alt=\"Hystrix监控流程\"></p>\n<p>当服务调用达到两个阈值，会自动开启断路器，在熔断器打开期间，任何到该接口的请求均不可用，同时在断路器打开5s后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果执行成功，断路器彻底关闭，执行失败则重新打开</p>\n<h2 id=\"6-6、Hystrix-Dashboard（仪表盘）\"><a href=\"#6-6、Hystrix-Dashboard（仪表盘）\" class=\"headerlink\" title=\"6.6、Hystrix Dashboard（仪表盘）\"></a>6.6、Hystrix Dashboard（仪表盘）</h2><ol>\n<li>基本概念</li>\n</ol>\n<p>Hystrix Dashboard主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题</p>\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<p>（1）新建一个 Hystrix Dashboard 工程<br>（2）引入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Cloud Hystrix Dashboard --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>（3）启动类开启监控功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 开启 Hystrix Dashboard 监控功能 */</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure>\n<p>（4）访问仪表盘界面</p>\n<blockquote>\n<p><a href=\"http://localhost:9000/hystrix\">http://localhost:9000/hystrix</a><br>端口为项目的端口号</p>\n</blockquote>\n<h1 id=\"7、zuul（网关）\"><a href=\"#7、zuul（网关）\" class=\"headerlink\" title=\"7、zuul（网关）\"></a>7、zuul（网关）</h1><p>Zuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。zuul 包含了对请求的<strong>路由</strong>和<strong>过滤</strong>两个最主要的功能。</p>\n<p>Zuul是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能:</p>\n<p>（1）聚合接口使得服务对调用者透明，客户端与后端的耦合度降低<br>（2）聚合后台服务，节省流量，提高性能，提升用户体验<br>（3）提供安全、流控、过滤、缓存、计费、监控等 API 管理功能</p>\n<h2 id=\"7-1、搭建环境\"><a href=\"#7-1、搭建环境\" class=\"headerlink\" title=\"7.1、搭建环境\"></a>7.1、搭建环境</h2><p>创建一个应用，在启动类中添加注解@EnableZuulProxy，声明这是一个网关服务提供者</p>\n<h2 id=\"7-2、路由规则配置\"><a href=\"#7-2、路由规则配置\" class=\"headerlink\" title=\"7.2、路由规则配置\"></a>7.2、路由规则配置</h2><h3 id=\"7-2-1、URL地址路由\"><a href=\"#7-2-1、URL地址路由\" class=\"headerlink\" title=\"7.2.1、URL地址路由\"></a>7.2.1、URL地址路由</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 路由规则</span><br><span class=\"line\">zuul:</span><br><span class=\"line\">\troutes :</span><br><span class=\"line\">        # 路由 id 自定义</span><br><span class=\"line\">        product-service :</span><br><span class=\"line\">\t\t\tpath: /product-service<span class=\"comment\">/**配请求 ur1 的映射路径#</span></span><br><span class=\"line\"><span class=\"comment\">    \t\turl: http://localhost:7070/ # 映射路径对应的微服务地址</span></span><br></pre></td></tr></table></figure>\n<p>通配符含义：</p>\n<table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>含义</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>？</td>\n<td>匹配任意单个字符</td>\n<td>&#x2F;product-service&#x2F;?</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配任意数量字符不包括子路径</td>\n<td>&#x2F;product-service&#x2F;*</td>\n</tr>\n<tr>\n<td>**</td>\n<td>匹配任意数量字符包括所有子路径</td>\n<td>&#x2F;product-service&#x2F;**</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-2-2、服务名称路由\"><a href=\"#7-2-2、服务名称路由\" class=\"headerlink\" title=\"7.2.2、服务名称路由\"></a>7.2.2、服务名称路由</h3><p>微服务一般是由几十、上百个服务组成，对于 URL 地址路由的方式，如果对每个服务实例手动指定一个唯一访问地址，这样做显然是不合理的。<br>Zuul 支持与 Eureka 整合开发，根据 serviceld 自动从注册中心获取服务地并转发清求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而目在添加或移除服务实例时不用修改 Zuul 的路由配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">路由规则</span><br><span class=\"line\">Zuul</span><br><span class=\"line\">\troutes:</span><br><span class=\"line\">\t# 路由 id 自定义</span><br><span class=\"line\">\t\tproduct-service:</span><br><span class=\"line\">\t\tpath: /product-service<span class=\"comment\">/**#配置请 url 的映射路径</span></span><br><span class=\"line\"><span class=\"comment\">\t\tserviceId: product-service # 根据 serviceId 自动从注册中心获取服务地址并转发请求</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-2-3、简化路由配置\"><a href=\"#7-2-3、简化路由配置\" class=\"headerlink\" title=\"7.2.3、简化路由配置\"></a>7.2.3、简化路由配置</h3><p>Zuul 为了方便大家使用，提供了默认路由配置: 路由 id 和 微服务名称 一致，path 默认对应 微服务名称&#x2F;* ，所以以下配置就没必要再写了。</p>\n<h2 id=\"7-3、路由排除\"><a href=\"#7-3、路由排除\" class=\"headerlink\" title=\"7.3、路由排除\"></a>7.3、路由排除</h2><p>我们可以通过路由排除设置不允许被访问的资源。允许被访问的资源可以通过路由规则进行设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 路由规则</span><br><span class=\"line\">Zuul:</span><br><span class=\"line\">\t#ignored-patterns: <span class=\"comment\">/**/order/** # URL 地址排除，排除所有包含 /order/ 的路径</span></span><br><span class=\"line\"><span class=\"comment\">\tignored-services: order-service # 服务名称排除，多个服务逗号分隔，&#x27;*’排除所有</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-4、路由前缀\"><a href=\"#7-4、路由前缀\" class=\"headerlink\" title=\"7.4、路由前缀\"></a>7.4、路由前缀</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Zuul:</span><br><span class=\"line\">\tprefix: /api</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-5、网关过滤器\"><a href=\"#7-5、网关过滤器\" class=\"headerlink\" title=\"7.5、网关过滤器\"></a>7.5、网关过滤器</h2><h3 id=\"7-5-1、关键名词\"><a href=\"#7-5-1、关键名词\" class=\"headerlink\" title=\"7.5.1、关键名词\"></a>7.5.1、关键名词</h3><p>类型: 定义路由流程中应用过滤器的阶段。共 pre、routing、 post、error 4 个类型<br>执行顺序: 在同类型中，定义过滤器执行的顺序。比如多个 pre 类型的执行顺序.<br>条件: 执行过滤器所需的条件。true 开启，false 关闭.<br>动作: 如果符合条件，将执行的动作。具体操作。</p>\n<h3 id=\"7-5-2、过滤器类型\"><a href=\"#7-5-2、过滤器类型\" class=\"headerlink\" title=\"7.5.2、过滤器类型\"></a>7.5.2、过滤器类型</h3><p> <strong>pre</strong>: 请求被路由到源服务器之前执行的过滤器</p>\n<blockquote>\n<p>身份认证<br>选路由<br>请求日志</p>\n</blockquote>\n<p><strong>routing</strong>: 处理将请求发送到源服务器的过滤器。<br><strong>post</strong>: 响应从源服务器返回时执行的过滤器</p>\n<blockquote>\n<p>对响应增加 HTTP 头<br>收集统计和度量指标<br>将响应以流的方式发送回客户端</p>\n</blockquote>\n<p><strong>error</strong>:上述阶段中出现错误时执行的过滤器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginFilter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ZuulFilter</span>&#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">filterType</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 登录校验，肯定是在前置拦截 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;pre&quot;</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">filterOrder</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 顺序设置为1 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldFilter</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 返回true，代表过滤器生效。 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">run</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZuulException &#123;</span><br><span class=\"line\">    <span class=\"comment\">//处理业务逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-6、网关限流\"><a href=\"#7-6、网关限流\" class=\"headerlink\" title=\"7.6、网关限流\"></a>7.6、网关限流</h2><p>这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的</p>\n<p><strong>计数器</strong>：计算单元时间内访问接口的次数，如果达到次数，则限制访问</p>\n<p><strong>漏桶算法</strong>：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃</p>\n<p><strong>令牌桶算法：</strong><br>（1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理;<br>（2）根据限流大小，设置按照一定的速率往桶里添加令牌;<br>（3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝;<br>（4）请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除:<br>（5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。</p>\n<blockquote>\n<p>令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放回定数量的令牌</p>\n</blockquote>\n<h3 id=\"7-6-1、网关限流\"><a href=\"#7-6-1、网关限流\" class=\"headerlink\" title=\"7.6.1、网关限流\"></a>7.6.1、网关限流</h3><ol>\n<li>全局限流配置</li>\n</ol>\n<p>使用全局限流配置，zuul会对代理的所有服务提供限流保护</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启限流保护</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 60s内请求超过3次，服务端就抛出异常，60s后可以恢复正常请求</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.limit</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.refresh-interval</span>=<span class=\"string\">60</span></span><br><span class=\"line\"><span class=\"comment\"># 针对IP进行限流，不影响其他IP</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.type</span>=<span class=\"string\">origin</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>局部限流配置</li>\n</ol>\n<p>使用局部限流配置，zuul仅针对配置的服务提供限流保护</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启限流保护</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># hystrix-application-client服务60s内请求超过3次，服务抛出异常。</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.limit</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.refresh-interval</span>=<span class=\"string\">60</span></span><br><span class=\"line\"><span class=\"comment\"># 针对IP限流。</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.type</span>=<span class=\"string\">origin</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"8、sleuth（链路追踪）\"><a href=\"#8、sleuth（链路追踪）\" class=\"headerlink\" title=\"8、sleuth（链路追踪）\"></a>8、sleuth（链路追踪）</h1><h2 id=\"8-1、链路追踪\"><a href=\"#8-1、链路追踪\" class=\"headerlink\" title=\"8.1、链路追踪\"></a>8.1、链路追踪</h2><p>单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整记录下来.</p>\n<h2 id=\"8-2、sleuth\"><a href=\"#8-2、sleuth\" class=\"headerlink\" title=\"8.2、sleuth\"></a>8.2、sleuth</h2><p>Spring Cloud sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，和其他基于日志的追踪系统，例如ELK (Elasticsearch 、 Logstash、Kibana)<br>Spring cloud sleuth 提供了以下功能:</p>\n<ul>\n<li>辩路追踪: 通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。</li>\n<li>性能分析 :通过 sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。</li>\n<li>数据分析，优化链路 : 对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施.</li>\n<li>可视化错误 : 对于程序未捕获的异常，可以配合 Zipkin 查看。</li>\n</ul>\n<h2 id=\"8-3、专业术语\"><a href=\"#8-3、专业术语\" class=\"headerlink\" title=\"8.3、专业术语\"></a>8.3、专业术语</h2><h3 id=\"8-3-1、span\"><a href=\"#8-3-1、span\" class=\"headerlink\" title=\"8.3.1、span\"></a>8.3.1、span</h3><p>基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父ID，以重建在一次追踪过程中不同 Span 之间的关系</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、微服务架构\"><a href=\"#1、微服务架构\" class=\"headerlink\" title=\"1、微服务架构\"></a>1、微服务架构</h1><h2 id=\"1-1、基本概念\"><a href=\"#1-1、基本概念\" class=\"headerlink\" title=\"1.1、基本概念\"></a>1.1、基本概念</h2><p>微服务是一种架构，这种架构是将单个整体应用程序分割成更小的项目关联的独立服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现，这些独立的微服务</p>\n<h2 id=\"1-2、为什么要用微服务？\"><a href=\"#1-2、为什么要用微服务？\" class=\"headerlink\" title=\"1.2、为什么要用微服务？\"></a>1.2、为什么要用微服务？</h2><h3 id=\"1-2-1、优点\"><a href=\"#1-2-1、优点\" class=\"headerlink\" title=\"1.2.1、优点\"></a>1.2.1、优点</h3><ol>\n<li>将服务拆分成单一职责的小服务，进行单独部署，服务之间通过网络进行通信</li>\n<li>每个服务应该有自己的管理团队，高度自治</li>\n<li>服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃</li>\n</ol>\n<h3 id=\"1-2-2、缺点\"><a href=\"#1-2-2、缺点\" class=\"headerlink\" title=\"1.2.2、缺点\"></a>1.2.2、缺点</h3><ol>\n<li>开发人员需要处理分布式系统的复杂性</li>\n<li>随着服务的增加，运维的压力也在增大</li>\n<li>服务治理（负载均衡，服务熔断，服务配置管理）和服务监控</li>\n</ol>\n<h2 id=\"1-3、架构的演变\"><a href=\"#1-3、架构的演变\" class=\"headerlink\" title=\"1.3、架构的演变\"></a>1.3、架构的演变</h2><h3 id=\"1-3-1、单一架构（all-in-one）\"><a href=\"#1-3-1、单一架构（all-in-one）\" class=\"headerlink\" title=\"1.3.1、单一架构（all in one）\"></a>1.3.1、单一架构（all in one）</h3><p>一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(<strong>ORM</strong>)是影响项目开发的关键（mybatis，hibernate）</p>\n<blockquote>\n<p>缺点：随着应用功能的增多，代码量越来越大，越来越难维护</p>\n</blockquote>\n<h3 id=\"1-3-2、垂直架构（vertical-application）\"><a href=\"#1-3-2、垂直架构（vertical-application）\" class=\"headerlink\" title=\"1.3.2、垂直架构（vertical application）\"></a>1.3.2、垂直架构（vertical application）</h3><p>当访问量逐渐增大，单一应用无法满足需求，我们就需要增加节点来提供系统的访问能力，但是并不是所有的模块都需要进行性能的提高，这时候单体应用架构无法满足我们的需求；我们需要将系统里面的模块进行拆分，这样对于后面的水平扩容是非常友好的；<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307290956007.jpg\" alt=\"垂直架构\"></p>\n<blockquote>\n<p>优点：系统拆分实现了流量分担，提高了系统并发量<br>   垂直架构中可以针对不同模块进行针对性优化<br>   方便水平扩展，负载均衡，系统容错率提高</p>\n</blockquote>\n<blockquote>\n<p>缺点：垂直架构中相同逻辑代码需要不断的复制，不能复用。每个垂直模块都相当于一个独立的系统</p>\n</blockquote>\n<h3 id=\"1-3-3、分布式服务架构（distributed-service）\"><a href=\"#1-3-3、分布式服务架构（distributed-service）\" class=\"headerlink\" title=\"1.3.3、分布式服务架构（distributed service）\"></a>1.3.3、分布式服务架构（distributed service）</h3><p>当垂直应用越来越多，重复的业务代码就会越来越多，并且在垂直架构中应用之间的交互不可避免，此时，为了解决基础代码重复太多、应用之间的调用等问题；我们将重复的代码抽取出来作为独立的服务，对外提供服务；</p>\n<blockquote>\n<p>rpc是传输层传输协议，效率比应用层传输要高<br>dubbo采用rpc<br>springcloud采用http，属于应用层传输</p>\n</blockquote>\n<blockquote>\n<p>优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</p>\n</blockquote>\n<blockquote>\n<p>缺点：服务越来越多，需要管理每个服务的地址，调用关系错综复杂，难以理清依赖关系，服务状态难以管理，无法根据服务情况动态管理</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291006525.jpg\" alt=\"分布式架构\"></p>\n<h3 id=\"1-3-4、SOA架构\"><a href=\"#1-3-4、SOA架构\" class=\"headerlink\" title=\"1.3.4、SOA架构\"></a>1.3.4、SOA架构</h3><p>在分布式架构下，当服务越来越多，容量的评估，小服务资源等浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理（根据请求量动态的分配资源）。它一般使用中心化的思想实现，服务的管理和调度都由中央的服务总线（ESB）来负责</p>\n<h3 id=\"1-3-4、微服务架构\"><a href=\"#1-3-4、微服务架构\" class=\"headerlink\" title=\"1.3.4、微服务架构\"></a>1.3.4、微服务架构</h3><p>微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中每个服务独立，互不影响；（怎么理解粒度更细？：微服务采用去中心化的思想来治理，注册中心只是服务发现的工具，而服务之间的调用，熔断，负载均衡等都是都是由服务自己控制的）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291013480.png\" alt=\"微服务架构\"></p>\n<h2 id=\"1-4、微服务架构解决方案\"><a href=\"#1-4、微服务架构解决方案\" class=\"headerlink\" title=\"1.4、微服务架构解决方案\"></a>1.4、微服务架构解决方案</h2><ul>\n<li><strong>国内阿里系</strong></li>\n</ul>\n<p>springboot + dubbo + zookeeper</p>\n<ul>\n<li><strong>spring cloud技术栈</strong></li>\n</ul>\n<p>spring cloud netflix<br>spring cloud spring （spring自己封装的微服务解决方案）<br>spring cloud alibaba（阿里巴巴解决方案）</p>\n<h2 id=\"1-5、SpringCloud概念\"><a href=\"#1-5、SpringCloud概念\" class=\"headerlink\" title=\"1.5、SpringCloud概念\"></a>1.5、SpringCloud概念</h2><h3 id=\"1-5-1、基本概念\"><a href=\"#1-5-1、基本概念\" class=\"headerlink\" title=\"1.5.1、基本概念\"></a>1.5.1、基本概念</h3><p>Spring Cloud是一个含概多个子项目的微服务开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.Spring Cloud在整合过程中主要是针对Netflix(耐非),alibaba开源组件的封装</p>\n<h3 id=\"1-5-2、版本\"><a href=\"#1-5-2、版本\" class=\"headerlink\" title=\"1.5.2、版本\"></a>1.5.2、版本</h3><p>springcloud版本采用伦敦地铁站命名，根据首字母顺序排序 这样设计的目的是为了更好的管理每个springcloud子项目清单，避免了总版本号与子项目版本号混淆</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291014046.png\" alt=\"image.png\"></p>\n<h3 id=\"1-5-3、组件\"><a href=\"#1-5-3、组件\" class=\"headerlink\" title=\"1.5.3、组件\"></a>1.5.3、组件</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>spring cloud官方</th>\n<th>spring cloud netflix</th>\n<th>spring cloud alibaba</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务注册发现</td>\n<td>-</td>\n<td>Eureka</td>\n<td>nacos</td>\n</tr>\n<tr>\n<td>分布式配置</td>\n<td>spring cloud config</td>\n<td>Archaius</td>\n<td>nacos</td>\n</tr>\n<tr>\n<td>服务熔断</td>\n<td>-</td>\n<td>Hystrix</td>\n<td>Sentinel</td>\n</tr>\n<tr>\n<td>服务调用</td>\n<td>Open Fegin</td>\n<td>Fegin</td>\n<td>Dubbo RPC</td>\n</tr>\n<tr>\n<td>服务路由</td>\n<td>spring cloud gateway</td>\n<td>zuul</td>\n<td>dubbo proxy</td>\n</tr>\n<tr>\n<td>分布式消息</td>\n<td>rabbitmq</td>\n<td>-</td>\n<td>rocketmq</td>\n</tr>\n<tr>\n<td>负载均衡</td>\n<td>-</td>\n<td>ribbon</td>\n<td>dubbo LB</td>\n</tr>\n<tr>\n<td>分布式事务</td>\n<td>-</td>\n<td>-</td>\n<td>Seata</td>\n</tr>\n</tbody></table>\n<h1 id=\"2、项目搭建（父工程）\"><a href=\"#2、项目搭建（父工程）\" class=\"headerlink\" title=\"2、项目搭建（父工程）\"></a>2、项目搭建（父工程）</h1><h2 id=\"2-1、引入依赖\"><a href=\"#2-1、引入依赖\" class=\"headerlink\" title=\"2.1、引入依赖\"></a>2.1、引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--springBoot父项目--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.5.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--springBoot--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--springCloud--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>Hoxton.SR6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--maven只能有一个parent 所以这里以pom引入父项目--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3、eureka（注册中心）\"><a href=\"#3、eureka（注册中心）\" class=\"headerlink\" title=\"3、eureka（注册中心）\"></a>3、eureka（注册中心）</h1><h2 id=\"3-1、基本概念\"><a href=\"#3-1、基本概念\" class=\"headerlink\" title=\"3.1、基本概念\"></a>3.1、基本概念</h2><p>注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。两个重要的功能：<strong>服务注册</strong>和<strong>服务发现</strong></p>\n<h2 id=\"3-2、常用的注册中心\"><a href=\"#3-2、常用的注册中心\" class=\"headerlink\" title=\"3.2、常用的注册中心\"></a>3.2、常用的注册中心</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291044882.png\" alt=\"常用的注册中心\"></p>\n<h2 id=\"3-3、eureka角色\"><a href=\"#3-3、eureka角色\" class=\"headerlink\" title=\"3.3、eureka角色\"></a>3.3、eureka角色</h2><ul>\n<li><strong>服务注册中心（server</strong>）：Eureka的服务端应用，提供服务注册和发现功能.</li>\n<li><strong>服务提供者（client）</strong>： 启动后向Eureka注册自己信息（地址，提供什么服务）</li>\n</ul>\n<blockquote>\n<p>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</p>\n</blockquote>\n<ul>\n<li><strong>服务消费者（client）</strong>：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li>\n</ul>\n<h2 id=\"3-4、eureka-server开发\"><a href=\"#3-4、eureka-server开发\" class=\"headerlink\" title=\"3.4、eureka server开发\"></a>3.4、eureka server开发</h2><p>搭建eureka server子项目</p>\n<h3 id=\"3-4-1、引入依赖\"><a href=\"#3-4-1、引入依赖\" class=\"headerlink\" title=\"3.4.1、引入依赖\"></a>3.4.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--springBoot--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--eurekaServer--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-2、配置文件\"><a href=\"#3-4-2、配置文件\" class=\"headerlink\" title=\"3.4.2、配置文件\"></a>3.4.2、配置文件</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># eureka server端口号 （默认就是8761）</span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8761</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-3、入口类加注解\"><a href=\"#3-4-3、入口类加注解\" class=\"headerlink\" title=\"3.4.3、入口类加注解\"></a>3.4.3、入口类加注解</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableEurekaServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EurekaServerApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-5、eureka-client开发\"><a href=\"#3-5、eureka-client开发\" class=\"headerlink\" title=\"3.5、eureka client开发\"></a>3.5、eureka client开发</h2><h3 id=\"3-5-1、引入依赖\"><a href=\"#3-5-1、引入依赖\" class=\"headerlink\" title=\"3.5.1、引入依赖\"></a>3.5.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--eureka client依赖--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--springboot依赖--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-2、配置文件\"><a href=\"#3-5-2、配置文件\" class=\"headerlink\" title=\"3.5.2、配置文件\"></a>3.5.2、配置文件</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8989</span></span><br><span class=\"line\"><span class=\"comment\"># 应用名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKACLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-3、启动类\"><a href=\"#3-5-3、启动类\" class=\"headerlink\" title=\"3.5.3、启动类\"></a>3.5.3、启动类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableEurekaClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EurekaClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6、eureka自我保护机制\"><a href=\"#3-6、eureka自我保护机制\" class=\"headerlink\" title=\"3.6、eureka自我保护机制\"></a>3.6、eureka自我保护机制</h2><h3 id=\"3-6-1、自我保护机制\"><a href=\"#3-6-1、自我保护机制\" class=\"headerlink\" title=\"3.6.1、自我保护机制\"></a>3.6.1、自我保护机制</h3><p>默认情况下，如果eureka server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，eureka server将会移除掉该实例（eureka客户端每隔60秒会发送一次心跳包）</p>\n<p>但是当网络分区发生故障，微服务和eureka server之间无法通信，但是微服务本身是正常的，此时不应该移除这个服务，所以就引入了自我保护机制</p>\n<p>Eureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期</p>\n<blockquote>\n<p>自我保护机制清除：<br>（1）心跳次数高于预期值<br>（2）自我保护机制被禁用</p>\n</blockquote>\n<h3 id=\"3-6-2、如何关闭自我保护机制\"><a href=\"#3-6-2、如何关闭自我保护机制\" class=\"headerlink\" title=\"3.6.2、如何关闭自我保护机制\"></a>3.6.2、如何关闭自我保护机制</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">eureka</span>:<span class=\"string\"></span></span><br><span class=\"line\">  <span class=\"attr\">server</span>:<span class=\"string\"></span></span><br><span class=\"line\"><span class=\"comment\">    #服务端是否开启自我保护机制 （默认true）</span></span><br><span class=\"line\">    <span class=\"attr\">enable-self-preservation</span>: <span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\">    # eureka客户端每隔多长时间发一次心跳（单位毫秒，默认是60*1000）即60秒</span></span><br><span class=\"line\">    <span class=\"attr\">eviction-interval-timer-in-ms</span>: <span class=\"string\">60000</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、eureka-server集群\"><a href=\"#3-7、eureka-server集群\" class=\"headerlink\" title=\"3.7、eureka server集群\"></a>3.7、eureka server集群</h2><p>多个注册中心之间相互注册就可搭建eureka server集群</p>\n<blockquote>\n<p>服务端：eureka.client.service-url.defaultZone 配置其它的注册中心地址即可</p>\n</blockquote>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># eureka server端口号 （默认就是8761）</span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8761</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER01</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8762/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"># eureka server端口号 </span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8762</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER02</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>客户端：所有的注册中心地址都需要指明</p>\n</blockquote>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8989</span></span><br><span class=\"line\"><span class=\"comment\"># 应用名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKACLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka,http://localhost:8762/eureka</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"4、consul（注册中心）\"><a href=\"#4、consul（注册中心）\" class=\"headerlink\" title=\"4、consul（注册中心）\"></a>4、consul（注册中心）</h1><h2 id=\"4-1、简介\"><a href=\"#4-1、简介\" class=\"headerlink\" title=\"4.1、简介\"></a>4.1、简介</h2><p>consul是基于go语言进行开发的服务注册中心，是一个可以直接运行的注册中心工具，不需要像eureka注册中心一样再进行编码。使用起来较为简单</p>\n<h2 id=\"4-2、安装\"><a href=\"#4-2、安装\" class=\"headerlink\" title=\"4.2、安装\"></a>4.2、安装</h2><ol>\n<li><p>下载 <a href=\"https://www.consul.io/downloads\">https://www.consul.io/downloads</a></p>\n</li>\n<li><p>解压</p>\n</li>\n<li><p>启动服务注册中心（cmd）</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">consul</span> <span class=\"string\">agent -dev</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问管理界面：<a href=\"http://localhost:8500/\">http://localhost:8500/</a></p>\n</li>\n</ol>\n<h2 id=\"4-3、consul-client开发\"><a href=\"#4-3、consul-client开发\" class=\"headerlink\" title=\"4.3、consul client开发\"></a>4.3、consul client开发</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--springboot依赖--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--consul客户端组件--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"comment\">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写配置文件</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8082</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">CONSULCLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 向consul server服务注册地址</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.port</span>=<span class=\"string\">8500</span></span><br><span class=\"line\"><span class=\"comment\"># 默认为$&#123;spring.application.name&#125;</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.discovery.service-name</span>=<span class=\"string\">CONSULCLIENT</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动类添加注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">// 除了eureka，其它注册中心客户端都可以用该注解</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-4、consul健康检查\"><a href=\"#4-4、consul健康检查\" class=\"headerlink\" title=\"4.4、consul健康检查\"></a>4.4、consul健康检查</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291356805.png\" alt=\"image (10).png\"></p>\n<ol>\n<li>默认情况下consul监控健康是开启的，但必须依赖健康监控依赖才能正常响应客户端发来的心跳，否则界面会显示错误，引入健康依赖之后服务正常<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"5、openFeign（服务间通信）\"><a href=\"#5、openFeign（服务间通信）\" class=\"headerlink\" title=\"5、openFeign（服务间通信）\"></a>5、openFeign（服务间通信）</h1><h2 id=\"5-1、基于RestTemplate实现调用\"><a href=\"#5-1、基于RestTemplate实现调用\" class=\"headerlink\" title=\"5.1、基于RestTemplate实现调用\"></a>5.1、基于RestTemplate实现调用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2Controller</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;client 2 OK!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">RestTemplate</span> <span class=\"variable\">restTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> restTemplate.getForObject(<span class=\"string\">&quot;http://localhost:8088/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span>+result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2、基于RestTemplate-Ribbon实现负载均衡调用\"><a href=\"#5-2、基于RestTemplate-Ribbon实现负载均衡调用\" class=\"headerlink\" title=\"5.2、基于RestTemplate+Ribbon实现负载均衡调用\"></a>5.2、基于RestTemplate+Ribbon实现负载均衡调用</h2><p>spring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现，通过spring cloud封装，可以让我们轻松的进行客户端负载均衡调用。Ribbon可从注册中心中获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例</p>\n<ol>\n<li><strong>编码形式</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">// 服务注册与发现客户端对象（获取服务列表后需要手动选取）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiscoveryClient discoveryClient;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">// 具有负载均衡的服务注册与发现客户端对象（根据负载均衡策略自动选取一个）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// （1）DiscoveryClient</span></span><br><span class=\"line\">        List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(<span class=\"string\">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>().getForObject(serviceInstances.get(<span class=\"number\">0</span>).getUri() + <span class=\"string\">&quot;/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"comment\">// （2）LoadBalanceClient</span></span><br><span class=\"line\">        <span class=\"type\">ServiceInstance</span> <span class=\"variable\">serviceInstances2</span> <span class=\"operator\">=</span> loadBalancerClient.choose(<span class=\"string\">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>().getForObject(serviceInstances2.getUri() + <span class=\"string\">&quot;/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>@LoadBalance注解实现负载均衡</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@LoadBalanced</span> <span class=\"comment\">// 使RestTemplate对象具有ribbon负载均衡特性</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RestTemplate <span class=\"title function_\">restTemplate</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RestTemplate restTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result3</span> <span class=\"operator\">=</span> restTemplate.getForObject(<span class=\"string\">&quot;http://CONSULCLIENT2/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Ribbon负载均衡策略</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>策略类</th>\n<th>命名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RoundRobinRule</td>\n<td>轮询策略</td>\n<td>轮询选择，轮询index，选择index对应位置的Server</td>\n</tr>\n<tr>\n<td>RandomRule</td>\n<td>随机策略</td>\n<td>随机选择server</td>\n</tr>\n<tr>\n<td>BestAvailableRule</td>\n<td>最低并发策略</td>\n<td>选择其中并发链接最低的server</td>\n</tr>\n<tr>\n<td>RetryRule</td>\n<td>重试策略</td>\n<td>其实就是轮询策略的加强版，轮询策略服务不可用时不处理，重试策略会尝试其它节点</td>\n</tr>\n<tr>\n<td>AvailabilityFilteringRule</td>\n<td>可用过滤策略</td>\n<td>过滤掉一直连接失败的provider和繁忙的provider</td>\n</tr>\n<tr>\n<td>ZoneAvoidanceRule</td>\n<td>区域权重策略</td>\n<td>如果某个ip区域内有一个或多个示例不可达或响应慢，都会降低该ip区域内其它ip被选中的权重</td>\n</tr>\n</tbody></table>\n<ol start=\"4\">\n<li><strong>负载均衡策略设置</strong></li>\n</ol>\n<p>（1）局部修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 负载均衡策略 provider为调用的服务的名称</span><br><span class=\"line\"># 格式：服务应用名.ribbon.负载均衡策略名字</span><br><span class=\"line\">provider:</span><br><span class=\"line\">  ribbon:</span><br><span class=\"line\">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure>\n<p>（2）全局修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 所有被调用服务均使用该策略</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RandomRule <span class=\"title function_\">randomRule</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomRule</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-3、基于openFeign实现调用\"><a href=\"#5-3、基于openFeign实现调用\" class=\"headerlink\" title=\"5.3、基于openFeign实现调用\"></a>5.3、基于openFeign实现调用</h2><h3 id=\"5-3-1、Feign\"><a href=\"#5-3-1、Feign\" class=\"headerlink\" title=\"5.3.1、Feign\"></a>5.3.1、Feign</h3><blockquote>\n<p>Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务</p>\n</blockquote>\n<h3 id=\"5-3-2、openFeign\"><a href=\"#5-3-2、openFeign\" class=\"headerlink\" title=\"5.3.2、openFeign\"></a>5.3.2、openFeign</h3><blockquote>\n<p>OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。<br>OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，<br>并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</p>\n</blockquote>\n<h3 id=\"5-3-3、openFeign调用\"><a href=\"#5-3-3、openFeign调用\" class=\"headerlink\" title=\"5.3.3、openFeign调用\"></a>5.3.3、openFeign调用</h3><h4 id=\"5-3-3-1、编码\"><a href=\"#5-3-3-1、编码\" class=\"headerlink\" title=\"5.3.3.1、编码\"></a>5.3.3.1、编码</h4><p>（1）引入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--openFeign--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>（2）启动类开启openFeign的调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"meta\">@EnableFeignClients</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）创建业务层接口，添加@FeginClient注解声明需要调用的服务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FeignClient(&quot;CONSULCLIENT2&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Client2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    String <span class=\"title function_\">test2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（4）调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client2 client2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> client2.test2();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-3-3-2、接口参数传递详解\"><a href=\"#5-3-3-2、接口参数传递详解\" class=\"headerlink\" title=\"5.3.3.2、接口参数传递详解\"></a>5.3.3.2、接口参数传递详解</h4><blockquote>\n<p>（1）test？name&#x3D;xxx&amp;age&#x3D;10  —— @RequestParam(“name”)<br>（2）test&#x2F;{id}   ——  @PathVarible(“id”)<br>（3）test(@RequestBody User user)<br>（4）集合和数组作为参数时封装到VO对象中</p>\n</blockquote>\n<h4 id=\"5-3-3-3、超时处理\"><a href=\"#5-3-3-3、超时处理\" class=\"headerlink\" title=\"5.3.3.3、超时处理\"></a>5.3.3.3、超时处理</h4><ol>\n<li>默认超时时间：1s</li>\n<li>修改某个服务的超时时间</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feign.client.config.PRODUCTS.connecTimeOut</span>=<span class=\"string\">5000 # 配置指定服务连接超时</span></span><br><span class=\"line\"><span class=\"attr\">feign.client.config.PRODUCTS.readTimeOut</span>=<span class=\"string\">5000 # 配置指定服务等待超时</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改所有服务超时时间</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feign.client.config.default.connecTimeOut</span>=<span class=\"string\">5000 # 配置服务连接超时</span></span><br><span class=\"line\"><span class=\"attr\">feign.client.config.default.readTimeOut</span>=<span class=\"string\">5000 # 配置服务等待超时</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、Hystrix（服务熔断）\"><a href=\"#6、Hystrix（服务熔断）\" class=\"headerlink\" title=\"6、Hystrix（服务熔断）\"></a>6、Hystrix（服务熔断）</h1><h2 id=\"6-1、什么是服务雪崩？\"><a href=\"#6-1、什么是服务雪崩？\" class=\"headerlink\" title=\"6.1、什么是服务雪崩？\"></a>6.1、什么是服务雪崩？</h2><p>因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象</p>\n<blockquote>\n<p>（1）程序bug导致服务不可用，或者运行缓慢<br>（2）缓存击穿，导致调用全部访问某服务，导致down掉<br>（3）访问量的突然激增</p>\n</blockquote>\n<h2 id=\"6-2、解决服务雪崩（-熔断-降级）\"><a href=\"#6-2、解决服务雪崩（-熔断-降级）\" class=\"headerlink\" title=\"6.2、解决服务雪崩（ 熔断 + 降级）\"></a>6.2、解决服务雪崩（ 熔断 + 降级）</h2><ol>\n<li><strong>服务熔断</strong></li>\n</ol>\n<p>一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，向调用方返回一个符合预期的的备选响应，而不是长时间等待或抛出异常。所以很多地方把熔断亦称为过载保护</p>\n<ol start=\"2\">\n<li><strong>服务降级</strong></li>\n</ol>\n<p>当网站或服务流量突然增加时，为了保证系统核心服务正常运行，有策略的关闭系统中的边缘服务，以保证核心服务的正常运行</p>\n<ol start=\"3\">\n<li><strong>熔断降级的关系</strong></li>\n</ol>\n<p>熔断必会出发降级，所以熔断也是降级的一种，区别在于熔断是对调用链路的保护，降级是对系统过载的一种保护</p>\n<h2 id=\"6-3、Hystrix概念\"><a href=\"#6-3、Hystrix概念\" class=\"headerlink\" title=\"6.3、Hystrix概念\"></a>6.3、Hystrix概念</h2><p>Hystrix是处理分布式系统延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时，异常等。Hystrix能够保证在一个依赖出现问题时，不会导致整体服务失败，避免雪崩效应，提高分布式系统的弹性</p>\n<h2 id=\"6-4、编码\"><a href=\"#6-4、编码\" class=\"headerlink\" title=\"6.4、编码\"></a>6.4、编码</h2><ol>\n<li>所有服务引入Hystrix依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--hystrix--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>服务提供者</li>\n</ol>\n<p>（直接调用服务提供者的方案，是一种服务降级的思想）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启熔断功能</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span> <span class=\"comment\">//开启hystrix熔断功能</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClient2Application</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClient2Application.class,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2Controller</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand(fallbackMethod = &quot;demoFallBack&quot;,defaultFallback = &quot;defaultFallBack&quot;)</span> <span class=\"comment\">//熔断之后的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(Integer id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;发生异常！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;client 2:8088 OK!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">demoFallBack</span><span class=\"params\">(Integer id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务被熔断&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">defaultFallBack</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务被熔断(默认)&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>服务消费者</li>\n</ol>\n<p>（通过服务消费者调用的方案，服务者完全挂掉时的处理，是一种服务熔断的思想）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启openFeign支持服务降级</span><br><span class=\"line\">feign.hystrix.enabled=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span>  <span class=\"comment\">// 开启服务注册客户端</span></span><br><span class=\"line\"><span class=\"meta\">@EnableFeignClients</span>  <span class=\"comment\">// 开启openFeign调用</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span> <span class=\"comment\">// 开启hystrix熔断功能</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fallback:指定当服务不可用时，默认的备选处理</span></span><br><span class=\"line\"><span class=\"meta\">@FeignClient(value = &quot;CONSULCLIENT2&quot;,fallback = Client2FallBack.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Client2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class=\"line\">    String <span class=\"title function_\">test2</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2FallBack</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Client2</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test2</span><span class=\"params\">(Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;当前服务不可达&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client2 client2;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> client2.test2(id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、Hystrix服务熔断机制\"><a href=\"#6-5、Hystrix服务熔断机制\" class=\"headerlink\" title=\"6.5、Hystrix服务熔断机制\"></a>6.5、Hystrix服务熔断机制</h2><h3 id=\"6-5-1、Hystrix断路器打开的条件\"><a href=\"#6-5-1、Hystrix断路器打开的条件\" class=\"headerlink\" title=\"6.5.1、Hystrix断路器打开的条件\"></a>6.5.1、Hystrix断路器打开的条件</h3><p>a. 当满足一定阈值的时候（默认10秒内超过20个请求次数）<br>b. 当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p>\n<blockquote>\n<p>注意：一旦断路开启之后，所有到这个服务请求均不可用，只有在断路关闭之后才可用</p>\n</blockquote>\n<h3 id=\"6-5-2、Hystrix监控流程\"><a href=\"#6-5-2、Hystrix监控流程\" class=\"headerlink\" title=\"6.5.2、Hystrix监控流程\"></a>6.5.2、Hystrix监控流程</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291357597.png\" alt=\"Hystrix监控流程\"></p>\n<p>当服务调用达到两个阈值，会自动开启断路器，在熔断器打开期间，任何到该接口的请求均不可用，同时在断路器打开5s后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果执行成功，断路器彻底关闭，执行失败则重新打开</p>\n<h2 id=\"6-6、Hystrix-Dashboard（仪表盘）\"><a href=\"#6-6、Hystrix-Dashboard（仪表盘）\" class=\"headerlink\" title=\"6.6、Hystrix Dashboard（仪表盘）\"></a>6.6、Hystrix Dashboard（仪表盘）</h2><ol>\n<li>基本概念</li>\n</ol>\n<p>Hystrix Dashboard主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题</p>\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<p>（1）新建一个 Hystrix Dashboard 工程<br>（2）引入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Cloud Hystrix Dashboard --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>（3）启动类开启监控功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 开启 Hystrix Dashboard 监控功能 */</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure>\n<p>（4）访问仪表盘界面</p>\n<blockquote>\n<p><a href=\"http://localhost:9000/hystrix\">http://localhost:9000/hystrix</a><br>端口为项目的端口号</p>\n</blockquote>\n<h1 id=\"7、zuul（网关）\"><a href=\"#7、zuul（网关）\" class=\"headerlink\" title=\"7、zuul（网关）\"></a>7、zuul（网关）</h1><p>Zuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。zuul 包含了对请求的<strong>路由</strong>和<strong>过滤</strong>两个最主要的功能。</p>\n<p>Zuul是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能:</p>\n<p>（1）聚合接口使得服务对调用者透明，客户端与后端的耦合度降低<br>（2）聚合后台服务，节省流量，提高性能，提升用户体验<br>（3）提供安全、流控、过滤、缓存、计费、监控等 API 管理功能</p>\n<h2 id=\"7-1、搭建环境\"><a href=\"#7-1、搭建环境\" class=\"headerlink\" title=\"7.1、搭建环境\"></a>7.1、搭建环境</h2><p>创建一个应用，在启动类中添加注解@EnableZuulProxy，声明这是一个网关服务提供者</p>\n<h2 id=\"7-2、路由规则配置\"><a href=\"#7-2、路由规则配置\" class=\"headerlink\" title=\"7.2、路由规则配置\"></a>7.2、路由规则配置</h2><h3 id=\"7-2-1、URL地址路由\"><a href=\"#7-2-1、URL地址路由\" class=\"headerlink\" title=\"7.2.1、URL地址路由\"></a>7.2.1、URL地址路由</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 路由规则</span><br><span class=\"line\">zuul:</span><br><span class=\"line\">\troutes :</span><br><span class=\"line\">        # 路由 id 自定义</span><br><span class=\"line\">        product-service :</span><br><span class=\"line\">\t\t\tpath: /product-service<span class=\"comment\">/**配请求 ur1 的映射路径#</span></span><br><span class=\"line\"><span class=\"comment\">    \t\turl: http://localhost:7070/ # 映射路径对应的微服务地址</span></span><br></pre></td></tr></table></figure>\n<p>通配符含义：</p>\n<table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>含义</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>？</td>\n<td>匹配任意单个字符</td>\n<td>&#x2F;product-service&#x2F;?</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配任意数量字符不包括子路径</td>\n<td>&#x2F;product-service&#x2F;*</td>\n</tr>\n<tr>\n<td>**</td>\n<td>匹配任意数量字符包括所有子路径</td>\n<td>&#x2F;product-service&#x2F;**</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-2-2、服务名称路由\"><a href=\"#7-2-2、服务名称路由\" class=\"headerlink\" title=\"7.2.2、服务名称路由\"></a>7.2.2、服务名称路由</h3><p>微服务一般是由几十、上百个服务组成，对于 URL 地址路由的方式，如果对每个服务实例手动指定一个唯一访问地址，这样做显然是不合理的。<br>Zuul 支持与 Eureka 整合开发，根据 serviceld 自动从注册中心获取服务地并转发清求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而目在添加或移除服务实例时不用修改 Zuul 的路由配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">路由规则</span><br><span class=\"line\">Zuul</span><br><span class=\"line\">\troutes:</span><br><span class=\"line\">\t# 路由 id 自定义</span><br><span class=\"line\">\t\tproduct-service:</span><br><span class=\"line\">\t\tpath: /product-service<span class=\"comment\">/**#配置请 url 的映射路径</span></span><br><span class=\"line\"><span class=\"comment\">\t\tserviceId: product-service # 根据 serviceId 自动从注册中心获取服务地址并转发请求</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-2-3、简化路由配置\"><a href=\"#7-2-3、简化路由配置\" class=\"headerlink\" title=\"7.2.3、简化路由配置\"></a>7.2.3、简化路由配置</h3><p>Zuul 为了方便大家使用，提供了默认路由配置: 路由 id 和 微服务名称 一致，path 默认对应 微服务名称&#x2F;* ，所以以下配置就没必要再写了。</p>\n<h2 id=\"7-3、路由排除\"><a href=\"#7-3、路由排除\" class=\"headerlink\" title=\"7.3、路由排除\"></a>7.3、路由排除</h2><p>我们可以通过路由排除设置不允许被访问的资源。允许被访问的资源可以通过路由规则进行设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 路由规则</span><br><span class=\"line\">Zuul:</span><br><span class=\"line\">\t#ignored-patterns: <span class=\"comment\">/**/order/** # URL 地址排除，排除所有包含 /order/ 的路径</span></span><br><span class=\"line\"><span class=\"comment\">\tignored-services: order-service # 服务名称排除，多个服务逗号分隔，&#x27;*’排除所有</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-4、路由前缀\"><a href=\"#7-4、路由前缀\" class=\"headerlink\" title=\"7.4、路由前缀\"></a>7.4、路由前缀</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Zuul:</span><br><span class=\"line\">\tprefix: /api</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-5、网关过滤器\"><a href=\"#7-5、网关过滤器\" class=\"headerlink\" title=\"7.5、网关过滤器\"></a>7.5、网关过滤器</h2><h3 id=\"7-5-1、关键名词\"><a href=\"#7-5-1、关键名词\" class=\"headerlink\" title=\"7.5.1、关键名词\"></a>7.5.1、关键名词</h3><p>类型: 定义路由流程中应用过滤器的阶段。共 pre、routing、 post、error 4 个类型<br>执行顺序: 在同类型中，定义过滤器执行的顺序。比如多个 pre 类型的执行顺序.<br>条件: 执行过滤器所需的条件。true 开启，false 关闭.<br>动作: 如果符合条件，将执行的动作。具体操作。</p>\n<h3 id=\"7-5-2、过滤器类型\"><a href=\"#7-5-2、过滤器类型\" class=\"headerlink\" title=\"7.5.2、过滤器类型\"></a>7.5.2、过滤器类型</h3><p> <strong>pre</strong>: 请求被路由到源服务器之前执行的过滤器</p>\n<blockquote>\n<p>身份认证<br>选路由<br>请求日志</p>\n</blockquote>\n<p><strong>routing</strong>: 处理将请求发送到源服务器的过滤器。<br><strong>post</strong>: 响应从源服务器返回时执行的过滤器</p>\n<blockquote>\n<p>对响应增加 HTTP 头<br>收集统计和度量指标<br>将响应以流的方式发送回客户端</p>\n</blockquote>\n<p><strong>error</strong>:上述阶段中出现错误时执行的过滤器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginFilter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ZuulFilter</span>&#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">filterType</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 登录校验，肯定是在前置拦截 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;pre&quot;</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">filterOrder</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 顺序设置为1 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldFilter</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 返回true，代表过滤器生效。 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">run</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZuulException &#123;</span><br><span class=\"line\">    <span class=\"comment\">//处理业务逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-6、网关限流\"><a href=\"#7-6、网关限流\" class=\"headerlink\" title=\"7.6、网关限流\"></a>7.6、网关限流</h2><p>这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的</p>\n<p><strong>计数器</strong>：计算单元时间内访问接口的次数，如果达到次数，则限制访问</p>\n<p><strong>漏桶算法</strong>：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃</p>\n<p><strong>令牌桶算法：</strong><br>（1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理;<br>（2）根据限流大小，设置按照一定的速率往桶里添加令牌;<br>（3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝;<br>（4）请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除:<br>（5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。</p>\n<blockquote>\n<p>令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放回定数量的令牌</p>\n</blockquote>\n<h3 id=\"7-6-1、网关限流\"><a href=\"#7-6-1、网关限流\" class=\"headerlink\" title=\"7.6.1、网关限流\"></a>7.6.1、网关限流</h3><ol>\n<li>全局限流配置</li>\n</ol>\n<p>使用全局限流配置，zuul会对代理的所有服务提供限流保护</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启限流保护</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 60s内请求超过3次，服务端就抛出异常，60s后可以恢复正常请求</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.limit</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.refresh-interval</span>=<span class=\"string\">60</span></span><br><span class=\"line\"><span class=\"comment\"># 针对IP进行限流，不影响其他IP</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.type</span>=<span class=\"string\">origin</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>局部限流配置</li>\n</ol>\n<p>使用局部限流配置，zuul仅针对配置的服务提供限流保护</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启限流保护</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># hystrix-application-client服务60s内请求超过3次，服务抛出异常。</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.limit</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.refresh-interval</span>=<span class=\"string\">60</span></span><br><span class=\"line\"><span class=\"comment\"># 针对IP限流。</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.type</span>=<span class=\"string\">origin</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"8、sleuth（链路追踪）\"><a href=\"#8、sleuth（链路追踪）\" class=\"headerlink\" title=\"8、sleuth（链路追踪）\"></a>8、sleuth（链路追踪）</h1><h2 id=\"8-1、链路追踪\"><a href=\"#8-1、链路追踪\" class=\"headerlink\" title=\"8.1、链路追踪\"></a>8.1、链路追踪</h2><p>单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整记录下来.</p>\n<h2 id=\"8-2、sleuth\"><a href=\"#8-2、sleuth\" class=\"headerlink\" title=\"8.2、sleuth\"></a>8.2、sleuth</h2><p>Spring Cloud sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，和其他基于日志的追踪系统，例如ELK (Elasticsearch 、 Logstash、Kibana)<br>Spring cloud sleuth 提供了以下功能:</p>\n<ul>\n<li>辩路追踪: 通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。</li>\n<li>性能分析 :通过 sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。</li>\n<li>数据分析，优化链路 : 对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施.</li>\n<li>可视化错误 : 对于程序未捕获的异常，可以配合 Zipkin 查看。</li>\n</ul>\n<h2 id=\"8-3、专业术语\"><a href=\"#8-3、专业术语\" class=\"headerlink\" title=\"8.3、专业术语\"></a>8.3、专业术语</h2><h3 id=\"8-3-1、span\"><a href=\"#8-3-1、span\" class=\"headerlink\" title=\"8.3.1、span\"></a>8.3.1、span</h3><p>基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父ID，以重建在一次追踪过程中不同 Span 之间的关系</p>\n"},{"title":"夏","date":"2023-07-27T16:00:00.000Z","abbrlink":23609,"_content":"# 1、夏朝年表\n\n夏朝（约前2070年－约前1600年，473年）是中国历史记载的第一个中原部族世袭制朝代\n\n|   序号   |   姓名      |   在位时长                 |   相关事件                            |\n|:-------|:----------|:-----------------------|:----------------------------------|\n|    1   |   禹       | 前2029年-前1982年（46年）     |   **涂山大会**，铸造九鼎，象征九州，第一次有了国家的概念   |\n|    2   |   启       | 前1982年-前1963年（29年）     |   由禅让制变为世袭制，击败了有扈氏的反抗             |\n|    3   |   太康      |     前1963年-前1955年（29年） |   不理朝政，被有穷氏后羿夺权，**太康失国**，实际在位2年   |\n|    4   |   仲康      |     前1955年-前1946年（13年） |   后羿专权，仲康反抗失败被软禁，抑郁而终             |\n|    5   |   相       |     前1946年-前1916年（28年） |   被寒浞的儿子浇攻破自刎，大臣寒浞杀后羿夺权           |\n|    6   |   少康/杜康   |     前1876年-前1855年（22年） |   相的遗腹子，攻杀寒浞，复国，**少康中兴**          |\n|    7   |   季杼      |     前1855年-前1836年（17年） |   参加过复兴夏朝的战争                      |\n|    8   |   槐/帝芬    |     前1836年-前1790年（44年） |                                   |\n|    9   |   芒       |     前1790年-前1732年（18年） |                                   |\n|   10   |   泄/帝降    |     前1732年-前1706年（21年） |   正式赐封九夷各部诸侯爵位                    |\n|   11   |   不降      |     前1706年-前1644（59年）  |                                   |\n|   12   |   扃       |     前1644年-前1626年（21年） |                                   |\n|   13   |   廑       |     前1626年-前1615年（20年） |   夏国开始衰落                          |\n|   14   |   孔甲      |     前1615年-前1604年（31年） |   胡作非为的残暴昏君                       |\n|   15   |   皋       |     前1604年-前1599年（11年） |                                   |\n|   16   |   发       |     前1599年-前1590年（19年） |   各方诸侯已不来朝贺                       |\n|   17   |   桀       |     前1590年-前1559年（52年） |   暴君，被商汤灭，亡国                      | \n\n# 2、涂山之会\n\n&emsp;&emsp;涂山之会被认为是中国夏朝建立的标志性事件。禹为了巩固王权，禹在淮水中游的涂山(今安徽埠西郊怀远县) 召开大会。夏、夷诸部众多邦国和部落的首领一起参会，史称涂山之会。\n大会后，诸部落首领为表敬意，常来都城献“金”(即青铜) 。后来，九州所贡之铜年年增多，大禹想起从前黄帝轩辕氏功成铸鼎。为了纪念涂山大会，就将各州所贡之金，就拿来铸该州的鼎，将该州内的山川形势都铸在上面。即冀州鼎、充州鼎、青州鼎、徐州鼎、扬州鼎、荆州鼎、**豫州鼎（河南）**、梁州鼎、雍州鼎。鼎上铸着各种山川名物、奇禽异兽。九鼎象征着九坐，其中豫州鼎为中央大鼎，豫州即为中央枢纽。九鼎集中在夏王朝都城**阳城**，借以显示夏王大禹成为九州之主，天下从此一统。大禹把九鼎称为镇国之宝，各方诸侯来朝见时，都要向九鼎顶礼膜拜。从此，九鼎成为国家最重要的礼器。\n\n# 3、太康失国，少康中兴\n\n&emsp;&emsp;启死后，他的儿子太康继承了王位，成天只顾打猎、游玩、宴饮，不管朝政。这样昏聘无能的王使民众感到十分愤怒，其他部落也都对他非常不满。东夷族趁此机会开始大肆西进。东夷族有穷氏当时的首领叫做**羿**，也有人管他叫夷羿、后羿。有一次，太康去洛水南面打猎，去了一百天都还没回来，羿就看准了这次机会，带兵趁机占领了夏朝的国都，得到夏民的拥护，赶走了太康。这件事在历史上被称为“太康失国”，也叫“后羿代夏”。\n&emsp;&emsp;后羿的射箭技术非常出名，在夺取了夏朝的政权之后，他重蹈了太康的覆辙。后羿仗着自己射箭的本领天天在原野之中打猎玩乐，也不处理王朝中的事务。不去重用朝中那些有贤能的大臣，反而将政事交给了自己身边一个叫做**寒浞**的亲信。寒浞的奸诈在伯明氏中可是远近闻名，他一边对后羿奉承谄媚，一边用小恩小惠来收买人心，骗取民众的信任与支持。寒浞的权力越来越大，终于，他买通了后羿的亲信随从，趁后羿出去打猎之时杀害了后羿，还霸占了后羿的妻妾和财产，夺得了统治权。但这场关于权力的杀戮还远远没有停止。\n&emsp;&emsp;太康被放逐后不久就死去了，虽然他不再是部落联盟的王，但是相对于自己的部落来说，他还是首领。太康死后，他的弟弟仲康继任首领，但部落的力量实在太弱小，没有复国之力。仲康死后，他的儿子**相**继任了部落首领的位置。\n&emsp;&emsp;寒浞杀死后羿后，开始疯狂地消除亲夏的势力，相也被杀死于帝丘。相的妻子此时已经怀有身孕，在这危机的混战之中，她从墙洞中仓皇出逃，一路逃回了自己的娘家一一有仍氏(今山东金乡境)，并在那里生下了少康，但是寒浞不打算就此收手。\n&emsp;&emsp;少康长大之后，在有仍氏做牧正（主管畜牧）。浇听说相的后代还活着，就派人去追捕少康，少康紧急逃往有虞氏(今河南虞城)，有虞氏的首领很看好少康，让他担任掌管饮食的庖正，还给他娶了妻子，分了土地和民众。有了封地和人口，少康开始积极联络夏朝的余众潜心筹备复国。民众们也已经看透了寒浞实际上是一个没有德行，奸诈虚伪的人。最终，少康联合夏朝的旧臣**伯靡**，灭掉了寒捉和有穷氏，少康被拥立为夏王，重新恢复了夏朝。","source":"_posts/夏.md","raw":"---\ntitle: 夏\ndate: 2023/07/28\ncategories:\n  - 历史\ntags:\n  - 中国历史\nabbrlink: 23609\n---\n# 1、夏朝年表\n\n夏朝（约前2070年－约前1600年，473年）是中国历史记载的第一个中原部族世袭制朝代\n\n|   序号   |   姓名      |   在位时长                 |   相关事件                            |\n|:-------|:----------|:-----------------------|:----------------------------------|\n|    1   |   禹       | 前2029年-前1982年（46年）     |   **涂山大会**，铸造九鼎，象征九州，第一次有了国家的概念   |\n|    2   |   启       | 前1982年-前1963年（29年）     |   由禅让制变为世袭制，击败了有扈氏的反抗             |\n|    3   |   太康      |     前1963年-前1955年（29年） |   不理朝政，被有穷氏后羿夺权，**太康失国**，实际在位2年   |\n|    4   |   仲康      |     前1955年-前1946年（13年） |   后羿专权，仲康反抗失败被软禁，抑郁而终             |\n|    5   |   相       |     前1946年-前1916年（28年） |   被寒浞的儿子浇攻破自刎，大臣寒浞杀后羿夺权           |\n|    6   |   少康/杜康   |     前1876年-前1855年（22年） |   相的遗腹子，攻杀寒浞，复国，**少康中兴**          |\n|    7   |   季杼      |     前1855年-前1836年（17年） |   参加过复兴夏朝的战争                      |\n|    8   |   槐/帝芬    |     前1836年-前1790年（44年） |                                   |\n|    9   |   芒       |     前1790年-前1732年（18年） |                                   |\n|   10   |   泄/帝降    |     前1732年-前1706年（21年） |   正式赐封九夷各部诸侯爵位                    |\n|   11   |   不降      |     前1706年-前1644（59年）  |                                   |\n|   12   |   扃       |     前1644年-前1626年（21年） |                                   |\n|   13   |   廑       |     前1626年-前1615年（20年） |   夏国开始衰落                          |\n|   14   |   孔甲      |     前1615年-前1604年（31年） |   胡作非为的残暴昏君                       |\n|   15   |   皋       |     前1604年-前1599年（11年） |                                   |\n|   16   |   发       |     前1599年-前1590年（19年） |   各方诸侯已不来朝贺                       |\n|   17   |   桀       |     前1590年-前1559年（52年） |   暴君，被商汤灭，亡国                      | \n\n# 2、涂山之会\n\n&emsp;&emsp;涂山之会被认为是中国夏朝建立的标志性事件。禹为了巩固王权，禹在淮水中游的涂山(今安徽埠西郊怀远县) 召开大会。夏、夷诸部众多邦国和部落的首领一起参会，史称涂山之会。\n大会后，诸部落首领为表敬意，常来都城献“金”(即青铜) 。后来，九州所贡之铜年年增多，大禹想起从前黄帝轩辕氏功成铸鼎。为了纪念涂山大会，就将各州所贡之金，就拿来铸该州的鼎，将该州内的山川形势都铸在上面。即冀州鼎、充州鼎、青州鼎、徐州鼎、扬州鼎、荆州鼎、**豫州鼎（河南）**、梁州鼎、雍州鼎。鼎上铸着各种山川名物、奇禽异兽。九鼎象征着九坐，其中豫州鼎为中央大鼎，豫州即为中央枢纽。九鼎集中在夏王朝都城**阳城**，借以显示夏王大禹成为九州之主，天下从此一统。大禹把九鼎称为镇国之宝，各方诸侯来朝见时，都要向九鼎顶礼膜拜。从此，九鼎成为国家最重要的礼器。\n\n# 3、太康失国，少康中兴\n\n&emsp;&emsp;启死后，他的儿子太康继承了王位，成天只顾打猎、游玩、宴饮，不管朝政。这样昏聘无能的王使民众感到十分愤怒，其他部落也都对他非常不满。东夷族趁此机会开始大肆西进。东夷族有穷氏当时的首领叫做**羿**，也有人管他叫夷羿、后羿。有一次，太康去洛水南面打猎，去了一百天都还没回来，羿就看准了这次机会，带兵趁机占领了夏朝的国都，得到夏民的拥护，赶走了太康。这件事在历史上被称为“太康失国”，也叫“后羿代夏”。\n&emsp;&emsp;后羿的射箭技术非常出名，在夺取了夏朝的政权之后，他重蹈了太康的覆辙。后羿仗着自己射箭的本领天天在原野之中打猎玩乐，也不处理王朝中的事务。不去重用朝中那些有贤能的大臣，反而将政事交给了自己身边一个叫做**寒浞**的亲信。寒浞的奸诈在伯明氏中可是远近闻名，他一边对后羿奉承谄媚，一边用小恩小惠来收买人心，骗取民众的信任与支持。寒浞的权力越来越大，终于，他买通了后羿的亲信随从，趁后羿出去打猎之时杀害了后羿，还霸占了后羿的妻妾和财产，夺得了统治权。但这场关于权力的杀戮还远远没有停止。\n&emsp;&emsp;太康被放逐后不久就死去了，虽然他不再是部落联盟的王，但是相对于自己的部落来说，他还是首领。太康死后，他的弟弟仲康继任首领，但部落的力量实在太弱小，没有复国之力。仲康死后，他的儿子**相**继任了部落首领的位置。\n&emsp;&emsp;寒浞杀死后羿后，开始疯狂地消除亲夏的势力，相也被杀死于帝丘。相的妻子此时已经怀有身孕，在这危机的混战之中，她从墙洞中仓皇出逃，一路逃回了自己的娘家一一有仍氏(今山东金乡境)，并在那里生下了少康，但是寒浞不打算就此收手。\n&emsp;&emsp;少康长大之后，在有仍氏做牧正（主管畜牧）。浇听说相的后代还活着，就派人去追捕少康，少康紧急逃往有虞氏(今河南虞城)，有虞氏的首领很看好少康，让他担任掌管饮食的庖正，还给他娶了妻子，分了土地和民众。有了封地和人口，少康开始积极联络夏朝的余众潜心筹备复国。民众们也已经看透了寒浞实际上是一个没有德行，奸诈虚伪的人。最终，少康联合夏朝的旧臣**伯靡**，灭掉了寒捉和有穷氏，少康被拥立为夏王，重新恢复了夏朝。","slug":"夏","published":1,"updated":"2023-07-28T14:58:01.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkqz2iq0000w6wuj6bt96j42","content":"<h1 id=\"1、夏朝年表\"><a href=\"#1、夏朝年表\" class=\"headerlink\" title=\"1、夏朝年表\"></a>1、夏朝年表</h1><p>夏朝（约前2070年－约前1600年，473年）是中国历史记载的第一个中原部族世袭制朝代</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时长</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">禹</td>\n<td align=\"left\">前2029年-前1982年（46年）</td>\n<td align=\"left\"><strong>涂山大会</strong>，铸造九鼎，象征九州，第一次有了国家的概念</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">启</td>\n<td align=\"left\">前1982年-前1963年（29年）</td>\n<td align=\"left\">由禅让制变为世袭制，击败了有扈氏的反抗</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">太康</td>\n<td align=\"left\">前1963年-前1955年（29年）</td>\n<td align=\"left\">不理朝政，被有穷氏后羿夺权，<strong>太康失国</strong>，实际在位2年</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">仲康</td>\n<td align=\"left\">前1955年-前1946年（13年）</td>\n<td align=\"left\">后羿专权，仲康反抗失败被软禁，抑郁而终</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">相</td>\n<td align=\"left\">前1946年-前1916年（28年）</td>\n<td align=\"left\">被寒浞的儿子浇攻破自刎，大臣寒浞杀后羿夺权</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">少康&#x2F;杜康</td>\n<td align=\"left\">前1876年-前1855年（22年）</td>\n<td align=\"left\">相的遗腹子，攻杀寒浞，复国，<strong>少康中兴</strong></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">季杼</td>\n<td align=\"left\">前1855年-前1836年（17年）</td>\n<td align=\"left\">参加过复兴夏朝的战争</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">槐&#x2F;帝芬</td>\n<td align=\"left\">前1836年-前1790年（44年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">芒</td>\n<td align=\"left\">前1790年-前1732年（18年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">泄&#x2F;帝降</td>\n<td align=\"left\">前1732年-前1706年（21年）</td>\n<td align=\"left\">正式赐封九夷各部诸侯爵位</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">不降</td>\n<td align=\"left\">前1706年-前1644（59年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">扃</td>\n<td align=\"left\">前1644年-前1626年（21年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">廑</td>\n<td align=\"left\">前1626年-前1615年（20年）</td>\n<td align=\"left\">夏国开始衰落</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">孔甲</td>\n<td align=\"left\">前1615年-前1604年（31年）</td>\n<td align=\"left\">胡作非为的残暴昏君</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">皋</td>\n<td align=\"left\">前1604年-前1599年（11年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">发</td>\n<td align=\"left\">前1599年-前1590年（19年）</td>\n<td align=\"left\">各方诸侯已不来朝贺</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">桀</td>\n<td align=\"left\">前1590年-前1559年（52年）</td>\n<td align=\"left\">暴君，被商汤灭，亡国</td>\n</tr>\n</tbody></table>\n<h1 id=\"2、涂山之会\"><a href=\"#2、涂山之会\" class=\"headerlink\" title=\"2、涂山之会\"></a>2、涂山之会</h1><p>&emsp;&emsp;涂山之会被认为是中国夏朝建立的标志性事件。禹为了巩固王权，禹在淮水中游的涂山(今安徽埠西郊怀远县) 召开大会。夏、夷诸部众多邦国和部落的首领一起参会，史称涂山之会。<br>大会后，诸部落首领为表敬意，常来都城献“金”(即青铜) 。后来，九州所贡之铜年年增多，大禹想起从前黄帝轩辕氏功成铸鼎。为了纪念涂山大会，就将各州所贡之金，就拿来铸该州的鼎，将该州内的山川形势都铸在上面。即冀州鼎、充州鼎、青州鼎、徐州鼎、扬州鼎、荆州鼎、<strong>豫州鼎（河南）</strong>、梁州鼎、雍州鼎。鼎上铸着各种山川名物、奇禽异兽。九鼎象征着九坐，其中豫州鼎为中央大鼎，豫州即为中央枢纽。九鼎集中在夏王朝都城<strong>阳城</strong>，借以显示夏王大禹成为九州之主，天下从此一统。大禹把九鼎称为镇国之宝，各方诸侯来朝见时，都要向九鼎顶礼膜拜。从此，九鼎成为国家最重要的礼器。</p>\n<h1 id=\"3、太康失国，少康中兴\"><a href=\"#3、太康失国，少康中兴\" class=\"headerlink\" title=\"3、太康失国，少康中兴\"></a>3、太康失国，少康中兴</h1><p>&emsp;&emsp;启死后，他的儿子太康继承了王位，成天只顾打猎、游玩、宴饮，不管朝政。这样昏聘无能的王使民众感到十分愤怒，其他部落也都对他非常不满。东夷族趁此机会开始大肆西进。东夷族有穷氏当时的首领叫做<strong>羿</strong>，也有人管他叫夷羿、后羿。有一次，太康去洛水南面打猎，去了一百天都还没回来，羿就看准了这次机会，带兵趁机占领了夏朝的国都，得到夏民的拥护，赶走了太康。这件事在历史上被称为“太康失国”，也叫“后羿代夏”。<br>&emsp;&emsp;后羿的射箭技术非常出名，在夺取了夏朝的政权之后，他重蹈了太康的覆辙。后羿仗着自己射箭的本领天天在原野之中打猎玩乐，也不处理王朝中的事务。不去重用朝中那些有贤能的大臣，反而将政事交给了自己身边一个叫做<strong>寒浞</strong>的亲信。寒浞的奸诈在伯明氏中可是远近闻名，他一边对后羿奉承谄媚，一边用小恩小惠来收买人心，骗取民众的信任与支持。寒浞的权力越来越大，终于，他买通了后羿的亲信随从，趁后羿出去打猎之时杀害了后羿，还霸占了后羿的妻妾和财产，夺得了统治权。但这场关于权力的杀戮还远远没有停止。<br>&emsp;&emsp;太康被放逐后不久就死去了，虽然他不再是部落联盟的王，但是相对于自己的部落来说，他还是首领。太康死后，他的弟弟仲康继任首领，但部落的力量实在太弱小，没有复国之力。仲康死后，他的儿子<strong>相</strong>继任了部落首领的位置。<br>&emsp;&emsp;寒浞杀死后羿后，开始疯狂地消除亲夏的势力，相也被杀死于帝丘。相的妻子此时已经怀有身孕，在这危机的混战之中，她从墙洞中仓皇出逃，一路逃回了自己的娘家一一有仍氏(今山东金乡境)，并在那里生下了少康，但是寒浞不打算就此收手。<br>&emsp;&emsp;少康长大之后，在有仍氏做牧正（主管畜牧）。浇听说相的后代还活着，就派人去追捕少康，少康紧急逃往有虞氏(今河南虞城)，有虞氏的首领很看好少康，让他担任掌管饮食的庖正，还给他娶了妻子，分了土地和民众。有了封地和人口，少康开始积极联络夏朝的余众潜心筹备复国。民众们也已经看透了寒浞实际上是一个没有德行，奸诈虚伪的人。最终，少康联合夏朝的旧臣<strong>伯靡</strong>，灭掉了寒捉和有穷氏，少康被拥立为夏王，重新恢复了夏朝。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、夏朝年表\"><a href=\"#1、夏朝年表\" class=\"headerlink\" title=\"1、夏朝年表\"></a>1、夏朝年表</h1><p>夏朝（约前2070年－约前1600年，473年）是中国历史记载的第一个中原部族世袭制朝代</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时长</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">禹</td>\n<td align=\"left\">前2029年-前1982年（46年）</td>\n<td align=\"left\"><strong>涂山大会</strong>，铸造九鼎，象征九州，第一次有了国家的概念</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">启</td>\n<td align=\"left\">前1982年-前1963年（29年）</td>\n<td align=\"left\">由禅让制变为世袭制，击败了有扈氏的反抗</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">太康</td>\n<td align=\"left\">前1963年-前1955年（29年）</td>\n<td align=\"left\">不理朝政，被有穷氏后羿夺权，<strong>太康失国</strong>，实际在位2年</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">仲康</td>\n<td align=\"left\">前1955年-前1946年（13年）</td>\n<td align=\"left\">后羿专权，仲康反抗失败被软禁，抑郁而终</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">相</td>\n<td align=\"left\">前1946年-前1916年（28年）</td>\n<td align=\"left\">被寒浞的儿子浇攻破自刎，大臣寒浞杀后羿夺权</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">少康&#x2F;杜康</td>\n<td align=\"left\">前1876年-前1855年（22年）</td>\n<td align=\"left\">相的遗腹子，攻杀寒浞，复国，<strong>少康中兴</strong></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">季杼</td>\n<td align=\"left\">前1855年-前1836年（17年）</td>\n<td align=\"left\">参加过复兴夏朝的战争</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">槐&#x2F;帝芬</td>\n<td align=\"left\">前1836年-前1790年（44年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">芒</td>\n<td align=\"left\">前1790年-前1732年（18年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">泄&#x2F;帝降</td>\n<td align=\"left\">前1732年-前1706年（21年）</td>\n<td align=\"left\">正式赐封九夷各部诸侯爵位</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">不降</td>\n<td align=\"left\">前1706年-前1644（59年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">扃</td>\n<td align=\"left\">前1644年-前1626年（21年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">廑</td>\n<td align=\"left\">前1626年-前1615年（20年）</td>\n<td align=\"left\">夏国开始衰落</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">孔甲</td>\n<td align=\"left\">前1615年-前1604年（31年）</td>\n<td align=\"left\">胡作非为的残暴昏君</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">皋</td>\n<td align=\"left\">前1604年-前1599年（11年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">发</td>\n<td align=\"left\">前1599年-前1590年（19年）</td>\n<td align=\"left\">各方诸侯已不来朝贺</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">桀</td>\n<td align=\"left\">前1590年-前1559年（52年）</td>\n<td align=\"left\">暴君，被商汤灭，亡国</td>\n</tr>\n</tbody></table>\n<h1 id=\"2、涂山之会\"><a href=\"#2、涂山之会\" class=\"headerlink\" title=\"2、涂山之会\"></a>2、涂山之会</h1><p>&emsp;&emsp;涂山之会被认为是中国夏朝建立的标志性事件。禹为了巩固王权，禹在淮水中游的涂山(今安徽埠西郊怀远县) 召开大会。夏、夷诸部众多邦国和部落的首领一起参会，史称涂山之会。<br>大会后，诸部落首领为表敬意，常来都城献“金”(即青铜) 。后来，九州所贡之铜年年增多，大禹想起从前黄帝轩辕氏功成铸鼎。为了纪念涂山大会，就将各州所贡之金，就拿来铸该州的鼎，将该州内的山川形势都铸在上面。即冀州鼎、充州鼎、青州鼎、徐州鼎、扬州鼎、荆州鼎、<strong>豫州鼎（河南）</strong>、梁州鼎、雍州鼎。鼎上铸着各种山川名物、奇禽异兽。九鼎象征着九坐，其中豫州鼎为中央大鼎，豫州即为中央枢纽。九鼎集中在夏王朝都城<strong>阳城</strong>，借以显示夏王大禹成为九州之主，天下从此一统。大禹把九鼎称为镇国之宝，各方诸侯来朝见时，都要向九鼎顶礼膜拜。从此，九鼎成为国家最重要的礼器。</p>\n<h1 id=\"3、太康失国，少康中兴\"><a href=\"#3、太康失国，少康中兴\" class=\"headerlink\" title=\"3、太康失国，少康中兴\"></a>3、太康失国，少康中兴</h1><p>&emsp;&emsp;启死后，他的儿子太康继承了王位，成天只顾打猎、游玩、宴饮，不管朝政。这样昏聘无能的王使民众感到十分愤怒，其他部落也都对他非常不满。东夷族趁此机会开始大肆西进。东夷族有穷氏当时的首领叫做<strong>羿</strong>，也有人管他叫夷羿、后羿。有一次，太康去洛水南面打猎，去了一百天都还没回来，羿就看准了这次机会，带兵趁机占领了夏朝的国都，得到夏民的拥护，赶走了太康。这件事在历史上被称为“太康失国”，也叫“后羿代夏”。<br>&emsp;&emsp;后羿的射箭技术非常出名，在夺取了夏朝的政权之后，他重蹈了太康的覆辙。后羿仗着自己射箭的本领天天在原野之中打猎玩乐，也不处理王朝中的事务。不去重用朝中那些有贤能的大臣，反而将政事交给了自己身边一个叫做<strong>寒浞</strong>的亲信。寒浞的奸诈在伯明氏中可是远近闻名，他一边对后羿奉承谄媚，一边用小恩小惠来收买人心，骗取民众的信任与支持。寒浞的权力越来越大，终于，他买通了后羿的亲信随从，趁后羿出去打猎之时杀害了后羿，还霸占了后羿的妻妾和财产，夺得了统治权。但这场关于权力的杀戮还远远没有停止。<br>&emsp;&emsp;太康被放逐后不久就死去了，虽然他不再是部落联盟的王，但是相对于自己的部落来说，他还是首领。太康死后，他的弟弟仲康继任首领，但部落的力量实在太弱小，没有复国之力。仲康死后，他的儿子<strong>相</strong>继任了部落首领的位置。<br>&emsp;&emsp;寒浞杀死后羿后，开始疯狂地消除亲夏的势力，相也被杀死于帝丘。相的妻子此时已经怀有身孕，在这危机的混战之中，她从墙洞中仓皇出逃，一路逃回了自己的娘家一一有仍氏(今山东金乡境)，并在那里生下了少康，但是寒浞不打算就此收手。<br>&emsp;&emsp;少康长大之后，在有仍氏做牧正（主管畜牧）。浇听说相的后代还活着，就派人去追捕少康，少康紧急逃往有虞氏(今河南虞城)，有虞氏的首领很看好少康，让他担任掌管饮食的庖正，还给他娶了妻子，分了土地和民众。有了封地和人口，少康开始积极联络夏朝的余众潜心筹备复国。民众们也已经看透了寒浞实际上是一个没有德行，奸诈虚伪的人。最终，少康联合夏朝的旧臣<strong>伯靡</strong>，灭掉了寒捉和有穷氏，少康被拥立为夏王，重新恢复了夏朝。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clkqz2ipo00016wujfu6w1t53","category_id":"clkqz2ips00046wuj2bs2cmdw","_id":"clkqz2ipw000b6wuj2ctf8jmi"},{"post_id":"clkqz2ipr00036wujakd1hodm","category_id":"clkqz2ips00046wuj2bs2cmdw","_id":"clkqz2ipw000d6wujewvzgxwv"},{"post_id":"clkqz2ipy000l6wuj0n09fuct","category_id":"clkqz2ips00046wuj2bs2cmdw","_id":"clkqz2ipz000q6wuj54a65drj"},{"post_id":"clkqz2ipy000m6wuj99s3boqi","category_id":"clkqz2ips00046wuj2bs2cmdw","_id":"clkqz2iq0000t6wujdmywhdm1"},{"post_id":"clkqz2iq0000s6wujf05mfl1a","category_id":"clkqz2ips00046wuj2bs2cmdw","_id":"clkqz2iq1000z6wujh7xd05yt"},{"post_id":"clkqz2iq0000w6wuj6bt96j42","category_id":"clkqz2iq0000r6wujcuwk38p3","_id":"clkqz2iq100116wujdug566n8"},{"post_id":"clkqz2ipz000o6wujdlwx2mrl","category_id":"clkqz2iq0000r6wujcuwk38p3","_id":"clkqz2iq200136wujhnxvdqsr"},{"post_id":"clkqz2ipz000p6wuj2a3ibc9o","category_id":"clkqz2iq0000r6wujcuwk38p3","_id":"clkqz2iq200156wuj3tq677p3"}],"PostTag":[{"post_id":"clkqz2ipo00016wujfu6w1t53","tag_id":"clkqz2ipt00056wujgerpdjym","_id":"clkqz2ipw000f6wujb0sygtfd"},{"post_id":"clkqz2ipo00016wujfu6w1t53","tag_id":"clkqz2ipu000a6wuj5e609ki8","_id":"clkqz2ipw000g6wujdypi4jhf"},{"post_id":"clkqz2ipo00016wujfu6w1t53","tag_id":"clkqz2ipw000c6wujdrkh6d58","_id":"clkqz2ipw000i6wuj3b2i1vta"},{"post_id":"clkqz2ipr00036wujakd1hodm","tag_id":"clkqz2ipw000e6wuj8kg89gpl","_id":"clkqz2ipw000j6wujcnj61oc3"},{"post_id":"clkqz2ipr00036wujakd1hodm","tag_id":"clkqz2ipw000h6wujapqeeqcc","_id":"clkqz2ipw000k6wuj30666gty"},{"post_id":"clkqz2ipy000l6wuj0n09fuct","tag_id":"clkqz2ipz000n6wujaxy29wwb","_id":"clkqz2iq0000v6wuj2frj9qxc"},{"post_id":"clkqz2ipy000m6wuj99s3boqi","tag_id":"clkqz2iq0000u6wuja3k07d8s","_id":"clkqz2iq100106wujgrmu3y7i"},{"post_id":"clkqz2ipz000o6wujdlwx2mrl","tag_id":"clkqz2iq1000y6wujglr42p8l","_id":"clkqz2iq200146wuj365gf6vv"},{"post_id":"clkqz2ipz000p6wuj2a3ibc9o","tag_id":"clkqz2iq1000y6wujglr42p8l","_id":"clkqz2iq200186wujhjbkhdvs"},{"post_id":"clkqz2ipz000p6wuj2a3ibc9o","tag_id":"clkqz2iq200166wuj9rkvfmp2","_id":"clkqz2iq200196wujf9ti7iyx"},{"post_id":"clkqz2iq0000s6wujf05mfl1a","tag_id":"clkqz2iq200176wuj8m4e2s57","_id":"clkqz2iq2001c6wujfv3h4cgu"},{"post_id":"clkqz2iq0000s6wujf05mfl1a","tag_id":"clkqz2iq2001a6wuj7jko1rac","_id":"clkqz2iq2001d6wuj757f35ri"},{"post_id":"clkqz2iq0000w6wuj6bt96j42","tag_id":"clkqz2iq1000y6wujglr42p8l","_id":"clkqz2iq2001e6wuj8kg911qc"}],"Tag":[{"name":"juc","_id":"clkqz2ipt00056wujgerpdjym"},{"name":"多线程","_id":"clkqz2ipu000a6wuj5e609ki8"},{"name":"并发编程","_id":"clkqz2ipw000c6wujdrkh6d58"},{"name":"RabbitMQ","_id":"clkqz2ipw000e6wuj8kg89gpl"},{"name":"消息队列","_id":"clkqz2ipw000h6wujapqeeqcc"},{"name":"spring","_id":"clkqz2ipz000n6wujaxy29wwb"},{"name":"nginx","_id":"clkqz2iq0000u6wuja3k07d8s"},{"name":"中国历史","_id":"clkqz2iq1000y6wujglr42p8l"},{"name":"商朝","_id":"clkqz2iq200166wuj9rkvfmp2"},{"name":"springCloud","_id":"clkqz2iq200176wuj8m4e2s57"},{"name":"编程基础","_id":"clkqz2iq2001a6wuj7jko1rac"}]}}
=======
{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/custom.css","path":"css/custom.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/foot.js","path":"js/foot.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/css/LXGWZhenKai.ttf","path":"css/LXGWZhenKai.ttf","modified":0,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"0ba2ea8a346b2e193945de5bc8f9d9aa4a81461b","modified":1690265412000},{"_id":"source/README.md","hash":"3cf29680a7f1c21572333cf7cf2029c6c567e670","modified":1690248645293},{"_id":"source/_posts/JUC.md","hash":"b9be4bd0c047e351e37b1d782f540609d1b0b0bf","modified":1690253750559},{"_id":"source/_posts/RabbitMQ.md","hash":"52953d4711ed73a7e5f1b7be27dea60f8a99ae4c","modified":1690350149957},{"_id":"source/categories/index.md","hash":"2f5289cf24818f4762f158fd603bdc47ca3cf1bf","modified":1689725262532},{"_id":"source/_posts/nginx.md","hash":"513bf212c4d7480d99541e0e37d4e87755215b10","modified":1690253750561},{"_id":"source/_posts/spring.md","hash":"c8029f842f33eb42192a9858060f82701f5d11fb","modified":1690253750563},{"_id":"source/about/index.md","hash":"c1d344f09e319216d06e80750c3e5a23068bafff","modified":1690253700284},{"_id":"source/tags/index.md","hash":"537fa92c4d8d77af6f4a699df28695fe0c9a6565","modified":1689725262572},{"_id":"source/css/custom.css","hash":"72b3900fac2a8af003a1bf4abba69dcfa6251f22","modified":1689725262564},{"_id":"themes/butterfly/package.json","hash":"a6a032654a36408d7b7274bc9cfe21f89946d29c","modified":1689725262610},{"_id":"themes/butterfly/README_CN.md","hash":"f6ae7f38d016135340fd25c5fd1be65452b6773d","modified":1689725262574},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1689725262573},{"_id":"themes/butterfly/README.md","hash":"5ca893c78f8971f512da55c785b8ccbfa9d37cfc","modified":1689725262574},{"_id":"themes/butterfly/languages/en.yml","hash":"4957fd976c99745d3aa24000a85b2955e8d1cf81","modified":1689725262575},{"_id":"themes/butterfly/languages/default.yml","hash":"d444cbb5c5456aaf27f3fb1b4308634689c7bb53","modified":1689725262575},{"_id":"themes/butterfly/_config.yml","hash":"818dc0782ca6713379e164e2741cb9578d29b0fd","modified":1690350493462},{"_id":"themes/butterfly/plugins.yml","hash":"6d68dab3b79accb1bceb4710c8aaab724a45053a","modified":1689725262610},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1689725262576},{"_id":"themes/butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1689725262576},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1689725262609},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1689725262611},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1689725262609},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1689725262611},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1689725262609},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1689725262611},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"145ec301db185c8a06de1f34a77ca391e1d2729b","modified":1689725262576},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1689725262612},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1689725262611},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1689725262609},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1689725262612},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1689725262612},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1689725262613},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1689725262613},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a3323fcb11cfd3f3e21230737341beb5d76b40aa","modified":1689725262613},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"8ff03b35385f9162e1eb54dceb5fa7f781306caf","modified":1689725262614},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"6005907245dd74b153f03afdccfae1abb66bb482","modified":1689725262614},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"cc8672dc0c2762b694f689cbeb6e34810f1c194e","modified":1689725262575},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"7222102f9919f8e961d4f1688425845fb7775ada","modified":1689725262614},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1689725262615},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1689725262615},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1689725262615},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1689725262616},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"b8d95ac1851c37f1dce4b1dd4a1d3ffdff501a03","modified":1689725262616},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1689725262616},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1689725262617},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1689725262617},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1689725262617},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"fc5a80707cf522378be3cf8638ef78bccc88c510","modified":1689725262617},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1689725262618},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1689725262618},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1689725262634},{"_id":"themes/butterfly/source/css/var.styl","hash":"e1e37a2e932163886789b72624c7348545003f1d","modified":1689725262634},{"_id":"themes/butterfly/source/css/custom.css","hash":"941d80e05e34f710eb978e0040ab14e3a6f727bf","modified":1689725262633},{"_id":"themes/butterfly/source/js/foot.js","hash":"65cf405d3e3e37682062d948924d8101b566e31b","modified":1689725262636},{"_id":"themes/butterfly/source/js/main.js","hash":"4fd1cd7a02dedcb686caf6149c35fd8e1fbcafc9","modified":1689725262637},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"a102a6cacf7b20183946a54580867a964f3674c4","modified":1689725262638},{"_id":"themes/butterfly/source/img/avatar.jpg","hash":"bbf597f4a75a617bed638ac124502fd76068f62b","modified":1689725262635},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1689725262577},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1689725262635},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1689725262577},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1689725262636},{"_id":"themes/butterfly/source/js/utils.js","hash":"13b2b02118a0f4ec2e9e0bb1b90f5b1a30a70f44","modified":1689725262639},{"_id":"themes/butterfly/source/img/favicon.png","hash":"f17fd89a2e05a689c4f5481be9ea6b09f7b8d945","modified":1689725262635},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1689725262585},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"e334a2688ca1ae9095dd4058710fc5eaf1353cca","modified":1690253516787},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"c55f05400eb27ab051f47396ec8d4249ce6f71ec","modified":1689725262586},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1689725262587},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"431b4a252443e224872bd6b4f6aa76ed1679a82c","modified":1689725262619},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1689725262577},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"9066a62e442affce3a923a06a90486bf9d364e0e","modified":1689725262626},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"e43017dbc73e0ce95dcfcb9dfb4fcce0c1715dd4","modified":1689725262620},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"3969f599e8657adf8c3ce287d83f5d0a23f276a9","modified":1689725262622},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1689725262623},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"4c86c10f8ec0c8fb60b400a5a2f14699d3155be4","modified":1689725262627},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1689725262619},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1689725262623},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"20303c0dad28e5c5335ce2fa6582f1fafae5b628","modified":1689725262624},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"e2869b71266bd49285f22da89560d875e8c61541","modified":1689725262623},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1689725262582},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1689725262624},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1689725262625},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc029f5e00d7904c0878efd20dd4e09fc55e1d03","modified":1689725262625},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1689725262622},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1689725262626},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1689725262625},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"824b2b2d2ee72583b9e009c0bb13e29e806534cc","modified":1689725262625},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1689725262628},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1689725262626},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1689725262624},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1689725262627},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1689725262627},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1689725262629},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1689725262628},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"57d333ef47bfb8fd22da31f600527c9d91e8e322","modified":1689725262629},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1689725262628},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1689725262633},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1689725262630},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1689725262631},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1689725262631},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"7c463ba25b3b54f0f46dfd75971d792816e942a8","modified":1689725262631},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1689725262632},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1689725262633},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1689725262632},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1689725262632},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1689725262633},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1689725262630},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1689725262629},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1689725262630},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"bbe930d8425bdaee2a5ba3cade42b617cee42934","modified":1689725262638},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"40e76d6da538cb3c1ef6b79ffc0adfa64fe6b8ba","modified":1689725262638},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1689725262581},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1689725262581},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1689725262581},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1689725262583},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1689725262582},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1689725262583},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1689725262583},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1689725262585},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1689725262582},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1689725262585},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1689725262584},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"3adb731465a4ab14529277fd7867889e0800ad16","modified":1689725262584},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1689725262584},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1689725262586},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1689725262585},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1689725262578},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1689725262586},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1689725262580},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1689725262580},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1689725262579},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1689725262578},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1689725262579},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"f5207840c96df6b26ad227433babca4f8c362624","modified":1689725262579},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1689725262580},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1689725262580},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1689725262588},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1689725262601},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1689725262605},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1689725262601},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1689725262605},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"82bb447a5d045980789cf3f9de9d49cc32011b13","modified":1689725262601},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1689725262604},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1689725262605},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1689725262607},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1689725262597},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1689725262606},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1689725262606},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1689725262607},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1689725262606},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"ba94ceb40d7c81372a76103d958dcc2cc6a84f00","modified":1689725262608},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1689725262607},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1689725262608},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1689725262607},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1689725262608},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1689725262620},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1689725262621},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1689725262621},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"0010c7a10d265c4329f0fd4db85b4a9ea7ba06b5","modified":1689725262588},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1689725262621},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1689725262622},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1689725262588},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1689725262592},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1689725262592},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1689725262591},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1689725262592},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f8b73bc63ec1b45d86aa3891d8c81ef4d5980943","modified":1689725262593},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1689725262592},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b19b123df682b23491b17dcca386d79062cd8f6e","modified":1689725262594},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"b47698e153c73cb29286b19bec5ddd920cb7ffba","modified":1689725262593},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1689725262593},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a56edeb1ce2f1b1fb0e866a30543f274b9f7d69e","modified":1689725262594},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"1a20b11fa0e6b1943e9b4d81e197a25ca36af66d","modified":1689725262594},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"7c7fbe27d82becc9ee509765f1195c69f5864a0b","modified":1689725262595},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1689725262595},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"c5e131d65a7ad30f3cb98ac3b94cd2f6a94c22e9","modified":1689725262595},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1689725262595},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f618457d62ef35d78a31e7fb1e375a462f64b228","modified":1689725262596},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"386a2b371644c2682560733617561ba6e6bf9ab2","modified":1689725262596},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4bb4cf58e219dfb8787273c931b1ea978b2ab88f","modified":1689725262596},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1689725262589},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"6b0d28671afd5ed286a714f25ba16256a2e7d880","modified":1689725262597},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1689725262596},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1689725262589},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1689725262589},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1689725262590},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1689725262590},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"c42bbce31fcd8846cf3360f4c383dec9368daeba","modified":1689725262591},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1689725262589},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1689725262598},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1689725262597},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1689725262604},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1689725262590},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1689725262603},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1689725262604},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1689725262603},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1689725262598},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"da94966a9650ef3e4c69f3ee93758b30fa42cb78","modified":1689725262598},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1689725262599},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1689725262599},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1689725262599},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1689725262600},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1689725262599},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1689725262602},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1689725262600},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1689725262600},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"ba04174d977da988a1d49c06641262c413352346","modified":1689725262602},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1689725262602},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1689725262603},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"2f3af113713563e34b10bbe998cc15008f81c85a","modified":1689725262601},{"_id":"themes/butterfly/source/js/jquery.js","hash":"aab820a7c9bb693c5df41f9886179eba2649b028","modified":1689725262637},{"_id":"source/css/LXGWZhenKai.ttf","hash":"3e173155b120631bbf5c7a7921308977bdd48cf2","modified":1689725262563},{"_id":"public/css/custom.css","hash":"d6a18ee419b53590c6c6f241718b63c380658959","modified":1690350147092},{"_id":"public/search.xml","hash":"648313aa16b7996d4e77d4ec7acace9cf13b0035","modified":1690528083099},{"_id":"public/README.html","hash":"766627ff9d5e1744871cb75de66fac0b7f66cc7e","modified":1690528083099},{"_id":"public/categories/index.html","hash":"1fd22032bd057ab7bf653d25b5aa90c10428fb9e","modified":1690528083099},{"_id":"public/tags/index.html","hash":"a19b3cc11c9c9d03921a8d0b4d147e579f1e9b85","modified":1690528083099},{"_id":"public/archives/index.html","hash":"479d1b4607784b93a7aa7f1bd1bbf24b59f8ab54","modified":1690528083099},{"_id":"public/archives/2023/index.html","hash":"8f957debcd7974df018153df6e84dee382217e81","modified":1690528083099},{"_id":"public/archives/2023/07/index.html","hash":"4fe8d2e4110d2e879ffbbc4cff314b56208eb0b6","modified":1690528083099},{"_id":"public/categories/coding/index.html","hash":"6f01e3d7c41647211494bc2c68d2d8cc4e8c0d7b","modified":1690528083099},{"_id":"public/tags/juc/index.html","hash":"bc5e986b05b63af29c0959570d50c44cdb51d25d","modified":1690528083099},{"_id":"public/tags/多线程/index.html","hash":"51a6db3c65c1944dbbe09c27d2f732446b08a356","modified":1690528083099},{"_id":"public/tags/并发编程/index.html","hash":"c78347775463172b7991455367c30c241013918b","modified":1690528083099},{"_id":"public/tags/RabbitMQ/index.html","hash":"5e02f11ef2b5f279078bfbb04a346e8f7364feea","modified":1690528083099},{"_id":"public/tags/消息队列/index.html","hash":"e10118e47a0c81c58191e98cc080df0ce9dcf21f","modified":1690528083099},{"_id":"public/tags/编程基础/index.html","hash":"57876d2d8e5ac6d711a75af7ab3836b7a7c54420","modified":1690528083099},{"_id":"public/tags/nginx/index.html","hash":"8234bdc97c4bc83d9aecd5a51c8fe78cebc4f04a","modified":1690528083099},{"_id":"public/tags/spring/index.html","hash":"9cf96099f1c86014a85e71e249604156739c5165","modified":1690528083099},{"_id":"public/about/index.html","hash":"9c2e3ae999522cec3ca55167b3e2daebcf931cdb","modified":1690528083099},{"_id":"public/posts/33708.html","hash":"1ac3702f571ac76e6c8eff538333bb11d8ffab35","modified":1690528083099},{"_id":"public/posts/9964.html","hash":"9141fc93972cf188d0d33cb365749810fb3740b8","modified":1690528083099},{"_id":"public/posts/42310.html","hash":"c0a8c39c5ede26038a16d1e9d98e806dc28506bc","modified":1690528083099},{"_id":"public/posts/58122.html","hash":"2f6727ebe82ead39500732b8881610937ea74dfe","modified":1690528083099},{"_id":"public/index.html","hash":"7070b96693fefce5f7e82b7323c15616db644b10","modified":1690528083099},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1690350147092},{"_id":"public/img/avatar.jpg","hash":"bbf597f4a75a617bed638ac124502fd76068f62b","modified":1690350147092},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1690350147092},{"_id":"public/img/favicon.png","hash":"f17fd89a2e05a689c4f5481be9ea6b09f7b8d945","modified":1690350147092},{"_id":"public/CNAME","hash":"0ba2ea8a346b2e193945de5bc8f9d9aa4a81461b","modified":1690350147092},{"_id":"public/js/foot.js","hash":"c5462aab335dca72e6cc7e4427e3e4996b9357c5","modified":1690350147092},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1690350147092},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1690350147092},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1690350147092},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1690350147092},{"_id":"public/css/index.css","hash":"b3e22c48b65075f4ee8c026344f026c25fe18c8d","modified":1690350147092},{"_id":"public/js/jquery.js","hash":"0fa72756e48c33a6feeace1ffa5d790d58b53729","modified":1690350147092},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1690350147092},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1690350147092},{"_id":"public/css/LXGWZhenKai.ttf","hash":"3e173155b120631bbf5c7a7921308977bdd48cf2","modified":1690350147092},{"_id":"source/_posts/中国历史年表.md","hash":"4e1021e05f815bb91736d31b9c81c6890f872bb9","modified":1690528086035},{"_id":"public/posts/0.html","hash":"6068dee15fdf3d56bfaeb19f4e0af38aaa92fff7","modified":1690528083099}],"Category":[{"name":"coding","_id":"clkjau31h0003igumhspqcsqz"}],"Data":[],"Page":[{"_content":"my blog","source":"README.md","raw":"my blog","date":"2023-07-25T01:30:45.293Z","updated":"2023-07-25T01:30:45.293Z","path":"README.html","title":"","comments":1,"layout":"page","_id":"clkjau31b0000igum5jrm4xnq","content":"<p>my blog</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>my blog</p>\n"},{"title":"关于","date":"2023-07-15T01:31:31.000Z","_content":"\n<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，也会更加注重内容的排版布局\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果某篇文章对你有些帮助，那我的目的就达到了","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2023-07-15 09:31:31\n---\n\n<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，也会更加注重内容的排版布局\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果某篇文章对你有些帮助，那我的目的就达到了","updated":"2023-07-25T02:55:00.284Z","path":"about/index.html","comments":1,"layout":"page","_id":"clkjau31g0002igum0oh142bf","content":"<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，也会更加注重内容的排版布局\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果某篇文章对你有些帮助，那我的目的就达到了","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，也会更加注重内容的排版布局\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果某篇文章对你有些帮助，那我的目的就达到了"},{"_content":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","source":"css/custom.css","raw":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","date":"2023-07-19T00:07:42.564Z","updated":"2023-07-19T00:07:42.564Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"clkjau31j0005igum6a262b6i","content":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","site":{"data":{}},"cover":false,"excerpt":"","more":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}"},{"title":"categories","date":"2023-07-14T17:44:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-07-15 01:44:20\ntype: \"categories\"\n---\n","updated":"2023-07-19T00:07:42.532Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clkjau31k0006igumdf011xw2","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"tags","date":"2023-07-15T01:31:31.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-07-15 09:31:31\ntype: \"tags\"\n---\n","updated":"2023-07-19T00:07:42.572Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clkjau31m000digum0lf5g933","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"juc","date":"2023-07-14T16:00:00.000Z","abbrlink":42310,"_content":"# 1、java多线程基本概念\n## 1.1、进程和线程\n\n1. **进程**\n- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 \n- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 \n- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） \n\n2. **线程**\n- 一个进程之内可以分为一到多个线程。 \n- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 \n- **Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器**\n## 1.2、并发和并行\n并发：线程轮流使用CPU\n并行：多核cpu下，多个核同时调度运行线程\n\n## 1.3、多线程的应用\n### 1.3.1、异步调用\n比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 \n### 1.3.2、提升效率\n充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。\n```java\n计算 1 花费 10 ms\n计算 2 花费 11 ms\n计算 3 花费 9 ms\n汇总需要 1 ms\n```\n\n- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms \n- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms \n\n> 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n\n# 2、java线程\n## 2.1、线程的创建\n### 2.1.1、直接使用Thread\n```java\n// 创建线程对象\nThread t = new Thread() {\n    public void run() {\n        // 要执行的任务\n    }\n};\n// 启动线程\nt.start();\n```\n### 2.1.2、使用 Runnable 配合 Thread \n```java\nRunnable runnable = new Runnable() {\n    public void run(){\n        // 要执行的任务\n    }\n};\n// 创建线程对象\nThread t = new Thread( runnable );\n// 启动线程\nt.start();\n```\njava8可用lambda精简\n```java\n// 创建任务对象\nRunnable task2 = () -> log.debug(\"hello\");\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nThread t2 = new Thread(task2, \"t2\");\nt2.start();\n```\n### 2.1.3、FutureTask 配合 Thread \nFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\n\n```java\n// 创建任务对象\nFutureTask<Integer> task3 = new FutureTask<>(() -> {\n    log.debug(\"hello\");\n    return 100;\n});\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nnew Thread(task3, \"t3\").start();\n\n// 主线程阻塞，同步等待 task 执行完毕的结果\nInteger result = task3.get();\nlog.debug(\"结果是:{}\", result);\n```\n## 2.2、查看进程线程\n### 2.2.1、windows\n\n1. tasklist 查看进程 \n2. taskkill 杀死进程 \n3. netstat -ano|findstr 8080 根据端口查看进程\n### 2.2.2、linux\n\n1. ps -fe 查看所有进程 \n2. kill 杀死进程\n3.  top -Hp <PID> 查看某个进程（PID）的所有线程 \n4. netstat -nlp|grep 8080 根据端口查看进程\n### 2.2.3、JDK\n\n1. jps 命令查看所有 Java 进程\n2.  jstack <PID> 查看某个 Java 进程（PID）的所有线程状态\n3.  jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）\n\n## 2.3、线程运行原理\n\n1. **线程创建**\n\n每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成\n，栈帧对应着每次方法调用所占内存\n\n2. **上下文切换**\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 \n> 线程的 cpu 时间片用完 \n> 垃圾回收 \n> 有更高优先级的线程需要运行 \n> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 \n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 \n\n##  2.4、start与run\n\n- 直接调用 run 是在主线程中执行了 run，没有启动新的线程 \n- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n\n## 2.5、sleep 与 yield \n\n1. **sleep**\n- 1. 调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞） \n- 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException \n- 3. 睡眠结束后的线程未必会立刻得到执行 \n\n2. **yield**\n- 1. 调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程 \n- 2. 具体的实现依赖于操作系统的任务调度器 \n\n## 2.6、join\njoin：t1调用t2的join方法，会先执行t2，然后执行t1\n如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间\n```java\nstatic int r = 0;\npublic static void main(String[] args) throws InterruptedException {\n    test1();\n}\n\nprivate static void test1() throws InterruptedException {\n    log.debug(\"开始\");\n    Thread t1 = new Thread(() -> {\n        log.debug(\"开始\");\n        sleep(1);\n        log.debug(\"结束\");\n        r = 10;\n    });\n    t1.start();\n    // t1.join();\n    log.debug(\"结果为:{}\", r);\n    log.debug(\"结束\");\n}\n```\n> 如果不加t1.join()结果为0，加上以后结果为1\n\n\n## 2.7、interrupt\n### 2.7.1、打断阻塞状态的线程\nsleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断\n```java\nprivate static void test1() throws InterruptedException {\n    Thread t1 = new Thread(()->{\n        sleep(1);\n    }, \"t1\");\n    t1.start();\n    sleep(0.5);\n    t1.interrupt();\n    log.debug(\" 打断状态: {}\", t1.isInterrupted());\n}\n```\n输出\n```java\njava.lang.InterruptedException: sleep interrupted\n     at java.lang.Thread.sleep(Native Method)\n     at java.lang.Thread.sleep(Thread.java:340)\n     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)\n     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)\n     at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)\n     at java.lang.Thread.run(Thread.java:745)\n21:18:10.374 [main] c.TestInterrupt - 打断状态: false\n```\n### 2.7.2、打断正常运行的线程\n打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）\n```java\nprivate static void test2() throws InterruptedException {\n    Thread t2 = new Thread(()->{\n        while(true) {\n            Thread current = Thread.currentThread();\n            boolean interrupted = current.isInterrupted();\n            if(interrupted) {\n                log.debug(\" 打断状态: {}\", interrupted);\n                break;\n            }\n        }\n    }, \"t2\");\n    t2.start();\n    sleep(0.5);\n    t2.interrupt();\n}\n```\n输出\n```java\n20:57:37.964 [t2] c.TestInterrupt - 打断状态: true \n```\n\n## 2.8、主线程与守护线程\n默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 \n\n例\n```java\nlog.debug(\"开始运行...\");\nThread t1 = new Thread(() -> {\n    log.debug(\"开始运行...\");\n    sleep(2);\n    log.debug(\"运行结束...\");\n}, \"daemon\");\n// 设置该线程为守护线程\nt1.setDaemon(true);\nt1.start();\n\nsleep(1);\nlog.debug(\"运行结束...\");\n```\n输出\n```java\n08:26:38.123 [main] c.TestDaemon - 开始运行... \n08:26:38.213 [daemon] c.TestDaemon - 开始运行... \n08:26:39.215 [main] c.TestDaemon - 运行结束...\n```\n\n> **注意 **\n> - 垃圾回收器线程就是一种守护线程 \n> - Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 \n\n\n## 2.9、线程状态\n| 状态   | 说明 |\n| --- | --- |\n| NEW | 初始状态:线程被创建，但还没有调用start()方法 |\n| RUNNABLE | 运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作\"运行\" |\n| BLOCKED | 阻塞状态:表示线程阻塞于锁 |\n| WAITING | 等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) |\n| TIMEWAITING | 超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的 |\n| TERMINATED | 终止状态:表示当前线程已经执行完毕 |\n\n![线程状态](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg)\n\n\n# 3、共享模型之管程\n管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的\n## 3.1、monitor\nMonitor 被翻译为**监视器**或**管程**\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针\n\n### 3.1.1、Monitor结构\n**结构**：owner  entryList  waitSet\n\n![monitor结构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg)\n\n\n### 3.1.2、Monitor原理\n（1）刚开始monitor中owner为null \n（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程 \n（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞 \n（4）t1执行完会唤醒entrylist中的某个线程（不公平）\n（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n## 3.2、java对象结构\n\n1. **对象头**\n\n包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）\n\n![java对象头](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg)\n\n\n2. **实例数据**\n\n实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息\n\n3. **对齐填充**\n\n对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。\n## 3.3、synchronized升级\n### 3.3.1、偏向锁\n> 使用场景：如果只有一个线程，就不需要每次的申请释放锁\n\n只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 \n### 3.3.2、轻量级锁\n> 使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化\n\n![轻量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg)\n\n\n\n1. 创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象\n2. 让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录\n3. 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁\n4. 如果 cas 失败，有两种情况  \n\n（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 \n（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）\n\n5. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一\n6. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 \n\n（1）成功，则解锁成功 \n（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\n### 3.3.3、重量级锁\n> 使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁\n\n![重量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg)\n\n\n1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\n2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 \n\n（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 \n（2）然后自己进入 Monitor 的 EntryList阻塞队列\n\n3. 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）\n\n> 调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n### 3.3.4、自旋锁\n重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)\n\n## 3.4、wait/notify\nOwner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争\n\n### 3.4.1、sleep和wait的区别？\n\n1.  sleep 是 Thread 方法，而 wait 是 Object 的方法 \n2.  sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 \n3.  sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 \n\n## 3.5、park/unpark\n它们是 LockSupport 类中的方法\n```java\n// 暂停当前线程\nLockSupport.park(); \n// 恢复某个线程的运行\nLockSupport.unpark(暂停线程对象)\n```\n\n### 3.5.1、与 Object 的 wait & notify 相比 \n\n- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\n- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 \n- park & unpark 可以先 unpark，而 wait & notify 不能先 notify \n\n### 3.5.2、原理\n每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex \n\n核心部分是counter，我们可以理解为一个标记位。\n当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。\n当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。\n## 3.6、死锁\n多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁\n### 3.6.1、死锁的必要条件\n\n1. 互斥条件：一个资源一次只能被一个进程使用\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放\n3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺\n4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系\n### 3.6.2、死锁的实现\n```java\n/**\n * 实现一个死锁\n * 如果把lock(target, owner);放到上面则不会死锁\n */\npublic class DeadLock {\n    public static void main(String[] args) throws InterruptedException {\n        final Object owner = new Object();\n        final Object target = new Object();\n        //开启一个新线程\n        new Thread(() -> {\n            try {\n                lock(owner, target);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        //主线程\n        lock(target, owner);\n    }\n    public static void lock(Object owner, Object target) throws InterruptedException {\n        synchronized (owner) {\n            Thread.sleep(1000);\n            synchronized (target) {\n                System.out.println(\"success\");\n            }\n        }\n    }\n}\n```\n### 3.6.3、定位死锁\n检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁\n### 3.6.4、哲学家就餐问题\n\n![哲学家就餐问题](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg)\n\n\n有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 \n\n1. 筷子类\n\n```java\nclass Chopstick {\n    String name;\n    \n    public Chopstick(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return \"筷子{\" + name + '}';\n    }\n}\n```\n\n2. 哲学家类\n\n```java\nclass Philosopher extends Thread {\n    Chopstick left;\n    Chopstick right;\n    \n    public Philosopher(String name, Chopstick left, Chopstick right) {\n        super(name);\n        this.left = left;\n        this.right = right;\n    }\n    \n    private void eat() {\n        log.debug(\"eating...\");\n        Sleeper.sleep(1);\n    }\n    \n    @Override\n    public void run() {\n        while (true) {\n            // 获得左手筷子\n            synchronized (left) {\n                // 获得右手筷子\n                synchronized (right) {\n                    // 吃饭\n                    eat();\n                }\n                // 放下右手筷子\n            }\n            // 放下左手筷子\n        }\n    }\n}\n```\n\n3. 就餐\n\n```java\nChopstick c1 = new Chopstick(\"1\");\nChopstick c2 = new Chopstick(\"2\");\nChopstick c3 = new Chopstick(\"3\");\nChopstick c4 = new Chopstick(\"4\");\nChopstick c5 = new Chopstick(\"5\");\n\nnew Philosopher(\"苏格拉底\", c1, c2).start();\nnew Philosopher(\"柏拉图\", c2, c3).start();\nnew Philosopher(\"亚里士多德\", c3, c4).start();\nnew Philosopher(\"赫拉克利特\", c4, c5).start();\nnew Philosopher(\"阿基米德\", c5, c1).start();\n```\n## 3.7、活锁\n两个线程互相改变对方的结束条件导致谁也无法结束\n> eg：共享变量count为10000, t1线程while count > 0, count-- ;t2线程while count < 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行\n\n\n## 3.8、**ReentrantLock**\n相对于 synchronized 它具备如下特点 \n\n1. 可中断 \n2. 可以设置超时时间 \n3. 可以设置为公平锁 （默认不公平）\n4. 支持多个条件变量 \n\n与 synchronized 一样，都支持可重入 \n# 4、共享模型之内存\n## 4.1、java内存模型（jmm）\nJava内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本\n## 4.2、线程安全性的三个体现\n**原子性**：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）\n**可见性**：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）\n**有序性**：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）\n# 5、共享模型之无锁\n## 5.1、CAS\n### 5.1.1、CAS基本概念\nCAS是所有原子类的底层原理，乐观锁主要采用CAS算法。\nCAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。\n> 1. CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性\n> 2. CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果\n\n\n### 5.1.2、CAS问题\n多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。\n\n**解决方案：**\n使用AtomicStampReference \nAtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验\n\n## 5.2、volatile\n### 5.2.1、如何保证可见性和有序性\n\n1. **保证可见性（缓存一致性协议MESI）**\n\n首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用**MESI协议**保证缓存一致性。\n如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu**总线嗅探机制**监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值\n\n> **M 修改** (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中\n**E 独享、互斥** (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。\n**S 共享** (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态\n**I 无效** (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态\n\n\n> 涉及到的指令\nlock(锁定)：将一个变量标识为被一个线程独占状态\nstore(存储)：作用于工作内存的变量,将变量传输到主内存中\nwrite(写入)：将store入主内存的变量,放入到主内存的变量中\n\n\n2. **保证有序性（禁止指令重排优化）**\n\n多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的\n内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序\n\n## 5.3、原子类\n| 类型   | 具体类 |\n| --- | --- |\n| Atomic 基本类型原子类   | AtomicInteger AtomicLong AtomicBoolean |\n| AtomicArray 数组类型原子类 | AtomicIntegerArray  AtomicLongArray AtomicReferenceArray |\n| AtomicReference 引用类型原子类 | AtomicReference AtomicStampedReference AtomicMarkableReference |\n| AtomicFieldUpdate 升级类型原子类 | AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater |\n\n\n# 6、共享模式之工具\n## 6.1、线程池\n### 6.1.1、**ThreadPoolExecutor**\n\n1. **构造方法**\n\n通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建\n\n> 1. corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。\n> 2. maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。\n> 3. keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。\n> 4. unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n> 5. workQueue：缓存队列，用来存放等待被执行的任务。\n> 6. threadFactory 线程工厂\n> 7. handler：拒绝策略\n（1）abortPolicy：抛出异常（默认）\n（2）discardPolicy：放弃本次任务\n（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代\n（4）callerrunPolicy：让调用者运行任务\n\n\n2. **工作原理**\n\n如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n如果当前线程池中正在执行任务的的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；\n如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；\n如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理\n### 6.1.2、Executors类中提供的工厂方法\n根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池\n\n1. **newFixedThreadPool**\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n> 特点：\n> - 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 \n> - 阻塞队列是无界的，可以放任意数量的任务 \n> \n评价：\n> 适用于任务量已知，相对耗时的任务\n\n\n2. **newCachedThreadPool**\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n> 特点 \n> - 核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 \n>    - 全部都是救急线程（60s 后可以回收）\n>    - 救急线程可以无限创建 \n> - 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）\n> \n评价：\n> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程\n> 适合任务数比较密集，但每个任务执行时间较短的情况\n\n\n3. newSingleThreadExecutor\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n使用场景： \n希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。\n任务执行完毕，这唯一的线程也不会被释放。 \n\n### 6.1.3、创建多大的线程池\n\n- 过小会导致程序不能充分地利用系统资源、容易导致饥饿 \n- 过大会导致更多的线程上下文切换，影响性能\n\n1. **CPU 密集型运算 **\n\n通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 \n\n2. **I/O密集型**\n\nCPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 \n经验公式如下 ：\n`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间` \n\n## 6.2、锁\n### 6.2.1、AQS\n\n1. 基本概念\n\nAbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...\n\n2. 原理 \n\n它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）\n\n3. 实现\n\n自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n> **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的\n\n### 6.2.2、ReentrantLock\n**实现原理**\n\n1. 首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能\n2. 它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法\n3. 加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列\n4. 持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）\n\n**条件变量——Condition**\nCondition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程\n### 6.2.3、**ReentrantReadWriteLock**\n#### 4.2.3.1、ReentrantReadWriteLock基本概念\nReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用\n#### 4.2.3.2、锁获取过程\n\n1. 获取读锁\n\n如果写锁没有被另一个线程持有，则获取读锁并立即返回。     \n \t如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。\n\n4. 获取写入锁\n\n如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *\n如果当前线程持有写锁，则将写锁计数 +1，然后返回\n如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。\n\n#### 4.2.3.3、常见问题\n\n1. **读锁和写锁的可重入性**\n\n在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加\n\n2. **当前线程获取锁失败，被阻塞的后续操作是什么？**\n\n获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁\n\n3. **锁降级是怎么降级的？**\n\n在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）\n\n## 6.3、工具\n### 6.3.1、Semaphore\n\n1. **概念**\n\nSemaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）\n```java\npublic class DataSourcePool {\n \n    private final CopyOnWriteArrayList<Connection> list;\n    \n    //用到了信号量\n    private final Semaphore semaphore;\n \n    public DataSourcePool(int size) throws SQLException {\n        list = new CopyOnWriteArrayList<>();\n        semaphore = new Semaphore(size);\n        for (int i=0;i<size;i++){\n            Connection connection = DriverManager.getConnection(\"url\");\n            list.add(connection);\n        }\n    }\n    \n    //使用同步方法获取\n    public synchronized Connection getConnection() throws InterruptedException {\n        //先将当前信号量-1，如果为0，将阻塞\n        semaphore.acquire();\n        return list.remove(0);\n    }\n \n    public synchronized void  close(Connection connection){\n        //信号量+1\n        semaphore.release();\n        list.add(connection);\n    }\n}\n```\n\n2. **原理**\n\nSemaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n\n1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。\n2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state=state-1。state<0,令牌数量不足，加入阻塞队列。>=0则获取成功\n3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state=state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程\n### 6.3.2、CountdownLatch\n\n1. **概念**\n\nCountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n    ExecutorService service = Executors.newFixedThreadPool(4);\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(()->{\n        try {\n            log.debug(\"waiting...\");\n            latch.await();\n            log.debug(\"wait end...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n    \n}\n```\n```java\n18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting... \n18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2 \n18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end...\n```\n\n2. **原理**\n\nCountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n1、初始化CountDownLatch实际就是设置了AQS的state为计数的值\n2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值\n3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试\n\n3. **和join的区别？**\n\nCountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成\n\n### 6.3.3、CyclicBarrier\n\n1. **概念**\n\nCyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行\n实现王者荣耀10个人都加载完才开始游戏\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        int count = 10;\n        CyclicBarrier cb = new CyclicBarrier(count, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"全部加载完毕\");\n            }\n        });\n        ExecutorService executorService = Executors.newFixedThreadPool(count);\n        for (int x = 0; x < count; x++) {\n            executorService.execute(new Worker(cb));\n        }\n    }\n}\n\nclass Worker extends Thread {\n    CyclicBarrier cyclicBarrier;\n    public Worker(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" 已加载完\");\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java\npool-1-thread-1 已加载完\npool-1-thread-5 已加载完\npool-1-thread-4 已加载完\npool-1-thread-3 已加载完\npool-1-thread-6 已加载完\npool-1-thread-2 已加载完\npool-1-thread-7 已加载完\npool-1-thread-8 已加载完\npool-1-thread-9 已加载完\npool-1-thread-10 已加载完\n全部加载完毕\n\n```\n\n2. **原理**\n\n1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count\n2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；\n3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；\n4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；\n5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。\n\n## 6.4、线程安全集合类\n### 6.4.1、概述\n\t\t\t\t\t\t  \n线程安全实现类有三类：\n\n1. 遗留的线程安全集合如 Hashtable ， Vector \n2. 使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）\n\n>    - Collections.synchronizedCollection \n>    - Collections.synchronizedList \n>    - Collections.synchronizedMap \n>    - Collections.synchronizedSet \n>    - Collections.synchronizedNavigableMap \n>    - Collections.synchronizedNavigableSet\n>    - Collections.synchronizedSortedMap \n>    - Collections.synchronizedSortedSet \n\n4. JUC下的安全集合: Blocking、CopyOnWrite、Concurrent \n\n> - Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)\n> - CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)\n> - Concurrent 类型的容器 （内部很多操作使用cas优化）\n>    - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 \n>    - 弱一致性 \n>       - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 \n>       - 求大小弱一致性，size 操作未必是 100% 准确 \n>       - 读取弱一致性 \n\n> 遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历\n\n### 6.4.2、concurrentHashMap\n**JDK1.8前**\nConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。\n\n元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部\n\n锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数\n\n\n> ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表\n\n\n**JDK1.8**\n\n在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全\n\n1. 初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 \n2. 插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 \n3. 扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 \n4. 查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。\n\n\n\n### 6.4.3、BlockingQueue\n主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue \n\n1. 区别\n\n（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表\n（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）\n（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现\n\n### 6.4.4、ConcurrentLinkedQueue \nConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）\n\n### 6.4.5、CopyOnWriteArrayList\n\n1. 首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行\n2. 写数据时会加ReentLocak锁，防止并发写入丢失数据的问题\n3. 写操作结束后会把原数组指向新数组\n4. CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景\n\n\n","source":"_posts/JUC.md","raw":"---\ntitle: juc\ndate: 2023/07/15\ncategories:\n  - coding\ntags:\n  - juc\n  - 多线程\n  - 并发编程\nabbrlink: 42310\n---\n# 1、java多线程基本概念\n## 1.1、进程和线程\n\n1. **进程**\n- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 \n- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 \n- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） \n\n2. **线程**\n- 一个进程之内可以分为一到多个线程。 \n- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 \n- **Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器**\n## 1.2、并发和并行\n并发：线程轮流使用CPU\n并行：多核cpu下，多个核同时调度运行线程\n\n## 1.3、多线程的应用\n### 1.3.1、异步调用\n比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 \n### 1.3.2、提升效率\n充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。\n```java\n计算 1 花费 10 ms\n计算 2 花费 11 ms\n计算 3 花费 9 ms\n汇总需要 1 ms\n```\n\n- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms \n- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms \n\n> 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n\n# 2、java线程\n## 2.1、线程的创建\n### 2.1.1、直接使用Thread\n```java\n// 创建线程对象\nThread t = new Thread() {\n    public void run() {\n        // 要执行的任务\n    }\n};\n// 启动线程\nt.start();\n```\n### 2.1.2、使用 Runnable 配合 Thread \n```java\nRunnable runnable = new Runnable() {\n    public void run(){\n        // 要执行的任务\n    }\n};\n// 创建线程对象\nThread t = new Thread( runnable );\n// 启动线程\nt.start();\n```\njava8可用lambda精简\n```java\n// 创建任务对象\nRunnable task2 = () -> log.debug(\"hello\");\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nThread t2 = new Thread(task2, \"t2\");\nt2.start();\n```\n### 2.1.3、FutureTask 配合 Thread \nFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\n\n```java\n// 创建任务对象\nFutureTask<Integer> task3 = new FutureTask<>(() -> {\n    log.debug(\"hello\");\n    return 100;\n});\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nnew Thread(task3, \"t3\").start();\n\n// 主线程阻塞，同步等待 task 执行完毕的结果\nInteger result = task3.get();\nlog.debug(\"结果是:{}\", result);\n```\n## 2.2、查看进程线程\n### 2.2.1、windows\n\n1. tasklist 查看进程 \n2. taskkill 杀死进程 \n3. netstat -ano|findstr 8080 根据端口查看进程\n### 2.2.2、linux\n\n1. ps -fe 查看所有进程 \n2. kill 杀死进程\n3.  top -Hp <PID> 查看某个进程（PID）的所有线程 \n4. netstat -nlp|grep 8080 根据端口查看进程\n### 2.2.3、JDK\n\n1. jps 命令查看所有 Java 进程\n2.  jstack <PID> 查看某个 Java 进程（PID）的所有线程状态\n3.  jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）\n\n## 2.3、线程运行原理\n\n1. **线程创建**\n\n每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成\n，栈帧对应着每次方法调用所占内存\n\n2. **上下文切换**\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 \n> 线程的 cpu 时间片用完 \n> 垃圾回收 \n> 有更高优先级的线程需要运行 \n> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 \n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 \n\n##  2.4、start与run\n\n- 直接调用 run 是在主线程中执行了 run，没有启动新的线程 \n- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n\n## 2.5、sleep 与 yield \n\n1. **sleep**\n- 1. 调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞） \n- 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException \n- 3. 睡眠结束后的线程未必会立刻得到执行 \n\n2. **yield**\n- 1. 调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程 \n- 2. 具体的实现依赖于操作系统的任务调度器 \n\n## 2.6、join\njoin：t1调用t2的join方法，会先执行t2，然后执行t1\n如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间\n```java\nstatic int r = 0;\npublic static void main(String[] args) throws InterruptedException {\n    test1();\n}\n\nprivate static void test1() throws InterruptedException {\n    log.debug(\"开始\");\n    Thread t1 = new Thread(() -> {\n        log.debug(\"开始\");\n        sleep(1);\n        log.debug(\"结束\");\n        r = 10;\n    });\n    t1.start();\n    // t1.join();\n    log.debug(\"结果为:{}\", r);\n    log.debug(\"结束\");\n}\n```\n> 如果不加t1.join()结果为0，加上以后结果为1\n\n\n## 2.7、interrupt\n### 2.7.1、打断阻塞状态的线程\nsleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断\n```java\nprivate static void test1() throws InterruptedException {\n    Thread t1 = new Thread(()->{\n        sleep(1);\n    }, \"t1\");\n    t1.start();\n    sleep(0.5);\n    t1.interrupt();\n    log.debug(\" 打断状态: {}\", t1.isInterrupted());\n}\n```\n输出\n```java\njava.lang.InterruptedException: sleep interrupted\n     at java.lang.Thread.sleep(Native Method)\n     at java.lang.Thread.sleep(Thread.java:340)\n     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)\n     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)\n     at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)\n     at java.lang.Thread.run(Thread.java:745)\n21:18:10.374 [main] c.TestInterrupt - 打断状态: false\n```\n### 2.7.2、打断正常运行的线程\n打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）\n```java\nprivate static void test2() throws InterruptedException {\n    Thread t2 = new Thread(()->{\n        while(true) {\n            Thread current = Thread.currentThread();\n            boolean interrupted = current.isInterrupted();\n            if(interrupted) {\n                log.debug(\" 打断状态: {}\", interrupted);\n                break;\n            }\n        }\n    }, \"t2\");\n    t2.start();\n    sleep(0.5);\n    t2.interrupt();\n}\n```\n输出\n```java\n20:57:37.964 [t2] c.TestInterrupt - 打断状态: true \n```\n\n## 2.8、主线程与守护线程\n默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 \n\n例\n```java\nlog.debug(\"开始运行...\");\nThread t1 = new Thread(() -> {\n    log.debug(\"开始运行...\");\n    sleep(2);\n    log.debug(\"运行结束...\");\n}, \"daemon\");\n// 设置该线程为守护线程\nt1.setDaemon(true);\nt1.start();\n\nsleep(1);\nlog.debug(\"运行结束...\");\n```\n输出\n```java\n08:26:38.123 [main] c.TestDaemon - 开始运行... \n08:26:38.213 [daemon] c.TestDaemon - 开始运行... \n08:26:39.215 [main] c.TestDaemon - 运行结束...\n```\n\n> **注意 **\n> - 垃圾回收器线程就是一种守护线程 \n> - Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 \n\n\n## 2.9、线程状态\n| 状态   | 说明 |\n| --- | --- |\n| NEW | 初始状态:线程被创建，但还没有调用start()方法 |\n| RUNNABLE | 运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作\"运行\" |\n| BLOCKED | 阻塞状态:表示线程阻塞于锁 |\n| WAITING | 等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) |\n| TIMEWAITING | 超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的 |\n| TERMINATED | 终止状态:表示当前线程已经执行完毕 |\n\n![线程状态](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg)\n\n\n# 3、共享模型之管程\n管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的\n## 3.1、monitor\nMonitor 被翻译为**监视器**或**管程**\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针\n\n### 3.1.1、Monitor结构\n**结构**：owner  entryList  waitSet\n\n![monitor结构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg)\n\n\n### 3.1.2、Monitor原理\n（1）刚开始monitor中owner为null \n（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程 \n（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞 \n（4）t1执行完会唤醒entrylist中的某个线程（不公平）\n（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n## 3.2、java对象结构\n\n1. **对象头**\n\n包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）\n\n![java对象头](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg)\n\n\n2. **实例数据**\n\n实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息\n\n3. **对齐填充**\n\n对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。\n## 3.3、synchronized升级\n### 3.3.1、偏向锁\n> 使用场景：如果只有一个线程，就不需要每次的申请释放锁\n\n只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 \n### 3.3.2、轻量级锁\n> 使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化\n\n![轻量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg)\n\n\n\n1. 创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象\n2. 让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录\n3. 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁\n4. 如果 cas 失败，有两种情况  \n\n（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 \n（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）\n\n5. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一\n6. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 \n\n（1）成功，则解锁成功 \n（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\n### 3.3.3、重量级锁\n> 使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁\n\n![重量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg)\n\n\n1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\n2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 \n\n（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 \n（2）然后自己进入 Monitor 的 EntryList阻塞队列\n\n3. 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）\n\n> 调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n### 3.3.4、自旋锁\n重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)\n\n## 3.4、wait/notify\nOwner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争\n\n### 3.4.1、sleep和wait的区别？\n\n1.  sleep 是 Thread 方法，而 wait 是 Object 的方法 \n2.  sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 \n3.  sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 \n\n## 3.5、park/unpark\n它们是 LockSupport 类中的方法\n```java\n// 暂停当前线程\nLockSupport.park(); \n// 恢复某个线程的运行\nLockSupport.unpark(暂停线程对象)\n```\n\n### 3.5.1、与 Object 的 wait & notify 相比 \n\n- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\n- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 \n- park & unpark 可以先 unpark，而 wait & notify 不能先 notify \n\n### 3.5.2、原理\n每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex \n\n核心部分是counter，我们可以理解为一个标记位。\n当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。\n当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。\n## 3.6、死锁\n多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁\n### 3.6.1、死锁的必要条件\n\n1. 互斥条件：一个资源一次只能被一个进程使用\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放\n3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺\n4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系\n### 3.6.2、死锁的实现\n```java\n/**\n * 实现一个死锁\n * 如果把lock(target, owner);放到上面则不会死锁\n */\npublic class DeadLock {\n    public static void main(String[] args) throws InterruptedException {\n        final Object owner = new Object();\n        final Object target = new Object();\n        //开启一个新线程\n        new Thread(() -> {\n            try {\n                lock(owner, target);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        //主线程\n        lock(target, owner);\n    }\n    public static void lock(Object owner, Object target) throws InterruptedException {\n        synchronized (owner) {\n            Thread.sleep(1000);\n            synchronized (target) {\n                System.out.println(\"success\");\n            }\n        }\n    }\n}\n```\n### 3.6.3、定位死锁\n检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁\n### 3.6.4、哲学家就餐问题\n\n![哲学家就餐问题](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg)\n\n\n有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 \n\n1. 筷子类\n\n```java\nclass Chopstick {\n    String name;\n    \n    public Chopstick(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return \"筷子{\" + name + '}';\n    }\n}\n```\n\n2. 哲学家类\n\n```java\nclass Philosopher extends Thread {\n    Chopstick left;\n    Chopstick right;\n    \n    public Philosopher(String name, Chopstick left, Chopstick right) {\n        super(name);\n        this.left = left;\n        this.right = right;\n    }\n    \n    private void eat() {\n        log.debug(\"eating...\");\n        Sleeper.sleep(1);\n    }\n    \n    @Override\n    public void run() {\n        while (true) {\n            // 获得左手筷子\n            synchronized (left) {\n                // 获得右手筷子\n                synchronized (right) {\n                    // 吃饭\n                    eat();\n                }\n                // 放下右手筷子\n            }\n            // 放下左手筷子\n        }\n    }\n}\n```\n\n3. 就餐\n\n```java\nChopstick c1 = new Chopstick(\"1\");\nChopstick c2 = new Chopstick(\"2\");\nChopstick c3 = new Chopstick(\"3\");\nChopstick c4 = new Chopstick(\"4\");\nChopstick c5 = new Chopstick(\"5\");\n\nnew Philosopher(\"苏格拉底\", c1, c2).start();\nnew Philosopher(\"柏拉图\", c2, c3).start();\nnew Philosopher(\"亚里士多德\", c3, c4).start();\nnew Philosopher(\"赫拉克利特\", c4, c5).start();\nnew Philosopher(\"阿基米德\", c5, c1).start();\n```\n## 3.7、活锁\n两个线程互相改变对方的结束条件导致谁也无法结束\n> eg：共享变量count为10000, t1线程while count > 0, count-- ;t2线程while count < 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行\n\n\n## 3.8、**ReentrantLock**\n相对于 synchronized 它具备如下特点 \n\n1. 可中断 \n2. 可以设置超时时间 \n3. 可以设置为公平锁 （默认不公平）\n4. 支持多个条件变量 \n\n与 synchronized 一样，都支持可重入 \n# 4、共享模型之内存\n## 4.1、java内存模型（jmm）\nJava内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本\n## 4.2、线程安全性的三个体现\n**原子性**：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）\n**可见性**：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）\n**有序性**：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）\n# 5、共享模型之无锁\n## 5.1、CAS\n### 5.1.1、CAS基本概念\nCAS是所有原子类的底层原理，乐观锁主要采用CAS算法。\nCAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。\n> 1. CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性\n> 2. CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果\n\n\n### 5.1.2、CAS问题\n多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。\n\n**解决方案：**\n使用AtomicStampReference \nAtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验\n\n## 5.2、volatile\n### 5.2.1、如何保证可见性和有序性\n\n1. **保证可见性（缓存一致性协议MESI）**\n\n首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用**MESI协议**保证缓存一致性。\n如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu**总线嗅探机制**监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值\n\n> **M 修改** (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中\n**E 独享、互斥** (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。\n**S 共享** (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态\n**I 无效** (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态\n\n\n> 涉及到的指令\nlock(锁定)：将一个变量标识为被一个线程独占状态\nstore(存储)：作用于工作内存的变量,将变量传输到主内存中\nwrite(写入)：将store入主内存的变量,放入到主内存的变量中\n\n\n2. **保证有序性（禁止指令重排优化）**\n\n多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的\n内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序\n\n## 5.3、原子类\n| 类型   | 具体类 |\n| --- | --- |\n| Atomic 基本类型原子类   | AtomicInteger AtomicLong AtomicBoolean |\n| AtomicArray 数组类型原子类 | AtomicIntegerArray  AtomicLongArray AtomicReferenceArray |\n| AtomicReference 引用类型原子类 | AtomicReference AtomicStampedReference AtomicMarkableReference |\n| AtomicFieldUpdate 升级类型原子类 | AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater |\n\n\n# 6、共享模式之工具\n## 6.1、线程池\n### 6.1.1、**ThreadPoolExecutor**\n\n1. **构造方法**\n\n通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建\n\n> 1. corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。\n> 2. maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。\n> 3. keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。\n> 4. unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n> 5. workQueue：缓存队列，用来存放等待被执行的任务。\n> 6. threadFactory 线程工厂\n> 7. handler：拒绝策略\n（1）abortPolicy：抛出异常（默认）\n（2）discardPolicy：放弃本次任务\n（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代\n（4）callerrunPolicy：让调用者运行任务\n\n\n2. **工作原理**\n\n如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n如果当前线程池中正在执行任务的的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；\n如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；\n如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理\n### 6.1.2、Executors类中提供的工厂方法\n根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池\n\n1. **newFixedThreadPool**\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n> 特点：\n> - 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 \n> - 阻塞队列是无界的，可以放任意数量的任务 \n> \n评价：\n> 适用于任务量已知，相对耗时的任务\n\n\n2. **newCachedThreadPool**\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n> 特点 \n> - 核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 \n>    - 全部都是救急线程（60s 后可以回收）\n>    - 救急线程可以无限创建 \n> - 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）\n> \n评价：\n> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程\n> 适合任务数比较密集，但每个任务执行时间较短的情况\n\n\n3. newSingleThreadExecutor\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n使用场景： \n希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。\n任务执行完毕，这唯一的线程也不会被释放。 \n\n### 6.1.3、创建多大的线程池\n\n- 过小会导致程序不能充分地利用系统资源、容易导致饥饿 \n- 过大会导致更多的线程上下文切换，影响性能\n\n1. **CPU 密集型运算 **\n\n通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 \n\n2. **I/O密集型**\n\nCPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 \n经验公式如下 ：\n`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间` \n\n## 6.2、锁\n### 6.2.1、AQS\n\n1. 基本概念\n\nAbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...\n\n2. 原理 \n\n它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）\n\n3. 实现\n\n自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n> **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的\n\n### 6.2.2、ReentrantLock\n**实现原理**\n\n1. 首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能\n2. 它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法\n3. 加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列\n4. 持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）\n\n**条件变量——Condition**\nCondition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程\n### 6.2.3、**ReentrantReadWriteLock**\n#### 4.2.3.1、ReentrantReadWriteLock基本概念\nReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用\n#### 4.2.3.2、锁获取过程\n\n1. 获取读锁\n\n如果写锁没有被另一个线程持有，则获取读锁并立即返回。     \n \t如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。\n\n4. 获取写入锁\n\n如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *\n如果当前线程持有写锁，则将写锁计数 +1，然后返回\n如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。\n\n#### 4.2.3.3、常见问题\n\n1. **读锁和写锁的可重入性**\n\n在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加\n\n2. **当前线程获取锁失败，被阻塞的后续操作是什么？**\n\n获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁\n\n3. **锁降级是怎么降级的？**\n\n在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）\n\n## 6.3、工具\n### 6.3.1、Semaphore\n\n1. **概念**\n\nSemaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）\n```java\npublic class DataSourcePool {\n \n    private final CopyOnWriteArrayList<Connection> list;\n    \n    //用到了信号量\n    private final Semaphore semaphore;\n \n    public DataSourcePool(int size) throws SQLException {\n        list = new CopyOnWriteArrayList<>();\n        semaphore = new Semaphore(size);\n        for (int i=0;i<size;i++){\n            Connection connection = DriverManager.getConnection(\"url\");\n            list.add(connection);\n        }\n    }\n    \n    //使用同步方法获取\n    public synchronized Connection getConnection() throws InterruptedException {\n        //先将当前信号量-1，如果为0，将阻塞\n        semaphore.acquire();\n        return list.remove(0);\n    }\n \n    public synchronized void  close(Connection connection){\n        //信号量+1\n        semaphore.release();\n        list.add(connection);\n    }\n}\n```\n\n2. **原理**\n\nSemaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n\n1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。\n2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state=state-1。state<0,令牌数量不足，加入阻塞队列。>=0则获取成功\n3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state=state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程\n### 6.3.2、CountdownLatch\n\n1. **概念**\n\nCountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n    ExecutorService service = Executors.newFixedThreadPool(4);\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(()->{\n        try {\n            log.debug(\"waiting...\");\n            latch.await();\n            log.debug(\"wait end...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n    \n}\n```\n```java\n18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting... \n18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2 \n18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end...\n```\n\n2. **原理**\n\nCountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n1、初始化CountDownLatch实际就是设置了AQS的state为计数的值\n2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值\n3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试\n\n3. **和join的区别？**\n\nCountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成\n\n### 6.3.3、CyclicBarrier\n\n1. **概念**\n\nCyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行\n实现王者荣耀10个人都加载完才开始游戏\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        int count = 10;\n        CyclicBarrier cb = new CyclicBarrier(count, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"全部加载完毕\");\n            }\n        });\n        ExecutorService executorService = Executors.newFixedThreadPool(count);\n        for (int x = 0; x < count; x++) {\n            executorService.execute(new Worker(cb));\n        }\n    }\n}\n\nclass Worker extends Thread {\n    CyclicBarrier cyclicBarrier;\n    public Worker(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" 已加载完\");\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java\npool-1-thread-1 已加载完\npool-1-thread-5 已加载完\npool-1-thread-4 已加载完\npool-1-thread-3 已加载完\npool-1-thread-6 已加载完\npool-1-thread-2 已加载完\npool-1-thread-7 已加载完\npool-1-thread-8 已加载完\npool-1-thread-9 已加载完\npool-1-thread-10 已加载完\n全部加载完毕\n\n```\n\n2. **原理**\n\n1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count\n2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；\n3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；\n4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；\n5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。\n\n## 6.4、线程安全集合类\n### 6.4.1、概述\n\t\t\t\t\t\t  \n线程安全实现类有三类：\n\n1. 遗留的线程安全集合如 Hashtable ， Vector \n2. 使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）\n\n>    - Collections.synchronizedCollection \n>    - Collections.synchronizedList \n>    - Collections.synchronizedMap \n>    - Collections.synchronizedSet \n>    - Collections.synchronizedNavigableMap \n>    - Collections.synchronizedNavigableSet\n>    - Collections.synchronizedSortedMap \n>    - Collections.synchronizedSortedSet \n\n4. JUC下的安全集合: Blocking、CopyOnWrite、Concurrent \n\n> - Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)\n> - CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)\n> - Concurrent 类型的容器 （内部很多操作使用cas优化）\n>    - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 \n>    - 弱一致性 \n>       - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 \n>       - 求大小弱一致性，size 操作未必是 100% 准确 \n>       - 读取弱一致性 \n\n> 遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历\n\n### 6.4.2、concurrentHashMap\n**JDK1.8前**\nConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。\n\n元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部\n\n锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数\n\n\n> ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表\n\n\n**JDK1.8**\n\n在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全\n\n1. 初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 \n2. 插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 \n3. 扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 \n4. 查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。\n\n\n\n### 6.4.3、BlockingQueue\n主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue \n\n1. 区别\n\n（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表\n（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）\n（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现\n\n### 6.4.4、ConcurrentLinkedQueue \nConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）\n\n### 6.4.5、CopyOnWriteArrayList\n\n1. 首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行\n2. 写数据时会加ReentLocak锁，防止并发写入丢失数据的问题\n3. 写操作结束后会把原数组指向新数组\n4. CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景\n\n\n","slug":"JUC","published":1,"updated":"2023-07-25T02:55:50.559Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkjau31e0001igumdv7k6phm","content":"<h1 id=\"1、java多线程基本概念\"><a href=\"#1、java多线程基本概念\" class=\"headerlink\" title=\"1、java多线程基本概念\"></a>1、java多线程基本概念</h1><h2 id=\"1-1、进程和线程\"><a href=\"#1-1、进程和线程\" class=\"headerlink\" title=\"1.1、进程和线程\"></a>1.1、进程和线程</h2><ol>\n<li><strong>进程</strong></li>\n</ol>\n<ul>\n<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li>\n<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>\n<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>\n</ul>\n<ol start=\"2\">\n<li><strong>线程</strong></li>\n</ol>\n<ul>\n<li>一个进程之内可以分为一到多个线程。 </li>\n<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li>\n<li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li>\n</ul>\n<h2 id=\"1-2、并发和并行\"><a href=\"#1-2、并发和并行\" class=\"headerlink\" title=\"1.2、并发和并行\"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p>\n<h2 id=\"1-3、多线程的应用\"><a href=\"#1-3、多线程的应用\" class=\"headerlink\" title=\"1.3、多线程的应用\"></a>1.3、多线程的应用</h2><h3 id=\"1-3-1、异步调用\"><a href=\"#1-3-1、异步调用\" class=\"headerlink\" title=\"1.3.1、异步调用\"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p>\n<h3 id=\"1-3-2、提升效率\"><a href=\"#1-3-2、提升效率\" class=\"headerlink\" title=\"1.3.2、提升效率\"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算 <span class=\"number\">1</span> 花费 <span class=\"number\">10</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">2</span> 花费 <span class=\"number\">11</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">3</span> 花费 <span class=\"number\">9</span> ms</span><br><span class=\"line\">汇总需要 <span class=\"number\">1</span> ms</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li>\n<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms</li>\n</ul>\n<blockquote>\n<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>\n</blockquote>\n<h1 id=\"2、java线程\"><a href=\"#2、java线程\" class=\"headerlink\" title=\"2、java线程\"></a>2、java线程</h1><h2 id=\"2-1、线程的创建\"><a href=\"#2-1、线程的创建\" class=\"headerlink\" title=\"2.1、线程的创建\"></a>2.1、线程的创建</h2><h3 id=\"2-1-1、直接使用Thread\"><a href=\"#2-1-1、直接使用Thread\" class=\"headerlink\" title=\"2.1.1、直接使用Thread\"></a>2.1.1、直接使用Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、使用-Runnable-配合-Thread\"><a href=\"#2-1-2、使用-Runnable-配合-Thread\" class=\"headerlink\" title=\"2.1.2、使用 Runnable 配合 Thread\"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>( runnable );</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<p>java8可用lambda精简</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">task2</span> <span class=\"operator\">=</span> () -&gt; log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task2, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">t2.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3、FutureTask-配合-Thread\"><a href=\"#2-1-3、FutureTask-配合-Thread\" class=\"headerlink\" title=\"2.1.3、FutureTask 配合 Thread\"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\">FutureTask&lt;Integer&gt; task3 = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task3, <span class=\"string\">&quot;t3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> task3.get();</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、查看进程线程\"><a href=\"#2-2、查看进程线程\" class=\"headerlink\" title=\"2.2、查看进程线程\"></a>2.2、查看进程线程</h2><h3 id=\"2-2-1、windows\"><a href=\"#2-2-1、windows\" class=\"headerlink\" title=\"2.2.1、windows\"></a>2.2.1、windows</h3><ol>\n<li>tasklist 查看进程 </li>\n<li>taskkill 杀死进程 </li>\n<li>netstat -ano|findstr 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-2、linux\"><a href=\"#2-2-2、linux\" class=\"headerlink\" title=\"2.2.2、linux\"></a>2.2.2、linux</h3><ol>\n<li>ps -fe 查看所有进程 </li>\n<li>kill 杀死进程</li>\n<li>top -Hp <PID> 查看某个进程（PID）的所有线程 </li>\n<li>netstat -nlp|grep 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-3、JDK\"><a href=\"#2-2-3、JDK\" class=\"headerlink\" title=\"2.2.3、JDK\"></a>2.2.3、JDK</h3><ol>\n<li>jps 命令查看所有 Java 进程</li>\n<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>\n<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>\n</ol>\n<h2 id=\"2-3、线程运行原理\"><a href=\"#2-3、线程运行原理\" class=\"headerlink\" title=\"2.3、线程运行原理\"></a>2.3、线程运行原理</h2><ol>\n<li><strong>线程创建</strong></li>\n</ol>\n<p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成<br>，栈帧对应着每次方法调用所占内存</p>\n<ol start=\"2\">\n<li><strong>上下文切换</strong></li>\n</ol>\n<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p>\n<blockquote>\n<p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p>\n</blockquote>\n<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p>\n<h2 id=\"2-4、start与run\"><a href=\"#2-4、start与run\" class=\"headerlink\" title=\"2.4、start与run\"></a>2.4、start与run</h2><ul>\n<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>\n<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>\n</ul>\n<h2 id=\"2-5、sleep-与-yield\"><a href=\"#2-5、sleep-与-yield\" class=\"headerlink\" title=\"2.5、sleep 与 yield\"></a>2.5、sleep 与 yield</h2><ol>\n<li><strong>sleep</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>睡眠结束后的线程未必会立刻得到执行</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>yield</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>具体的实现依赖于操作系统的任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-6、join\"><a href=\"#2-6、join\" class=\"headerlink\" title=\"2.6、join\"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    test1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">        r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"comment\">// t1.join();</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不加t1.join()结果为0，加上以后结果为1</p>\n</blockquote>\n<h2 id=\"2-7、interrupt\"><a href=\"#2-7、interrupt\" class=\"headerlink\" title=\"2.7、interrupt\"></a>2.7、interrupt</h2><h3 id=\"2-7-1、打断阻塞状态的线程\"><a href=\"#2-7-1、打断阻塞状态的线程\" class=\"headerlink\" title=\"2.7.1、打断阻塞状态的线程\"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t1.interrupt();</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">     at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">     at java.lang.Thread.sleep(Thread.java:<span class=\"number\">340</span>)</span><br><span class=\"line\">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class=\"number\">386</span>)</span><br><span class=\"line\">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class=\"number\">3</span>(TestInterrupt.java:<span class=\"number\">59</span>)</span><br><span class=\"line\">     at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">18</span>:<span class=\"number\">10.374</span> [main] c.TestInterrupt - 打断状态: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-2、打断正常运行的线程\"><a href=\"#2-7-2、打断正常运行的线程\" class=\"headerlink\" title=\"2.7.2、打断正常运行的线程\"></a>2.7.2、打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> current.isInterrupted();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(interrupted) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t2.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class=\"literal\">true</span> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8、主线程与守护线程\"><a href=\"#2-8、主线程与守护线程\" class=\"headerlink\" title=\"2.8、主线程与守护线程\"></a>2.8、主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </p>\n<p>例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;daemon&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置该线程为守护线程</span></span><br><span class=\"line\">t1.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>**注意 **</p>\n<ul>\n<li>垃圾回收器线程就是一种守护线程 </li>\n<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>\n</ul>\n</blockquote>\n<h2 id=\"2-9、线程状态\"><a href=\"#2-9、线程状态\" class=\"headerlink\" title=\"2.9、线程状态\"></a>2.9、线程状态</h2><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NEW</td>\n<td>初始状态:线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>阻塞状态:表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td>WAITING</td>\n<td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>\n</tr>\n<tr>\n<td>TIMEWAITING</td>\n<td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>终止状态:表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg\" alt=\"线程状态\"></p>\n<h1 id=\"3、共享模型之管程\"><a href=\"#3、共享模型之管程\" class=\"headerlink\" title=\"3、共享模型之管程\"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p>\n<h2 id=\"3-1、monitor\"><a href=\"#3-1、monitor\" class=\"headerlink\" title=\"3.1、monitor\"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>\n<h3 id=\"3-1-1、Monitor结构\"><a href=\"#3-1-1、Monitor结构\" class=\"headerlink\" title=\"3.1.1、Monitor结构\"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg\" alt=\"monitor结构\"></p>\n<h3 id=\"3-1-2、Monitor原理\"><a href=\"#3-1-2、Monitor原理\" class=\"headerlink\" title=\"3.1.2、Monitor原理\"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n<h2 id=\"3-2、java对象结构\"><a href=\"#3-2、java对象结构\" class=\"headerlink\" title=\"3.2、java对象结构\"></a>3.2、java对象结构</h2><ol>\n<li><strong>对象头</strong></li>\n</ol>\n<p>包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg\" alt=\"java对象头\"></p>\n<ol start=\"2\">\n<li><strong>实例数据</strong></li>\n</ol>\n<p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p>\n<ol start=\"3\">\n<li><strong>对齐填充</strong></li>\n</ol>\n<p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>\n<h2 id=\"3-3、synchronized升级\"><a href=\"#3-3、synchronized升级\" class=\"headerlink\" title=\"3.3、synchronized升级\"></a>3.3、synchronized升级</h2><h3 id=\"3-3-1、偏向锁\"><a href=\"#3-3-1、偏向锁\" class=\"headerlink\" title=\"3.3.1、偏向锁\"></a>3.3.1、偏向锁</h3><blockquote>\n<p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p>\n</blockquote>\n<p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>\n<h3 id=\"3-3-2、轻量级锁\"><a href=\"#3-3-2、轻量级锁\" class=\"headerlink\" title=\"3.3.2、轻量级锁\"></a>3.3.2、轻量级锁</h3><blockquote>\n<p>使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg\" alt=\"轻量级锁\"></p>\n<ol>\n<li>创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象</li>\n<li>让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>\n<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>\n<li>如果 cas 失败，有两种情况</li>\n</ol>\n<p>（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程<br>（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）</p>\n<ol start=\"5\">\n<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>\n<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</li>\n</ol>\n<p>（1）成功，则解锁成功<br>（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>\n<h3 id=\"3-3-3、重量级锁\"><a href=\"#3-3-3、重量级锁\" class=\"headerlink\" title=\"3.3.3、重量级锁\"></a>3.3.3、重量级锁</h3><blockquote>\n<p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg\" alt=\"重量级锁\"></p>\n<ol>\n<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>\n<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</li>\n</ol>\n<p>（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<br>（2）然后自己进入 Monitor 的 EntryList阻塞队列</p>\n<ol start=\"3\">\n<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）</li>\n</ol>\n<blockquote>\n<p>调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n</blockquote>\n<h3 id=\"3-3-4、自旋锁\"><a href=\"#3-3-4、自旋锁\" class=\"headerlink\" title=\"3.3.4、自旋锁\"></a>3.3.4、自旋锁</h3><p>重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)</p>\n<h2 id=\"3-4、wait-notify\"><a href=\"#3-4、wait-notify\" class=\"headerlink\" title=\"3.4、wait&#x2F;notify\"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p>\n<h3 id=\"3-4-1、sleep和wait的区别？\"><a href=\"#3-4-1、sleep和wait的区别？\" class=\"headerlink\" title=\"3.4.1、sleep和wait的区别？\"></a>3.4.1、sleep和wait的区别？</h3><ol>\n<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>\n<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>\n<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>\n</ol>\n<h2 id=\"3-5、park-unpark\"><a href=\"#3-5、park-unpark\" class=\"headerlink\" title=\"3.5、park&#x2F;unpark\"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂停当前线程</span></span><br><span class=\"line\">LockSupport.park(); </span><br><span class=\"line\"><span class=\"comment\">// 恢复某个线程的运行</span></span><br><span class=\"line\">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-1、与-Object-的-wait-notify-相比\"><a href=\"#3-5-1、与-Object-的-wait-notify-相比\" class=\"headerlink\" title=\"3.5.1、与 Object 的 wait &amp; notify 相比\"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul>\n<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>\n<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>\n<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>\n</ul>\n<h3 id=\"3-5-2、原理\"><a href=\"#3-5-2、原理\" class=\"headerlink\" title=\"3.5.2、原理\"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p>\n<p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p>\n<h2 id=\"3-6、死锁\"><a href=\"#3-6、死锁\" class=\"headerlink\" title=\"3.6、死锁\"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p>\n<h3 id=\"3-6-1、死锁的必要条件\"><a href=\"#3-6-1、死锁的必要条件\" class=\"headerlink\" title=\"3.6.1、死锁的必要条件\"></a>3.6.1、死锁的必要条件</h3><ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h3 id=\"3-6-2、死锁的实现\"><a href=\"#3-6-2、死锁的实现\" class=\"headerlink\" title=\"3.6.2、死锁的实现\"></a>3.6.2、死锁的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">owner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"comment\">//开启一个新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                lock(owner, target);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"comment\">//主线程</span></span><br><span class=\"line\">        lock(target, owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">(Object owner, Object target)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (owner) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (target) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;success&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-3、定位死锁\"><a href=\"#3-6-3、定位死锁\" class=\"headerlink\" title=\"3.6.3、定位死锁\"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p>\n<h3 id=\"3-6-4、哲学家就餐问题\"><a href=\"#3-6-4、哲学家就餐问题\" class=\"headerlink\" title=\"3.6.4、哲学家就餐问题\"></a>3.6.4、哲学家就餐问题</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg\" alt=\"哲学家就餐问题\"></p>\n<p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p>\n<ol>\n<li>筷子类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chopstick</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Chopstick</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;筷子&#123;&quot;</span> + name + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>哲学家类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Philosopher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    Chopstick left;</span><br><span class=\"line\">    Chopstick right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Philosopher</span><span class=\"params\">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;eating...&quot;</span>);</span><br><span class=\"line\">        Sleeper.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得左手筷子</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (left) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获得右手筷子</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (right) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">                    eat();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 放下右手筷子</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 放下左手筷子</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>就餐</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c5</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、活锁\"><a href=\"#3-7、活锁\" class=\"headerlink\" title=\"3.7、活锁\"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p>\n<blockquote>\n<p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p>\n</blockquote>\n<h2 id=\"3-8、ReentrantLock\"><a href=\"#3-8、ReentrantLock\" class=\"headerlink\" title=\"3.8、ReentrantLock\"></a>3.8、<strong>ReentrantLock</strong></h2><p>相对于 synchronized 它具备如下特点 </p>\n<ol>\n<li>可中断 </li>\n<li>可以设置超时时间 </li>\n<li>可以设置为公平锁 （默认不公平）</li>\n<li>支持多个条件变量</li>\n</ol>\n<p>与 synchronized 一样，都支持可重入 </p>\n<h1 id=\"4、共享模型之内存\"><a href=\"#4、共享模型之内存\" class=\"headerlink\" title=\"4、共享模型之内存\"></a>4、共享模型之内存</h1><h2 id=\"4-1、java内存模型（jmm）\"><a href=\"#4-1、java内存模型（jmm）\" class=\"headerlink\" title=\"4.1、java内存模型（jmm）\"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p>\n<h2 id=\"4-2、线程安全性的三个体现\"><a href=\"#4-2、线程安全性的三个体现\" class=\"headerlink\" title=\"4.2、线程安全性的三个体现\"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）<br><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）<br><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）</p>\n<h1 id=\"5、共享模型之无锁\"><a href=\"#5、共享模型之无锁\" class=\"headerlink\" title=\"5、共享模型之无锁\"></a>5、共享模型之无锁</h1><h2 id=\"5-1、CAS\"><a href=\"#5-1、CAS\" class=\"headerlink\" title=\"5.1、CAS\"></a>5.1、CAS</h2><h3 id=\"5-1-1、CAS基本概念\"><a href=\"#5-1-1、CAS基本概念\" class=\"headerlink\" title=\"5.1.1、CAS基本概念\"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>\n<blockquote>\n<ol>\n<li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li>\n<li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li>\n</ol>\n</blockquote>\n<h3 id=\"5-1-2、CAS问题\"><a href=\"#5-1-2、CAS问题\" class=\"headerlink\" title=\"5.1.2、CAS问题\"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p>\n<p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p>\n<h2 id=\"5-2、volatile\"><a href=\"#5-2、volatile\" class=\"headerlink\" title=\"5.2、volatile\"></a>5.2、volatile</h2><h3 id=\"5-2-1、如何保证可见性和有序性\"><a href=\"#5-2-1、如何保证可见性和有序性\" class=\"headerlink\" title=\"5.2.1、如何保证可见性和有序性\"></a>5.2.1、如何保证可见性和有序性</h3><ol>\n<li><strong>保证可见性（缓存一致性协议MESI）</strong></li>\n</ol>\n<p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p>\n<blockquote>\n<p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p>\n</blockquote>\n<blockquote>\n<p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>保证有序性（禁止指令重排优化）</strong></li>\n</ol>\n<p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p>\n<h2 id=\"5-3、原子类\"><a href=\"#5-3、原子类\" class=\"headerlink\" title=\"5.3、原子类\"></a>5.3、原子类</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>具体类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic 基本类型原子类</td>\n<td>AtomicInteger AtomicLong AtomicBoolean</td>\n</tr>\n<tr>\n<td>AtomicArray 数组类型原子类</td>\n<td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td>\n</tr>\n<tr>\n<td>AtomicReference 引用类型原子类</td>\n<td>AtomicReference AtomicStampedReference AtomicMarkableReference</td>\n</tr>\n<tr>\n<td>AtomicFieldUpdate 升级类型原子类</td>\n<td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td>\n</tr>\n</tbody></table>\n<h1 id=\"6、共享模式之工具\"><a href=\"#6、共享模式之工具\" class=\"headerlink\" title=\"6、共享模式之工具\"></a>6、共享模式之工具</h1><h2 id=\"6-1、线程池\"><a href=\"#6-1、线程池\" class=\"headerlink\" title=\"6.1、线程池\"></a>6.1、线程池</h2><h3 id=\"6-1-1、ThreadPoolExecutor\"><a href=\"#6-1-1、ThreadPoolExecutor\" class=\"headerlink\" title=\"6.1.1、ThreadPoolExecutor\"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol>\n<li><strong>构造方法</strong></li>\n</ol>\n<p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p>\n<blockquote>\n<ol>\n<li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li>\n<li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li>\n<li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li>\n<li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>\n<li>workQueue：缓存队列，用来存放等待被执行的任务。</li>\n<li>threadFactory 线程工厂</li>\n<li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>\n<h3 id=\"6-1-2、Executors类中提供的工厂方法\"><a href=\"#6-1-2、Executors类中提供的工厂方法\" class=\"headerlink\" title=\"6.1.2、Executors类中提供的工厂方法\"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p>\n<ol>\n<li><strong>newFixedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newFixedThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点：</p>\n<ul>\n<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>\n<li>阻塞队列是无界的，可以放任意数量的任务</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>适用于任务量已知，相对耗时的任务</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>newCachedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newCachedThreadPool</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点 </p>\n<ul>\n<li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul>\n<li>全部都是救急线程（60s 后可以回收）</li>\n<li>救急线程可以无限创建</li>\n</ul>\n</li>\n<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p>\n</blockquote>\n<ol start=\"3\">\n<li>newSingleThreadExecutor</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newSingleThreadExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\">        (<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。 </p>\n<h3 id=\"6-1-3、创建多大的线程池\"><a href=\"#6-1-3、创建多大的线程池\" class=\"headerlink\" title=\"6.1.3、创建多大的线程池\"></a>6.1.3、创建多大的线程池</h3><ul>\n<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>\n<li>过大会导致更多的线程上下文切换，影响性能</li>\n</ul>\n<ol>\n<li>**CPU 密集型运算 **</li>\n</ol>\n<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>\n<ol start=\"2\">\n<li><strong>I&#x2F;O密集型</strong></li>\n</ol>\n<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>\n<h2 id=\"6-2、锁\"><a href=\"#6-2、锁\" class=\"headerlink\" title=\"6.2、锁\"></a>6.2、锁</h2><h3 id=\"6-2-1、AQS\"><a href=\"#6-2-1、AQS\" class=\"headerlink\" title=\"6.2.1、AQS\"></a>6.2.1、AQS</h3><ol>\n<li>基本概念</li>\n</ol>\n<p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p>\n<ol start=\"2\">\n<li>原理</li>\n</ol>\n<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>\n<blockquote>\n<p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>\n</blockquote>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p>\n<h3 id=\"6-2-2、ReentrantLock\"><a href=\"#6-2-2、ReentrantLock\" class=\"headerlink\" title=\"6.2.2、ReentrantLock\"></a>6.2.2、ReentrantLock</h3><p><strong>实现原理</strong></p>\n<ol>\n<li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li>\n<li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li>\n<li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li>\n<li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li>\n</ol>\n<p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p>\n<h3 id=\"6-2-3、ReentrantReadWriteLock\"><a href=\"#6-2-3、ReentrantReadWriteLock\" class=\"headerlink\" title=\"6.2.3、ReentrantReadWriteLock\"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id=\"4-2-3-1、ReentrantReadWriteLock基本概念\"><a href=\"#4-2-3-1、ReentrantReadWriteLock基本概念\" class=\"headerlink\" title=\"4.2.3.1、ReentrantReadWriteLock基本概念\"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p>\n<h4 id=\"4-2-3-2、锁获取过程\"><a href=\"#4-2-3-2、锁获取过程\" class=\"headerlink\" title=\"4.2.3.2、锁获取过程\"></a>4.2.3.2、锁获取过程</h4><ol>\n<li>获取读锁</li>\n</ol>\n<p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>     如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。</p>\n<ol start=\"4\">\n<li>获取写入锁</li>\n</ol>\n<p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p>\n<h4 id=\"4-2-3-3、常见问题\"><a href=\"#4-2-3-3、常见问题\" class=\"headerlink\" title=\"4.2.3.3、常见问题\"></a>4.2.3.3、常见问题</h4><ol>\n<li><strong>读锁和写锁的可重入性</strong></li>\n</ol>\n<p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p>\n<ol start=\"2\">\n<li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li>\n</ol>\n<p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p>\n<ol start=\"3\">\n<li><strong>锁降级是怎么降级的？</strong></li>\n</ol>\n<p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p>\n<h2 id=\"6-3、工具\"><a href=\"#6-3、工具\" class=\"headerlink\" title=\"6.3、工具\"></a>6.3、工具</h2><h3 id=\"6-3-1、Semaphore\"><a href=\"#6-3-1、Semaphore\" class=\"headerlink\" title=\"6.3.1、Semaphore\"></a>6.3.1、Semaphore</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourcePool</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//用到了信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DataSourcePool</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">        list = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        semaphore = <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">            list.add(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用同步方法获取</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class=\"line\">        semaphore.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">close</span><span class=\"params\">(Connection connection)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//信号量+1</span></span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">        list.add(connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p>\n<p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p>\n<h3 id=\"6-3-2、CountdownLatch\"><a href=\"#6-3-2、CountdownLatch\" class=\"headerlink\" title=\"6.3.2、CountdownLatch\"></a>6.3.2、CountdownLatch</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ExecutorService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1.5</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;wait end...&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - waiting... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">26.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - end..<span class=\"number\">.2</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.335</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - end..<span class=\"number\">.1</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - end..<span class=\"number\">.0</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - wait end...</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p>\n<ol start=\"3\">\n<li><strong>和join的区别？</strong></li>\n</ol>\n<p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p>\n<h3 id=\"6-3-3、CyclicBarrier\"><a href=\"#6-3-3、CyclicBarrier\" class=\"headerlink\" title=\"6.3.3、CyclicBarrier\"></a>6.3.3、CyclicBarrier</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(count, <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;全部加载完毕&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; x &lt; count; x++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(cb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    CyclicBarrier cyclicBarrier;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已加载完&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            cyclicBarrier.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">6</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">7</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">8</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">9</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">10</span> 已加载完</span><br><span class=\"line\">全部加载完毕</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p>\n<h2 id=\"6-4、线程安全集合类\"><a href=\"#6-4、线程安全集合类\" class=\"headerlink\" title=\"6.4、线程安全集合类\"></a>6.4、线程安全集合类</h2><h3 id=\"6-4-1、概述\"><a href=\"#6-4-1、概述\" class=\"headerlink\" title=\"6.4.1、概述\"></a>6.4.1、概述</h3><p>线程安全实现类有三类：</p>\n<ol>\n<li>遗留的线程安全集合如 Hashtable ， Vector </li>\n<li>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</li>\n</ol>\n<blockquote>\n<ul>\n<li>Collections.synchronizedCollection </li>\n<li>Collections.synchronizedList </li>\n<li>Collections.synchronizedMap </li>\n<li>Collections.synchronizedSet </li>\n<li>Collections.synchronizedNavigableMap </li>\n<li>Collections.synchronizedNavigableSet</li>\n<li>Collections.synchronizedSortedMap </li>\n<li>Collections.synchronizedSortedSet</li>\n</ul>\n</blockquote>\n<ol start=\"4\">\n<li>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent</li>\n</ol>\n<blockquote>\n<ul>\n<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li>\n<li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li>\n<li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul>\n<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>\n<li>弱一致性 <ul>\n<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li>\n<li>求大小弱一致性，size 操作未必是 100% 准确 </li>\n<li>读取弱一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p>\n</blockquote>\n<h3 id=\"6-4-2、concurrentHashMap\"><a href=\"#6-4-2、concurrentHashMap\" class=\"headerlink\" title=\"6.4.2、concurrentHashMap\"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p>\n<p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p>\n<p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p>\n<blockquote>\n<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p>\n</blockquote>\n<p><strong>JDK1.8</strong></p>\n<p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p>\n<ol>\n<li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li>\n<li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li>\n<li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li>\n<li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li>\n</ol>\n<h3 id=\"6-4-3、BlockingQueue\"><a href=\"#6-4-3、BlockingQueue\" class=\"headerlink\" title=\"6.4.3、BlockingQueue\"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p>\n<ol>\n<li>区别</li>\n</ol>\n<p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p>\n<h3 id=\"6-4-4、ConcurrentLinkedQueue\"><a href=\"#6-4-4、ConcurrentLinkedQueue\" class=\"headerlink\" title=\"6.4.4、ConcurrentLinkedQueue\"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p>\n<h3 id=\"6-4-5、CopyOnWriteArrayList\"><a href=\"#6-4-5、CopyOnWriteArrayList\" class=\"headerlink\" title=\"6.4.5、CopyOnWriteArrayList\"></a>6.4.5、CopyOnWriteArrayList</h3><ol>\n<li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li>\n<li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li>\n<li>写操作结束后会把原数组指向新数组</li>\n<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、java多线程基本概念\"><a href=\"#1、java多线程基本概念\" class=\"headerlink\" title=\"1、java多线程基本概念\"></a>1、java多线程基本概念</h1><h2 id=\"1-1、进程和线程\"><a href=\"#1-1、进程和线程\" class=\"headerlink\" title=\"1.1、进程和线程\"></a>1.1、进程和线程</h2><ol>\n<li><strong>进程</strong></li>\n</ol>\n<ul>\n<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li>\n<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>\n<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>\n</ul>\n<ol start=\"2\">\n<li><strong>线程</strong></li>\n</ol>\n<ul>\n<li>一个进程之内可以分为一到多个线程。 </li>\n<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li>\n<li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li>\n</ul>\n<h2 id=\"1-2、并发和并行\"><a href=\"#1-2、并发和并行\" class=\"headerlink\" title=\"1.2、并发和并行\"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p>\n<h2 id=\"1-3、多线程的应用\"><a href=\"#1-3、多线程的应用\" class=\"headerlink\" title=\"1.3、多线程的应用\"></a>1.3、多线程的应用</h2><h3 id=\"1-3-1、异步调用\"><a href=\"#1-3-1、异步调用\" class=\"headerlink\" title=\"1.3.1、异步调用\"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p>\n<h3 id=\"1-3-2、提升效率\"><a href=\"#1-3-2、提升效率\" class=\"headerlink\" title=\"1.3.2、提升效率\"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算 <span class=\"number\">1</span> 花费 <span class=\"number\">10</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">2</span> 花费 <span class=\"number\">11</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">3</span> 花费 <span class=\"number\">9</span> ms</span><br><span class=\"line\">汇总需要 <span class=\"number\">1</span> ms</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li>\n<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms</li>\n</ul>\n<blockquote>\n<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>\n</blockquote>\n<h1 id=\"2、java线程\"><a href=\"#2、java线程\" class=\"headerlink\" title=\"2、java线程\"></a>2、java线程</h1><h2 id=\"2-1、线程的创建\"><a href=\"#2-1、线程的创建\" class=\"headerlink\" title=\"2.1、线程的创建\"></a>2.1、线程的创建</h2><h3 id=\"2-1-1、直接使用Thread\"><a href=\"#2-1-1、直接使用Thread\" class=\"headerlink\" title=\"2.1.1、直接使用Thread\"></a>2.1.1、直接使用Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、使用-Runnable-配合-Thread\"><a href=\"#2-1-2、使用-Runnable-配合-Thread\" class=\"headerlink\" title=\"2.1.2、使用 Runnable 配合 Thread\"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>( runnable );</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<p>java8可用lambda精简</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">task2</span> <span class=\"operator\">=</span> () -&gt; log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task2, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">t2.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3、FutureTask-配合-Thread\"><a href=\"#2-1-3、FutureTask-配合-Thread\" class=\"headerlink\" title=\"2.1.3、FutureTask 配合 Thread\"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\">FutureTask&lt;Integer&gt; task3 = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task3, <span class=\"string\">&quot;t3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> task3.get();</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、查看进程线程\"><a href=\"#2-2、查看进程线程\" class=\"headerlink\" title=\"2.2、查看进程线程\"></a>2.2、查看进程线程</h2><h3 id=\"2-2-1、windows\"><a href=\"#2-2-1、windows\" class=\"headerlink\" title=\"2.2.1、windows\"></a>2.2.1、windows</h3><ol>\n<li>tasklist 查看进程 </li>\n<li>taskkill 杀死进程 </li>\n<li>netstat -ano|findstr 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-2、linux\"><a href=\"#2-2-2、linux\" class=\"headerlink\" title=\"2.2.2、linux\"></a>2.2.2、linux</h3><ol>\n<li>ps -fe 查看所有进程 </li>\n<li>kill 杀死进程</li>\n<li>top -Hp <PID> 查看某个进程（PID）的所有线程 </li>\n<li>netstat -nlp|grep 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-3、JDK\"><a href=\"#2-2-3、JDK\" class=\"headerlink\" title=\"2.2.3、JDK\"></a>2.2.3、JDK</h3><ol>\n<li>jps 命令查看所有 Java 进程</li>\n<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>\n<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>\n</ol>\n<h2 id=\"2-3、线程运行原理\"><a href=\"#2-3、线程运行原理\" class=\"headerlink\" title=\"2.3、线程运行原理\"></a>2.3、线程运行原理</h2><ol>\n<li><strong>线程创建</strong></li>\n</ol>\n<p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成<br>，栈帧对应着每次方法调用所占内存</p>\n<ol start=\"2\">\n<li><strong>上下文切换</strong></li>\n</ol>\n<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p>\n<blockquote>\n<p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p>\n</blockquote>\n<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p>\n<h2 id=\"2-4、start与run\"><a href=\"#2-4、start与run\" class=\"headerlink\" title=\"2.4、start与run\"></a>2.4、start与run</h2><ul>\n<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>\n<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>\n</ul>\n<h2 id=\"2-5、sleep-与-yield\"><a href=\"#2-5、sleep-与-yield\" class=\"headerlink\" title=\"2.5、sleep 与 yield\"></a>2.5、sleep 与 yield</h2><ol>\n<li><strong>sleep</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>睡眠结束后的线程未必会立刻得到执行</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>yield</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>具体的实现依赖于操作系统的任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-6、join\"><a href=\"#2-6、join\" class=\"headerlink\" title=\"2.6、join\"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    test1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">        r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"comment\">// t1.join();</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不加t1.join()结果为0，加上以后结果为1</p>\n</blockquote>\n<h2 id=\"2-7、interrupt\"><a href=\"#2-7、interrupt\" class=\"headerlink\" title=\"2.7、interrupt\"></a>2.7、interrupt</h2><h3 id=\"2-7-1、打断阻塞状态的线程\"><a href=\"#2-7-1、打断阻塞状态的线程\" class=\"headerlink\" title=\"2.7.1、打断阻塞状态的线程\"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t1.interrupt();</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">     at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">     at java.lang.Thread.sleep(Thread.java:<span class=\"number\">340</span>)</span><br><span class=\"line\">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class=\"number\">386</span>)</span><br><span class=\"line\">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class=\"number\">3</span>(TestInterrupt.java:<span class=\"number\">59</span>)</span><br><span class=\"line\">     at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">18</span>:<span class=\"number\">10.374</span> [main] c.TestInterrupt - 打断状态: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-2、打断正常运行的线程\"><a href=\"#2-7-2、打断正常运行的线程\" class=\"headerlink\" title=\"2.7.2、打断正常运行的线程\"></a>2.7.2、打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> current.isInterrupted();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(interrupted) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t2.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class=\"literal\">true</span> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8、主线程与守护线程\"><a href=\"#2-8、主线程与守护线程\" class=\"headerlink\" title=\"2.8、主线程与守护线程\"></a>2.8、主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </p>\n<p>例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;daemon&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置该线程为守护线程</span></span><br><span class=\"line\">t1.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>**注意 **</p>\n<ul>\n<li>垃圾回收器线程就是一种守护线程 </li>\n<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>\n</ul>\n</blockquote>\n<h2 id=\"2-9、线程状态\"><a href=\"#2-9、线程状态\" class=\"headerlink\" title=\"2.9、线程状态\"></a>2.9、线程状态</h2><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NEW</td>\n<td>初始状态:线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>阻塞状态:表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td>WAITING</td>\n<td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>\n</tr>\n<tr>\n<td>TIMEWAITING</td>\n<td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>终止状态:表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg\" alt=\"线程状态\"></p>\n<h1 id=\"3、共享模型之管程\"><a href=\"#3、共享模型之管程\" class=\"headerlink\" title=\"3、共享模型之管程\"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p>\n<h2 id=\"3-1、monitor\"><a href=\"#3-1、monitor\" class=\"headerlink\" title=\"3.1、monitor\"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>\n<h3 id=\"3-1-1、Monitor结构\"><a href=\"#3-1-1、Monitor结构\" class=\"headerlink\" title=\"3.1.1、Monitor结构\"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg\" alt=\"monitor结构\"></p>\n<h3 id=\"3-1-2、Monitor原理\"><a href=\"#3-1-2、Monitor原理\" class=\"headerlink\" title=\"3.1.2、Monitor原理\"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n<h2 id=\"3-2、java对象结构\"><a href=\"#3-2、java对象结构\" class=\"headerlink\" title=\"3.2、java对象结构\"></a>3.2、java对象结构</h2><ol>\n<li><strong>对象头</strong></li>\n</ol>\n<p>包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg\" alt=\"java对象头\"></p>\n<ol start=\"2\">\n<li><strong>实例数据</strong></li>\n</ol>\n<p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p>\n<ol start=\"3\">\n<li><strong>对齐填充</strong></li>\n</ol>\n<p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>\n<h2 id=\"3-3、synchronized升级\"><a href=\"#3-3、synchronized升级\" class=\"headerlink\" title=\"3.3、synchronized升级\"></a>3.3、synchronized升级</h2><h3 id=\"3-3-1、偏向锁\"><a href=\"#3-3-1、偏向锁\" class=\"headerlink\" title=\"3.3.1、偏向锁\"></a>3.3.1、偏向锁</h3><blockquote>\n<p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p>\n</blockquote>\n<p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>\n<h3 id=\"3-3-2、轻量级锁\"><a href=\"#3-3-2、轻量级锁\" class=\"headerlink\" title=\"3.3.2、轻量级锁\"></a>3.3.2、轻量级锁</h3><blockquote>\n<p>使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg\" alt=\"轻量级锁\"></p>\n<ol>\n<li>创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象</li>\n<li>让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>\n<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>\n<li>如果 cas 失败，有两种情况</li>\n</ol>\n<p>（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程<br>（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）</p>\n<ol start=\"5\">\n<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>\n<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</li>\n</ol>\n<p>（1）成功，则解锁成功<br>（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>\n<h3 id=\"3-3-3、重量级锁\"><a href=\"#3-3-3、重量级锁\" class=\"headerlink\" title=\"3.3.3、重量级锁\"></a>3.3.3、重量级锁</h3><blockquote>\n<p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg\" alt=\"重量级锁\"></p>\n<ol>\n<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>\n<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</li>\n</ol>\n<p>（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<br>（2）然后自己进入 Monitor 的 EntryList阻塞队列</p>\n<ol start=\"3\">\n<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）</li>\n</ol>\n<blockquote>\n<p>调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n</blockquote>\n<h3 id=\"3-3-4、自旋锁\"><a href=\"#3-3-4、自旋锁\" class=\"headerlink\" title=\"3.3.4、自旋锁\"></a>3.3.4、自旋锁</h3><p>重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)</p>\n<h2 id=\"3-4、wait-notify\"><a href=\"#3-4、wait-notify\" class=\"headerlink\" title=\"3.4、wait&#x2F;notify\"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p>\n<h3 id=\"3-4-1、sleep和wait的区别？\"><a href=\"#3-4-1、sleep和wait的区别？\" class=\"headerlink\" title=\"3.4.1、sleep和wait的区别？\"></a>3.4.1、sleep和wait的区别？</h3><ol>\n<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>\n<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>\n<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>\n</ol>\n<h2 id=\"3-5、park-unpark\"><a href=\"#3-5、park-unpark\" class=\"headerlink\" title=\"3.5、park&#x2F;unpark\"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂停当前线程</span></span><br><span class=\"line\">LockSupport.park(); </span><br><span class=\"line\"><span class=\"comment\">// 恢复某个线程的运行</span></span><br><span class=\"line\">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-1、与-Object-的-wait-notify-相比\"><a href=\"#3-5-1、与-Object-的-wait-notify-相比\" class=\"headerlink\" title=\"3.5.1、与 Object 的 wait &amp; notify 相比\"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul>\n<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>\n<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>\n<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>\n</ul>\n<h3 id=\"3-5-2、原理\"><a href=\"#3-5-2、原理\" class=\"headerlink\" title=\"3.5.2、原理\"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p>\n<p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p>\n<h2 id=\"3-6、死锁\"><a href=\"#3-6、死锁\" class=\"headerlink\" title=\"3.6、死锁\"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p>\n<h3 id=\"3-6-1、死锁的必要条件\"><a href=\"#3-6-1、死锁的必要条件\" class=\"headerlink\" title=\"3.6.1、死锁的必要条件\"></a>3.6.1、死锁的必要条件</h3><ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h3 id=\"3-6-2、死锁的实现\"><a href=\"#3-6-2、死锁的实现\" class=\"headerlink\" title=\"3.6.2、死锁的实现\"></a>3.6.2、死锁的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">owner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"comment\">//开启一个新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                lock(owner, target);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"comment\">//主线程</span></span><br><span class=\"line\">        lock(target, owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">(Object owner, Object target)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (owner) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (target) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;success&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-3、定位死锁\"><a href=\"#3-6-3、定位死锁\" class=\"headerlink\" title=\"3.6.3、定位死锁\"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p>\n<h3 id=\"3-6-4、哲学家就餐问题\"><a href=\"#3-6-4、哲学家就餐问题\" class=\"headerlink\" title=\"3.6.4、哲学家就餐问题\"></a>3.6.4、哲学家就餐问题</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg\" alt=\"哲学家就餐问题\"></p>\n<p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p>\n<ol>\n<li>筷子类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chopstick</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Chopstick</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;筷子&#123;&quot;</span> + name + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>哲学家类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Philosopher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    Chopstick left;</span><br><span class=\"line\">    Chopstick right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Philosopher</span><span class=\"params\">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;eating...&quot;</span>);</span><br><span class=\"line\">        Sleeper.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得左手筷子</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (left) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获得右手筷子</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (right) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">                    eat();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 放下右手筷子</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 放下左手筷子</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>就餐</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c5</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、活锁\"><a href=\"#3-7、活锁\" class=\"headerlink\" title=\"3.7、活锁\"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p>\n<blockquote>\n<p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p>\n</blockquote>\n<h2 id=\"3-8、ReentrantLock\"><a href=\"#3-8、ReentrantLock\" class=\"headerlink\" title=\"3.8、ReentrantLock\"></a>3.8、<strong>ReentrantLock</strong></h2><p>相对于 synchronized 它具备如下特点 </p>\n<ol>\n<li>可中断 </li>\n<li>可以设置超时时间 </li>\n<li>可以设置为公平锁 （默认不公平）</li>\n<li>支持多个条件变量</li>\n</ol>\n<p>与 synchronized 一样，都支持可重入 </p>\n<h1 id=\"4、共享模型之内存\"><a href=\"#4、共享模型之内存\" class=\"headerlink\" title=\"4、共享模型之内存\"></a>4、共享模型之内存</h1><h2 id=\"4-1、java内存模型（jmm）\"><a href=\"#4-1、java内存模型（jmm）\" class=\"headerlink\" title=\"4.1、java内存模型（jmm）\"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p>\n<h2 id=\"4-2、线程安全性的三个体现\"><a href=\"#4-2、线程安全性的三个体现\" class=\"headerlink\" title=\"4.2、线程安全性的三个体现\"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）<br><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）<br><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）</p>\n<h1 id=\"5、共享模型之无锁\"><a href=\"#5、共享模型之无锁\" class=\"headerlink\" title=\"5、共享模型之无锁\"></a>5、共享模型之无锁</h1><h2 id=\"5-1、CAS\"><a href=\"#5-1、CAS\" class=\"headerlink\" title=\"5.1、CAS\"></a>5.1、CAS</h2><h3 id=\"5-1-1、CAS基本概念\"><a href=\"#5-1-1、CAS基本概念\" class=\"headerlink\" title=\"5.1.1、CAS基本概念\"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>\n<blockquote>\n<ol>\n<li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li>\n<li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li>\n</ol>\n</blockquote>\n<h3 id=\"5-1-2、CAS问题\"><a href=\"#5-1-2、CAS问题\" class=\"headerlink\" title=\"5.1.2、CAS问题\"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p>\n<p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p>\n<h2 id=\"5-2、volatile\"><a href=\"#5-2、volatile\" class=\"headerlink\" title=\"5.2、volatile\"></a>5.2、volatile</h2><h3 id=\"5-2-1、如何保证可见性和有序性\"><a href=\"#5-2-1、如何保证可见性和有序性\" class=\"headerlink\" title=\"5.2.1、如何保证可见性和有序性\"></a>5.2.1、如何保证可见性和有序性</h3><ol>\n<li><strong>保证可见性（缓存一致性协议MESI）</strong></li>\n</ol>\n<p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p>\n<blockquote>\n<p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p>\n</blockquote>\n<blockquote>\n<p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>保证有序性（禁止指令重排优化）</strong></li>\n</ol>\n<p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p>\n<h2 id=\"5-3、原子类\"><a href=\"#5-3、原子类\" class=\"headerlink\" title=\"5.3、原子类\"></a>5.3、原子类</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>具体类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic 基本类型原子类</td>\n<td>AtomicInteger AtomicLong AtomicBoolean</td>\n</tr>\n<tr>\n<td>AtomicArray 数组类型原子类</td>\n<td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td>\n</tr>\n<tr>\n<td>AtomicReference 引用类型原子类</td>\n<td>AtomicReference AtomicStampedReference AtomicMarkableReference</td>\n</tr>\n<tr>\n<td>AtomicFieldUpdate 升级类型原子类</td>\n<td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td>\n</tr>\n</tbody></table>\n<h1 id=\"6、共享模式之工具\"><a href=\"#6、共享模式之工具\" class=\"headerlink\" title=\"6、共享模式之工具\"></a>6、共享模式之工具</h1><h2 id=\"6-1、线程池\"><a href=\"#6-1、线程池\" class=\"headerlink\" title=\"6.1、线程池\"></a>6.1、线程池</h2><h3 id=\"6-1-1、ThreadPoolExecutor\"><a href=\"#6-1-1、ThreadPoolExecutor\" class=\"headerlink\" title=\"6.1.1、ThreadPoolExecutor\"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol>\n<li><strong>构造方法</strong></li>\n</ol>\n<p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p>\n<blockquote>\n<ol>\n<li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li>\n<li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li>\n<li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li>\n<li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>\n<li>workQueue：缓存队列，用来存放等待被执行的任务。</li>\n<li>threadFactory 线程工厂</li>\n<li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>\n<h3 id=\"6-1-2、Executors类中提供的工厂方法\"><a href=\"#6-1-2、Executors类中提供的工厂方法\" class=\"headerlink\" title=\"6.1.2、Executors类中提供的工厂方法\"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p>\n<ol>\n<li><strong>newFixedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newFixedThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点：</p>\n<ul>\n<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>\n<li>阻塞队列是无界的，可以放任意数量的任务</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>适用于任务量已知，相对耗时的任务</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>newCachedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newCachedThreadPool</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点 </p>\n<ul>\n<li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul>\n<li>全部都是救急线程（60s 后可以回收）</li>\n<li>救急线程可以无限创建</li>\n</ul>\n</li>\n<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p>\n</blockquote>\n<ol start=\"3\">\n<li>newSingleThreadExecutor</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newSingleThreadExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\">        (<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。 </p>\n<h3 id=\"6-1-3、创建多大的线程池\"><a href=\"#6-1-3、创建多大的线程池\" class=\"headerlink\" title=\"6.1.3、创建多大的线程池\"></a>6.1.3、创建多大的线程池</h3><ul>\n<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>\n<li>过大会导致更多的线程上下文切换，影响性能</li>\n</ul>\n<ol>\n<li>**CPU 密集型运算 **</li>\n</ol>\n<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>\n<ol start=\"2\">\n<li><strong>I&#x2F;O密集型</strong></li>\n</ol>\n<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>\n<h2 id=\"6-2、锁\"><a href=\"#6-2、锁\" class=\"headerlink\" title=\"6.2、锁\"></a>6.2、锁</h2><h3 id=\"6-2-1、AQS\"><a href=\"#6-2-1、AQS\" class=\"headerlink\" title=\"6.2.1、AQS\"></a>6.2.1、AQS</h3><ol>\n<li>基本概念</li>\n</ol>\n<p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p>\n<ol start=\"2\">\n<li>原理</li>\n</ol>\n<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>\n<blockquote>\n<p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>\n</blockquote>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p>\n<h3 id=\"6-2-2、ReentrantLock\"><a href=\"#6-2-2、ReentrantLock\" class=\"headerlink\" title=\"6.2.2、ReentrantLock\"></a>6.2.2、ReentrantLock</h3><p><strong>实现原理</strong></p>\n<ol>\n<li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li>\n<li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li>\n<li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li>\n<li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li>\n</ol>\n<p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p>\n<h3 id=\"6-2-3、ReentrantReadWriteLock\"><a href=\"#6-2-3、ReentrantReadWriteLock\" class=\"headerlink\" title=\"6.2.3、ReentrantReadWriteLock\"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id=\"4-2-3-1、ReentrantReadWriteLock基本概念\"><a href=\"#4-2-3-1、ReentrantReadWriteLock基本概念\" class=\"headerlink\" title=\"4.2.3.1、ReentrantReadWriteLock基本概念\"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p>\n<h4 id=\"4-2-3-2、锁获取过程\"><a href=\"#4-2-3-2、锁获取过程\" class=\"headerlink\" title=\"4.2.3.2、锁获取过程\"></a>4.2.3.2、锁获取过程</h4><ol>\n<li>获取读锁</li>\n</ol>\n<p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>     如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。</p>\n<ol start=\"4\">\n<li>获取写入锁</li>\n</ol>\n<p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p>\n<h4 id=\"4-2-3-3、常见问题\"><a href=\"#4-2-3-3、常见问题\" class=\"headerlink\" title=\"4.2.3.3、常见问题\"></a>4.2.3.3、常见问题</h4><ol>\n<li><strong>读锁和写锁的可重入性</strong></li>\n</ol>\n<p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p>\n<ol start=\"2\">\n<li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li>\n</ol>\n<p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p>\n<ol start=\"3\">\n<li><strong>锁降级是怎么降级的？</strong></li>\n</ol>\n<p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p>\n<h2 id=\"6-3、工具\"><a href=\"#6-3、工具\" class=\"headerlink\" title=\"6.3、工具\"></a>6.3、工具</h2><h3 id=\"6-3-1、Semaphore\"><a href=\"#6-3-1、Semaphore\" class=\"headerlink\" title=\"6.3.1、Semaphore\"></a>6.3.1、Semaphore</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourcePool</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//用到了信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DataSourcePool</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">        list = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        semaphore = <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">            list.add(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用同步方法获取</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class=\"line\">        semaphore.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">close</span><span class=\"params\">(Connection connection)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//信号量+1</span></span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">        list.add(connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p>\n<p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p>\n<h3 id=\"6-3-2、CountdownLatch\"><a href=\"#6-3-2、CountdownLatch\" class=\"headerlink\" title=\"6.3.2、CountdownLatch\"></a>6.3.2、CountdownLatch</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ExecutorService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1.5</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;wait end...&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - waiting... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">26.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - end..<span class=\"number\">.2</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.335</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - end..<span class=\"number\">.1</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - end..<span class=\"number\">.0</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - wait end...</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p>\n<ol start=\"3\">\n<li><strong>和join的区别？</strong></li>\n</ol>\n<p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p>\n<h3 id=\"6-3-3、CyclicBarrier\"><a href=\"#6-3-3、CyclicBarrier\" class=\"headerlink\" title=\"6.3.3、CyclicBarrier\"></a>6.3.3、CyclicBarrier</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(count, <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;全部加载完毕&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; x &lt; count; x++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(cb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    CyclicBarrier cyclicBarrier;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已加载完&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            cyclicBarrier.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">6</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">7</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">8</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">9</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">10</span> 已加载完</span><br><span class=\"line\">全部加载完毕</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p>\n<h2 id=\"6-4、线程安全集合类\"><a href=\"#6-4、线程安全集合类\" class=\"headerlink\" title=\"6.4、线程安全集合类\"></a>6.4、线程安全集合类</h2><h3 id=\"6-4-1、概述\"><a href=\"#6-4-1、概述\" class=\"headerlink\" title=\"6.4.1、概述\"></a>6.4.1、概述</h3><p>线程安全实现类有三类：</p>\n<ol>\n<li>遗留的线程安全集合如 Hashtable ， Vector </li>\n<li>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</li>\n</ol>\n<blockquote>\n<ul>\n<li>Collections.synchronizedCollection </li>\n<li>Collections.synchronizedList </li>\n<li>Collections.synchronizedMap </li>\n<li>Collections.synchronizedSet </li>\n<li>Collections.synchronizedNavigableMap </li>\n<li>Collections.synchronizedNavigableSet</li>\n<li>Collections.synchronizedSortedMap </li>\n<li>Collections.synchronizedSortedSet</li>\n</ul>\n</blockquote>\n<ol start=\"4\">\n<li>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent</li>\n</ol>\n<blockquote>\n<ul>\n<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li>\n<li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li>\n<li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul>\n<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>\n<li>弱一致性 <ul>\n<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li>\n<li>求大小弱一致性，size 操作未必是 100% 准确 </li>\n<li>读取弱一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p>\n</blockquote>\n<h3 id=\"6-4-2、concurrentHashMap\"><a href=\"#6-4-2、concurrentHashMap\" class=\"headerlink\" title=\"6.4.2、concurrentHashMap\"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p>\n<p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p>\n<p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p>\n<blockquote>\n<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p>\n</blockquote>\n<p><strong>JDK1.8</strong></p>\n<p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p>\n<ol>\n<li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li>\n<li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li>\n<li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li>\n<li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li>\n</ol>\n<h3 id=\"6-4-3、BlockingQueue\"><a href=\"#6-4-3、BlockingQueue\" class=\"headerlink\" title=\"6.4.3、BlockingQueue\"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p>\n<ol>\n<li>区别</li>\n</ol>\n<p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p>\n<h3 id=\"6-4-4、ConcurrentLinkedQueue\"><a href=\"#6-4-4、ConcurrentLinkedQueue\" class=\"headerlink\" title=\"6.4.4、ConcurrentLinkedQueue\"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p>\n<h3 id=\"6-4-5、CopyOnWriteArrayList\"><a href=\"#6-4-5、CopyOnWriteArrayList\" class=\"headerlink\" title=\"6.4.5、CopyOnWriteArrayList\"></a>6.4.5、CopyOnWriteArrayList</h3><ol>\n<li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li>\n<li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li>\n<li>写操作结束后会把原数组指向新数组</li>\n<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>\n</ol>\n"},{"title":"RabbitMQ","date":"2023-07-23T16:00:00.000Z","abbrlink":33708,"_content":"# 1、基本基础\n## 1.1、mq概念\nMQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信\n## 1.2、mq优缺点\n**优势：**\n（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单\n（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度\n（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  \n\n**劣势：**\n（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用\n（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？\n（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性\n## 1.3、mq产品选型\n\n|指标 | **ActiveMQ** | **RabbitMQ** | **RocketM Q** | **Kafka** |\n| --- | --- | --- | --- | --- |\n| 数据量级（每秒） | 万级 | 万级 | 十万级 | 十万级 |\n| 可靠性 | 低概率丢失 | 0丢失 | 0丢失 | 0丢失 |\n| 可用性 | 主从架构 | 主从架构 | 分布式 | 分布式 |\n| 时效性 | 毫秒 | 微秒 | 毫秒 | 毫秒 |\n\n> 一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。\n\n## 1.4、AMQP协议\n AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是**应用层协议**的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制 1\n\n## 1.5、rabbitMQ安装\n\n1. 安装Eralng，下面链接已提供otp_win64_20.2.exe\n\n链接： [https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg](https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg)\n提取码：x9m7\n\n2. 安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe\n\n链接： [https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg](https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg)\n提取码：h4r3\n\n3. 配置erlang环境变量\n\n![配置erlang环境变量](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png)\n\n\n\n4. 测试erlang\n\n![测试erlang](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png)\n\n\n5. 启动rabbitmq\n\n![启动rabbitmq](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png)\n\n\n6. 访问 [http://127.0.0.1:15672/](http://127.0.0.1:15672/)      guest guest\n\n\n# 2、组件\n## 2.1、RabbitMQ架构\n![RabbitMQ架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png)\n\n\n（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。\n（2）Connection：连接，应用程序与Server的网络连接，TCP连接。\n（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。\n（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。\n（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。\n（6）Queue：消息队列，用来保存消息，供消费者消费\n（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。\n（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。\n（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”\n\n## 2.2、4种Exchange交换机类型\n### 2.2.1、Direct Exchange（直连交换机）\n\n根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。\n\n![直连交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png)\n\n\n### 2.2.2、Fanout Exchange（广播交换机）\n该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么\n> 如果想让多个消费者消费到数据必须不指定queues，指定交换机\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n\n        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生\n\n        exchange = @Exchange(value = \"business_rrpc_exchange\",type = ExchangeTypes.FANOUT)\n\n))\n\n\n```\n### 2.2.3、Topic Exchange（主题交换机）\n\n将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“\\*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.\\* ” 只会匹配到“abc.def”。\n\n![主题交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png)\n\n\n### 2.2.4、Headers Exchanges（头交换机）\n\n与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()\n\n> 匹配规则x-match有下列两种类型：\nx-match = all ：表示所有的键值对都匹配才能接受到消息\nx-match = any ：表示只要有键值对匹配就能接受到消息\n\n![image (6).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png)\n\n\n## 2.3、工作模式\n### 2.3.1、简单模式\n一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景\n\n![简单模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png)\n\n\n> P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理\n\n\n```java\n// 1. 创建队列\n@Bean\npublic Queue Queue() {\n    return new Queue(\"hello\");\n}\n\n// 2. 生产者\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        amqpTemplate.convertAndSend(\"queue1\", content);\n        return content;\n    }\n}\n\n// 3. 消费者\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(msg);\n    }\n}\n\n```\n\n\n### 2.3.2、工作队列模式\n一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率\n\n> 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度\n\n![工作队列模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png)\n\n\n**实现方式**\n多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息\n```java\n// 增加一个消费者监听同一个队列\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276)\n\n### 2.3.3、发布订阅模式\n一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景\n\n![发布订阅模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png)\n\n\n1. **实现方式**\n\n（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 \n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nFanoutExchange fanoutExchange1() {\n    return new FanoutExchange(\"fanoutExchange1\");\n}\n\n@Bean\nBinding bindingExchangeA(Queue queue1, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue1).to(fanoutExchange1);\n}\n\n@Bean\nBinding bindingExchangeB(Queue queue2, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue2).to(fanoutExchange1);\n}\n```\n\n（2）生产者消费者\n\n```java\n// 生产者：第二个参数是队列名，设置为空\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"\", content);\n        }\n        return content;\n    }\n}\n// 消费者1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer1: \"+msg);\n    }\n}\n// 消费者2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339)\n\n### 2.3.4、路由模式\n一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景\n\n![路由模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png)\n\n**实现方式**\n（1）交换机和队列根据指定路由规则绑定\n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nDirectExchange directExchange1() {\n    return new DirectExchange(\"directExchange1\");\n}\n\n@Bean\nBinding bindingExchangeMessage1(Queue queue1, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue1).to(directExchange1).with(\"routingKey1\");\n}\n\n\n@Bean\nBinding bindingExchangeMessage2(Queue queue2, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue2).to(directExchange1).with(\"routingKey2\");\n}\n```\n\n（2）生产者和消费者\n```java\n// consumer1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue1 consumer1: \"+msg);\n    }\n}\n// consumer2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue2 consumer2: \"+msg);\n    }\n}\n// producer\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"routingKey1\", content);\n        }\n        return content;\n    }\n}\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335)\n\n\n# 3、高级特性\n\n## 3.1、保证消息传递的可靠性\nRabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消费者消息确认\n（1）投递确认：**confirm确认模式**（producer——>exchange），**return退回模式**（exchange——>queue）\n（2）消费者确认：ACK消息签收机制，表示消费者收到消息后的确认方式\n\n### 3.1.1、confirm确认模式\n消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)\n\n\n### 3.1.2、return退回模式\n\n消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）\n\n\n**实现confirm callback和return callback：**\n\n1. 配置文件开启相关配置\n\n```yml\nspring:\n  #配置rabbitMq 服务器\n  rabbitmq:\n    host: 127.0.0.1\n    port: 5672\n    username: yancey\n    password: yancey\n \n    # confirmCallback 确认模式\n    # SIMPLE       禁用发布确认模式，是默认值\n\t# CORRELATED   发布消息成功到交换器或失败后 会触发回调方法\n\t# NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用。rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 返回false则会关闭channel，则接下来无法发送消息到broker;\n    publisher-confirm-type: correlated\n \n    # returnCallback 退回模式\n    publisher-returns: true\n```\n\n2. 编写配置类\n\n```java\n@Configuration\npublic class RabbitConfig {\n \n    @Bean\n    public RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) {\n        RabbitTemplate rabbitTemplate = new RabbitTemplate();\n        rabbitTemplate.setConnectionFactory(connectionFactory);\n \n        //设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。\n        //我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)\n        rabbitTemplate.setMandatory(true);\n \n        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {\n            @Override\n            public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n                log.info(\"相关数据：\" + correlationData);\n                if (ack) {\n                    log.info(\"投递成功,确认情况：\" + ack);\n                } else {\n                    log.info(\"投递失败,确认情况：\" + ack);\n                    log.info(\"原因：\" + cause);\n                }\n            }\n        });\n \n        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {\n            @Override\n            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {\n               log.info(\"ReturnCallback:     \" + \"消息：\" + message);\n               log.info(\"ReturnCallback:     \" + \"回应码：\" + replyCode);\n               log.info(\"ReturnCallback:     \" + \"回应信息：\" + replyText);\n               log.info(\"ReturnCallback:     \" + \"交换机：\" + exchange);\n               log.info(\"ReturnCallback:     \" + \"路由键：\" + routingKey);\n            }\n        });\n \n        return rabbitTemplate;\n    }\n}\n```\n\n\n### 3.1.3、消费者端ack机制\n消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除\n\n1. rabbitmq默认的是自动ack，无需添加其他配置\n\n若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。\n若消费过程中出现异常，则超过ack心跳时间，会触发重试消费\n\n2. 手动ack\n\n开启方式简单，只需要放开此配置即可\n```java\nacknowledge-mode: manual # 设置消费端手动 ack\n```\n\n消费者类\n```java\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        try {\n            int i = 10/0;\n            // 消费成功后ack\n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n        }catch (Exception e){\n            // 消费失败后ack\n            // 三个参数：\n            // （1）delivery_tag：表示消息的唯一标识符\n            // （2）multiple：表示是否将delivery_tag之前的所有未确认消息都拒绝。如果multiple为true，则RabbitMQ将拒绝所有未确认的消息，如果为false，则只拒绝指定的消息\n            // （3）requeue：表示是否将被拒绝的消息重新放回队列中。如果requeue为true，则消息将返回到队列中以便重新处理，如果为false，则消息将被丢弃\n            channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);\n\t\t\n            if (message.getMessageProperties().getRedelivered()) {//判断是否已经重试过\n                log.error(\"消息已重复处理失败,拒绝再次接收...\");\n                channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); // 拒绝消息\n                // 重复消费失败的消息入库...\n            } else {\n                log.error(\"消息即将再次返回队列处理...\");\n                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);\n            }\n\t\t\n        }\n    }\n}\n```\n\n\n>requeue参数设置为true，可以将消息返回到队列中以便重新处理\n>但是这样可能导致无限循环地处理同一个错误消息\n>所以上面代码采用了折中方案：首次失败的消息通知队列重发，重复失败的消息落地进行后面的补偿机制\n\n\n\n## 3.2、消息持久化机制\n持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：\n\n1. Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。\n2. Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。\n3. 消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。\n\n>  注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可\n\n### 3.2.1、交换机持久化\n在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true\n```java\n// autoDelete:当所有绑定队列都不在使用时，是否自动 删除\npublic DirectExchange(String name, boolean durable, boolean autoDelete) {\n        super(name, durable, autoDelete);\n}\n\n```\n\n### 3.2.2、队列持久化\n申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true\n```java\n// durable: 是否做队列持久化\n// exclusive: 是否排外。两个作用：（1）当连接关闭时connection.close()该队列是否会自动删除（2）对当前队列加锁，其他通道channel是不能访问的，用于一个队列只能有一个消费者来消费的场景\n// autoDelete:当所有消费客户端连接断开后，是否自动删除 \npublic Queue(String name, boolean durable, boolean exclusive, boolean autoDelete) {\n        this(name, durable, exclusive, autoDelete, (Map)null);\n}\n```\n\n## 3.3、避免消息重复消费\n### 3.3.1、消息重复发送的场景\n消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息\n\n### 3.3.2、解决方案\n保证消费者的幂等性（调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果）\n\n如何保证幂等性？\n1. 使用代码的逻辑判断，判断消息状态是否已经被消费过了\n\n> 使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。\n\n2. 使用token，要申请，一次有效性。\n\n> 在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）\n\n\n## 3.4、避免消息积压问题\n### 3.4.1、消息积压场景\n消费者宕机/消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压\n### 3.4.2、解决方案\n\n1. 上线更多的消费者（如：库存服务），进行正常消费\n2. 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。\n\n## 3.5、保证消息的顺序性\n### 3.5.1、消息顺序错乱场景\n\n生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。\n\n### 3.5.2、解决方案\n保证队列与消费者一对一\n思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的 \n\n","source":"_posts/RabbitMQ.md","raw":"---\ntitle: RabbitMQ\ndate: 2023/07/24\ncategories:\n  - coding\ntags:\n  - RabbitMQ\n  - 消息队列\n  - 编程基础\nabbrlink: 33708\n---\n# 1、基本基础\n## 1.1、mq概念\nMQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信\n## 1.2、mq优缺点\n**优势：**\n（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单\n（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度\n（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  \n\n**劣势：**\n（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用\n（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？\n（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性\n## 1.3、mq产品选型\n\n|指标 | **ActiveMQ** | **RabbitMQ** | **RocketM Q** | **Kafka** |\n| --- | --- | --- | --- | --- |\n| 数据量级（每秒） | 万级 | 万级 | 十万级 | 十万级 |\n| 可靠性 | 低概率丢失 | 0丢失 | 0丢失 | 0丢失 |\n| 可用性 | 主从架构 | 主从架构 | 分布式 | 分布式 |\n| 时效性 | 毫秒 | 微秒 | 毫秒 | 毫秒 |\n\n> 一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。\n\n## 1.4、AMQP协议\n AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是**应用层协议**的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制 1\n\n## 1.5、rabbitMQ安装\n\n1. 安装Eralng，下面链接已提供otp_win64_20.2.exe\n\n链接： [https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg](https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg)\n提取码：x9m7\n\n2. 安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe\n\n链接： [https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg](https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg)\n提取码：h4r3\n\n3. 配置erlang环境变量\n\n![配置erlang环境变量](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png)\n\n\n\n4. 测试erlang\n\n![测试erlang](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png)\n\n\n5. 启动rabbitmq\n\n![启动rabbitmq](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png)\n\n\n6. 访问 [http://127.0.0.1:15672/](http://127.0.0.1:15672/)      guest guest\n\n\n# 2、组件\n## 2.1、RabbitMQ架构\n![RabbitMQ架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png)\n\n\n（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。\n（2）Connection：连接，应用程序与Server的网络连接，TCP连接。\n（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。\n（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。\n（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。\n（6）Queue：消息队列，用来保存消息，供消费者消费\n（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。\n（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。\n（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”\n\n## 2.2、4种Exchange交换机类型\n### 2.2.1、Direct Exchange（直连交换机）\n\n根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。\n\n![直连交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png)\n\n\n### 2.2.2、Fanout Exchange（广播交换机）\n该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么\n> 如果想让多个消费者消费到数据必须不指定queues，指定交换机\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n\n        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生\n\n        exchange = @Exchange(value = \"business_rrpc_exchange\",type = ExchangeTypes.FANOUT)\n\n))\n\n\n```\n### 2.2.3、Topic Exchange（主题交换机）\n\n将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“\\*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.\\* ” 只会匹配到“abc.def”。\n\n![主题交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png)\n\n\n### 2.2.4、Headers Exchanges（头交换机）\n\n与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()\n\n> 匹配规则x-match有下列两种类型：\nx-match = all ：表示所有的键值对都匹配才能接受到消息\nx-match = any ：表示只要有键值对匹配就能接受到消息\n\n![image (6).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png)\n\n\n## 2.3、工作模式\n### 2.3.1、简单模式\n一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景\n\n![简单模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png)\n\n\n> P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理\n\n\n```java\n// 1. 创建队列\n@Bean\npublic Queue Queue() {\n    return new Queue(\"hello\");\n}\n\n// 2. 生产者\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        amqpTemplate.convertAndSend(\"queue1\", content);\n        return content;\n    }\n}\n\n// 3. 消费者\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(msg);\n    }\n}\n\n```\n\n\n### 2.3.2、工作队列模式\n一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率\n\n> 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度\n\n![工作队列模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png)\n\n\n**实现方式**\n多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息\n```java\n// 增加一个消费者监听同一个队列\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276)\n\n### 2.3.3、发布订阅模式\n一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景\n\n![发布订阅模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png)\n\n\n1. **实现方式**\n\n（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 \n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nFanoutExchange fanoutExchange1() {\n    return new FanoutExchange(\"fanoutExchange1\");\n}\n\n@Bean\nBinding bindingExchangeA(Queue queue1, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue1).to(fanoutExchange1);\n}\n\n@Bean\nBinding bindingExchangeB(Queue queue2, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue2).to(fanoutExchange1);\n}\n```\n\n（2）生产者消费者\n\n```java\n// 生产者：第二个参数是队列名，设置为空\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"\", content);\n        }\n        return content;\n    }\n}\n// 消费者1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer1: \"+msg);\n    }\n}\n// 消费者2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339)\n\n### 2.3.4、路由模式\n一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景\n\n![路由模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png)\n\n**实现方式**\n（1）交换机和队列根据指定路由规则绑定\n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nDirectExchange directExchange1() {\n    return new DirectExchange(\"directExchange1\");\n}\n\n@Bean\nBinding bindingExchangeMessage1(Queue queue1, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue1).to(directExchange1).with(\"routingKey1\");\n}\n\n\n@Bean\nBinding bindingExchangeMessage2(Queue queue2, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue2).to(directExchange1).with(\"routingKey2\");\n}\n```\n\n（2）生产者和消费者\n```java\n// consumer1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue1 consumer1: \"+msg);\n    }\n}\n// consumer2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue2 consumer2: \"+msg);\n    }\n}\n// producer\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"routingKey1\", content);\n        }\n        return content;\n    }\n}\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335)\n\n\n# 3、高级特性\n\n## 3.1、保证消息传递的可靠性\nRabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消费者消息确认\n（1）投递确认：**confirm确认模式**（producer——>exchange），**return退回模式**（exchange——>queue）\n（2）消费者确认：ACK消息签收机制，表示消费者收到消息后的确认方式\n\n### 3.1.1、confirm确认模式\n消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)\n\n\n### 3.1.2、return退回模式\n\n消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）\n\n\n**实现confirm callback和return callback：**\n\n1. 配置文件开启相关配置\n\n```yml\nspring:\n  #配置rabbitMq 服务器\n  rabbitmq:\n    host: 127.0.0.1\n    port: 5672\n    username: yancey\n    password: yancey\n \n    # confirmCallback 确认模式\n    # SIMPLE       禁用发布确认模式，是默认值\n\t# CORRELATED   发布消息成功到交换器或失败后 会触发回调方法\n\t# NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用。rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 返回false则会关闭channel，则接下来无法发送消息到broker;\n    publisher-confirm-type: correlated\n \n    # returnCallback 退回模式\n    publisher-returns: true\n```\n\n2. 编写配置类\n\n```java\n@Configuration\npublic class RabbitConfig {\n \n    @Bean\n    public RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) {\n        RabbitTemplate rabbitTemplate = new RabbitTemplate();\n        rabbitTemplate.setConnectionFactory(connectionFactory);\n \n        //设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。\n        //我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)\n        rabbitTemplate.setMandatory(true);\n \n        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {\n            @Override\n            public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n                log.info(\"相关数据：\" + correlationData);\n                if (ack) {\n                    log.info(\"投递成功,确认情况：\" + ack);\n                } else {\n                    log.info(\"投递失败,确认情况：\" + ack);\n                    log.info(\"原因：\" + cause);\n                }\n            }\n        });\n \n        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {\n            @Override\n            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {\n               log.info(\"ReturnCallback:     \" + \"消息：\" + message);\n               log.info(\"ReturnCallback:     \" + \"回应码：\" + replyCode);\n               log.info(\"ReturnCallback:     \" + \"回应信息：\" + replyText);\n               log.info(\"ReturnCallback:     \" + \"交换机：\" + exchange);\n               log.info(\"ReturnCallback:     \" + \"路由键：\" + routingKey);\n            }\n        });\n \n        return rabbitTemplate;\n    }\n}\n```\n\n\n### 3.1.3、消费者端ack机制\n消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除\n\n1. rabbitmq默认的是自动ack，无需添加其他配置\n\n若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。\n若消费过程中出现异常，则超过ack心跳时间，会触发重试消费\n\n2. 手动ack\n\n开启方式简单，只需要放开此配置即可\n```java\nacknowledge-mode: manual # 设置消费端手动 ack\n```\n\n消费者类\n```java\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        try {\n            int i = 10/0;\n            // 消费成功后ack\n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n        }catch (Exception e){\n            // 消费失败后ack\n            // 三个参数：\n            // （1）delivery_tag：表示消息的唯一标识符\n            // （2）multiple：表示是否将delivery_tag之前的所有未确认消息都拒绝。如果multiple为true，则RabbitMQ将拒绝所有未确认的消息，如果为false，则只拒绝指定的消息\n            // （3）requeue：表示是否将被拒绝的消息重新放回队列中。如果requeue为true，则消息将返回到队列中以便重新处理，如果为false，则消息将被丢弃\n            channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);\n\t\t\n            if (message.getMessageProperties().getRedelivered()) {//判断是否已经重试过\n                log.error(\"消息已重复处理失败,拒绝再次接收...\");\n                channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); // 拒绝消息\n                // 重复消费失败的消息入库...\n            } else {\n                log.error(\"消息即将再次返回队列处理...\");\n                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);\n            }\n\t\t\n        }\n    }\n}\n```\n\n\n>requeue参数设置为true，可以将消息返回到队列中以便重新处理\n>但是这样可能导致无限循环地处理同一个错误消息\n>所以上面代码采用了折中方案：首次失败的消息通知队列重发，重复失败的消息落地进行后面的补偿机制\n\n\n\n## 3.2、消息持久化机制\n持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：\n\n1. Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。\n2. Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。\n3. 消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。\n\n>  注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可\n\n### 3.2.1、交换机持久化\n在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true\n```java\n// autoDelete:当所有绑定队列都不在使用时，是否自动 删除\npublic DirectExchange(String name, boolean durable, boolean autoDelete) {\n        super(name, durable, autoDelete);\n}\n\n```\n\n### 3.2.2、队列持久化\n申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true\n```java\n// durable: 是否做队列持久化\n// exclusive: 是否排外。两个作用：（1）当连接关闭时connection.close()该队列是否会自动删除（2）对当前队列加锁，其他通道channel是不能访问的，用于一个队列只能有一个消费者来消费的场景\n// autoDelete:当所有消费客户端连接断开后，是否自动删除 \npublic Queue(String name, boolean durable, boolean exclusive, boolean autoDelete) {\n        this(name, durable, exclusive, autoDelete, (Map)null);\n}\n```\n\n## 3.3、避免消息重复消费\n### 3.3.1、消息重复发送的场景\n消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息\n\n### 3.3.2、解决方案\n保证消费者的幂等性（调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果）\n\n如何保证幂等性？\n1. 使用代码的逻辑判断，判断消息状态是否已经被消费过了\n\n> 使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。\n\n2. 使用token，要申请，一次有效性。\n\n> 在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）\n\n\n## 3.4、避免消息积压问题\n### 3.4.1、消息积压场景\n消费者宕机/消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压\n### 3.4.2、解决方案\n\n1. 上线更多的消费者（如：库存服务），进行正常消费\n2. 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。\n\n## 3.5、保证消息的顺序性\n### 3.5.1、消息顺序错乱场景\n\n生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。\n\n### 3.5.2、解决方案\n保证队列与消费者一对一\n思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的 \n\n","slug":"RabbitMQ","published":1,"updated":"2023-07-26T05:42:29.957Z","_id":"clkjau31m000eigum2978cac6","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1、基本基础\"><a href=\"#1、基本基础\" class=\"headerlink\" title=\"1、基本基础\"></a>1、基本基础</h1><h2 id=\"1-1、mq概念\"><a href=\"#1-1、mq概念\" class=\"headerlink\" title=\"1.1、mq概念\"></a>1.1、mq概念</h2><p>MQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信</p>\n<h2 id=\"1-2、mq优缺点\"><a href=\"#1-2、mq优缺点\" class=\"headerlink\" title=\"1.2、mq优缺点\"></a>1.2、mq优缺点</h2><p><strong>优势：</strong><br>（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单<br>（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度<br>（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  </p>\n<p><strong>劣势：</strong><br>（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用<br>（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？<br>（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性</p>\n<h2 id=\"1-3、mq产品选型\"><a href=\"#1-3、mq产品选型\" class=\"headerlink\" title=\"1.3、mq产品选型\"></a>1.3、mq产品选型</h2><table>\n<thead>\n<tr>\n<th>指标</th>\n<th><strong>ActiveMQ</strong></th>\n<th><strong>RabbitMQ</strong></th>\n<th><strong>RocketM Q</strong></th>\n<th><strong>Kafka</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据量级（每秒）</td>\n<td>万级</td>\n<td>万级</td>\n<td>十万级</td>\n<td>十万级</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>低概率丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>主从架构</td>\n<td>主从架构</td>\n<td>分布式</td>\n<td>分布式</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>毫秒</td>\n<td>微秒</td>\n<td>毫秒</td>\n<td>毫秒</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。</p>\n</blockquote>\n<h2 id=\"1-4、AMQP协议\"><a href=\"#1-4、AMQP协议\" class=\"headerlink\" title=\"1.4、AMQP协议\"></a>1.4、AMQP协议</h2><p> AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是<strong>应用层协议</strong>的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制 1</p>\n<h2 id=\"1-5、rabbitMQ安装\"><a href=\"#1-5、rabbitMQ安装\" class=\"headerlink\" title=\"1.5、rabbitMQ安装\"></a>1.5、rabbitMQ安装</h2><ol>\n<li>安装Eralng，下面链接已提供otp_win64_20.2.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg\">https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg</a><br>提取码：x9m7</p>\n<ol start=\"2\">\n<li>安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg\">https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg</a><br>提取码：h4r3</p>\n<ol start=\"3\">\n<li>配置erlang环境变量</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png\" alt=\"配置erlang环境变量\"></p>\n<ol start=\"4\">\n<li>测试erlang</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png\" alt=\"测试erlang\"></p>\n<ol start=\"5\">\n<li>启动rabbitmq</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png\" alt=\"启动rabbitmq\"></p>\n<ol start=\"6\">\n<li>访问 <a href=\"http://127.0.0.1:15672/\">http://127.0.0.1:15672/</a>      guest guest</li>\n</ol>\n<h1 id=\"2、组件\"><a href=\"#2、组件\" class=\"headerlink\" title=\"2、组件\"></a>2、组件</h1><h2 id=\"2-1、RabbitMQ架构\"><a href=\"#2-1、RabbitMQ架构\" class=\"headerlink\" title=\"2.1、RabbitMQ架构\"></a>2.1、RabbitMQ架构</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png\" alt=\"RabbitMQ架构\"></p>\n<p>（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。<br>（2）Connection：连接，应用程序与Server的网络连接，TCP连接。<br>（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。<br>（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。<br>（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。<br>（6）Queue：消息队列，用来保存消息，供消费者消费<br>（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。<br>（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。<br>（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”</p>\n<h2 id=\"2-2、4种Exchange交换机类型\"><a href=\"#2-2、4种Exchange交换机类型\" class=\"headerlink\" title=\"2.2、4种Exchange交换机类型\"></a>2.2、4种Exchange交换机类型</h2><h3 id=\"2-2-1、Direct-Exchange（直连交换机）\"><a href=\"#2-2-1、Direct-Exchange（直连交换机）\" class=\"headerlink\" title=\"2.2.1、Direct Exchange（直连交换机）\"></a>2.2.1、Direct Exchange（直连交换机）</h3><p>根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png\" alt=\"直连交换机\"></p>\n<h3 id=\"2-2-2、Fanout-Exchange（广播交换机）\"><a href=\"#2-2-2、Fanout-Exchange（广播交换机）\" class=\"headerlink\" title=\"2.2.2、Fanout Exchange（广播交换机）\"></a>2.2.2、Fanout Exchange（广播交换机）</h3><p>该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么</p>\n<blockquote>\n<p>如果想让多个消费者消费到数据必须不指定queues，指定交换机</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(value = &quot;business_rrpc_exchange&quot;,type = ExchangeTypes.FANOUT)</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-3、Topic-Exchange（主题交换机）\"><a href=\"#2-2-3、Topic-Exchange（主题交换机）\" class=\"headerlink\" title=\"2.2.3、Topic Exchange（主题交换机）\"></a>2.2.3、Topic Exchange（主题交换机）</h3><p>将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.* ” 只会匹配到“abc.def”。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png\" alt=\"主题交换机\"></p>\n<h3 id=\"2-2-4、Headers-Exchanges（头交换机）\"><a href=\"#2-2-4、Headers-Exchanges（头交换机）\" class=\"headerlink\" title=\"2.2.4、Headers Exchanges（头交换机）\"></a>2.2.4、Headers Exchanges（头交换机）</h3><p>与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()</p>\n<blockquote>\n<p>匹配规则x-match有下列两种类型：<br>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息<br>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png\" alt=\"image (6).png\"></p>\n<h2 id=\"2-3、工作模式\"><a href=\"#2-3、工作模式\" class=\"headerlink\" title=\"2.3、工作模式\"></a>2.3、工作模式</h2><h3 id=\"2-3-1、简单模式\"><a href=\"#2-3-1、简单模式\" class=\"headerlink\" title=\"2.3.1、简单模式\"></a>2.3.1、简单模式</h3><p>一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png\" alt=\"简单模式\"></p>\n<blockquote>\n<p>P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建队列</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">Queue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 生产者</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;queue1&quot;</span>, content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 消费者</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-3-2、工作队列模式\"><a href=\"#2-3-2、工作队列模式\" class=\"headerlink\" title=\"2.3.2、工作队列模式\"></a>2.3.2、工作队列模式</h3><p>一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率</p>\n<blockquote>\n<p>对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png\" alt=\"工作队列模式\"></p>\n<p><strong>实现方式</strong><br>多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 增加一个消费者监听同一个队列</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276\" alt=\"image.png\"></p>\n<h3 id=\"2-3-3、发布订阅模式\"><a href=\"#2-3-3、发布订阅模式\" class=\"headerlink\" title=\"2.3.3、发布订阅模式\"></a>2.3.3、发布订阅模式</h3><p>一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png\" alt=\"发布订阅模式\"></p>\n<ol>\n<li><strong>实现方式</strong></li>\n</ol>\n<p>（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">FanoutExchange <span class=\"title function_\">fanoutExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FanoutExchange</span>(<span class=\"string\">&quot;fanoutExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeA</span><span class=\"params\">(Queue queue1, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeB</span><span class=\"params\">(Queue queue2, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者：第二个参数是队列名，设置为空</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339\" alt=\"image.png\"></p>\n<h3 id=\"2-3-4、路由模式\"><a href=\"#2-3-4、路由模式\" class=\"headerlink\" title=\"2.3.4、路由模式\"></a>2.3.4、路由模式</h3><p>一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png\" alt=\"路由模式\"></p>\n<p><strong>实现方式</strong><br>（1）交换机和队列根据指定路由规则绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">DirectExchange <span class=\"title function_\">directExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;directExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage1</span><span class=\"params\">(Queue queue1, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(directExchange1).with(<span class=\"string\">&quot;routingKey1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage2</span><span class=\"params\">(Queue queue2, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(directExchange1).with(<span class=\"string\">&quot;routingKey2&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者和消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue1 consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue2 consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// producer</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;routingKey1&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335\" alt=\"image.png\"></p>\n<h1 id=\"3、高级特性\"><a href=\"#3、高级特性\" class=\"headerlink\" title=\"3、高级特性\"></a>3、高级特性</h1><h2 id=\"3-1、保证消息传递的可靠性\"><a href=\"#3-1、保证消息传递的可靠性\" class=\"headerlink\" title=\"3.1、保证消息传递的可靠性\"></a>3.1、保证消息传递的可靠性</h2><p>RabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消费者消息确认<br>（1）投递确认：<strong>confirm确认模式</strong>（producer——&gt;exchange），<strong>return退回模式</strong>（exchange——&gt;queue）<br>（2）消费者确认：ACK消息签收机制，表示消费者收到消息后的确认方式</p>\n<h3 id=\"3-1-1、confirm确认模式\"><a href=\"#3-1-1、confirm确认模式\" class=\"headerlink\" title=\"3.1.1、confirm确认模式\"></a>3.1.1、confirm确认模式</h3><p>消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)</p>\n<h3 id=\"3-1-2、return退回模式\"><a href=\"#3-1-2、return退回模式\" class=\"headerlink\" title=\"3.1.2、return退回模式\"></a>3.1.2、return退回模式</h3><p>消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）</p>\n<p><strong>实现confirm callback和return callback：</strong></p>\n<ol>\n<li>配置文件开启相关配置</li>\n</ol>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"comment\">#配置rabbitMq 服务器</span></span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">5672</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">yancey</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">yancey</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># confirmCallback 确认模式</span></span><br><span class=\"line\">    <span class=\"comment\"># SIMPLE       禁用发布确认模式，是默认值</span></span><br><span class=\"line\">\t<span class=\"comment\"># CORRELATED   发布消息成功到交换器或失败后 会触发回调方法</span></span><br><span class=\"line\">\t<span class=\"comment\"># NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用。rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 返回false则会关闭channel，则接下来无法发送消息到broker;</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-confirm-type:</span> <span class=\"string\">correlated</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># returnCallback 退回模式</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-returns:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写配置类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RabbitTemplate <span class=\"title function_\">createRabbitTemplate</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RabbitTemplate</span> <span class=\"variable\">rabbitTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>();</span><br><span class=\"line\">        rabbitTemplate.setConnectionFactory(connectionFactory);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。</span></span><br><span class=\"line\">        <span class=\"comment\">//我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)</span></span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"literal\">true</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"type\">boolean</span> ack, String cause)</span> &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;相关数据：&quot;</span> + correlationData);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;投递成功,确认情况：&quot;</span> + ack);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;投递失败,确认情况：&quot;</span> + ack);</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;原因：&quot;</span> + cause);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ReturnCallback() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"type\">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;消息：&quot;</span> + message);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;回应码：&quot;</span> + replyCode);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;回应信息：&quot;</span> + replyText);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;交换机：&quot;</span> + exchange);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;路由键：&quot;</span> + routingKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rabbitTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-1-3、消费者端ack机制\"><a href=\"#3-1-3、消费者端ack机制\" class=\"headerlink\" title=\"3.1.3、消费者端ack机制\"></a>3.1.3、消费者端ack机制</h3><p>消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除</p>\n<ol>\n<li>rabbitmq默认的是自动ack，无需添加其他配置</li>\n</ol>\n<p>若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。<br>若消费过程中出现异常，则超过ack心跳时间，会触发重试消费</p>\n<ol start=\"2\">\n<li>手动ack</li>\n</ol>\n<p>开启方式简单，只需要放开此配置即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acknowledge-mode: manual # 设置消费端手动 ack</span><br></pre></td></tr></table></figure>\n\n<p>消费者类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>/<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 消费成功后ack</span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 消费失败后ack</span></span><br><span class=\"line\">            <span class=\"comment\">// 三个参数：</span></span><br><span class=\"line\">            <span class=\"comment\">// （1）delivery_tag：表示消息的唯一标识符</span></span><br><span class=\"line\">            <span class=\"comment\">// （2）multiple：表示是否将delivery_tag之前的所有未确认消息都拒绝。如果multiple为true，则RabbitMQ将拒绝所有未确认的消息，如果为false，则只拒绝指定的消息</span></span><br><span class=\"line\">            <span class=\"comment\">// （3）requeue：表示是否将被拒绝的消息重新放回队列中。如果requeue为true，则消息将返回到队列中以便重新处理，如果为false，则消息将被丢弃</span></span><br><span class=\"line\">            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class=\"literal\">false</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.getMessageProperties().getRedelivered()) &#123;<span class=\"comment\">//判断是否已经重试过</span></span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;消息已重复处理失败,拒绝再次接收...&quot;</span>);</span><br><span class=\"line\">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>); <span class=\"comment\">// 拒绝消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 重复消费失败的消息入库...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;消息即将再次返回队列处理...&quot;</span>);</span><br><span class=\"line\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>requeue参数设置为true，可以将消息返回到队列中以便重新处理<br>但是这样可能导致无限循环地处理同一个错误消息<br>所以上面代码采用了折中方案：首次失败的消息通知队列重发，重复失败的消息落地进行后面的补偿机制</p>\n</blockquote>\n<h2 id=\"3-2、消息持久化机制\"><a href=\"#3-2、消息持久化机制\" class=\"headerlink\" title=\"3.2、消息持久化机制\"></a>3.2、消息持久化机制</h2><p>持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：</p>\n<ol>\n<li>Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。</li>\n<li>Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。</li>\n<li>消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。</li>\n</ol>\n<blockquote>\n<p> 注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可</p>\n</blockquote>\n<h3 id=\"3-2-1、交换机持久化\"><a href=\"#3-2-1、交换机持久化\" class=\"headerlink\" title=\"3.2.1、交换机持久化\"></a>3.2.1、交换机持久化</h3><p>在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// autoDelete:当所有绑定队列都不在使用时，是否自动 删除</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DirectExchange</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, durable, autoDelete);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2、队列持久化\"><a href=\"#3-2-2、队列持久化\" class=\"headerlink\" title=\"3.2.2、队列持久化\"></a>3.2.2、队列持久化</h3><p>申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// durable: 是否做队列持久化</span></span><br><span class=\"line\"><span class=\"comment\">// exclusive: 是否排外。两个作用：（1）当连接关闭时connection.close()该队列是否会自动删除（2）对当前队列加锁，其他通道channel是不能访问的，用于一个队列只能有一个消费者来消费的场景</span></span><br><span class=\"line\"><span class=\"comment\">// autoDelete:当所有消费客户端连接断开后，是否自动删除 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Queue</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> exclusive, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(name, durable, exclusive, autoDelete, (Map)<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3、避免消息重复消费\"><a href=\"#3-3、避免消息重复消费\" class=\"headerlink\" title=\"3.3、避免消息重复消费\"></a>3.3、避免消息重复消费</h2><h3 id=\"3-3-1、消息重复发送的场景\"><a href=\"#3-3-1、消息重复发送的场景\" class=\"headerlink\" title=\"3.3.1、消息重复发送的场景\"></a>3.3.1、消息重复发送的场景</h3><p>消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息</p>\n<h3 id=\"3-3-2、解决方案\"><a href=\"#3-3-2、解决方案\" class=\"headerlink\" title=\"3.3.2、解决方案\"></a>3.3.2、解决方案</h3><p>保证消费者的幂等性（调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果）</p>\n<p>如何保证幂等性？</p>\n<ol>\n<li>使用代码的逻辑判断，判断消息状态是否已经被消费过了</li>\n</ol>\n<blockquote>\n<p>使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。</p>\n</blockquote>\n<ol start=\"2\">\n<li>使用token，要申请，一次有效性。</li>\n</ol>\n<blockquote>\n<p>在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）</p>\n</blockquote>\n<h2 id=\"3-4、避免消息积压问题\"><a href=\"#3-4、避免消息积压问题\" class=\"headerlink\" title=\"3.4、避免消息积压问题\"></a>3.4、避免消息积压问题</h2><h3 id=\"3-4-1、消息积压场景\"><a href=\"#3-4-1、消息积压场景\" class=\"headerlink\" title=\"3.4.1、消息积压场景\"></a>3.4.1、消息积压场景</h3><p>消费者宕机&#x2F;消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压</p>\n<h3 id=\"3-4-2、解决方案\"><a href=\"#3-4-2、解决方案\" class=\"headerlink\" title=\"3.4.2、解决方案\"></a>3.4.2、解决方案</h3><ol>\n<li>上线更多的消费者（如：库存服务），进行正常消费</li>\n<li>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。</li>\n</ol>\n<h2 id=\"3-5、保证消息的顺序性\"><a href=\"#3-5、保证消息的顺序性\" class=\"headerlink\" title=\"3.5、保证消息的顺序性\"></a>3.5、保证消息的顺序性</h2><h3 id=\"3-5-1、消息顺序错乱场景\"><a href=\"#3-5-1、消息顺序错乱场景\" class=\"headerlink\" title=\"3.5.1、消息顺序错乱场景\"></a>3.5.1、消息顺序错乱场景</h3><p>生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。</p>\n<h3 id=\"3-5-2、解决方案\"><a href=\"#3-5-2、解决方案\" class=\"headerlink\" title=\"3.5.2、解决方案\"></a>3.5.2、解决方案</h3><p>保证队列与消费者一对一<br>思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的 </p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、基本基础\"><a href=\"#1、基本基础\" class=\"headerlink\" title=\"1、基本基础\"></a>1、基本基础</h1><h2 id=\"1-1、mq概念\"><a href=\"#1-1、mq概念\" class=\"headerlink\" title=\"1.1、mq概念\"></a>1.1、mq概念</h2><p>MQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信</p>\n<h2 id=\"1-2、mq优缺点\"><a href=\"#1-2、mq优缺点\" class=\"headerlink\" title=\"1.2、mq优缺点\"></a>1.2、mq优缺点</h2><p><strong>优势：</strong><br>（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单<br>（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度<br>（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  </p>\n<p><strong>劣势：</strong><br>（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用<br>（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？<br>（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性</p>\n<h2 id=\"1-3、mq产品选型\"><a href=\"#1-3、mq产品选型\" class=\"headerlink\" title=\"1.3、mq产品选型\"></a>1.3、mq产品选型</h2><table>\n<thead>\n<tr>\n<th>指标</th>\n<th><strong>ActiveMQ</strong></th>\n<th><strong>RabbitMQ</strong></th>\n<th><strong>RocketM Q</strong></th>\n<th><strong>Kafka</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据量级（每秒）</td>\n<td>万级</td>\n<td>万级</td>\n<td>十万级</td>\n<td>十万级</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>低概率丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>主从架构</td>\n<td>主从架构</td>\n<td>分布式</td>\n<td>分布式</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>毫秒</td>\n<td>微秒</td>\n<td>毫秒</td>\n<td>毫秒</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。</p>\n</blockquote>\n<h2 id=\"1-4、AMQP协议\"><a href=\"#1-4、AMQP协议\" class=\"headerlink\" title=\"1.4、AMQP协议\"></a>1.4、AMQP协议</h2><p> AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是<strong>应用层协议</strong>的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制 1</p>\n<h2 id=\"1-5、rabbitMQ安装\"><a href=\"#1-5、rabbitMQ安装\" class=\"headerlink\" title=\"1.5、rabbitMQ安装\"></a>1.5、rabbitMQ安装</h2><ol>\n<li>安装Eralng，下面链接已提供otp_win64_20.2.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg\">https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg</a><br>提取码：x9m7</p>\n<ol start=\"2\">\n<li>安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg\">https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg</a><br>提取码：h4r3</p>\n<ol start=\"3\">\n<li>配置erlang环境变量</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png\" alt=\"配置erlang环境变量\"></p>\n<ol start=\"4\">\n<li>测试erlang</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png\" alt=\"测试erlang\"></p>\n<ol start=\"5\">\n<li>启动rabbitmq</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png\" alt=\"启动rabbitmq\"></p>\n<ol start=\"6\">\n<li>访问 <a href=\"http://127.0.0.1:15672/\">http://127.0.0.1:15672/</a>      guest guest</li>\n</ol>\n<h1 id=\"2、组件\"><a href=\"#2、组件\" class=\"headerlink\" title=\"2、组件\"></a>2、组件</h1><h2 id=\"2-1、RabbitMQ架构\"><a href=\"#2-1、RabbitMQ架构\" class=\"headerlink\" title=\"2.1、RabbitMQ架构\"></a>2.1、RabbitMQ架构</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png\" alt=\"RabbitMQ架构\"></p>\n<p>（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。<br>（2）Connection：连接，应用程序与Server的网络连接，TCP连接。<br>（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。<br>（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。<br>（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。<br>（6）Queue：消息队列，用来保存消息，供消费者消费<br>（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。<br>（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。<br>（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”</p>\n<h2 id=\"2-2、4种Exchange交换机类型\"><a href=\"#2-2、4种Exchange交换机类型\" class=\"headerlink\" title=\"2.2、4种Exchange交换机类型\"></a>2.2、4种Exchange交换机类型</h2><h3 id=\"2-2-1、Direct-Exchange（直连交换机）\"><a href=\"#2-2-1、Direct-Exchange（直连交换机）\" class=\"headerlink\" title=\"2.2.1、Direct Exchange（直连交换机）\"></a>2.2.1、Direct Exchange（直连交换机）</h3><p>根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png\" alt=\"直连交换机\"></p>\n<h3 id=\"2-2-2、Fanout-Exchange（广播交换机）\"><a href=\"#2-2-2、Fanout-Exchange（广播交换机）\" class=\"headerlink\" title=\"2.2.2、Fanout Exchange（广播交换机）\"></a>2.2.2、Fanout Exchange（广播交换机）</h3><p>该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么</p>\n<blockquote>\n<p>如果想让多个消费者消费到数据必须不指定queues，指定交换机</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(value = &quot;business_rrpc_exchange&quot;,type = ExchangeTypes.FANOUT)</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-3、Topic-Exchange（主题交换机）\"><a href=\"#2-2-3、Topic-Exchange（主题交换机）\" class=\"headerlink\" title=\"2.2.3、Topic Exchange（主题交换机）\"></a>2.2.3、Topic Exchange（主题交换机）</h3><p>将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.* ” 只会匹配到“abc.def”。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png\" alt=\"主题交换机\"></p>\n<h3 id=\"2-2-4、Headers-Exchanges（头交换机）\"><a href=\"#2-2-4、Headers-Exchanges（头交换机）\" class=\"headerlink\" title=\"2.2.4、Headers Exchanges（头交换机）\"></a>2.2.4、Headers Exchanges（头交换机）</h3><p>与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()</p>\n<blockquote>\n<p>匹配规则x-match有下列两种类型：<br>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息<br>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png\" alt=\"image (6).png\"></p>\n<h2 id=\"2-3、工作模式\"><a href=\"#2-3、工作模式\" class=\"headerlink\" title=\"2.3、工作模式\"></a>2.3、工作模式</h2><h3 id=\"2-3-1、简单模式\"><a href=\"#2-3-1、简单模式\" class=\"headerlink\" title=\"2.3.1、简单模式\"></a>2.3.1、简单模式</h3><p>一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png\" alt=\"简单模式\"></p>\n<blockquote>\n<p>P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建队列</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">Queue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 生产者</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;queue1&quot;</span>, content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 消费者</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-3-2、工作队列模式\"><a href=\"#2-3-2、工作队列模式\" class=\"headerlink\" title=\"2.3.2、工作队列模式\"></a>2.3.2、工作队列模式</h3><p>一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率</p>\n<blockquote>\n<p>对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png\" alt=\"工作队列模式\"></p>\n<p><strong>实现方式</strong><br>多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 增加一个消费者监听同一个队列</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276\" alt=\"image.png\"></p>\n<h3 id=\"2-3-3、发布订阅模式\"><a href=\"#2-3-3、发布订阅模式\" class=\"headerlink\" title=\"2.3.3、发布订阅模式\"></a>2.3.3、发布订阅模式</h3><p>一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png\" alt=\"发布订阅模式\"></p>\n<ol>\n<li><strong>实现方式</strong></li>\n</ol>\n<p>（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">FanoutExchange <span class=\"title function_\">fanoutExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FanoutExchange</span>(<span class=\"string\">&quot;fanoutExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeA</span><span class=\"params\">(Queue queue1, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeB</span><span class=\"params\">(Queue queue2, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者：第二个参数是队列名，设置为空</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339\" alt=\"image.png\"></p>\n<h3 id=\"2-3-4、路由模式\"><a href=\"#2-3-4、路由模式\" class=\"headerlink\" title=\"2.3.4、路由模式\"></a>2.3.4、路由模式</h3><p>一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png\" alt=\"路由模式\"></p>\n<p><strong>实现方式</strong><br>（1）交换机和队列根据指定路由规则绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">DirectExchange <span class=\"title function_\">directExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;directExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage1</span><span class=\"params\">(Queue queue1, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(directExchange1).with(<span class=\"string\">&quot;routingKey1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage2</span><span class=\"params\">(Queue queue2, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(directExchange1).with(<span class=\"string\">&quot;routingKey2&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者和消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue1 consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue2 consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// producer</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;routingKey1&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335\" alt=\"image.png\"></p>\n<h1 id=\"3、高级特性\"><a href=\"#3、高级特性\" class=\"headerlink\" title=\"3、高级特性\"></a>3、高级特性</h1><h2 id=\"3-1、保证消息传递的可靠性\"><a href=\"#3-1、保证消息传递的可靠性\" class=\"headerlink\" title=\"3.1、保证消息传递的可靠性\"></a>3.1、保证消息传递的可靠性</h2><p>RabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消费者消息确认<br>（1）投递确认：<strong>confirm确认模式</strong>（producer——&gt;exchange），<strong>return退回模式</strong>（exchange——&gt;queue）<br>（2）消费者确认：ACK消息签收机制，表示消费者收到消息后的确认方式</p>\n<h3 id=\"3-1-1、confirm确认模式\"><a href=\"#3-1-1、confirm确认模式\" class=\"headerlink\" title=\"3.1.1、confirm确认模式\"></a>3.1.1、confirm确认模式</h3><p>消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)</p>\n<h3 id=\"3-1-2、return退回模式\"><a href=\"#3-1-2、return退回模式\" class=\"headerlink\" title=\"3.1.2、return退回模式\"></a>3.1.2、return退回模式</h3><p>消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）</p>\n<p><strong>实现confirm callback和return callback：</strong></p>\n<ol>\n<li>配置文件开启相关配置</li>\n</ol>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"comment\">#配置rabbitMq 服务器</span></span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">5672</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">yancey</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">yancey</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># confirmCallback 确认模式</span></span><br><span class=\"line\">    <span class=\"comment\"># SIMPLE       禁用发布确认模式，是默认值</span></span><br><span class=\"line\">\t<span class=\"comment\"># CORRELATED   发布消息成功到交换器或失败后 会触发回调方法</span></span><br><span class=\"line\">\t<span class=\"comment\"># NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用。rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 返回false则会关闭channel，则接下来无法发送消息到broker;</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-confirm-type:</span> <span class=\"string\">correlated</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># returnCallback 退回模式</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-returns:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写配置类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RabbitTemplate <span class=\"title function_\">createRabbitTemplate</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RabbitTemplate</span> <span class=\"variable\">rabbitTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>();</span><br><span class=\"line\">        rabbitTemplate.setConnectionFactory(connectionFactory);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。</span></span><br><span class=\"line\">        <span class=\"comment\">//我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)</span></span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"literal\">true</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"type\">boolean</span> ack, String cause)</span> &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;相关数据：&quot;</span> + correlationData);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;投递成功,确认情况：&quot;</span> + ack);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;投递失败,确认情况：&quot;</span> + ack);</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;原因：&quot;</span> + cause);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ReturnCallback() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"type\">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;消息：&quot;</span> + message);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;回应码：&quot;</span> + replyCode);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;回应信息：&quot;</span> + replyText);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;交换机：&quot;</span> + exchange);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;路由键：&quot;</span> + routingKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rabbitTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-1-3、消费者端ack机制\"><a href=\"#3-1-3、消费者端ack机制\" class=\"headerlink\" title=\"3.1.3、消费者端ack机制\"></a>3.1.3、消费者端ack机制</h3><p>消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除</p>\n<ol>\n<li>rabbitmq默认的是自动ack，无需添加其他配置</li>\n</ol>\n<p>若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。<br>若消费过程中出现异常，则超过ack心跳时间，会触发重试消费</p>\n<ol start=\"2\">\n<li>手动ack</li>\n</ol>\n<p>开启方式简单，只需要放开此配置即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acknowledge-mode: manual # 设置消费端手动 ack</span><br></pre></td></tr></table></figure>\n\n<p>消费者类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>/<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 消费成功后ack</span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 消费失败后ack</span></span><br><span class=\"line\">            <span class=\"comment\">// 三个参数：</span></span><br><span class=\"line\">            <span class=\"comment\">// （1）delivery_tag：表示消息的唯一标识符</span></span><br><span class=\"line\">            <span class=\"comment\">// （2）multiple：表示是否将delivery_tag之前的所有未确认消息都拒绝。如果multiple为true，则RabbitMQ将拒绝所有未确认的消息，如果为false，则只拒绝指定的消息</span></span><br><span class=\"line\">            <span class=\"comment\">// （3）requeue：表示是否将被拒绝的消息重新放回队列中。如果requeue为true，则消息将返回到队列中以便重新处理，如果为false，则消息将被丢弃</span></span><br><span class=\"line\">            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class=\"literal\">false</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.getMessageProperties().getRedelivered()) &#123;<span class=\"comment\">//判断是否已经重试过</span></span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;消息已重复处理失败,拒绝再次接收...&quot;</span>);</span><br><span class=\"line\">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>); <span class=\"comment\">// 拒绝消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 重复消费失败的消息入库...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;消息即将再次返回队列处理...&quot;</span>);</span><br><span class=\"line\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>requeue参数设置为true，可以将消息返回到队列中以便重新处理<br>但是这样可能导致无限循环地处理同一个错误消息<br>所以上面代码采用了折中方案：首次失败的消息通知队列重发，重复失败的消息落地进行后面的补偿机制</p>\n</blockquote>\n<h2 id=\"3-2、消息持久化机制\"><a href=\"#3-2、消息持久化机制\" class=\"headerlink\" title=\"3.2、消息持久化机制\"></a>3.2、消息持久化机制</h2><p>持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：</p>\n<ol>\n<li>Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。</li>\n<li>Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。</li>\n<li>消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。</li>\n</ol>\n<blockquote>\n<p> 注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可</p>\n</blockquote>\n<h3 id=\"3-2-1、交换机持久化\"><a href=\"#3-2-1、交换机持久化\" class=\"headerlink\" title=\"3.2.1、交换机持久化\"></a>3.2.1、交换机持久化</h3><p>在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// autoDelete:当所有绑定队列都不在使用时，是否自动 删除</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DirectExchange</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, durable, autoDelete);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2、队列持久化\"><a href=\"#3-2-2、队列持久化\" class=\"headerlink\" title=\"3.2.2、队列持久化\"></a>3.2.2、队列持久化</h3><p>申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// durable: 是否做队列持久化</span></span><br><span class=\"line\"><span class=\"comment\">// exclusive: 是否排外。两个作用：（1）当连接关闭时connection.close()该队列是否会自动删除（2）对当前队列加锁，其他通道channel是不能访问的，用于一个队列只能有一个消费者来消费的场景</span></span><br><span class=\"line\"><span class=\"comment\">// autoDelete:当所有消费客户端连接断开后，是否自动删除 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Queue</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> exclusive, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(name, durable, exclusive, autoDelete, (Map)<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3、避免消息重复消费\"><a href=\"#3-3、避免消息重复消费\" class=\"headerlink\" title=\"3.3、避免消息重复消费\"></a>3.3、避免消息重复消费</h2><h3 id=\"3-3-1、消息重复发送的场景\"><a href=\"#3-3-1、消息重复发送的场景\" class=\"headerlink\" title=\"3.3.1、消息重复发送的场景\"></a>3.3.1、消息重复发送的场景</h3><p>消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息</p>\n<h3 id=\"3-3-2、解决方案\"><a href=\"#3-3-2、解决方案\" class=\"headerlink\" title=\"3.3.2、解决方案\"></a>3.3.2、解决方案</h3><p>保证消费者的幂等性（调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果）</p>\n<p>如何保证幂等性？</p>\n<ol>\n<li>使用代码的逻辑判断，判断消息状态是否已经被消费过了</li>\n</ol>\n<blockquote>\n<p>使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。</p>\n</blockquote>\n<ol start=\"2\">\n<li>使用token，要申请，一次有效性。</li>\n</ol>\n<blockquote>\n<p>在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）</p>\n</blockquote>\n<h2 id=\"3-4、避免消息积压问题\"><a href=\"#3-4、避免消息积压问题\" class=\"headerlink\" title=\"3.4、避免消息积压问题\"></a>3.4、避免消息积压问题</h2><h3 id=\"3-4-1、消息积压场景\"><a href=\"#3-4-1、消息积压场景\" class=\"headerlink\" title=\"3.4.1、消息积压场景\"></a>3.4.1、消息积压场景</h3><p>消费者宕机&#x2F;消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压</p>\n<h3 id=\"3-4-2、解决方案\"><a href=\"#3-4-2、解决方案\" class=\"headerlink\" title=\"3.4.2、解决方案\"></a>3.4.2、解决方案</h3><ol>\n<li>上线更多的消费者（如：库存服务），进行正常消费</li>\n<li>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。</li>\n</ol>\n<h2 id=\"3-5、保证消息的顺序性\"><a href=\"#3-5、保证消息的顺序性\" class=\"headerlink\" title=\"3.5、保证消息的顺序性\"></a>3.5、保证消息的顺序性</h2><h3 id=\"3-5-1、消息顺序错乱场景\"><a href=\"#3-5-1、消息顺序错乱场景\" class=\"headerlink\" title=\"3.5.1、消息顺序错乱场景\"></a>3.5.1、消息顺序错乱场景</h3><p>生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。</p>\n<h3 id=\"3-5-2、解决方案\"><a href=\"#3-5-2、解决方案\" class=\"headerlink\" title=\"3.5.2、解决方案\"></a>3.5.2、解决方案</h3><p>保证队列与消费者一对一<br>思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的 </p>\n"},{"title":"nginx","date":"2023-07-14T16:00:00.000Z","abbrlink":58122,"_content":"# 1、nginx简介\n## 1.1、nginx概述\nNginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。\n## 1.2、正向代理\nnginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能\n正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【**代理客户端，服务端不知道实际发起请求的客户端**】\n> 例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色\n\n## 1.3、反向代理\n反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【**代理服务端，客户端不知道实际提供服务的服务端**】\n> 例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在\n\n## 1.4、负载均衡\n增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 \n## 1.5、动静分离\n为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力\n> 静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，**但是 tomcat 本身处理静态资源的效率并不高**，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 \n\n\n# 2、nginx安装\n\n1. **安装pcre依赖**\n\n（1）联网下载 pcre 压缩文件依赖：\n```shell\nwget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n```\n（2）解压压缩文件\n```shell\ntar –xvf pcre-8.37.tar.gz\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）查看\n```shell\npcre-config --version\n```\n\n2. **安装安装 openssl 、zlib 、 gcc 依赖**\n\n```shell\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n3. **安装nginx**\n\n（1）解压\n```shell\ntar -xvf nginx-1.12.2.tar.gz\n```\n（2）进入解压后目录，执行config命令\n```shell\n./configure\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）启动nginx\n```shell\n# 进入进入目录 /usr/local/nginx/sbin/nginx\n./nginx\n# 停止\n./nginx -s stop\n# 重启\n./nginx -s reload\n\n```\n\n# 3、nginx配置文件\nNginx配置文件分为三大块：全局块，events块，http块\n\n1. 从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等\n2. events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024\n3. http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等\n\n```shell\n\n#================ 全局快 ==================#\n#定义Nginx运行的用户和用户组\nuser  nginx;\n# 工作进程数，一般配置成和CPU数一样\nworker_processes  auto;\n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log  /var/log/nginx/error.log notice;\n#进程pid文件\npid        /var/run/nginx.pid;\n\n#=============== events块 ================#\nevents {\n    # 标识单个woker进程最大并发数\n    worker_connections  1024;\n}\n\n#=============== http块 =================#\nhttp {\n    #文件扩展名与文件类型映射表\n    include       /etc/nginx/mime.types;\n    #默认文件类型\n    default_type  application/octet-stream;\n    #日志格式设定\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #定义本虚拟主机的访问日志\n    access_log  /var/log/nginx/access.log  main;\n     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载\n    sendfile        on;\n    #长连接超时时间，单位是秒\n    keepalive_timeout  65;\n    #包括多个server块，而每个server块就相当于一个虚拟主机\n    server {\n          listen       80;\n          server_name  localhost;\n          # 对特定地址进行处理，地址定向\n          location / {\n              root   html;\n              index  index.html index.htm;\n          }\n  \n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   html;\n      }\n}\n```\n\n# 4、反向代理实现\n实现效果：输入 http://www.test.com, 自动跳转到百度首页\n\n\n```shell\nserver {\n         listen          80;\n         server_name     www.test.com;  #你的域名\n         location / {\n               proxy_pass          http://www.baidu.com/;  #需要反代的域名\n               proxy_redirect      off;\n               proxy_set_header    X-Real-IP      $remote_addr;\n               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n}\n\n```\n# 5、正向代理实现\n场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题\n场景2：内网机器访问外网，就需要正向代理，类似VPN\n```shell\nserver {\n\tlisten 8090;\n\t\n\tlocation / {\n    # resolver后面填写dns地址，可以多个，将以轮询方式请求\n\t\tresolver 218.85.157.99 218.85.152.99;\n    # resolver_timeout 解析超时时间\n\t\tresolver_timeout 30s;\n    # 代理服务器地址（即要请求的地址）\n\t\tproxy_pass http://$host$request_uri;\n\t}\n\taccess_log /data/httplogs/proxy-$host-aceess.log;\n}\n\n```\n# 6、负载均衡实现\n## 6.1、轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除\n```shell\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    upstream webservers{\n      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n \n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n             #转发到负载服务上\n            proxy_pass http://webservers/api/;\n         }\n    }\n}\n```\n## 6.2、weight\nweight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。\n```shell\n\n    upstream webservers{\n      server  192.168.9.134:8081 weight=8;\n      server  192.168.9.134:8082 weight=2;\n    }\n```\n## 6.3、ip_hash\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\n> 使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题\n\n```shell\n    upstream webservers{\n      ip_hash;\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n```\n## 6.4、fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```shell\nupstream webservers{\n        server 192.168.9.134:8081;\n        server 192.168.9.134:8082;\n        fair;\n}\n```\n## 6.5、url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n> 相同的url会被分配到同一个节点，主要为了提高缓存命中率\n\n```shell\nupstream webservers{\n    hash &request_uri;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n## 6.6、least_conn\n按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况\n```shell\nupstream webservers{\n    least_conn;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n# 7、动静分离\n利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能\n```shell\n#所有js,css相关的静态资源文件的请求由Nginx处理\nlocation ~.*\\.(js|css)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     12h; #过期时间为12小时\n}\n#所有图片等多媒体相关静态资源文件的请求由Nginx处理\nlocation ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     7d; #过期时间为7天\n}\n```\n","source":"_posts/nginx.md","raw":"---\ntitle: nginx\ndate: 2023/07/15\ncategories:\n  - coding\ntags:\n  - nginx\nabbrlink: 58122\n---\n# 1、nginx简介\n## 1.1、nginx概述\nNginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。\n## 1.2、正向代理\nnginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能\n正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【**代理客户端，服务端不知道实际发起请求的客户端**】\n> 例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色\n\n## 1.3、反向代理\n反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【**代理服务端，客户端不知道实际提供服务的服务端**】\n> 例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在\n\n## 1.4、负载均衡\n增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 \n## 1.5、动静分离\n为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力\n> 静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，**但是 tomcat 本身处理静态资源的效率并不高**，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 \n\n\n# 2、nginx安装\n\n1. **安装pcre依赖**\n\n（1）联网下载 pcre 压缩文件依赖：\n```shell\nwget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n```\n（2）解压压缩文件\n```shell\ntar –xvf pcre-8.37.tar.gz\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）查看\n```shell\npcre-config --version\n```\n\n2. **安装安装 openssl 、zlib 、 gcc 依赖**\n\n```shell\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n3. **安装nginx**\n\n（1）解压\n```shell\ntar -xvf nginx-1.12.2.tar.gz\n```\n（2）进入解压后目录，执行config命令\n```shell\n./configure\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）启动nginx\n```shell\n# 进入进入目录 /usr/local/nginx/sbin/nginx\n./nginx\n# 停止\n./nginx -s stop\n# 重启\n./nginx -s reload\n\n```\n\n# 3、nginx配置文件\nNginx配置文件分为三大块：全局块，events块，http块\n\n1. 从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等\n2. events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024\n3. http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等\n\n```shell\n\n#================ 全局快 ==================#\n#定义Nginx运行的用户和用户组\nuser  nginx;\n# 工作进程数，一般配置成和CPU数一样\nworker_processes  auto;\n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log  /var/log/nginx/error.log notice;\n#进程pid文件\npid        /var/run/nginx.pid;\n\n#=============== events块 ================#\nevents {\n    # 标识单个woker进程最大并发数\n    worker_connections  1024;\n}\n\n#=============== http块 =================#\nhttp {\n    #文件扩展名与文件类型映射表\n    include       /etc/nginx/mime.types;\n    #默认文件类型\n    default_type  application/octet-stream;\n    #日志格式设定\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #定义本虚拟主机的访问日志\n    access_log  /var/log/nginx/access.log  main;\n     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载\n    sendfile        on;\n    #长连接超时时间，单位是秒\n    keepalive_timeout  65;\n    #包括多个server块，而每个server块就相当于一个虚拟主机\n    server {\n          listen       80;\n          server_name  localhost;\n          # 对特定地址进行处理，地址定向\n          location / {\n              root   html;\n              index  index.html index.htm;\n          }\n  \n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   html;\n      }\n}\n```\n\n# 4、反向代理实现\n实现效果：输入 http://www.test.com, 自动跳转到百度首页\n\n\n```shell\nserver {\n         listen          80;\n         server_name     www.test.com;  #你的域名\n         location / {\n               proxy_pass          http://www.baidu.com/;  #需要反代的域名\n               proxy_redirect      off;\n               proxy_set_header    X-Real-IP      $remote_addr;\n               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n}\n\n```\n# 5、正向代理实现\n场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题\n场景2：内网机器访问外网，就需要正向代理，类似VPN\n```shell\nserver {\n\tlisten 8090;\n\t\n\tlocation / {\n    # resolver后面填写dns地址，可以多个，将以轮询方式请求\n\t\tresolver 218.85.157.99 218.85.152.99;\n    # resolver_timeout 解析超时时间\n\t\tresolver_timeout 30s;\n    # 代理服务器地址（即要请求的地址）\n\t\tproxy_pass http://$host$request_uri;\n\t}\n\taccess_log /data/httplogs/proxy-$host-aceess.log;\n}\n\n```\n# 6、负载均衡实现\n## 6.1、轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除\n```shell\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    upstream webservers{\n      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n \n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n             #转发到负载服务上\n            proxy_pass http://webservers/api/;\n         }\n    }\n}\n```\n## 6.2、weight\nweight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。\n```shell\n\n    upstream webservers{\n      server  192.168.9.134:8081 weight=8;\n      server  192.168.9.134:8082 weight=2;\n    }\n```\n## 6.3、ip_hash\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\n> 使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题\n\n```shell\n    upstream webservers{\n      ip_hash;\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n```\n## 6.4、fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```shell\nupstream webservers{\n        server 192.168.9.134:8081;\n        server 192.168.9.134:8082;\n        fair;\n}\n```\n## 6.5、url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n> 相同的url会被分配到同一个节点，主要为了提高缓存命中率\n\n```shell\nupstream webservers{\n    hash &request_uri;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n## 6.6、least_conn\n按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况\n```shell\nupstream webservers{\n    least_conn;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n# 7、动静分离\n利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能\n```shell\n#所有js,css相关的静态资源文件的请求由Nginx处理\nlocation ~.*\\.(js|css)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     12h; #过期时间为12小时\n}\n#所有图片等多媒体相关静态资源文件的请求由Nginx处理\nlocation ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     7d; #过期时间为7天\n}\n```\n","slug":"nginx","published":1,"updated":"2023-07-25T02:55:50.561Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkjau31m000figum7xakc7rp","content":"<h1 id=\"1、nginx简介\"><a href=\"#1、nginx简介\" class=\"headerlink\" title=\"1、nginx简介\"></a>1、nginx简介</h1><h2 id=\"1-1、nginx概述\"><a href=\"#1-1、nginx概述\" class=\"headerlink\" title=\"1.1、nginx概述\"></a>1.1、nginx概述</h2><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。</p>\n<h2 id=\"1-2、正向代理\"><a href=\"#1-2、正向代理\" class=\"headerlink\" title=\"1.2、正向代理\"></a>1.2、正向代理</h2><p>nginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能<br>正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【<strong>代理客户端，服务端不知道实际发起请求的客户端</strong>】</p>\n<blockquote>\n<p>例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色</p>\n</blockquote>\n<h2 id=\"1-3、反向代理\"><a href=\"#1-3、反向代理\" class=\"headerlink\" title=\"1.3、反向代理\"></a>1.3、反向代理</h2><p>反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【<strong>代理服务端，客户端不知道实际提供服务的服务端</strong>】</p>\n<blockquote>\n<p>例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在</p>\n</blockquote>\n<h2 id=\"1-4、负载均衡\"><a href=\"#1-4、负载均衡\" class=\"headerlink\" title=\"1.4、负载均衡\"></a>1.4、负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 </p>\n<h2 id=\"1-5、动静分离\"><a href=\"#1-5、动静分离\" class=\"headerlink\" title=\"1.5、动静分离\"></a>1.5、动静分离</h2><p>为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p>\n<blockquote>\n<p>静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，<strong>但是 tomcat 本身处理静态资源的效率并不高</strong>，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 </p>\n</blockquote>\n<h1 id=\"2、nginx安装\"><a href=\"#2、nginx安装\" class=\"headerlink\" title=\"2、nginx安装\"></a>2、nginx安装</h1><ol>\n<li><strong>安装pcre依赖</strong></li>\n</ol>\n<p>（1）联网下载 pcre 压缩文件依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）解压压缩文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar –xvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcre-config --version</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>安装安装 openssl 、zlib 、 gcc 依赖</strong></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>安装nginx</strong></li>\n</ol>\n<p>（1）解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）进入解压后目录，执行config命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入进入目录 /usr/local/nginx/sbin/nginx</span></span><br><span class=\"line\">./nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止</span></span><br><span class=\"line\">./nginx -s stop</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">./nginx -s reload</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、nginx配置文件\"><a href=\"#3、nginx配置文件\" class=\"headerlink\" title=\"3、nginx配置文件\"></a>3、nginx配置文件</h1><p>Nginx配置文件分为三大块：全局块，events块，http块</p>\n<ol>\n<li>从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等</li>\n<li>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024</li>\n<li>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">================ 全局快 ==================<span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">定义Nginx运行的用户和用户组</span></span><br><span class=\"line\">user  nginx;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作进程数，一般配置成和CPU数一样</span></span><br><span class=\"line\">worker_processes  auto;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class=\"line\">error_log  /var/log/nginx/error.log notice;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">进程pid文件</span></span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== events块 ================<span class=\"comment\">#</span></span></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 标识单个woker进程最大并发数</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== http块 =================<span class=\"comment\">#</span></span></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    #文件扩展名与文件类型映射表</span><br><span class=\"line\">    include       /etc/nginx/mime.types;</span><br><span class=\"line\">    #默认文件类型</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    #日志格式设定</span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\">    #定义本虚拟主机的访问日志</span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\">     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #长连接超时时间，单位是秒</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    #包括多个server块，而每个server块就相当于一个虚拟主机</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">          listen       80;</span><br><span class=\"line\">          server_name  localhost;</span><br><span class=\"line\">          # 对特定地址进行处理，地址定向</span><br><span class=\"line\">          location / &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">              index  index.html index.htm;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">          location = /50x.html &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、反向代理实现\"><a href=\"#4、反向代理实现\" class=\"headerlink\" title=\"4、反向代理实现\"></a>4、反向代理实现</h1><p>实现效果：输入 <a href=\"http://www.test.com/\">http://www.test.com</a>, 自动跳转到百度首页</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">         listen          80;</span><br><span class=\"line\">         server_name     www.test.com;  #你的域名</span><br><span class=\"line\">         location / &#123;</span><br><span class=\"line\">               proxy_pass          http://www.baidu.com/;  #需要反代的域名</span><br><span class=\"line\">               proxy_redirect      off;</span><br><span class=\"line\">               proxy_set_header    X-Real-IP      $remote_addr;</span><br><span class=\"line\">               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"5、正向代理实现\"><a href=\"#5、正向代理实现\" class=\"headerlink\" title=\"5、正向代理实现\"></a>5、正向代理实现</h1><p>场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题<br>场景2：内网机器访问外网，就需要正向代理，类似VPN</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 8090;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">    # resolver后面填写dns地址，可以多个，将以轮询方式请求</span><br><span class=\"line\">\t\tresolver 218.85.157.99 218.85.152.99;</span><br><span class=\"line\">    # resolver_timeout 解析超时时间</span><br><span class=\"line\">\t\tresolver_timeout 30s;</span><br><span class=\"line\">    # 代理服务器地址（即要请求的地址）</span><br><span class=\"line\">\t\tproxy_pass http://$host$request_uri;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taccess_log /data/httplogs/proxy-$host-aceess.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、负载均衡实现\"><a href=\"#6、负载均衡实现\" class=\"headerlink\" title=\"6、负载均衡实现\"></a>6、负载均衡实现</h1><h2 id=\"6-1、轮询（默认）\"><a href=\"#6-1、轮询（默认）\" class=\"headerlink\" title=\"6.1、轮询（默认）\"></a>6.1、轮询（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    upstream webservers&#123;</span><br><span class=\"line\">      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问</span><br><span class=\"line\">      server  192.168.9.134:8081;</span><br><span class=\"line\">      server  192.168.9.134:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">             #转发到负载服务上</span><br><span class=\"line\">            proxy_pass http://webservers/api/;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2、weight\"><a href=\"#6-2、weight\" class=\"headerlink\" title=\"6.2、weight\"></a>6.2、weight</h2><p>weight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  server  192.168.9.134:8081 weight=8;</span><br><span class=\"line\">  server  192.168.9.134:8082 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3、ip-hash\"><a href=\"#6-3、ip-hash\" class=\"headerlink\" title=\"6.3、ip_hash\"></a>6.3、ip_hash</h2><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>\n<blockquote>\n<p>使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server  192.168.9.134:8081;</span><br><span class=\"line\">  server  192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-4、fair\"><a href=\"#6-4、fair\" class=\"headerlink\" title=\"6.4、fair\"></a>6.4、fair</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">        server 192.168.9.134:8081;</span><br><span class=\"line\">        server 192.168.9.134:8082;</span><br><span class=\"line\">        fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、url-hash\"><a href=\"#6-5、url-hash\" class=\"headerlink\" title=\"6.5、url_hash\"></a>6.5、url_hash</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<blockquote>\n<p>相同的url会被分配到同一个节点，主要为了提高缓存命中率</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    hash &amp;request_uri;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-6、least-conn\"><a href=\"#6-6、least-conn\" class=\"headerlink\" title=\"6.6、least_conn\"></a>6.6、least_conn</h2><p>按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、动静分离\"><a href=\"#7、动静分离\" class=\"headerlink\" title=\"7、动静分离\"></a>7、动静分离</h1><p>利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有js,css相关的静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(js|css)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     12h; #过期时间为12小时</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有图片等多媒体相关静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     7d; #过期时间为7天</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、nginx简介\"><a href=\"#1、nginx简介\" class=\"headerlink\" title=\"1、nginx简介\"></a>1、nginx简介</h1><h2 id=\"1-1、nginx概述\"><a href=\"#1-1、nginx概述\" class=\"headerlink\" title=\"1.1、nginx概述\"></a>1.1、nginx概述</h2><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。</p>\n<h2 id=\"1-2、正向代理\"><a href=\"#1-2、正向代理\" class=\"headerlink\" title=\"1.2、正向代理\"></a>1.2、正向代理</h2><p>nginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能<br>正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【<strong>代理客户端，服务端不知道实际发起请求的客户端</strong>】</p>\n<blockquote>\n<p>例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色</p>\n</blockquote>\n<h2 id=\"1-3、反向代理\"><a href=\"#1-3、反向代理\" class=\"headerlink\" title=\"1.3、反向代理\"></a>1.3、反向代理</h2><p>反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【<strong>代理服务端，客户端不知道实际提供服务的服务端</strong>】</p>\n<blockquote>\n<p>例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在</p>\n</blockquote>\n<h2 id=\"1-4、负载均衡\"><a href=\"#1-4、负载均衡\" class=\"headerlink\" title=\"1.4、负载均衡\"></a>1.4、负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 </p>\n<h2 id=\"1-5、动静分离\"><a href=\"#1-5、动静分离\" class=\"headerlink\" title=\"1.5、动静分离\"></a>1.5、动静分离</h2><p>为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p>\n<blockquote>\n<p>静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，<strong>但是 tomcat 本身处理静态资源的效率并不高</strong>，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 </p>\n</blockquote>\n<h1 id=\"2、nginx安装\"><a href=\"#2、nginx安装\" class=\"headerlink\" title=\"2、nginx安装\"></a>2、nginx安装</h1><ol>\n<li><strong>安装pcre依赖</strong></li>\n</ol>\n<p>（1）联网下载 pcre 压缩文件依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）解压压缩文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar –xvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcre-config --version</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>安装安装 openssl 、zlib 、 gcc 依赖</strong></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>安装nginx</strong></li>\n</ol>\n<p>（1）解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）进入解压后目录，执行config命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入进入目录 /usr/local/nginx/sbin/nginx</span></span><br><span class=\"line\">./nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止</span></span><br><span class=\"line\">./nginx -s stop</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">./nginx -s reload</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、nginx配置文件\"><a href=\"#3、nginx配置文件\" class=\"headerlink\" title=\"3、nginx配置文件\"></a>3、nginx配置文件</h1><p>Nginx配置文件分为三大块：全局块，events块，http块</p>\n<ol>\n<li>从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等</li>\n<li>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024</li>\n<li>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">================ 全局快 ==================<span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">定义Nginx运行的用户和用户组</span></span><br><span class=\"line\">user  nginx;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作进程数，一般配置成和CPU数一样</span></span><br><span class=\"line\">worker_processes  auto;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class=\"line\">error_log  /var/log/nginx/error.log notice;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">进程pid文件</span></span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== events块 ================<span class=\"comment\">#</span></span></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 标识单个woker进程最大并发数</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== http块 =================<span class=\"comment\">#</span></span></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    #文件扩展名与文件类型映射表</span><br><span class=\"line\">    include       /etc/nginx/mime.types;</span><br><span class=\"line\">    #默认文件类型</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    #日志格式设定</span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\">    #定义本虚拟主机的访问日志</span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\">     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #长连接超时时间，单位是秒</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    #包括多个server块，而每个server块就相当于一个虚拟主机</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">          listen       80;</span><br><span class=\"line\">          server_name  localhost;</span><br><span class=\"line\">          # 对特定地址进行处理，地址定向</span><br><span class=\"line\">          location / &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">              index  index.html index.htm;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">          location = /50x.html &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、反向代理实现\"><a href=\"#4、反向代理实现\" class=\"headerlink\" title=\"4、反向代理实现\"></a>4、反向代理实现</h1><p>实现效果：输入 <a href=\"http://www.test.com/\">http://www.test.com</a>, 自动跳转到百度首页</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">         listen          80;</span><br><span class=\"line\">         server_name     www.test.com;  #你的域名</span><br><span class=\"line\">         location / &#123;</span><br><span class=\"line\">               proxy_pass          http://www.baidu.com/;  #需要反代的域名</span><br><span class=\"line\">               proxy_redirect      off;</span><br><span class=\"line\">               proxy_set_header    X-Real-IP      $remote_addr;</span><br><span class=\"line\">               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"5、正向代理实现\"><a href=\"#5、正向代理实现\" class=\"headerlink\" title=\"5、正向代理实现\"></a>5、正向代理实现</h1><p>场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题<br>场景2：内网机器访问外网，就需要正向代理，类似VPN</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 8090;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">    # resolver后面填写dns地址，可以多个，将以轮询方式请求</span><br><span class=\"line\">\t\tresolver 218.85.157.99 218.85.152.99;</span><br><span class=\"line\">    # resolver_timeout 解析超时时间</span><br><span class=\"line\">\t\tresolver_timeout 30s;</span><br><span class=\"line\">    # 代理服务器地址（即要请求的地址）</span><br><span class=\"line\">\t\tproxy_pass http://$host$request_uri;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taccess_log /data/httplogs/proxy-$host-aceess.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、负载均衡实现\"><a href=\"#6、负载均衡实现\" class=\"headerlink\" title=\"6、负载均衡实现\"></a>6、负载均衡实现</h1><h2 id=\"6-1、轮询（默认）\"><a href=\"#6-1、轮询（默认）\" class=\"headerlink\" title=\"6.1、轮询（默认）\"></a>6.1、轮询（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    upstream webservers&#123;</span><br><span class=\"line\">      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问</span><br><span class=\"line\">      server  192.168.9.134:8081;</span><br><span class=\"line\">      server  192.168.9.134:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">             #转发到负载服务上</span><br><span class=\"line\">            proxy_pass http://webservers/api/;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2、weight\"><a href=\"#6-2、weight\" class=\"headerlink\" title=\"6.2、weight\"></a>6.2、weight</h2><p>weight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  server  192.168.9.134:8081 weight=8;</span><br><span class=\"line\">  server  192.168.9.134:8082 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3、ip-hash\"><a href=\"#6-3、ip-hash\" class=\"headerlink\" title=\"6.3、ip_hash\"></a>6.3、ip_hash</h2><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>\n<blockquote>\n<p>使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server  192.168.9.134:8081;</span><br><span class=\"line\">  server  192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-4、fair\"><a href=\"#6-4、fair\" class=\"headerlink\" title=\"6.4、fair\"></a>6.4、fair</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">        server 192.168.9.134:8081;</span><br><span class=\"line\">        server 192.168.9.134:8082;</span><br><span class=\"line\">        fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、url-hash\"><a href=\"#6-5、url-hash\" class=\"headerlink\" title=\"6.5、url_hash\"></a>6.5、url_hash</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<blockquote>\n<p>相同的url会被分配到同一个节点，主要为了提高缓存命中率</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    hash &amp;request_uri;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-6、least-conn\"><a href=\"#6-6、least-conn\" class=\"headerlink\" title=\"6.6、least_conn\"></a>6.6、least_conn</h2><p>按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、动静分离\"><a href=\"#7、动静分离\" class=\"headerlink\" title=\"7、动静分离\"></a>7、动静分离</h1><p>利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有js,css相关的静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(js|css)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     12h; #过期时间为12小时</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有图片等多媒体相关静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     7d; #过期时间为7天</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"spring","date":"2023-07-21T16:00:00.000Z","abbrlink":9964,"_content":"# 1、前置内容\n## 1.1、EJB的问题\n它是一个重量级的框架，体现在：\n\n1. 运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源\n2. 代码移植性差\n## 1.2、什么是spring\nspring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式\n\n- 轻量级\n\n> 1. 对于运行环境没有额外要求（tomcat jetty weblogic等都可以）\n> 2. 代码一致性高（不需要实现额外接口）\n\n\n- javaEE解决方案\n\n> 包含了java web开发中 controller service dao层的解决方案\n\n\n- 整合设计模式\n\n> 工厂\n> 代理\n> 模板\n> 策略\n\n## 1.3、工厂设计模式\n### 1.3.1、什么是工厂设计模式\n```markdown\n1. 概念：通过工厂类创建对象\n2. 好处：解耦合\n   问题：不利于代码维护\n```\n### 1.3.2、通用工厂的设计（简单工厂+反射）\n```java\n// 工厂类\npublic class BeanFactory{\n    private static Properties env = new Properties();\n    static {\n        InputStream inputStream = BeanFactory.class.getResourceAsStream(\"/applicationContext.properties\");\n        try {\n            env.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static Object getBean(String key){\n        Object ret = null;\n        try{\n           Class clazz = Class.forName(env.getProperty(\"userBean\"));\n           ret = clazz.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return ret;\n    }\n}\n```\n# 2、spring IOC\n## 2.1、第一个spring程序\n### 2.1.1、核心API\n\n- ApplicationContext\n\n```markdown\n1. 作用：屏蔽实现的差异\n\n2. 好处：解耦合\n\n3. 接口类型：\n非web环境：ClassPathXmlApplicationContext\nweb环境：XmlWebApplicationContext（需要导入spring-webmvc）\n\n4. 重量级资源\napplicationContext工厂的对象占用大量内存\n不会频繁的创建，一个应用程序只会创建一个工厂对象\n所以applicationContext工厂一定是线程安全的\n```\n### 2.1.2、程序开发\n\n1. 引入依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.4.RELEASE</version>\n        </dependency>\n```\n\n2. 创建配置文件\n\nnew - xmlConfiguration File - spring config\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"person\" class=\"bean.Person\"/>\n</beans>\n```\n\n3. 通过工厂获取实例\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        Person person = (Person)ctx.getBean(\"person\");\n        System.out.println(person);\n    }\n}\n```\n\n### 2.1.3、思考\n\n1. 使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化\n\n2. 在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）\n\n\n## 2.2、spring与日志框架整合\nspring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息\n\n![日志框架](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png)\n\n\n- spring如何整合日志框架？\n\n> spring 1,2,3 早期都是jcl\nspring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2\n\n当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j\n1. pom\n\n```xml\n\t\t<!--日志门面-->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.7.25</version>\n        </dependency>\n        <!--log4j-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n```\n\n2. log4j.properties\n\n```properties\n### 配置根\nlog4j.rootLogger = debug, console\n\n### 配置输出到控制台\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern =  %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n```\n## 2.3、注入\n### 2.3.1、什么是注入？\n通过spring工厂及配置文件，为所创建对象的成员变量赋值\n\n### 2.3.2、为什么需要注入？\n之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合\n\n### 2.3.3、如何进行注入？\n#### 2.3.3.1、属性（field ）注入\n所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）\n\n```java\n@Autowired\nprivate Svc svc;\n```\n\n#### 2.3.3.2、setter注入\n通过对应变量的`setXXX()`方法以及在方法上面使用注解，来完成依赖注入。比如：\n```java\nprivate Helper helper;\n\n@Autowired\npublic void setHelper(Helper helper) {\n    this.helper = helper;\n}\n```\n#### 2.3.3.3、构造方法注入\n将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：\n```java\nprivate final Svc svc;\n\n@Autowired\npublic HelpService(@Qualifier(\"svcB\") Svc svc) {\n    this.svc = svc;\n}\n```\n\n## 2.4、spring对象的生命周期\n### 2.4.1、spring bean的生命周期\n\n![spring bean生命周期](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png)\n\n\n1. 实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。\n2. 属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中\n3. 回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。\n\n> Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。\n> 但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  \n\n1. 初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器\n2. 使用（In Use）：在初始化完成之后，Bean就可以被使用了。\n3. 销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用\n\n\n# 3、spring AOP\n\n## 3.1、spring动态代理\n### 3.1.1、spring动态代理概念\n\n1. 概念：通过代理类为目标类增加额外功能\n2. 好处：利于目标类的维护\n### 3.1.2、搭建开发环境\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>5.1.14.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjrt</artifactId>\n            <version>1.8.8</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.3</version>\n        </dependency>\n```\n### 3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\n\n1. 创建目标对象\n\n```java\npublic class UserServiceImpl implements UserService{\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n<bean id=\"userService\" class=\"service.UserServiceImpl\"></bean>\n```\n\n2. 额外功能\n\nMethodBeforeAdvice接口\n\n\n```java\npublic class Before implements MethodBeforeAdvice {\n    // 参数： 目标方法 目标方法参数 目标对象\n    public void before(Method method, Object[] objects, Object o) throws Throwable {\n        System.out.println(\"--method before advice log--\");\n    }\n}\n\n<bean id=\"before\" class=\"dynamic.Before\"></bean>\n```\n\n3. 定义切入点\n\n 切入点：额外功能加入的位置(方法)\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n    </aop:config>\n```\n\n4. 组装（2 3步整合）\n\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n        <!--组装：目的把切入点和额外功能进行整合-->\n        <aop:advisor advice-ref=\"before\" pointcut-ref=\"pc\"/>\n    </aop:config>\n```\n\n5. 测试\n\n```java\n    public static void main(String[] args) {\n        //目的：获得spring工厂创建的动态代理对象并进行调用\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        /**\n         * 1. spring的工厂通过原始对象的id值获得的是代理对象\n         * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储\n         */\n        UserService userService = (UserService)ctx.getBean(\"userService\");\n        userService.login();\n    }\n```\n### 3.1.4、思考\n\n1. spring创建的动态代理类在哪里？\n\n```java\nspring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失\n\n动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题\n\n```\n\n2. 动态字节码技术？\n\n```java\n通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失\n```\n### 3.1.5、额外功能详解\nMethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前\nMethodInterceptor 前，后，抛出异常 都可以运行\n所以我们实战中用到的更多的还是MethodInterceptor \n```java\npublic class Around  implements MethodInterceptor {\n    //methodInvocation : 额外功能所增加给的那个原始方法\n    public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n        System.out.println(\"--目标方法之前额外功能--\");\n        //原始方法执行\n        Object proceed = null;\n        try {\n            proceed = methodInvocation.proceed();\n        } catch (Throwable throwable){\n            System.out.println(\"--目标方法抛出异常额外功能--\");\n            throwable.printStackTrace();\n        }\n        System.out.println(\"--目标方法之后额外功能--\");\n        return proceed;\n    }\n}\n```\n> MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）\n\n### 3.1.6、切入点详解\n#### 3.1.6.1、切入点表达式\n\n\n```java\n<aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n\nexecution() ：切入点函数\n* *(..)：切入点表达式\n\n第一个* ：修饰符 返回值\n第二个* ：方法名(包+类+方法 or 直接方法)\n()：参数表 \n..：对于参数没有要求\n```\n\n- 定义login方法且login方法有两个字符串类型的参数作为切入点\n\n```java\n* login(String,String)\n```\n\n- 定义login方法且login方法有第一个参数必须为String作为切入点\n\n```java\n* login(String,..)\n```\n\n- kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）\n\n```java\n* com.kaka.UserServiceImpl.login(..)\n```\n\n- kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）\n\n```java\n* com.kaka..*.*()\n    \n    其中的..*代表当前包及其子包\n    如果是.*代表当前包\n```\n\n- 任意包下UserServiceImpl类作为切入点（类切入点表达式）\n\n```java\n* *..UserServiceImpl.*(..)\n  \n    其中的*..代表层级为1级或多级的包\n    如果是*.UserService 只能查找第一层级下的类\n```\n#### 3.1.6.2、切入点函数\n切入点函数：用于执行切入点表达式\n\n1. execution\n\n```java\n作用：最为重要的切入点函数，功能最全\n\t  执行方法切入点表达式 类切入点表达式 包切入点表达式\nexecution执行切入点表达式，书写麻烦\n注意：其他的切入点函数简化execution书写复杂度，功能上完全一致\n\n```\n\n2. args\n\n```java\n作用：主要用于函数（方法）参数的匹配\n方法参数必须是两个字符串类型的参数\n\nargs(String,String)\n等同于 execution(* *(String,String))\n```\n\n3. within\n\n```java\n作用：主要用于进行类，包切入点表达式的匹配\n\nwithin(*..UserServiceImpl)\n等同于execution(* *..UserServiceImpl.*(..))\n```\n\n4. @annotation\n\n```java\n作用：@annotation表示标注了某个注解的所有方法\n\n// 修饰的对象范围\n@Target(ElementType.METHOD)\n// 注解生命周期  SOURCE < CLASS < RUNTIME\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Log {\n}\n\npublic class UserServiceImpl implements UserService{\n    @Log\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n\n<aop:pointcut id=\"pc\" expression=\"@annotation(bean.Log)\"/>\n```\n#### 3.1.6.3、切入点函数的逻辑运算\n\n1. and与操作\n\n```java\n案例：login 同时 参数 两个字符串\n\nexecution(* login(..)) and args(String,String)\n等同于 execution(* login(String,String))    \n    \n注意：与操作不能用于同种类型的切入点函数\n```\n\n2. or或操作\n\n```java\n案例：register方法和login方法作为切入点\n\nexecution(* login(..)) or execution(* register(..))\n```\n## 3.2、AOP编程\n### 3.2.1、基本概念\n\n\n```java\n1. AOP：面向切面编程\n   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建\n\n2. OOP：面向对象编程\n   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建\n   \n3. POP：面向过程编程\n   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建\n \n```\n12.2、切面名词解释\n\n> 切面 = 切入点 + 额外功能\n\n多个额外功能相同的方法所代表的点连起来就是一个面\n\n![aop切面](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png)\n\n\n### 3.2.2、AOP底层实现原理\n#### 3.2.2.1、核心问题\n\n\n> 1. aop如何创建动态代理类（动态字节码技术）\n> 2. 如何实现通过原始对象的id值，获得的是代理对象\n\n\n### 3.2.3、动态代理类的创建\n#### 3.2.3.1、JDK动态代理\n\n- Proxy.newProxyInstancec：\n\n- 编码实现\n\n```java\npublic class TestJDKProxy {\n    /**\n     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以\n     2. JDK8.x 前必须加 final\n     final UserService userService = new UserServiceImpl();\n     */\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserServiceImpl();\n\n        // 2. JDK 动态代理\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(\"---- proxy log ----\");\n                // 原始方法运行\n                Object ret = method.invoke(userService, args);\n                return ret;\n            }\n        };\n        UserService userServiceProxy = (UserService) Proxy.\n                newProxyInstance(TestJDKProxy.class.getClassLoader(),\n                                userService.getClass().getInterfaces(),\n                                handler);\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n\n        userServiceProxy.register(new User());\n    }\n}\n```\n#### 3.2.3.2、CGLib动态代理\n\n- CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）\n\n> 在原始类没有实现接口的情况下cglib是一种很好的实现方式\n\n- cglib原理\n\n```java\npublic class TestCglib {\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserService();\n\n        /*\n         2. 通过 cglib 方式创建动态代理对象\n         对比 jdk 动态代理 ---> Proxy.newProxyInstance(classLoader, interface, invocationHandler);\n\n         Enhancer.setClassLoader()\n         Enhancer.setSuperClass()\n         Enhancer.setCallBack() ---> MethodInterceptor(cglib)\n         Enhancer.createProxy() ---> 创建代理对象\n         */\n        Enhancer enhancer = new Enhancer();\n\n        enhancer.setClassLoader(TestCglib.class.getClassLoader());\n        enhancer.setSuperclass(userService.getClass());\n\n        MethodInterceptor interceptor = new MethodInterceptor() {\n            @Override\n            public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n                System.out.println(\"--- cglib log ----\");\n                Object ret = method.invoke(userService, args); // 执行原始方法\n                return ret;\n            }\n        };\n\n        enhancer.setCallback(interceptor);\n        UserService userServiceProxy = (UserService) enhancer.create();\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n        userServiceProxy.register(new User());\n    }\n}\n```\n 总结：\n\n1. JDK 动态代理\nProxy.newProxyInstance：通过接口创建代理的实现类\n2. Cglib 动态代理\nEnhancer：通过继承父类创建的代理类\n\n### 3.2.4、基于注解的AOP编程\n#### 3.2.4.1、开发步骤\n\n1. 原始功能\n\n包含原始功能和实现类等\n\n2. 额外功能+切入点+组装切面\n\n```java\n/*\n    1. 额外功能\n        public class MyAround implements MethodInterceptor {\n            public Object invoke(MethodInvocation invocation) {\n                Object ret = invocation.invoke();\n                return ret;\n            }\n        }\n        <bean id=\"around\" class=\"com.yusael.dynamic.Around\"/>\n\n    2. 切入点\n        <aop:config>\n            <aop:pointcut id=\"pc\" expression=\"execution(* login(..)))\"/>\n            <aop:advisor advice-ref=\"around\" pointcut-ref=\"pc\"/>\n        </aop:config>\n */\n\n@Aspect\npublic class MyAspect {\n    @Around(\"execution(* login(..))\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n\n```\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <bean id=\"userService\" class=\"com.yusael.aspect.UserServiceImpl\"/>\n    <!--\n        切面:\n            1. 额外功能\n            2. 切入点\n            3. 组装切面\n    -->\n    <bean id=\"around\" class=\"com.yusael.aspect.MyAspect\"/>\n    <!--告知 Spring 基于注解进行 AOP 编程-->\n    <aop:aspectj-autoproxy/>\n\n</beans>\n\n```\n\n3. 切入点复用\n\n切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。\n\t通过这种方式定义切入点表达式，后续更加有利于切入点复用\n```java\n@Aspect\npublic class MyAspect {\n\n    @Pointcut(\"execution(* login(..))\")\n    public void myPoincut() {}\n\n    @Around(value = \"myPoincut()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n    @Around(value = \"myPoincut()\")\n    public Object around1(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect transaction ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n```\n#### 3.2.4.2、动态代理创建方式\n\nAOP 底层实现 2 种代理创建方式：\n\n1. JDK：通过 **实现接口，做新的实现类** 创建代理对象\n2. Cglib：通过 **继承父类，做新的子类** 创建代理对象\n\n**默认情况 AOP 编程 底层应用 JDK动态代理创建方式**\n```java\n<!-- 动态代理模式切换为cglib -->\n<aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n```\n\n# 4、spring 持久层\n## 4.1、spring与mybatis整合\n\n1. 引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-jdbc</artifactId>\n  <version>5.2.6.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis-spring</artifactId>\n  <version>2.0.4</version>\n</dependency>\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.1.12</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>5.1.43</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>3.5.4</version>\n</dependency>\n```\n\n2. spring配置文件\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <!--连接池-->\n        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n            <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n            <property name=\"url\" value=\"jdbc:mysql://localhost:3306/yus?useSSL=false\"/>\n            <property name=\"username\" value=\"root\"/>\n            <property name=\"password\" value=\"1234\"/>\n        </bean>\n\n        <!--创建SqlSessionFactory SqlSessionFactoryBean-->\n        <bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n            <property name=\"dataSource\" ref=\"dataSource\"/>\n            <property name=\"typeAliasesPackage\" value=\"com.yusael.entity\"/>\n            <property name=\"mapperLocations\">\n                <list>\n                    <value>classpath:com.yusael.dao/*Mapper.xml</value>\n                </list>\n            </property>\n        </bean>\n\n        <!--创建DAO对象 MapperScannerConfigure-->\n        <bean id=\"scanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n            <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactoryBean\"/>\n            <property name=\"basePackage\" value=\"com.yusael.dao\"/>\n        </bean>\n</beans>\n```\n\n3. 测试\n\n```java\n@Test\npublic void test() {\n    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n    UserDAO userDAO = (UserDAO) ctx.getBean(\"userDAO\");\n\n    User user = new User();\n    user.setName(\"xiaojr\");\n    user.setPassword(\"999999\");\n\n    userDAO.save(user);\n}\n```\n## 4.2、关于事务提交的疑问\n\n**问题**：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？\n\n> Mybatis 提供的连接池对象 —> 创建 Connection\n> Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。\n> Druid（C3P0、DBCP）作为连接池 —> 创建 Connection\n> Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。\n\n\n**答案**：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。\n\n**注意**：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题\n\n## 4.3、spring事务处理\n### 4.3.1、事务基本概念\n\n1. 什么是事务？\n\n事务时保证业务操作完整性的一种**数据库机制**\n\n2. 事务的四大特性？\n\nA 原子性\tC 一致性 I 隔离性\tD 持久性\n\n3. 如何控制事务？\n\n**JDBC：**\nConnection.setAutoCommit(false);\nConnection.commit();\nConnection.rollback();\n**Mybatis：**\nMybatis 自动开启事务\nsqlSession.commit();，底层还是调用的 Connection\nsqlSession.rollback();，底层还是调用的 Connection\n> 结论：控制事务的底层，都是通过 Connection 对象完成的\n\n### 4.3.2、spring控制事务的开发\nspring是通过aop的方式进行事务开发\n**增强功能：**原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法\n\n**切入点：**@Transactional （1）作用于类上（2）作用域方法。<\n\n**组装切面：**tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/> 自动扫描所有的@Transactional注解\n\n1. 搭建开发环境\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-tx</artifactId>\n\t<version>5.2.6.RELEASE</version>\n</dependency>\n```\n\n2. 编码\n\n```xml\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/>\n```\n进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib\n```xml\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\" proxy-target-class=\"true\"/>\n```\n### 4.3.3、事务的属性\n5个：隔离属性，传播属性，只读属性，超时属性，异常属性\n```markdown\n@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）\n```\n#### 4.3.3.1、隔离属性\n\n##### 4.3.3.1.1、并发问题&解决方案？\n**（1）脏读**：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象\n> eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了\n\n```java\n// 隔离级别：读已提交\n@Transaction(isolation=Isolation.READ_COMMITTED)\n```\n\n**（2）不可重复读**：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象\n> eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了\n> 注意：1.不是脏读 2.在一个事务中\n\n```java\n// 隔离级别：可重复读\n@Transaction(isolation=Isolation.REPEATABLE_READ)\n```\n> 本质：一把行锁（对数据库表的某一行加锁）\n\n\n\n**（3）幻读**：一个事务中，多次对**整表**进行**查询统计**，但是**结果不一样**，会在本事务中产生数据不一致的问题\n> 查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致\n\n```java\n// 隔离级别：序列化\n@Transaction(isolation=Isolation.SERIALIZABLE)\n```\n\n> 本质：表锁（对数据库某个表加锁）\n\n##### 4.3.3.1.2、安全与效率对比：\n\n- 并发安全：SERIALIZABLE > READ_ONLY > READ_COMMITTED\n- 运行效率：READ_COMMITTED > READ_ONLY > SERIALIZABLE\n\n##### 4.3.3.1.3、数据库默认隔离属性\nmysql：可重复读（REPEATABLE_READ）\nOracle：读已提交（READ_COMMITTED）\n\n#### 4.3.3.2、传播属性\n##### 4.3.3.2.1、基本概念\n传播属性：描述了事务解决 嵌套 问题 的特征\n**事务的嵌套**：指的是一个大的事务中，包含了若干个小的事务。\n**事务嵌套产生的问题**： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）\n\n##### 4.3.3.2.2、传播属性的值及用法\n| 传播属性的值 | 外部不存在事务 | 外部存在事务 | 用法 | 备注 |\n| --- | --- | --- | --- | --- |\n| REQUIRED | 开启新的事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.REQUIRED) | 增、删、改方法（保证了肯定会有事务的存在） |\n| REQUIRES_NEW | 开启新的事务 | 挂起外部事务，创建新的事务 | @Transactional(propagation = Propagation.REQUIRES_NEW) | 日志记录方法中（保证外部事务异常时能正常的记录日志） |\n| SUPPORTS | 不开启事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.SUPPORTS) | 查询方法 |\n| NOT_SUPPORTED | 不开启事务 | 挂起外部事务| @Transactional(propagation = Propagation.NOT_SUPPORTED) | 极其不常用 |\n| NEVER | 不开启事务 | 抛出异常 | @Transactional(propagation = Propagation.NEVER) | 极其不常用 |\n| MANDATORY（强制的） | 抛出异常 | 融合到外部事物中 | @Transactional(propagation = Propagation.MANDATORY) | 极其不常用 |\n\nSpring 中**传播属性的默认值**是：REQUIRED\n\n推荐传播属性的使用方式：\n\n- 增删改 方法：使用默认值 REQUIRED\n- 查询 方法：显示指定传播属性的值为 SUPPORTS\n\n\n#### 4.2.2.3、只读属性\n针对于 **只进行查询操作的业务方法**，可以加入只读属性，提高运行效率。\n默认值：false\n```java\n@Transactional(readOnly = true)\n```\n#### 4.2.2.4、超时属性\n指定了事务等待的最长时间。\n\n1. 为什么事务会进行等待？\n\n当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。\n\n2. 等待时间，单位是 秒\n3. 如何使用：@Transactional(timeout = 2)\n4. 超时属性的默认值：-1\n\n-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）\n\n#### 4.2.2.5、异常属性\nSpring 事务处理过程中：\n\n- 默认对于 RuntimeException 及其子类，采用 **回滚** 的策略。\n- 默认对于 对于其他类型的异常，采用 **提交** 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）\n\n```java\n@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)\n\n@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)\n```\n\n\n# 5、spring mvc\nspring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 \n\n## 5.1、父子容器关系\n1. Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）\n2. Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等\n3. Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）\n4. 调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止\n\n\n## 5.2、为什么要划分父子容器\n1. 分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）\n2. 性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能\n\n## 5.3、springBoot舍弃了父子容器的概念\n\nSpringBoot只有一个容器。\nSpring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署\n\n\n# 6、注解编程\n## 6.1、spring基础注解（spring2.X）\n### 6.1.1、对象创建相关\n#### 6.1.1.1、@Component\n\n1. 作用：替换原有Spring配置文件中的 <bean> 标签\n- id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO --> userDAO）\n- class 属性：通过反射获得的 class 的内容\n2. 细节：如何显式指定工厂创建对象的 id 值\n\n```java\n@Component(\"u\")\n```\n#### 6.1.1.2、@Repository、@Service、@Contoller\n@Repository、@Service、@Controller 都是 @Component 的 **衍生注解**。\n本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；\n它们的存在是为了：**更加准确的表达一个类型的作用**\n\n#### 6.1.1.3、@Scope\n作用：控制简单对象创建次数\n注意：不添加 @Scope，Spring 提供默认值 singleton\n```java\n// 创建单例对象\n@Component\n@Scope(\"singleton\")\npublic class Customer {}\n\n// 创建多例对象\n@Component\n@Scope(\"prototype\")\npublic class Customer {}\n```\n#### 6.1.1.4、@Lazy\n作用：延迟创建单实例对象\n注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象\n```java\n@Component\n@Lazy\npublic class Account {\n    public Account() {\n        System.out.println(\"Account.Account\");\n    }\n}\n```\n#### 6.1.1.5、@PostConstruct、@PreDestroy\n初始化相关方法： @PostConstruct\n```java\nInitializingBean\n<bean init-method=\"\"/>\n```\n销毁方法：@PreDestory\n```java\nDisposableBean\n<bean destory-method=\"\"/>\n```\n### 6.1.2、注入相关注解\n#### 6.1.2.1、@Autowired（用户自定义类型）\n\n1. @Autowired 注解 **基于类型进行注入** [推荐]：\n- 注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）\n\n```java\n@Autowired\nprivate UserDAO userDAO;\n```\n\n2. @Autowired、@Qualifier 注解联合实现 **基于名字进行注入** [了解]\n- 注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同\n\n```java\n@Autowired\n@Qualifier(\"userDAOImpl\")\nprivate UserDAO userDAO;\n```\n\n3. @Autowired 注解放置位置：\n- 放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）\n- **直接放置在成员变量上**，Spring 通过反射直接对成员变量进行赋值\n\n4. JSR提供的@Resource注解\n\n> JavaEE 规范中类似功能的注解：\n> - JSR250 提供的 @Resource(name=\"xxx\") **基于名字进行注入**\n等价于 @Autowired 与 @Qualifier 联合实现的效果\n注意：@Resource 注解如果名字没有配对成功，会继续 **按照类型进行注入**\n\n#### 6.1.2.2、@value、@PropertySource（JDK 类型）\n\n1. @value 注解的基本使用（xml配置）：\n\n```java\n1. 设置xxx.properties \n   id = 10\n   name = suns\n2. Spring的工厂读取这个配置文件 \n   <context:property-placeholder location=\"\"/>\n3. 代码中进行注入\n   属性 @Value(\"${key}\")\n\n```\n\n2. 使用 @PropertySource 取代 xml配置\n\n```java\n@Configuration\n@PropertySource(\"classpath:/init.properties\")\npublic class AppConfig1 {\n\n\t@Value(\"${id}\")\n\tprivate Integer id;\n\t@Value(\"${name}\")\n\tprivate String name;\n\t\n\t@Bean\n\tpublic Customer customer() {\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setId(id);\n\t\tcustomer.setName(name);\n\t\treturn customer;\n\t}\n}\n\n```\n\n3. @value 注解使用细节：\n- @Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null\n- @Value 注解 + Properties 这种方式，不能注入集合类型\nSpring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)\n## \n## 6.2、spring的高级注解（spring3.X及以上）\n### 6.2.1、@Configuration（配置bean）\n\n1. Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件\n2. 使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：\n\n```xml\n方法1: 指定配置bean的Class\nApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n\n方法2: 指定配置bean所在的路径(某个包及其子包)\nApplicationContext ctx = new AnnotationConfigApplicationContext(\"com.yusael\");\n```\n### 6.2.2、@Bean\n@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <bean 标签\n> **简单对象**：直接能够通过 new 方式创建的对象\n> - User、UserService、UserDAO\n> \n**复杂对象**：不能通过 new 的方式直接创建的对象\n> - Connection、SqlSessionFactory\n\n```java\n@Configuration\npublic class AppConfig{\n  // 简单对象\n\t@Bean\n  public Customer customer() {\n    Customer customer = new Customer();\n    return customer;\n  }\n\n  // 复杂对象\n  @Bean\n  public Connection conn1() {\n    Connection conn = null;\n    try {\n      ConnectionFactoryBean factoryBean = new ConnectionFactoryBean();\n      conn = factoryBean.getObject();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    return conn;\n  }\n}\n```\n### 6.2.3、@ComponentScan\n@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <context:component-scan> 标签\n目的：进行相关注解的扫描（@Component、@Value、@Autowired …)\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.yusael.scan\",\n               excludeFilters = {@ComponentScan.Filter(type= FilterType.ANNOTATION, value={Service.class}),\n                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = \"*..User1\")})\npublic class AppConfig2 {\n}\n```\n\n","source":"_posts/spring.md","raw":"---\ntitle: spring\ndate: 2023/07/22\ncategories:\n  - coding\ntags:\n  - spring\nabbrlink: 9964\n---\n# 1、前置内容\n## 1.1、EJB的问题\n它是一个重量级的框架，体现在：\n\n1. 运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源\n2. 代码移植性差\n## 1.2、什么是spring\nspring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式\n\n- 轻量级\n\n> 1. 对于运行环境没有额外要求（tomcat jetty weblogic等都可以）\n> 2. 代码一致性高（不需要实现额外接口）\n\n\n- javaEE解决方案\n\n> 包含了java web开发中 controller service dao层的解决方案\n\n\n- 整合设计模式\n\n> 工厂\n> 代理\n> 模板\n> 策略\n\n## 1.3、工厂设计模式\n### 1.3.1、什么是工厂设计模式\n```markdown\n1. 概念：通过工厂类创建对象\n2. 好处：解耦合\n   问题：不利于代码维护\n```\n### 1.3.2、通用工厂的设计（简单工厂+反射）\n```java\n// 工厂类\npublic class BeanFactory{\n    private static Properties env = new Properties();\n    static {\n        InputStream inputStream = BeanFactory.class.getResourceAsStream(\"/applicationContext.properties\");\n        try {\n            env.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static Object getBean(String key){\n        Object ret = null;\n        try{\n           Class clazz = Class.forName(env.getProperty(\"userBean\"));\n           ret = clazz.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return ret;\n    }\n}\n```\n# 2、spring IOC\n## 2.1、第一个spring程序\n### 2.1.1、核心API\n\n- ApplicationContext\n\n```markdown\n1. 作用：屏蔽实现的差异\n\n2. 好处：解耦合\n\n3. 接口类型：\n非web环境：ClassPathXmlApplicationContext\nweb环境：XmlWebApplicationContext（需要导入spring-webmvc）\n\n4. 重量级资源\napplicationContext工厂的对象占用大量内存\n不会频繁的创建，一个应用程序只会创建一个工厂对象\n所以applicationContext工厂一定是线程安全的\n```\n### 2.1.2、程序开发\n\n1. 引入依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.4.RELEASE</version>\n        </dependency>\n```\n\n2. 创建配置文件\n\nnew - xmlConfiguration File - spring config\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"person\" class=\"bean.Person\"/>\n</beans>\n```\n\n3. 通过工厂获取实例\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        Person person = (Person)ctx.getBean(\"person\");\n        System.out.println(person);\n    }\n}\n```\n\n### 2.1.3、思考\n\n1. 使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化\n\n2. 在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）\n\n\n## 2.2、spring与日志框架整合\nspring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息\n\n![日志框架](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png)\n\n\n- spring如何整合日志框架？\n\n> spring 1,2,3 早期都是jcl\nspring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2\n\n当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j\n1. pom\n\n```xml\n\t\t<!--日志门面-->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.7.25</version>\n        </dependency>\n        <!--log4j-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n```\n\n2. log4j.properties\n\n```properties\n### 配置根\nlog4j.rootLogger = debug, console\n\n### 配置输出到控制台\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern =  %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n```\n## 2.3、注入\n### 2.3.1、什么是注入？\n通过spring工厂及配置文件，为所创建对象的成员变量赋值\n\n### 2.3.2、为什么需要注入？\n之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合\n\n### 2.3.3、如何进行注入？\n#### 2.3.3.1、属性（field ）注入\n所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）\n\n```java\n@Autowired\nprivate Svc svc;\n```\n\n#### 2.3.3.2、setter注入\n通过对应变量的`setXXX()`方法以及在方法上面使用注解，来完成依赖注入。比如：\n```java\nprivate Helper helper;\n\n@Autowired\npublic void setHelper(Helper helper) {\n    this.helper = helper;\n}\n```\n#### 2.3.3.3、构造方法注入\n将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：\n```java\nprivate final Svc svc;\n\n@Autowired\npublic HelpService(@Qualifier(\"svcB\") Svc svc) {\n    this.svc = svc;\n}\n```\n\n## 2.4、spring对象的生命周期\n### 2.4.1、spring bean的生命周期\n\n![spring bean生命周期](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png)\n\n\n1. 实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。\n2. 属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中\n3. 回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。\n\n> Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。\n> 但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  \n\n1. 初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器\n2. 使用（In Use）：在初始化完成之后，Bean就可以被使用了。\n3. 销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用\n\n\n# 3、spring AOP\n\n## 3.1、spring动态代理\n### 3.1.1、spring动态代理概念\n\n1. 概念：通过代理类为目标类增加额外功能\n2. 好处：利于目标类的维护\n### 3.1.2、搭建开发环境\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>5.1.14.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjrt</artifactId>\n            <version>1.8.8</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.3</version>\n        </dependency>\n```\n### 3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\n\n1. 创建目标对象\n\n```java\npublic class UserServiceImpl implements UserService{\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n<bean id=\"userService\" class=\"service.UserServiceImpl\"></bean>\n```\n\n2. 额外功能\n\nMethodBeforeAdvice接口\n\n\n```java\npublic class Before implements MethodBeforeAdvice {\n    // 参数： 目标方法 目标方法参数 目标对象\n    public void before(Method method, Object[] objects, Object o) throws Throwable {\n        System.out.println(\"--method before advice log--\");\n    }\n}\n\n<bean id=\"before\" class=\"dynamic.Before\"></bean>\n```\n\n3. 定义切入点\n\n 切入点：额外功能加入的位置(方法)\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n    </aop:config>\n```\n\n4. 组装（2 3步整合）\n\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n        <!--组装：目的把切入点和额外功能进行整合-->\n        <aop:advisor advice-ref=\"before\" pointcut-ref=\"pc\"/>\n    </aop:config>\n```\n\n5. 测试\n\n```java\n    public static void main(String[] args) {\n        //目的：获得spring工厂创建的动态代理对象并进行调用\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        /**\n         * 1. spring的工厂通过原始对象的id值获得的是代理对象\n         * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储\n         */\n        UserService userService = (UserService)ctx.getBean(\"userService\");\n        userService.login();\n    }\n```\n### 3.1.4、思考\n\n1. spring创建的动态代理类在哪里？\n\n```java\nspring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失\n\n动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题\n\n```\n\n2. 动态字节码技术？\n\n```java\n通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失\n```\n### 3.1.5、额外功能详解\nMethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前\nMethodInterceptor 前，后，抛出异常 都可以运行\n所以我们实战中用到的更多的还是MethodInterceptor \n```java\npublic class Around  implements MethodInterceptor {\n    //methodInvocation : 额外功能所增加给的那个原始方法\n    public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n        System.out.println(\"--目标方法之前额外功能--\");\n        //原始方法执行\n        Object proceed = null;\n        try {\n            proceed = methodInvocation.proceed();\n        } catch (Throwable throwable){\n            System.out.println(\"--目标方法抛出异常额外功能--\");\n            throwable.printStackTrace();\n        }\n        System.out.println(\"--目标方法之后额外功能--\");\n        return proceed;\n    }\n}\n```\n> MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）\n\n### 3.1.6、切入点详解\n#### 3.1.6.1、切入点表达式\n\n\n```java\n<aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n\nexecution() ：切入点函数\n* *(..)：切入点表达式\n\n第一个* ：修饰符 返回值\n第二个* ：方法名(包+类+方法 or 直接方法)\n()：参数表 \n..：对于参数没有要求\n```\n\n- 定义login方法且login方法有两个字符串类型的参数作为切入点\n\n```java\n* login(String,String)\n```\n\n- 定义login方法且login方法有第一个参数必须为String作为切入点\n\n```java\n* login(String,..)\n```\n\n- kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）\n\n```java\n* com.kaka.UserServiceImpl.login(..)\n```\n\n- kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）\n\n```java\n* com.kaka..*.*()\n    \n    其中的..*代表当前包及其子包\n    如果是.*代表当前包\n```\n\n- 任意包下UserServiceImpl类作为切入点（类切入点表达式）\n\n```java\n* *..UserServiceImpl.*(..)\n  \n    其中的*..代表层级为1级或多级的包\n    如果是*.UserService 只能查找第一层级下的类\n```\n#### 3.1.6.2、切入点函数\n切入点函数：用于执行切入点表达式\n\n1. execution\n\n```java\n作用：最为重要的切入点函数，功能最全\n\t  执行方法切入点表达式 类切入点表达式 包切入点表达式\nexecution执行切入点表达式，书写麻烦\n注意：其他的切入点函数简化execution书写复杂度，功能上完全一致\n\n```\n\n2. args\n\n```java\n作用：主要用于函数（方法）参数的匹配\n方法参数必须是两个字符串类型的参数\n\nargs(String,String)\n等同于 execution(* *(String,String))\n```\n\n3. within\n\n```java\n作用：主要用于进行类，包切入点表达式的匹配\n\nwithin(*..UserServiceImpl)\n等同于execution(* *..UserServiceImpl.*(..))\n```\n\n4. @annotation\n\n```java\n作用：@annotation表示标注了某个注解的所有方法\n\n// 修饰的对象范围\n@Target(ElementType.METHOD)\n// 注解生命周期  SOURCE < CLASS < RUNTIME\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Log {\n}\n\npublic class UserServiceImpl implements UserService{\n    @Log\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n\n<aop:pointcut id=\"pc\" expression=\"@annotation(bean.Log)\"/>\n```\n#### 3.1.6.3、切入点函数的逻辑运算\n\n1. and与操作\n\n```java\n案例：login 同时 参数 两个字符串\n\nexecution(* login(..)) and args(String,String)\n等同于 execution(* login(String,String))    \n    \n注意：与操作不能用于同种类型的切入点函数\n```\n\n2. or或操作\n\n```java\n案例：register方法和login方法作为切入点\n\nexecution(* login(..)) or execution(* register(..))\n```\n## 3.2、AOP编程\n### 3.2.1、基本概念\n\n\n```java\n1. AOP：面向切面编程\n   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建\n\n2. OOP：面向对象编程\n   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建\n   \n3. POP：面向过程编程\n   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建\n \n```\n12.2、切面名词解释\n\n> 切面 = 切入点 + 额外功能\n\n多个额外功能相同的方法所代表的点连起来就是一个面\n\n![aop切面](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png)\n\n\n### 3.2.2、AOP底层实现原理\n#### 3.2.2.1、核心问题\n\n\n> 1. aop如何创建动态代理类（动态字节码技术）\n> 2. 如何实现通过原始对象的id值，获得的是代理对象\n\n\n### 3.2.3、动态代理类的创建\n#### 3.2.3.1、JDK动态代理\n\n- Proxy.newProxyInstancec：\n\n- 编码实现\n\n```java\npublic class TestJDKProxy {\n    /**\n     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以\n     2. JDK8.x 前必须加 final\n     final UserService userService = new UserServiceImpl();\n     */\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserServiceImpl();\n\n        // 2. JDK 动态代理\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(\"---- proxy log ----\");\n                // 原始方法运行\n                Object ret = method.invoke(userService, args);\n                return ret;\n            }\n        };\n        UserService userServiceProxy = (UserService) Proxy.\n                newProxyInstance(TestJDKProxy.class.getClassLoader(),\n                                userService.getClass().getInterfaces(),\n                                handler);\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n\n        userServiceProxy.register(new User());\n    }\n}\n```\n#### 3.2.3.2、CGLib动态代理\n\n- CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）\n\n> 在原始类没有实现接口的情况下cglib是一种很好的实现方式\n\n- cglib原理\n\n```java\npublic class TestCglib {\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserService();\n\n        /*\n         2. 通过 cglib 方式创建动态代理对象\n         对比 jdk 动态代理 ---> Proxy.newProxyInstance(classLoader, interface, invocationHandler);\n\n         Enhancer.setClassLoader()\n         Enhancer.setSuperClass()\n         Enhancer.setCallBack() ---> MethodInterceptor(cglib)\n         Enhancer.createProxy() ---> 创建代理对象\n         */\n        Enhancer enhancer = new Enhancer();\n\n        enhancer.setClassLoader(TestCglib.class.getClassLoader());\n        enhancer.setSuperclass(userService.getClass());\n\n        MethodInterceptor interceptor = new MethodInterceptor() {\n            @Override\n            public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n                System.out.println(\"--- cglib log ----\");\n                Object ret = method.invoke(userService, args); // 执行原始方法\n                return ret;\n            }\n        };\n\n        enhancer.setCallback(interceptor);\n        UserService userServiceProxy = (UserService) enhancer.create();\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n        userServiceProxy.register(new User());\n    }\n}\n```\n 总结：\n\n1. JDK 动态代理\nProxy.newProxyInstance：通过接口创建代理的实现类\n2. Cglib 动态代理\nEnhancer：通过继承父类创建的代理类\n\n### 3.2.4、基于注解的AOP编程\n#### 3.2.4.1、开发步骤\n\n1. 原始功能\n\n包含原始功能和实现类等\n\n2. 额外功能+切入点+组装切面\n\n```java\n/*\n    1. 额外功能\n        public class MyAround implements MethodInterceptor {\n            public Object invoke(MethodInvocation invocation) {\n                Object ret = invocation.invoke();\n                return ret;\n            }\n        }\n        <bean id=\"around\" class=\"com.yusael.dynamic.Around\"/>\n\n    2. 切入点\n        <aop:config>\n            <aop:pointcut id=\"pc\" expression=\"execution(* login(..)))\"/>\n            <aop:advisor advice-ref=\"around\" pointcut-ref=\"pc\"/>\n        </aop:config>\n */\n\n@Aspect\npublic class MyAspect {\n    @Around(\"execution(* login(..))\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n\n```\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <bean id=\"userService\" class=\"com.yusael.aspect.UserServiceImpl\"/>\n    <!--\n        切面:\n            1. 额外功能\n            2. 切入点\n            3. 组装切面\n    -->\n    <bean id=\"around\" class=\"com.yusael.aspect.MyAspect\"/>\n    <!--告知 Spring 基于注解进行 AOP 编程-->\n    <aop:aspectj-autoproxy/>\n\n</beans>\n\n```\n\n3. 切入点复用\n\n切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。\n\t通过这种方式定义切入点表达式，后续更加有利于切入点复用\n```java\n@Aspect\npublic class MyAspect {\n\n    @Pointcut(\"execution(* login(..))\")\n    public void myPoincut() {}\n\n    @Around(value = \"myPoincut()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n    @Around(value = \"myPoincut()\")\n    public Object around1(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect transaction ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n```\n#### 3.2.4.2、动态代理创建方式\n\nAOP 底层实现 2 种代理创建方式：\n\n1. JDK：通过 **实现接口，做新的实现类** 创建代理对象\n2. Cglib：通过 **继承父类，做新的子类** 创建代理对象\n\n**默认情况 AOP 编程 底层应用 JDK动态代理创建方式**\n```java\n<!-- 动态代理模式切换为cglib -->\n<aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n```\n\n# 4、spring 持久层\n## 4.1、spring与mybatis整合\n\n1. 引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-jdbc</artifactId>\n  <version>5.2.6.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis-spring</artifactId>\n  <version>2.0.4</version>\n</dependency>\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.1.12</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>5.1.43</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>3.5.4</version>\n</dependency>\n```\n\n2. spring配置文件\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <!--连接池-->\n        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n            <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n            <property name=\"url\" value=\"jdbc:mysql://localhost:3306/yus?useSSL=false\"/>\n            <property name=\"username\" value=\"root\"/>\n            <property name=\"password\" value=\"1234\"/>\n        </bean>\n\n        <!--创建SqlSessionFactory SqlSessionFactoryBean-->\n        <bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n            <property name=\"dataSource\" ref=\"dataSource\"/>\n            <property name=\"typeAliasesPackage\" value=\"com.yusael.entity\"/>\n            <property name=\"mapperLocations\">\n                <list>\n                    <value>classpath:com.yusael.dao/*Mapper.xml</value>\n                </list>\n            </property>\n        </bean>\n\n        <!--创建DAO对象 MapperScannerConfigure-->\n        <bean id=\"scanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n            <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactoryBean\"/>\n            <property name=\"basePackage\" value=\"com.yusael.dao\"/>\n        </bean>\n</beans>\n```\n\n3. 测试\n\n```java\n@Test\npublic void test() {\n    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n    UserDAO userDAO = (UserDAO) ctx.getBean(\"userDAO\");\n\n    User user = new User();\n    user.setName(\"xiaojr\");\n    user.setPassword(\"999999\");\n\n    userDAO.save(user);\n}\n```\n## 4.2、关于事务提交的疑问\n\n**问题**：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？\n\n> Mybatis 提供的连接池对象 —> 创建 Connection\n> Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。\n> Druid（C3P0、DBCP）作为连接池 —> 创建 Connection\n> Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。\n\n\n**答案**：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。\n\n**注意**：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题\n\n## 4.3、spring事务处理\n### 4.3.1、事务基本概念\n\n1. 什么是事务？\n\n事务时保证业务操作完整性的一种**数据库机制**\n\n2. 事务的四大特性？\n\nA 原子性\tC 一致性 I 隔离性\tD 持久性\n\n3. 如何控制事务？\n\n**JDBC：**\nConnection.setAutoCommit(false);\nConnection.commit();\nConnection.rollback();\n**Mybatis：**\nMybatis 自动开启事务\nsqlSession.commit();，底层还是调用的 Connection\nsqlSession.rollback();，底层还是调用的 Connection\n> 结论：控制事务的底层，都是通过 Connection 对象完成的\n\n### 4.3.2、spring控制事务的开发\nspring是通过aop的方式进行事务开发\n**增强功能：**原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法\n\n**切入点：**@Transactional （1）作用于类上（2）作用域方法。<\n\n**组装切面：**tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/> 自动扫描所有的@Transactional注解\n\n1. 搭建开发环境\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-tx</artifactId>\n\t<version>5.2.6.RELEASE</version>\n</dependency>\n```\n\n2. 编码\n\n```xml\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/>\n```\n进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib\n```xml\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\" proxy-target-class=\"true\"/>\n```\n### 4.3.3、事务的属性\n5个：隔离属性，传播属性，只读属性，超时属性，异常属性\n```markdown\n@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）\n```\n#### 4.3.3.1、隔离属性\n\n##### 4.3.3.1.1、并发问题&解决方案？\n**（1）脏读**：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象\n> eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了\n\n```java\n// 隔离级别：读已提交\n@Transaction(isolation=Isolation.READ_COMMITTED)\n```\n\n**（2）不可重复读**：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象\n> eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了\n> 注意：1.不是脏读 2.在一个事务中\n\n```java\n// 隔离级别：可重复读\n@Transaction(isolation=Isolation.REPEATABLE_READ)\n```\n> 本质：一把行锁（对数据库表的某一行加锁）\n\n\n\n**（3）幻读**：一个事务中，多次对**整表**进行**查询统计**，但是**结果不一样**，会在本事务中产生数据不一致的问题\n> 查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致\n\n```java\n// 隔离级别：序列化\n@Transaction(isolation=Isolation.SERIALIZABLE)\n```\n\n> 本质：表锁（对数据库某个表加锁）\n\n##### 4.3.3.1.2、安全与效率对比：\n\n- 并发安全：SERIALIZABLE > READ_ONLY > READ_COMMITTED\n- 运行效率：READ_COMMITTED > READ_ONLY > SERIALIZABLE\n\n##### 4.3.3.1.3、数据库默认隔离属性\nmysql：可重复读（REPEATABLE_READ）\nOracle：读已提交（READ_COMMITTED）\n\n#### 4.3.3.2、传播属性\n##### 4.3.3.2.1、基本概念\n传播属性：描述了事务解决 嵌套 问题 的特征\n**事务的嵌套**：指的是一个大的事务中，包含了若干个小的事务。\n**事务嵌套产生的问题**： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）\n\n##### 4.3.3.2.2、传播属性的值及用法\n| 传播属性的值 | 外部不存在事务 | 外部存在事务 | 用法 | 备注 |\n| --- | --- | --- | --- | --- |\n| REQUIRED | 开启新的事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.REQUIRED) | 增、删、改方法（保证了肯定会有事务的存在） |\n| REQUIRES_NEW | 开启新的事务 | 挂起外部事务，创建新的事务 | @Transactional(propagation = Propagation.REQUIRES_NEW) | 日志记录方法中（保证外部事务异常时能正常的记录日志） |\n| SUPPORTS | 不开启事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.SUPPORTS) | 查询方法 |\n| NOT_SUPPORTED | 不开启事务 | 挂起外部事务| @Transactional(propagation = Propagation.NOT_SUPPORTED) | 极其不常用 |\n| NEVER | 不开启事务 | 抛出异常 | @Transactional(propagation = Propagation.NEVER) | 极其不常用 |\n| MANDATORY（强制的） | 抛出异常 | 融合到外部事物中 | @Transactional(propagation = Propagation.MANDATORY) | 极其不常用 |\n\nSpring 中**传播属性的默认值**是：REQUIRED\n\n推荐传播属性的使用方式：\n\n- 增删改 方法：使用默认值 REQUIRED\n- 查询 方法：显示指定传播属性的值为 SUPPORTS\n\n\n#### 4.2.2.3、只读属性\n针对于 **只进行查询操作的业务方法**，可以加入只读属性，提高运行效率。\n默认值：false\n```java\n@Transactional(readOnly = true)\n```\n#### 4.2.2.4、超时属性\n指定了事务等待的最长时间。\n\n1. 为什么事务会进行等待？\n\n当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。\n\n2. 等待时间，单位是 秒\n3. 如何使用：@Transactional(timeout = 2)\n4. 超时属性的默认值：-1\n\n-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）\n\n#### 4.2.2.5、异常属性\nSpring 事务处理过程中：\n\n- 默认对于 RuntimeException 及其子类，采用 **回滚** 的策略。\n- 默认对于 对于其他类型的异常，采用 **提交** 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）\n\n```java\n@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)\n\n@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)\n```\n\n\n# 5、spring mvc\nspring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 \n\n## 5.1、父子容器关系\n1. Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）\n2. Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等\n3. Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）\n4. 调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止\n\n\n## 5.2、为什么要划分父子容器\n1. 分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）\n2. 性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能\n\n## 5.3、springBoot舍弃了父子容器的概念\n\nSpringBoot只有一个容器。\nSpring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署\n\n\n# 6、注解编程\n## 6.1、spring基础注解（spring2.X）\n### 6.1.1、对象创建相关\n#### 6.1.1.1、@Component\n\n1. 作用：替换原有Spring配置文件中的 <bean> 标签\n- id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO --> userDAO）\n- class 属性：通过反射获得的 class 的内容\n2. 细节：如何显式指定工厂创建对象的 id 值\n\n```java\n@Component(\"u\")\n```\n#### 6.1.1.2、@Repository、@Service、@Contoller\n@Repository、@Service、@Controller 都是 @Component 的 **衍生注解**。\n本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；\n它们的存在是为了：**更加准确的表达一个类型的作用**\n\n#### 6.1.1.3、@Scope\n作用：控制简单对象创建次数\n注意：不添加 @Scope，Spring 提供默认值 singleton\n```java\n// 创建单例对象\n@Component\n@Scope(\"singleton\")\npublic class Customer {}\n\n// 创建多例对象\n@Component\n@Scope(\"prototype\")\npublic class Customer {}\n```\n#### 6.1.1.4、@Lazy\n作用：延迟创建单实例对象\n注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象\n```java\n@Component\n@Lazy\npublic class Account {\n    public Account() {\n        System.out.println(\"Account.Account\");\n    }\n}\n```\n#### 6.1.1.5、@PostConstruct、@PreDestroy\n初始化相关方法： @PostConstruct\n```java\nInitializingBean\n<bean init-method=\"\"/>\n```\n销毁方法：@PreDestory\n```java\nDisposableBean\n<bean destory-method=\"\"/>\n```\n### 6.1.2、注入相关注解\n#### 6.1.2.1、@Autowired（用户自定义类型）\n\n1. @Autowired 注解 **基于类型进行注入** [推荐]：\n- 注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）\n\n```java\n@Autowired\nprivate UserDAO userDAO;\n```\n\n2. @Autowired、@Qualifier 注解联合实现 **基于名字进行注入** [了解]\n- 注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同\n\n```java\n@Autowired\n@Qualifier(\"userDAOImpl\")\nprivate UserDAO userDAO;\n```\n\n3. @Autowired 注解放置位置：\n- 放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）\n- **直接放置在成员变量上**，Spring 通过反射直接对成员变量进行赋值\n\n4. JSR提供的@Resource注解\n\n> JavaEE 规范中类似功能的注解：\n> - JSR250 提供的 @Resource(name=\"xxx\") **基于名字进行注入**\n等价于 @Autowired 与 @Qualifier 联合实现的效果\n注意：@Resource 注解如果名字没有配对成功，会继续 **按照类型进行注入**\n\n#### 6.1.2.2、@value、@PropertySource（JDK 类型）\n\n1. @value 注解的基本使用（xml配置）：\n\n```java\n1. 设置xxx.properties \n   id = 10\n   name = suns\n2. Spring的工厂读取这个配置文件 \n   <context:property-placeholder location=\"\"/>\n3. 代码中进行注入\n   属性 @Value(\"${key}\")\n\n```\n\n2. 使用 @PropertySource 取代 xml配置\n\n```java\n@Configuration\n@PropertySource(\"classpath:/init.properties\")\npublic class AppConfig1 {\n\n\t@Value(\"${id}\")\n\tprivate Integer id;\n\t@Value(\"${name}\")\n\tprivate String name;\n\t\n\t@Bean\n\tpublic Customer customer() {\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setId(id);\n\t\tcustomer.setName(name);\n\t\treturn customer;\n\t}\n}\n\n```\n\n3. @value 注解使用细节：\n- @Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null\n- @Value 注解 + Properties 这种方式，不能注入集合类型\nSpring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)\n## \n## 6.2、spring的高级注解（spring3.X及以上）\n### 6.2.1、@Configuration（配置bean）\n\n1. Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件\n2. 使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：\n\n```xml\n方法1: 指定配置bean的Class\nApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n\n方法2: 指定配置bean所在的路径(某个包及其子包)\nApplicationContext ctx = new AnnotationConfigApplicationContext(\"com.yusael\");\n```\n### 6.2.2、@Bean\n@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <bean 标签\n> **简单对象**：直接能够通过 new 方式创建的对象\n> - User、UserService、UserDAO\n> \n**复杂对象**：不能通过 new 的方式直接创建的对象\n> - Connection、SqlSessionFactory\n\n```java\n@Configuration\npublic class AppConfig{\n  // 简单对象\n\t@Bean\n  public Customer customer() {\n    Customer customer = new Customer();\n    return customer;\n  }\n\n  // 复杂对象\n  @Bean\n  public Connection conn1() {\n    Connection conn = null;\n    try {\n      ConnectionFactoryBean factoryBean = new ConnectionFactoryBean();\n      conn = factoryBean.getObject();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    return conn;\n  }\n}\n```\n### 6.2.3、@ComponentScan\n@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <context:component-scan> 标签\n目的：进行相关注解的扫描（@Component、@Value、@Autowired …)\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.yusael.scan\",\n               excludeFilters = {@ComponentScan.Filter(type= FilterType.ANNOTATION, value={Service.class}),\n                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = \"*..User1\")})\npublic class AppConfig2 {\n}\n```\n\n","slug":"spring","published":1,"updated":"2023-07-25T02:55:50.563Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clkjau31n000higum54w6e8b0","content":"<h1 id=\"1、前置内容\"><a href=\"#1、前置内容\" class=\"headerlink\" title=\"1、前置内容\"></a>1、前置内容</h1><h2 id=\"1-1、EJB的问题\"><a href=\"#1-1、EJB的问题\" class=\"headerlink\" title=\"1.1、EJB的问题\"></a>1.1、EJB的问题</h2><p>它是一个重量级的框架，体现在：</p>\n<ol>\n<li>运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源</li>\n<li>代码移植性差</li>\n</ol>\n<h2 id=\"1-2、什么是spring\"><a href=\"#1-2、什么是spring\" class=\"headerlink\" title=\"1.2、什么是spring\"></a>1.2、什么是spring</h2><p>spring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式</p>\n<ul>\n<li>轻量级</li>\n</ul>\n<blockquote>\n<ol>\n<li>对于运行环境没有额外要求（tomcat jetty weblogic等都可以）</li>\n<li>代码一致性高（不需要实现额外接口）</li>\n</ol>\n</blockquote>\n<ul>\n<li>javaEE解决方案</li>\n</ul>\n<blockquote>\n<p>包含了java web开发中 controller service dao层的解决方案</p>\n</blockquote>\n<ul>\n<li>整合设计模式</li>\n</ul>\n<blockquote>\n<p>工厂<br>代理<br>模板<br>策略</p>\n</blockquote>\n<h2 id=\"1-3、工厂设计模式\"><a href=\"#1-3、工厂设计模式\" class=\"headerlink\" title=\"1.3、工厂设计模式\"></a>1.3、工厂设计模式</h2><h3 id=\"1-3-1、什么是工厂设计模式\"><a href=\"#1-3-1、什么是工厂设计模式\" class=\"headerlink\" title=\"1.3.1、什么是工厂设计模式\"></a>1.3.1、什么是工厂设计模式</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 概念：通过工厂类创建对象</span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\">   问题：不利于代码维护</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-2、通用工厂的设计（简单工厂-反射）\"><a href=\"#1-3-2、通用工厂的设计（简单工厂-反射）\" class=\"headerlink\" title=\"1.3.2、通用工厂的设计（简单工厂+反射）\"></a>1.3.2、通用工厂的设计（简单工厂+反射）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Properties</span> <span class=\"variable\">env</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> BeanFactory.class.getResourceAsStream(<span class=\"string\">&quot;/applicationContext.properties&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            env.load(inputStream);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(env.getProperty(<span class=\"string\">&quot;userBean&quot;</span>));</span><br><span class=\"line\">           ret = clazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、spring-IOC\"><a href=\"#2、spring-IOC\" class=\"headerlink\" title=\"2、spring IOC\"></a>2、spring IOC</h1><h2 id=\"2-1、第一个spring程序\"><a href=\"#2-1、第一个spring程序\" class=\"headerlink\" title=\"2.1、第一个spring程序\"></a>2.1、第一个spring程序</h2><h3 id=\"2-1-1、核心API\"><a href=\"#2-1-1、核心API\" class=\"headerlink\" title=\"2.1.1、核心API\"></a>2.1.1、核心API</h3><ul>\n<li>ApplicationContext</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 作用：屏蔽实现的差异</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">3.</span> 接口类型：</span><br><span class=\"line\">非web环境：ClassPathXmlApplicationContext</span><br><span class=\"line\">web环境：XmlWebApplicationContext（需要导入spring-webmvc）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">4.</span> 重量级资源</span><br><span class=\"line\">applicationContext工厂的对象占用大量内存</span><br><span class=\"line\">不会频繁的创建，一个应用程序只会创建一个工厂对象</span><br><span class=\"line\">所以applicationContext工厂一定是线程安全的</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、程序开发\"><a href=\"#2-1-2、程序开发\" class=\"headerlink\" title=\"2.1.2、程序开发\"></a>2.1.2、程序开发</h3><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建配置文件</li>\n</ol>\n<p>new - xmlConfiguration File - spring config</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;person&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;bean.Person&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过工厂获取实例</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person)ctx.getBean(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">        System.out.println(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-3、思考\"><a href=\"#2-1-3、思考\" class=\"headerlink\" title=\"2.1.3、思考\"></a>2.1.3、思考</h3><ol>\n<li><p>使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化</p>\n</li>\n<li><p>在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）</p>\n</li>\n</ol>\n<h2 id=\"2-2、spring与日志框架整合\"><a href=\"#2-2、spring与日志框架整合\" class=\"headerlink\" title=\"2.2、spring与日志框架整合\"></a>2.2、spring与日志框架整合</h2><p>spring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png\" alt=\"日志框架\"></p>\n<ul>\n<li>spring如何整合日志框架？</li>\n</ul>\n<blockquote>\n<p>spring 1,2,3 早期都是jcl<br>spring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2</p>\n</blockquote>\n<p>当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j</p>\n<ol>\n<li>pom</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--日志门面--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.25<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--log4j--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.17<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>log4j.properties</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 配置根</span></span><br><span class=\"line\"><span class=\"attr\">log4j.rootLogger</span> = <span class=\"string\">debug, console</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### 配置输出到控制台</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console</span> = <span class=\"string\">org.apache.log4j.ConsoleAppender</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.Target</span> = <span class=\"string\">System.out</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout</span> = <span class=\"string\">org.apache.log4j.PatternLayout</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout.ConversionPattern</span> =  <span class=\"string\">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3、注入\"><a href=\"#2-3、注入\" class=\"headerlink\" title=\"2.3、注入\"></a>2.3、注入</h2><h3 id=\"2-3-1、什么是注入？\"><a href=\"#2-3-1、什么是注入？\" class=\"headerlink\" title=\"2.3.1、什么是注入？\"></a>2.3.1、什么是注入？</h3><p>通过spring工厂及配置文件，为所创建对象的成员变量赋值</p>\n<h3 id=\"2-3-2、为什么需要注入？\"><a href=\"#2-3-2、为什么需要注入？\" class=\"headerlink\" title=\"2.3.2、为什么需要注入？\"></a>2.3.2、为什么需要注入？</h3><p>之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合</p>\n<h3 id=\"2-3-3、如何进行注入？\"><a href=\"#2-3-3、如何进行注入？\" class=\"headerlink\" title=\"2.3.3、如何进行注入？\"></a>2.3.3、如何进行注入？</h3><h4 id=\"2-3-3-1、属性（field-）注入\"><a href=\"#2-3-3-1、属性（field-）注入\" class=\"headerlink\" title=\"2.3.3.1、属性（field ）注入\"></a>2.3.3.1、属性（field ）注入</h4><p>所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Svc svc;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-2、setter注入\"><a href=\"#2-3-3-2、setter注入\" class=\"headerlink\" title=\"2.3.3.2、setter注入\"></a>2.3.3.2、setter注入</h4><p>通过对应变量的<code>setXXX()</code>方法以及在方法上面使用注解，来完成依赖注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Helper helper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHelper</span><span class=\"params\">(Helper helper)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.helper = helper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-3-3、构造方法注入\"><a href=\"#2-3-3-3、构造方法注入\" class=\"headerlink\" title=\"2.3.3.3、构造方法注入\"></a>2.3.3.3、构造方法注入</h4><p>将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Svc svc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HelpService</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;svcB&quot;)</span> Svc svc)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.svc = svc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4、spring对象的生命周期\"><a href=\"#2-4、spring对象的生命周期\" class=\"headerlink\" title=\"2.4、spring对象的生命周期\"></a>2.4、spring对象的生命周期</h2><h3 id=\"2-4-1、spring-bean的生命周期\"><a href=\"#2-4-1、spring-bean的生命周期\" class=\"headerlink\" title=\"2.4.1、spring bean的生命周期\"></a>2.4.1、spring bean的生命周期</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png\" alt=\"spring bean生命周期\"></p>\n<ol>\n<li>实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。</li>\n<li>属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中</li>\n<li>回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。</li>\n</ol>\n<blockquote>\n<p>Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。<br>但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  </p>\n</blockquote>\n<ol>\n<li>初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器</li>\n<li>使用（In Use）：在初始化完成之后，Bean就可以被使用了。</li>\n<li>销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用</li>\n</ol>\n<h1 id=\"3、spring-AOP\"><a href=\"#3、spring-AOP\" class=\"headerlink\" title=\"3、spring AOP\"></a>3、spring AOP</h1><h2 id=\"3-1、spring动态代理\"><a href=\"#3-1、spring动态代理\" class=\"headerlink\" title=\"3.1、spring动态代理\"></a>3.1、spring动态代理</h2><h3 id=\"3-1-1、spring动态代理概念\"><a href=\"#3-1-1、spring动态代理概念\" class=\"headerlink\" title=\"3.1.1、spring动态代理概念\"></a>3.1.1、spring动态代理概念</h3><ol>\n<li>概念：通过代理类为目标类增加额外功能</li>\n<li>好处：利于目标类的维护</li>\n</ol>\n<h3 id=\"3-1-2、搭建开发环境\"><a href=\"#3-1-2、搭建开发环境\" class=\"headerlink\" title=\"3.1.2、搭建开发环境\"></a>3.1.2、搭建开发环境</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.14.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.8<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\"><a href=\"#3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\" class=\"headerlink\" title=\"3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\"></a>3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）</h3><ol>\n<li>创建目标对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;userService&quot;</span> class=<span class=\"string\">&quot;service.UserServiceImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>额外功能</li>\n</ol>\n<p>MethodBeforeAdvice接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Before</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodBeforeAdvice</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数： 目标方法 目标方法参数 目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(Method method, Object[] objects, Object o)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--method before advice log--&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;before&quot;</span> class=<span class=\"string\">&quot;dynamic.Before&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>定义切入点</li>\n</ol>\n<p> 切入点：额外功能加入的位置(方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>组装（2 3步整合）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">    &lt;!--组装：目的把切入点和额外功能进行整合--&gt;</span><br><span class=\"line\">    &lt;aop:advisor advice-ref=<span class=\"string\">&quot;before&quot;</span> pointcut-ref=<span class=\"string\">&quot;pc&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//目的：获得spring工厂创建的动态代理对象并进行调用</span></span><br><span class=\"line\">    <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. spring的工厂通过原始对象的id值获得的是代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> (UserService)ctx.getBean(<span class=\"string\">&quot;userService&quot;</span>);</span><br><span class=\"line\">    userService.login();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-4、思考\"><a href=\"#3-1-4、思考\" class=\"headerlink\" title=\"3.1.4、思考\"></a>3.1.4、思考</h3><ol>\n<li>spring创建的动态代理类在哪里？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失</span><br><span class=\"line\"></span><br><span class=\"line\">动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>动态字节码技术？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-5、额外功能详解\"><a href=\"#3-1-5、额外功能详解\" class=\"headerlink\" title=\"3.1.5、额外功能详解\"></a>3.1.5、额外功能详解</h3><p>MethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前<br>MethodInterceptor 前，后，抛出异常 都可以运行<br>所以我们实战中用到的更多的还是MethodInterceptor </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Around</span>  <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//methodInvocation : 额外功能所增加给的那个原始方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(MethodInvocation methodInvocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之前额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//原始方法执行</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">proceed</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            proceed = methodInvocation.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;--目标方法抛出异常额外功能--&quot;</span>);</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之后额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proceed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）</p>\n</blockquote>\n<h3 id=\"3-1-6、切入点详解\"><a href=\"#3-1-6、切入点详解\" class=\"headerlink\" title=\"3.1.6、切入点详解\"></a>3.1.6、切入点详解</h3><h4 id=\"3-1-6-1、切入点表达式\"><a href=\"#3-1-6-1、切入点表达式\" class=\"headerlink\" title=\"3.1.6.1、切入点表达式\"></a>3.1.6.1、切入点表达式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">execution() ：切入点函数</span><br><span class=\"line\">* *(..)：切入点表达式</span><br><span class=\"line\"></span><br><span class=\"line\">第一个* ：修饰符 返回值</span><br><span class=\"line\">第二个* ：方法名(包+类+方法 or 直接方法)</span><br><span class=\"line\">()：参数表 </span><br><span class=\"line\">..：对于参数没有要求</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有两个字符串类型的参数作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,String)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有第一个参数必须为String作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka.UserServiceImpl.login(..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka..*.*()</span><br><span class=\"line\">    </span><br><span class=\"line\">    其中的..*代表当前包及其子包</span><br><span class=\"line\">    如果是.*代表当前包</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任意包下UserServiceImpl类作为切入点（类切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* *..UserServiceImpl.*(..)</span><br><span class=\"line\">  </span><br><span class=\"line\">    其中的*..代表层级为<span class=\"number\">1</span>级或多级的包</span><br><span class=\"line\">    如果是*.UserService 只能查找第一层级下的类</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-2、切入点函数\"><a href=\"#3-1-6-2、切入点函数\" class=\"headerlink\" title=\"3.1.6.2、切入点函数\"></a>3.1.6.2、切入点函数</h4><p>切入点函数：用于执行切入点表达式</p>\n<ol>\n<li>execution</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：最为重要的切入点函数，功能最全</span><br><span class=\"line\">\t  执行方法切入点表达式 类切入点表达式 包切入点表达式</span><br><span class=\"line\">execution执行切入点表达式，书写麻烦</span><br><span class=\"line\">注意：其他的切入点函数简化execution书写复杂度，功能上完全一致</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>args</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于函数（方法）参数的匹配</span><br><span class=\"line\">方法参数必须是两个字符串类型的参数</span><br><span class=\"line\"></span><br><span class=\"line\">args(String,String)</span><br><span class=\"line\">等同于 execution(* *(String,String))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>within</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于进行类，包切入点表达式的匹配</span><br><span class=\"line\"></span><br><span class=\"line\">within(*..UserServiceImpl)</span><br><span class=\"line\">等同于execution(* *..UserServiceImpl.*(..))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>@annotation</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：<span class=\"meta\">@annotation</span>表示标注了某个注解的所有方法</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修饰的对象范围</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"comment\">// 注解生命周期  SOURCE &lt; CLASS &lt; RUNTIME</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Log &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Log</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;@annotation(bean.Log)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-3、切入点函数的逻辑运算\"><a href=\"#3-1-6-3、切入点函数的逻辑运算\" class=\"headerlink\" title=\"3.1.6.3、切入点函数的逻辑运算\"></a>3.1.6.3、切入点函数的逻辑运算</h4><ol>\n<li>and与操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：login 同时 参数 两个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) and <span class=\"title function_\">args</span><span class=\"params\">(String,String)</span></span><br><span class=\"line\">等同于 execution(* login(String,String))    </span><br><span class=\"line\">    </span><br><span class=\"line\">注意：与操作不能用于同种类型的切入点函数</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>or或操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：register方法和login方法作为切入点</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) or <span class=\"title function_\">execution</span><span class=\"params\">(* register(..)</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2、AOP编程\"><a href=\"#3-2、AOP编程\" class=\"headerlink\" title=\"3.2、AOP编程\"></a>3.2、AOP编程</h2><h3 id=\"3-2-1、基本概念\"><a href=\"#3-2-1、基本概念\" class=\"headerlink\" title=\"3.2.1、基本概念\"></a>3.2.1、基本概念</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> AOP：面向切面编程</span><br><span class=\"line\">   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> OOP：面向对象编程</span><br><span class=\"line\">   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"number\">3.</span> POP：面向过程编程</span><br><span class=\"line\">   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>12.2、切面名词解释</p>\n<blockquote>\n<p>切面 &#x3D; 切入点 + 额外功能</p>\n</blockquote>\n<p>多个额外功能相同的方法所代表的点连起来就是一个面</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png\" alt=\"aop切面\"></p>\n<h3 id=\"3-2-2、AOP底层实现原理\"><a href=\"#3-2-2、AOP底层实现原理\" class=\"headerlink\" title=\"3.2.2、AOP底层实现原理\"></a>3.2.2、AOP底层实现原理</h3><h4 id=\"3-2-2-1、核心问题\"><a href=\"#3-2-2-1、核心问题\" class=\"headerlink\" title=\"3.2.2.1、核心问题\"></a>3.2.2.1、核心问题</h4><blockquote>\n<ol>\n<li>aop如何创建动态代理类（动态字节码技术）</li>\n<li>如何实现通过原始对象的id值，获得的是代理对象</li>\n</ol>\n</blockquote>\n<h3 id=\"3-2-3、动态代理类的创建\"><a href=\"#3-2-3、动态代理类的创建\" class=\"headerlink\" title=\"3.2.3、动态代理类的创建\"></a>3.2.3、动态代理类的创建</h3><h4 id=\"3-2-3-1、JDK动态代理\"><a href=\"#3-2-3-1、JDK动态代理\" class=\"headerlink\" title=\"3.2.3.1、JDK动态代理\"></a>3.2.3.1、JDK动态代理</h4><ul>\n<li><p>Proxy.newProxyInstancec：</p>\n</li>\n<li><p>编码实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestJDKProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以</span></span><br><span class=\"line\"><span class=\"comment\">     2. JDK8.x 前必须加 final</span></span><br><span class=\"line\"><span class=\"comment\">     final UserService userService = new UserServiceImpl();</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. JDK 动态代理</span></span><br><span class=\"line\">        <span class=\"type\">InvocationHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;---- proxy log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 原始方法运行</span></span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) Proxy.</span><br><span class=\"line\">                newProxyInstance(TestJDKProxy.class.getClassLoader(),</span><br><span class=\"line\">                                userService.getClass().getInterfaces(),</span><br><span class=\"line\">                                handler);</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-2、CGLib动态代理\"><a href=\"#3-2-3-2、CGLib动态代理\" class=\"headerlink\" title=\"3.2.3.2、CGLib动态代理\"></a>3.2.3.2、CGLib动态代理</h4><ul>\n<li>CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）</li>\n</ul>\n<blockquote>\n<p>在原始类没有实现接口的情况下cglib是一种很好的实现方式</p>\n</blockquote>\n<ul>\n<li>cglib原理</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCglib</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         2. 通过 cglib 方式创建动态代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setClassLoader()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setSuperClass()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib)</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.createProxy() ---&gt; 创建代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setClassLoader(TestCglib.class.getClassLoader());</span><br><span class=\"line\">        enhancer.setSuperclass(userService.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">MethodInterceptor</span> <span class=\"variable\">interceptor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MethodInterceptor</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;--- cglib log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args); <span class=\"comment\">// 执行原始方法</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setCallback(interceptor);</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) enhancer.create();</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 总结：</p>\n<ol>\n<li>JDK 动态代理<br>Proxy.newProxyInstance：通过接口创建代理的实现类</li>\n<li>Cglib 动态代理<br>Enhancer：通过继承父类创建的代理类</li>\n</ol>\n<h3 id=\"3-2-4、基于注解的AOP编程\"><a href=\"#3-2-4、基于注解的AOP编程\" class=\"headerlink\" title=\"3.2.4、基于注解的AOP编程\"></a>3.2.4、基于注解的AOP编程</h3><h4 id=\"3-2-4-1、开发步骤\"><a href=\"#3-2-4-1、开发步骤\" class=\"headerlink\" title=\"3.2.4.1、开发步骤\"></a>3.2.4.1、开发步骤</h4><ol>\n<li>原始功能</li>\n</ol>\n<p>包含原始功能和实现类等</p>\n<ol start=\"2\">\n<li>额外功能+切入点+组装切面</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">        public class MyAround implements MethodInterceptor &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            public Object invoke(MethodInvocation invocation) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                Object ret = invocation.invoke();</span></span><br><span class=\"line\"><span class=\"comment\">                return ret;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;bean id=&quot;around&quot; class=&quot;com.yusael.dynamic.Around&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)))&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:advisor advice-ref=&quot;around&quot; pointcut-ref=&quot;pc&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;/aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        切面:</span></span><br><span class=\"line\"><span class=\"comment\">            1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">            2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">            3. 组装切面</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;around&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.MyAspect&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--告知 Spring 基于注解进行 AOP 编程--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>切入点复用</li>\n</ol>\n<p>切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。<br>    通过这种方式定义切入点表达式，后续更加有利于切入点复用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myPoincut</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around1</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect transaction ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-4-2、动态代理创建方式\"><a href=\"#3-2-4-2、动态代理创建方式\" class=\"headerlink\" title=\"3.2.4.2、动态代理创建方式\"></a>3.2.4.2、动态代理创建方式</h4><p>AOP 底层实现 2 种代理创建方式：</p>\n<ol>\n<li>JDK：通过 <strong>实现接口，做新的实现类</strong> 创建代理对象</li>\n<li>Cglib：通过 <strong>继承父类，做新的子类</strong> 创建代理对象</li>\n</ol>\n<p><strong>默认情况 AOP 编程 底层应用 JDK动态代理创建方式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 动态代理模式切换为cglib --&gt;</span><br><span class=\"line\">&lt;aop:aspectj-autoproxy proxy-target-class=<span class=\"string\">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、spring-持久层\"><a href=\"#4、spring-持久层\" class=\"headerlink\" title=\"4、spring 持久层\"></a>4、spring 持久层</h1><h2 id=\"4-1、spring与mybatis整合\"><a href=\"#4-1、spring与mybatis整合\" class=\"headerlink\" title=\"4.1、spring与mybatis整合\"></a>4.1、spring与mybatis整合</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>druid<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.43<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>spring配置文件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--连接池--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1234&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;typeAliasesPackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.entity&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapperLocations&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;scanner&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sqlSessionFactoryBeanName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;basePackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.dao&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">UserDAO</span> <span class=\"variable\">userDAO</span> <span class=\"operator\">=</span> (UserDAO) ctx.getBean(<span class=\"string\">&quot;userDAO&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">    user.setName(<span class=\"string\">&quot;xiaojr&quot;</span>);</span><br><span class=\"line\">    user.setPassword(<span class=\"string\">&quot;999999&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    userDAO.save(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2、关于事务提交的疑问\"><a href=\"#4-2、关于事务提交的疑问\" class=\"headerlink\" title=\"4.2、关于事务提交的疑问\"></a>4.2、关于事务提交的疑问</h2><p><strong>问题</strong>：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？</p>\n<blockquote>\n<p>Mybatis 提供的连接池对象 —&gt; 创建 Connection<br>Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。<br>Druid（C3P0、DBCP）作为连接池 —&gt; 创建 Connection<br>Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。</p>\n</blockquote>\n<p><strong>答案</strong>：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。</p>\n<p><strong>注意</strong>：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题</p>\n<h2 id=\"4-3、spring事务处理\"><a href=\"#4-3、spring事务处理\" class=\"headerlink\" title=\"4.3、spring事务处理\"></a>4.3、spring事务处理</h2><h3 id=\"4-3-1、事务基本概念\"><a href=\"#4-3-1、事务基本概念\" class=\"headerlink\" title=\"4.3.1、事务基本概念\"></a>4.3.1、事务基本概念</h3><ol>\n<li>什么是事务？</li>\n</ol>\n<p>事务时保证业务操作完整性的一种<strong>数据库机制</strong></p>\n<ol start=\"2\">\n<li>事务的四大特性？</li>\n</ol>\n<p>A 原子性\tC 一致性 I 隔离性\tD 持久性</p>\n<ol start=\"3\">\n<li>如何控制事务？</li>\n</ol>\n<p><strong>JDBC：</strong><br>Connection.setAutoCommit(false);<br>Connection.commit();<br>Connection.rollback();<br><strong>Mybatis：</strong><br>Mybatis 自动开启事务<br>sqlSession.commit();，底层还是调用的 Connection<br>sqlSession.rollback();，底层还是调用的 Connection</p>\n<blockquote>\n<p>结论：控制事务的底层，都是通过 Connection 对象完成的</p>\n</blockquote>\n<h3 id=\"4-3-2、spring控制事务的开发\"><a href=\"#4-3-2、spring控制事务的开发\" class=\"headerlink\" title=\"4.3.2、spring控制事务的开发\"></a>4.3.2、spring控制事务的开发</h3><p>spring是通过aop的方式进行事务开发<br><strong>增强功能：</strong>原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法</p>\n<p><strong>切入点：</strong>@Transactional （1）作用于类上（2）作用域方法。&lt;</p>\n<p><strong>组装切面：</strong>tx:annotation-driven transaction-manager&#x3D;”dataSourceTransactionManager”&#x2F;&gt; 自动扫描所有的@Transactional注解</p>\n<ol>\n<li>搭建开发环境</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-tx<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-3、事务的属性\"><a href=\"#4-3-3、事务的属性\" class=\"headerlink\" title=\"4.3.3、事务的属性\"></a>4.3.3、事务的属性</h3><p>5个：隔离属性，传播属性，只读属性，超时属性，异常属性</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-3-1、隔离属性\"><a href=\"#4-3-3-1、隔离属性\" class=\"headerlink\" title=\"4.3.3.1、隔离属性\"></a>4.3.3.1、隔离属性</h4><h5 id=\"4-3-3-1-1、并发问题-解决方案？\"><a href=\"#4-3-3-1-1、并发问题-解决方案？\" class=\"headerlink\" title=\"4.3.3.1.1、并发问题&amp;解决方案？\"></a>4.3.3.1.1、并发问题&amp;解决方案？</h5><p><strong>（1）脏读</strong>：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：读已提交</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）不可重复读</strong>：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了<br>注意：1.不是脏读 2.在一个事务中</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：可重复读</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.REPEATABLE_READ)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>本质：一把行锁（对数据库表的某一行加锁）</p>\n</blockquote>\n<p><strong>（3）幻读</strong>：一个事务中，多次对<strong>整表</strong>进行<strong>查询统计</strong>，但是<strong>结果不一样</strong>，会在本事务中产生数据不一致的问题</p>\n<blockquote>\n<p>查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：序列化</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.SERIALIZABLE)</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本质：表锁（对数据库某个表加锁）</p>\n</blockquote>\n<h5 id=\"4-3-3-1-2、安全与效率对比：\"><a href=\"#4-3-3-1-2、安全与效率对比：\" class=\"headerlink\" title=\"4.3.3.1.2、安全与效率对比：\"></a>4.3.3.1.2、安全与效率对比：</h5><ul>\n<li>并发安全：SERIALIZABLE &gt; READ_ONLY &gt; READ_COMMITTED</li>\n<li>运行效率：READ_COMMITTED &gt; READ_ONLY &gt; SERIALIZABLE</li>\n</ul>\n<h5 id=\"4-3-3-1-3、数据库默认隔离属性\"><a href=\"#4-3-3-1-3、数据库默认隔离属性\" class=\"headerlink\" title=\"4.3.3.1.3、数据库默认隔离属性\"></a>4.3.3.1.3、数据库默认隔离属性</h5><p>mysql：可重复读（REPEATABLE_READ）<br>Oracle：读已提交（READ_COMMITTED）</p>\n<h4 id=\"4-3-3-2、传播属性\"><a href=\"#4-3-3-2、传播属性\" class=\"headerlink\" title=\"4.3.3.2、传播属性\"></a>4.3.3.2、传播属性</h4><h5 id=\"4-3-3-2-1、基本概念\"><a href=\"#4-3-3-2-1、基本概念\" class=\"headerlink\" title=\"4.3.3.2.1、基本概念\"></a>4.3.3.2.1、基本概念</h5><p>传播属性：描述了事务解决 嵌套 问题 的特征<br><strong>事务的嵌套</strong>：指的是一个大的事务中，包含了若干个小的事务。<br><strong>事务嵌套产生的问题</strong>： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）</p>\n<h5 id=\"4-3-3-2-2、传播属性的值及用法\"><a href=\"#4-3-3-2-2、传播属性的值及用法\" class=\"headerlink\" title=\"4.3.3.2.2、传播属性的值及用法\"></a>4.3.3.2.2、传播属性的值及用法</h5><table>\n<thead>\n<tr>\n<th>传播属性的值</th>\n<th>外部不存在事务</th>\n<th>外部存在事务</th>\n<th>用法</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>REQUIRED</td>\n<td>开启新的事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRED)</td>\n<td>增、删、改方法（保证了肯定会有事务的存在）</td>\n</tr>\n<tr>\n<td>REQUIRES_NEW</td>\n<td>开启新的事务</td>\n<td>挂起外部事务，创建新的事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</td>\n<td>日志记录方法中（保证外部事务异常时能正常的记录日志）</td>\n</tr>\n<tr>\n<td>SUPPORTS</td>\n<td>不开启事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.SUPPORTS)</td>\n<td>查询方法</td>\n</tr>\n<tr>\n<td>NOT_SUPPORTED</td>\n<td>不开启事务</td>\n<td>挂起外部事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>NEVER</td>\n<td>不开启事务</td>\n<td>抛出异常</td>\n<td>@Transactional(propagation &#x3D; Propagation.NEVER)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>MANDATORY（强制的）</td>\n<td>抛出异常</td>\n<td>融合到外部事物中</td>\n<td>@Transactional(propagation &#x3D; Propagation.MANDATORY)</td>\n<td>极其不常用</td>\n</tr>\n</tbody></table>\n<p>Spring 中<strong>传播属性的默认值</strong>是：REQUIRED</p>\n<p>推荐传播属性的使用方式：</p>\n<ul>\n<li>增删改 方法：使用默认值 REQUIRED</li>\n<li>查询 方法：显示指定传播属性的值为 SUPPORTS</li>\n</ul>\n<h4 id=\"4-2-2-3、只读属性\"><a href=\"#4-2-2-3、只读属性\" class=\"headerlink\" title=\"4.2.2.3、只读属性\"></a>4.2.2.3、只读属性</h4><p>针对于 <strong>只进行查询操作的业务方法</strong>，可以加入只读属性，提高运行效率。<br>默认值：false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-2-4、超时属性\"><a href=\"#4-2-2-4、超时属性\" class=\"headerlink\" title=\"4.2.2.4、超时属性\"></a>4.2.2.4、超时属性</h4><p>指定了事务等待的最长时间。</p>\n<ol>\n<li>为什么事务会进行等待？</li>\n</ol>\n<p>当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。</p>\n<ol start=\"2\">\n<li>等待时间，单位是 秒</li>\n<li>如何使用：@Transactional(timeout &#x3D; 2)</li>\n<li>超时属性的默认值：-1</li>\n</ol>\n<p>-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）</p>\n<h4 id=\"4-2-2-5、异常属性\"><a href=\"#4-2-2-5、异常属性\" class=\"headerlink\" title=\"4.2.2.5、异常属性\"></a>4.2.2.5、异常属性</h4><p>Spring 事务处理过程中：</p>\n<ul>\n<li>默认对于 RuntimeException 及其子类，采用 <strong>回滚</strong> 的策略。</li>\n<li>默认对于 对于其他类型的异常，采用 <strong>提交</strong> 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"5、spring-mvc\"><a href=\"#5、spring-mvc\" class=\"headerlink\" title=\"5、spring mvc\"></a>5、spring mvc</h1><p>spring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 </p>\n<h2 id=\"5-1、父子容器关系\"><a href=\"#5-1、父子容器关系\" class=\"headerlink\" title=\"5.1、父子容器关系\"></a>5.1、父子容器关系</h2><ol>\n<li>Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）</li>\n<li>Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等</li>\n<li>Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）</li>\n<li>调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止</li>\n</ol>\n<h2 id=\"5-2、为什么要划分父子容器\"><a href=\"#5-2、为什么要划分父子容器\" class=\"headerlink\" title=\"5.2、为什么要划分父子容器\"></a>5.2、为什么要划分父子容器</h2><ol>\n<li>分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）</li>\n<li>性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能</li>\n</ol>\n<h2 id=\"5-3、springBoot舍弃了父子容器的概念\"><a href=\"#5-3、springBoot舍弃了父子容器的概念\" class=\"headerlink\" title=\"5.3、springBoot舍弃了父子容器的概念\"></a>5.3、springBoot舍弃了父子容器的概念</h2><p>SpringBoot只有一个容器。<br>Spring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署</p>\n<h1 id=\"6、注解编程\"><a href=\"#6、注解编程\" class=\"headerlink\" title=\"6、注解编程\"></a>6、注解编程</h1><h2 id=\"6-1、spring基础注解（spring2-X）\"><a href=\"#6-1、spring基础注解（spring2-X）\" class=\"headerlink\" title=\"6.1、spring基础注解（spring2.X）\"></a>6.1、spring基础注解（spring2.X）</h2><h3 id=\"6-1-1、对象创建相关\"><a href=\"#6-1-1、对象创建相关\" class=\"headerlink\" title=\"6.1.1、对象创建相关\"></a>6.1.1、对象创建相关</h3><h4 id=\"6-1-1-1、-Component\"><a href=\"#6-1-1-1、-Component\" class=\"headerlink\" title=\"6.1.1.1、@Component\"></a>6.1.1.1、@Component</h4><ol>\n<li>作用：替换原有Spring配置文件中的 <bean> 标签</li>\n</ol>\n<ul>\n<li>id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO –&gt; userDAO）</li>\n<li>class 属性：通过反射获得的 class 的内容</li>\n</ul>\n<ol start=\"2\">\n<li>细节：如何显式指定工厂创建对象的 id 值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;u&quot;)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-2、-Repository、-Service、-Contoller\"><a href=\"#6-1-1-2、-Repository、-Service、-Contoller\" class=\"headerlink\" title=\"6.1.1.2、@Repository、@Service、@Contoller\"></a>6.1.1.2、@Repository、@Service、@Contoller</h4><p>@Repository、@Service、@Controller 都是 @Component 的 <strong>衍生注解</strong>。<br>本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；<br>它们的存在是为了：<strong>更加准确的表达一个类型的作用</strong></p>\n<h4 id=\"6-1-1-3、-Scope\"><a href=\"#6-1-1-3、-Scope\" class=\"headerlink\" title=\"6.1.1.3、@Scope\"></a>6.1.1.3、@Scope</h4><p>作用：控制简单对象创建次数<br>注意：不添加 @Scope，Spring 提供默认值 singleton</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建单例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;singleton&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建多例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-4、-Lazy\"><a href=\"#6-1-1-4、-Lazy\" class=\"headerlink\" title=\"6.1.1.4、@Lazy\"></a>6.1.1.4、@Lazy</h4><p>作用：延迟创建单实例对象<br>注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Account</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Account</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Account.Account&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-5、-PostConstruct、-PreDestroy\"><a href=\"#6-1-1-5、-PostConstruct、-PreDestroy\" class=\"headerlink\" title=\"6.1.1.5、@PostConstruct、@PreDestroy\"></a>6.1.1.5、@PostConstruct、@PreDestroy</h4><p>初始化相关方法： @PostConstruct</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InitializingBean</span><br><span class=\"line\">&lt;bean init-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>销毁方法：@PreDestory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableBean</span><br><span class=\"line\">&lt;bean destory-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-1-2、注入相关注解\"><a href=\"#6-1-2、注入相关注解\" class=\"headerlink\" title=\"6.1.2、注入相关注解\"></a>6.1.2、注入相关注解</h3><h4 id=\"6-1-2-1、-Autowired（用户自定义类型）\"><a href=\"#6-1-2-1、-Autowired（用户自定义类型）\" class=\"headerlink\" title=\"6.1.2.1、@Autowired（用户自定义类型）\"></a>6.1.2.1、@Autowired（用户自定义类型）</h4><ol>\n<li>@Autowired 注解 <strong>基于类型进行注入</strong> [推荐]：</li>\n</ol>\n<ul>\n<li>注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>@Autowired、@Qualifier 注解联合实现 <strong>基于名字进行注入</strong> [了解]</li>\n</ol>\n<ul>\n<li>注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;userDAOImpl&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@Autowired 注解放置位置：</li>\n</ol>\n<ul>\n<li>放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）</li>\n<li><strong>直接放置在成员变量上</strong>，Spring 通过反射直接对成员变量进行赋值</li>\n</ul>\n<ol start=\"4\">\n<li>JSR提供的@Resource注解</li>\n</ol>\n<blockquote>\n<p>JavaEE 规范中类似功能的注解：</p>\n<ul>\n<li>JSR250 提供的 @Resource(name&#x3D;”xxx”) <strong>基于名字进行注入</strong><br>等价于 @Autowired 与 @Qualifier 联合实现的效果<br>注意：@Resource 注解如果名字没有配对成功，会继续 <strong>按照类型进行注入</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"6-1-2-2、-value、-PropertySource（JDK-类型）\"><a href=\"#6-1-2-2、-value、-PropertySource（JDK-类型）\" class=\"headerlink\" title=\"6.1.2.2、@value、@PropertySource（JDK 类型）\"></a>6.1.2.2、@value、@PropertySource（JDK 类型）</h4><ol>\n<li>@value 注解的基本使用（xml配置）：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 设置xxx.<span class=\"type\">properties</span> </span><br><span class=\"line\">   <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">   name = suns</span><br><span class=\"line\"><span class=\"number\">2.</span> Spring的工厂读取这个配置文件 </span><br><span class=\"line\">   &lt;context:property-placeholder location=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br><span class=\"line\"><span class=\"number\">3.</span> 代码中进行注入</span><br><span class=\"line\">   属性 <span class=\"meta\">@Value(&quot;$&#123;key&#125;&quot;)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 @PropertySource 取代 xml配置</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource(&quot;classpath:/init.properties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;id&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">\t\tcustomer.setId(id);</span><br><span class=\"line\">\t\tcustomer.setName(name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@value 注解使用细节：</li>\n</ol>\n<ul>\n<li>@Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null</li>\n<li>@Value 注解 + Properties 这种方式，不能注入集合类型<br>Spring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"6-2、spring的高级注解（spring3-X及以上）\"><a href=\"#6-2、spring的高级注解（spring3-X及以上）\" class=\"headerlink\" title=\"6.2、spring的高级注解（spring3.X及以上）\"></a>6.2、spring的高级注解（spring3.X及以上）</h2><h3 id=\"6-2-1、-Configuration（配置bean）\"><a href=\"#6-2-1、-Configuration（配置bean）\" class=\"headerlink\" title=\"6.2.1、@Configuration（配置bean）\"></a>6.2.1、@Configuration（配置bean）</h3><ol>\n<li>Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件</li>\n<li>使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法1: 指定配置bean的Class</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\">方法2: 指定配置bean所在的路径(某个包及其子包)</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.yusael&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2、-Bean\"><a href=\"#6-2-2、-Bean\" class=\"headerlink\" title=\"6.2.2、@Bean\"></a>6.2.2、@Bean</h3><p>@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 &lt;bean 标签</p>\n<blockquote>\n<p><strong>简单对象</strong>：直接能够通过 new 方式创建的对象</p>\n<ul>\n<li>User、UserService、UserDAO</li>\n</ul>\n</blockquote>\n<p><strong>复杂对象</strong>：不能通过 new 的方式直接创建的对象</p>\n<blockquote>\n<ul>\n<li>Connection、SqlSessionFactory</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 简单对象</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 复杂对象</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Connection <span class=\"title function_\">conn1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ConnectionFactoryBean</span> <span class=\"variable\">factoryBean</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactoryBean</span>();</span><br><span class=\"line\">      conn = factoryBean.getObject();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-3、-ComponentScan\"><a href=\"#6-2-3、-ComponentScan\" class=\"headerlink\" title=\"6.2.3、@ComponentScan\"></a>6.2.3、@ComponentScan</h3><p>@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <a href=\"context:component-scan\">context:component-scan</a> 标签<br>目的：进行相关注解的扫描（@Component、@Value、@Autowired …)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">               excludeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION, value=&#123;Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = &quot;*..User1&quot;)&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig2</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、前置内容\"><a href=\"#1、前置内容\" class=\"headerlink\" title=\"1、前置内容\"></a>1、前置内容</h1><h2 id=\"1-1、EJB的问题\"><a href=\"#1-1、EJB的问题\" class=\"headerlink\" title=\"1.1、EJB的问题\"></a>1.1、EJB的问题</h2><p>它是一个重量级的框架，体现在：</p>\n<ol>\n<li>运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源</li>\n<li>代码移植性差</li>\n</ol>\n<h2 id=\"1-2、什么是spring\"><a href=\"#1-2、什么是spring\" class=\"headerlink\" title=\"1.2、什么是spring\"></a>1.2、什么是spring</h2><p>spring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式</p>\n<ul>\n<li>轻量级</li>\n</ul>\n<blockquote>\n<ol>\n<li>对于运行环境没有额外要求（tomcat jetty weblogic等都可以）</li>\n<li>代码一致性高（不需要实现额外接口）</li>\n</ol>\n</blockquote>\n<ul>\n<li>javaEE解决方案</li>\n</ul>\n<blockquote>\n<p>包含了java web开发中 controller service dao层的解决方案</p>\n</blockquote>\n<ul>\n<li>整合设计模式</li>\n</ul>\n<blockquote>\n<p>工厂<br>代理<br>模板<br>策略</p>\n</blockquote>\n<h2 id=\"1-3、工厂设计模式\"><a href=\"#1-3、工厂设计模式\" class=\"headerlink\" title=\"1.3、工厂设计模式\"></a>1.3、工厂设计模式</h2><h3 id=\"1-3-1、什么是工厂设计模式\"><a href=\"#1-3-1、什么是工厂设计模式\" class=\"headerlink\" title=\"1.3.1、什么是工厂设计模式\"></a>1.3.1、什么是工厂设计模式</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 概念：通过工厂类创建对象</span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\">   问题：不利于代码维护</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-2、通用工厂的设计（简单工厂-反射）\"><a href=\"#1-3-2、通用工厂的设计（简单工厂-反射）\" class=\"headerlink\" title=\"1.3.2、通用工厂的设计（简单工厂+反射）\"></a>1.3.2、通用工厂的设计（简单工厂+反射）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Properties</span> <span class=\"variable\">env</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> BeanFactory.class.getResourceAsStream(<span class=\"string\">&quot;/applicationContext.properties&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            env.load(inputStream);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(env.getProperty(<span class=\"string\">&quot;userBean&quot;</span>));</span><br><span class=\"line\">           ret = clazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、spring-IOC\"><a href=\"#2、spring-IOC\" class=\"headerlink\" title=\"2、spring IOC\"></a>2、spring IOC</h1><h2 id=\"2-1、第一个spring程序\"><a href=\"#2-1、第一个spring程序\" class=\"headerlink\" title=\"2.1、第一个spring程序\"></a>2.1、第一个spring程序</h2><h3 id=\"2-1-1、核心API\"><a href=\"#2-1-1、核心API\" class=\"headerlink\" title=\"2.1.1、核心API\"></a>2.1.1、核心API</h3><ul>\n<li>ApplicationContext</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 作用：屏蔽实现的差异</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">3.</span> 接口类型：</span><br><span class=\"line\">非web环境：ClassPathXmlApplicationContext</span><br><span class=\"line\">web环境：XmlWebApplicationContext（需要导入spring-webmvc）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">4.</span> 重量级资源</span><br><span class=\"line\">applicationContext工厂的对象占用大量内存</span><br><span class=\"line\">不会频繁的创建，一个应用程序只会创建一个工厂对象</span><br><span class=\"line\">所以applicationContext工厂一定是线程安全的</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、程序开发\"><a href=\"#2-1-2、程序开发\" class=\"headerlink\" title=\"2.1.2、程序开发\"></a>2.1.2、程序开发</h3><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建配置文件</li>\n</ol>\n<p>new - xmlConfiguration File - spring config</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;person&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;bean.Person&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过工厂获取实例</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person)ctx.getBean(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">        System.out.println(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-3、思考\"><a href=\"#2-1-3、思考\" class=\"headerlink\" title=\"2.1.3、思考\"></a>2.1.3、思考</h3><ol>\n<li><p>使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化</p>\n</li>\n<li><p>在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）</p>\n</li>\n</ol>\n<h2 id=\"2-2、spring与日志框架整合\"><a href=\"#2-2、spring与日志框架整合\" class=\"headerlink\" title=\"2.2、spring与日志框架整合\"></a>2.2、spring与日志框架整合</h2><p>spring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png\" alt=\"日志框架\"></p>\n<ul>\n<li>spring如何整合日志框架？</li>\n</ul>\n<blockquote>\n<p>spring 1,2,3 早期都是jcl<br>spring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2</p>\n</blockquote>\n<p>当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j</p>\n<ol>\n<li>pom</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--日志门面--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.25<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--log4j--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.17<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>log4j.properties</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 配置根</span></span><br><span class=\"line\"><span class=\"attr\">log4j.rootLogger</span> = <span class=\"string\">debug, console</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### 配置输出到控制台</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console</span> = <span class=\"string\">org.apache.log4j.ConsoleAppender</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.Target</span> = <span class=\"string\">System.out</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout</span> = <span class=\"string\">org.apache.log4j.PatternLayout</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout.ConversionPattern</span> =  <span class=\"string\">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3、注入\"><a href=\"#2-3、注入\" class=\"headerlink\" title=\"2.3、注入\"></a>2.3、注入</h2><h3 id=\"2-3-1、什么是注入？\"><a href=\"#2-3-1、什么是注入？\" class=\"headerlink\" title=\"2.3.1、什么是注入？\"></a>2.3.1、什么是注入？</h3><p>通过spring工厂及配置文件，为所创建对象的成员变量赋值</p>\n<h3 id=\"2-3-2、为什么需要注入？\"><a href=\"#2-3-2、为什么需要注入？\" class=\"headerlink\" title=\"2.3.2、为什么需要注入？\"></a>2.3.2、为什么需要注入？</h3><p>之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合</p>\n<h3 id=\"2-3-3、如何进行注入？\"><a href=\"#2-3-3、如何进行注入？\" class=\"headerlink\" title=\"2.3.3、如何进行注入？\"></a>2.3.3、如何进行注入？</h3><h4 id=\"2-3-3-1、属性（field-）注入\"><a href=\"#2-3-3-1、属性（field-）注入\" class=\"headerlink\" title=\"2.3.3.1、属性（field ）注入\"></a>2.3.3.1、属性（field ）注入</h4><p>所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Svc svc;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-2、setter注入\"><a href=\"#2-3-3-2、setter注入\" class=\"headerlink\" title=\"2.3.3.2、setter注入\"></a>2.3.3.2、setter注入</h4><p>通过对应变量的<code>setXXX()</code>方法以及在方法上面使用注解，来完成依赖注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Helper helper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHelper</span><span class=\"params\">(Helper helper)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.helper = helper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-3-3、构造方法注入\"><a href=\"#2-3-3-3、构造方法注入\" class=\"headerlink\" title=\"2.3.3.3、构造方法注入\"></a>2.3.3.3、构造方法注入</h4><p>将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Svc svc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HelpService</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;svcB&quot;)</span> Svc svc)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.svc = svc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4、spring对象的生命周期\"><a href=\"#2-4、spring对象的生命周期\" class=\"headerlink\" title=\"2.4、spring对象的生命周期\"></a>2.4、spring对象的生命周期</h2><h3 id=\"2-4-1、spring-bean的生命周期\"><a href=\"#2-4-1、spring-bean的生命周期\" class=\"headerlink\" title=\"2.4.1、spring bean的生命周期\"></a>2.4.1、spring bean的生命周期</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png\" alt=\"spring bean生命周期\"></p>\n<ol>\n<li>实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。</li>\n<li>属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中</li>\n<li>回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。</li>\n</ol>\n<blockquote>\n<p>Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。<br>但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  </p>\n</blockquote>\n<ol>\n<li>初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器</li>\n<li>使用（In Use）：在初始化完成之后，Bean就可以被使用了。</li>\n<li>销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用</li>\n</ol>\n<h1 id=\"3、spring-AOP\"><a href=\"#3、spring-AOP\" class=\"headerlink\" title=\"3、spring AOP\"></a>3、spring AOP</h1><h2 id=\"3-1、spring动态代理\"><a href=\"#3-1、spring动态代理\" class=\"headerlink\" title=\"3.1、spring动态代理\"></a>3.1、spring动态代理</h2><h3 id=\"3-1-1、spring动态代理概念\"><a href=\"#3-1-1、spring动态代理概念\" class=\"headerlink\" title=\"3.1.1、spring动态代理概念\"></a>3.1.1、spring动态代理概念</h3><ol>\n<li>概念：通过代理类为目标类增加额外功能</li>\n<li>好处：利于目标类的维护</li>\n</ol>\n<h3 id=\"3-1-2、搭建开发环境\"><a href=\"#3-1-2、搭建开发环境\" class=\"headerlink\" title=\"3.1.2、搭建开发环境\"></a>3.1.2、搭建开发环境</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.14.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.8<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\"><a href=\"#3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\" class=\"headerlink\" title=\"3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\"></a>3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）</h3><ol>\n<li>创建目标对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;userService&quot;</span> class=<span class=\"string\">&quot;service.UserServiceImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>额外功能</li>\n</ol>\n<p>MethodBeforeAdvice接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Before</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodBeforeAdvice</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数： 目标方法 目标方法参数 目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(Method method, Object[] objects, Object o)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--method before advice log--&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;before&quot;</span> class=<span class=\"string\">&quot;dynamic.Before&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>定义切入点</li>\n</ol>\n<p> 切入点：额外功能加入的位置(方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>组装（2 3步整合）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">    &lt;!--组装：目的把切入点和额外功能进行整合--&gt;</span><br><span class=\"line\">    &lt;aop:advisor advice-ref=<span class=\"string\">&quot;before&quot;</span> pointcut-ref=<span class=\"string\">&quot;pc&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//目的：获得spring工厂创建的动态代理对象并进行调用</span></span><br><span class=\"line\">    <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. spring的工厂通过原始对象的id值获得的是代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> (UserService)ctx.getBean(<span class=\"string\">&quot;userService&quot;</span>);</span><br><span class=\"line\">    userService.login();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-4、思考\"><a href=\"#3-1-4、思考\" class=\"headerlink\" title=\"3.1.4、思考\"></a>3.1.4、思考</h3><ol>\n<li>spring创建的动态代理类在哪里？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失</span><br><span class=\"line\"></span><br><span class=\"line\">动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>动态字节码技术？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-5、额外功能详解\"><a href=\"#3-1-5、额外功能详解\" class=\"headerlink\" title=\"3.1.5、额外功能详解\"></a>3.1.5、额外功能详解</h3><p>MethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前<br>MethodInterceptor 前，后，抛出异常 都可以运行<br>所以我们实战中用到的更多的还是MethodInterceptor </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Around</span>  <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//methodInvocation : 额外功能所增加给的那个原始方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(MethodInvocation methodInvocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之前额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//原始方法执行</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">proceed</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            proceed = methodInvocation.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;--目标方法抛出异常额外功能--&quot;</span>);</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之后额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proceed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）</p>\n</blockquote>\n<h3 id=\"3-1-6、切入点详解\"><a href=\"#3-1-6、切入点详解\" class=\"headerlink\" title=\"3.1.6、切入点详解\"></a>3.1.6、切入点详解</h3><h4 id=\"3-1-6-1、切入点表达式\"><a href=\"#3-1-6-1、切入点表达式\" class=\"headerlink\" title=\"3.1.6.1、切入点表达式\"></a>3.1.6.1、切入点表达式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">execution() ：切入点函数</span><br><span class=\"line\">* *(..)：切入点表达式</span><br><span class=\"line\"></span><br><span class=\"line\">第一个* ：修饰符 返回值</span><br><span class=\"line\">第二个* ：方法名(包+类+方法 or 直接方法)</span><br><span class=\"line\">()：参数表 </span><br><span class=\"line\">..：对于参数没有要求</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有两个字符串类型的参数作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,String)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有第一个参数必须为String作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka.UserServiceImpl.login(..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka..*.*()</span><br><span class=\"line\">    </span><br><span class=\"line\">    其中的..*代表当前包及其子包</span><br><span class=\"line\">    如果是.*代表当前包</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任意包下UserServiceImpl类作为切入点（类切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* *..UserServiceImpl.*(..)</span><br><span class=\"line\">  </span><br><span class=\"line\">    其中的*..代表层级为<span class=\"number\">1</span>级或多级的包</span><br><span class=\"line\">    如果是*.UserService 只能查找第一层级下的类</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-2、切入点函数\"><a href=\"#3-1-6-2、切入点函数\" class=\"headerlink\" title=\"3.1.6.2、切入点函数\"></a>3.1.6.2、切入点函数</h4><p>切入点函数：用于执行切入点表达式</p>\n<ol>\n<li>execution</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：最为重要的切入点函数，功能最全</span><br><span class=\"line\">\t  执行方法切入点表达式 类切入点表达式 包切入点表达式</span><br><span class=\"line\">execution执行切入点表达式，书写麻烦</span><br><span class=\"line\">注意：其他的切入点函数简化execution书写复杂度，功能上完全一致</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>args</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于函数（方法）参数的匹配</span><br><span class=\"line\">方法参数必须是两个字符串类型的参数</span><br><span class=\"line\"></span><br><span class=\"line\">args(String,String)</span><br><span class=\"line\">等同于 execution(* *(String,String))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>within</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于进行类，包切入点表达式的匹配</span><br><span class=\"line\"></span><br><span class=\"line\">within(*..UserServiceImpl)</span><br><span class=\"line\">等同于execution(* *..UserServiceImpl.*(..))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>@annotation</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：<span class=\"meta\">@annotation</span>表示标注了某个注解的所有方法</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修饰的对象范围</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"comment\">// 注解生命周期  SOURCE &lt; CLASS &lt; RUNTIME</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Log &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Log</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;@annotation(bean.Log)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-3、切入点函数的逻辑运算\"><a href=\"#3-1-6-3、切入点函数的逻辑运算\" class=\"headerlink\" title=\"3.1.6.3、切入点函数的逻辑运算\"></a>3.1.6.3、切入点函数的逻辑运算</h4><ol>\n<li>and与操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：login 同时 参数 两个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) and <span class=\"title function_\">args</span><span class=\"params\">(String,String)</span></span><br><span class=\"line\">等同于 execution(* login(String,String))    </span><br><span class=\"line\">    </span><br><span class=\"line\">注意：与操作不能用于同种类型的切入点函数</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>or或操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：register方法和login方法作为切入点</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) or <span class=\"title function_\">execution</span><span class=\"params\">(* register(..)</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2、AOP编程\"><a href=\"#3-2、AOP编程\" class=\"headerlink\" title=\"3.2、AOP编程\"></a>3.2、AOP编程</h2><h3 id=\"3-2-1、基本概念\"><a href=\"#3-2-1、基本概念\" class=\"headerlink\" title=\"3.2.1、基本概念\"></a>3.2.1、基本概念</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> AOP：面向切面编程</span><br><span class=\"line\">   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> OOP：面向对象编程</span><br><span class=\"line\">   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"number\">3.</span> POP：面向过程编程</span><br><span class=\"line\">   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>12.2、切面名词解释</p>\n<blockquote>\n<p>切面 &#x3D; 切入点 + 额外功能</p>\n</blockquote>\n<p>多个额外功能相同的方法所代表的点连起来就是一个面</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png\" alt=\"aop切面\"></p>\n<h3 id=\"3-2-2、AOP底层实现原理\"><a href=\"#3-2-2、AOP底层实现原理\" class=\"headerlink\" title=\"3.2.2、AOP底层实现原理\"></a>3.2.2、AOP底层实现原理</h3><h4 id=\"3-2-2-1、核心问题\"><a href=\"#3-2-2-1、核心问题\" class=\"headerlink\" title=\"3.2.2.1、核心问题\"></a>3.2.2.1、核心问题</h4><blockquote>\n<ol>\n<li>aop如何创建动态代理类（动态字节码技术）</li>\n<li>如何实现通过原始对象的id值，获得的是代理对象</li>\n</ol>\n</blockquote>\n<h3 id=\"3-2-3、动态代理类的创建\"><a href=\"#3-2-3、动态代理类的创建\" class=\"headerlink\" title=\"3.2.3、动态代理类的创建\"></a>3.2.3、动态代理类的创建</h3><h4 id=\"3-2-3-1、JDK动态代理\"><a href=\"#3-2-3-1、JDK动态代理\" class=\"headerlink\" title=\"3.2.3.1、JDK动态代理\"></a>3.2.3.1、JDK动态代理</h4><ul>\n<li><p>Proxy.newProxyInstancec：</p>\n</li>\n<li><p>编码实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestJDKProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以</span></span><br><span class=\"line\"><span class=\"comment\">     2. JDK8.x 前必须加 final</span></span><br><span class=\"line\"><span class=\"comment\">     final UserService userService = new UserServiceImpl();</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. JDK 动态代理</span></span><br><span class=\"line\">        <span class=\"type\">InvocationHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;---- proxy log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 原始方法运行</span></span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) Proxy.</span><br><span class=\"line\">                newProxyInstance(TestJDKProxy.class.getClassLoader(),</span><br><span class=\"line\">                                userService.getClass().getInterfaces(),</span><br><span class=\"line\">                                handler);</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-2、CGLib动态代理\"><a href=\"#3-2-3-2、CGLib动态代理\" class=\"headerlink\" title=\"3.2.3.2、CGLib动态代理\"></a>3.2.3.2、CGLib动态代理</h4><ul>\n<li>CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）</li>\n</ul>\n<blockquote>\n<p>在原始类没有实现接口的情况下cglib是一种很好的实现方式</p>\n</blockquote>\n<ul>\n<li>cglib原理</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCglib</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         2. 通过 cglib 方式创建动态代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setClassLoader()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setSuperClass()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib)</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.createProxy() ---&gt; 创建代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setClassLoader(TestCglib.class.getClassLoader());</span><br><span class=\"line\">        enhancer.setSuperclass(userService.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">MethodInterceptor</span> <span class=\"variable\">interceptor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MethodInterceptor</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;--- cglib log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args); <span class=\"comment\">// 执行原始方法</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setCallback(interceptor);</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) enhancer.create();</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 总结：</p>\n<ol>\n<li>JDK 动态代理<br>Proxy.newProxyInstance：通过接口创建代理的实现类</li>\n<li>Cglib 动态代理<br>Enhancer：通过继承父类创建的代理类</li>\n</ol>\n<h3 id=\"3-2-4、基于注解的AOP编程\"><a href=\"#3-2-4、基于注解的AOP编程\" class=\"headerlink\" title=\"3.2.4、基于注解的AOP编程\"></a>3.2.4、基于注解的AOP编程</h3><h4 id=\"3-2-4-1、开发步骤\"><a href=\"#3-2-4-1、开发步骤\" class=\"headerlink\" title=\"3.2.4.1、开发步骤\"></a>3.2.4.1、开发步骤</h4><ol>\n<li>原始功能</li>\n</ol>\n<p>包含原始功能和实现类等</p>\n<ol start=\"2\">\n<li>额外功能+切入点+组装切面</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">        public class MyAround implements MethodInterceptor &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            public Object invoke(MethodInvocation invocation) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                Object ret = invocation.invoke();</span></span><br><span class=\"line\"><span class=\"comment\">                return ret;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;bean id=&quot;around&quot; class=&quot;com.yusael.dynamic.Around&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)))&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:advisor advice-ref=&quot;around&quot; pointcut-ref=&quot;pc&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;/aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        切面:</span></span><br><span class=\"line\"><span class=\"comment\">            1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">            2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">            3. 组装切面</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;around&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.MyAspect&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--告知 Spring 基于注解进行 AOP 编程--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>切入点复用</li>\n</ol>\n<p>切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。<br>    通过这种方式定义切入点表达式，后续更加有利于切入点复用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myPoincut</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around1</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect transaction ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-4-2、动态代理创建方式\"><a href=\"#3-2-4-2、动态代理创建方式\" class=\"headerlink\" title=\"3.2.4.2、动态代理创建方式\"></a>3.2.4.2、动态代理创建方式</h4><p>AOP 底层实现 2 种代理创建方式：</p>\n<ol>\n<li>JDK：通过 <strong>实现接口，做新的实现类</strong> 创建代理对象</li>\n<li>Cglib：通过 <strong>继承父类，做新的子类</strong> 创建代理对象</li>\n</ol>\n<p><strong>默认情况 AOP 编程 底层应用 JDK动态代理创建方式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 动态代理模式切换为cglib --&gt;</span><br><span class=\"line\">&lt;aop:aspectj-autoproxy proxy-target-class=<span class=\"string\">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、spring-持久层\"><a href=\"#4、spring-持久层\" class=\"headerlink\" title=\"4、spring 持久层\"></a>4、spring 持久层</h1><h2 id=\"4-1、spring与mybatis整合\"><a href=\"#4-1、spring与mybatis整合\" class=\"headerlink\" title=\"4.1、spring与mybatis整合\"></a>4.1、spring与mybatis整合</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>druid<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.43<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>spring配置文件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--连接池--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1234&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;typeAliasesPackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.entity&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapperLocations&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;scanner&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sqlSessionFactoryBeanName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;basePackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.dao&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">UserDAO</span> <span class=\"variable\">userDAO</span> <span class=\"operator\">=</span> (UserDAO) ctx.getBean(<span class=\"string\">&quot;userDAO&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">    user.setName(<span class=\"string\">&quot;xiaojr&quot;</span>);</span><br><span class=\"line\">    user.setPassword(<span class=\"string\">&quot;999999&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    userDAO.save(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2、关于事务提交的疑问\"><a href=\"#4-2、关于事务提交的疑问\" class=\"headerlink\" title=\"4.2、关于事务提交的疑问\"></a>4.2、关于事务提交的疑问</h2><p><strong>问题</strong>：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？</p>\n<blockquote>\n<p>Mybatis 提供的连接池对象 —&gt; 创建 Connection<br>Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。<br>Druid（C3P0、DBCP）作为连接池 —&gt; 创建 Connection<br>Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。</p>\n</blockquote>\n<p><strong>答案</strong>：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。</p>\n<p><strong>注意</strong>：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题</p>\n<h2 id=\"4-3、spring事务处理\"><a href=\"#4-3、spring事务处理\" class=\"headerlink\" title=\"4.3、spring事务处理\"></a>4.3、spring事务处理</h2><h3 id=\"4-3-1、事务基本概念\"><a href=\"#4-3-1、事务基本概念\" class=\"headerlink\" title=\"4.3.1、事务基本概念\"></a>4.3.1、事务基本概念</h3><ol>\n<li>什么是事务？</li>\n</ol>\n<p>事务时保证业务操作完整性的一种<strong>数据库机制</strong></p>\n<ol start=\"2\">\n<li>事务的四大特性？</li>\n</ol>\n<p>A 原子性\tC 一致性 I 隔离性\tD 持久性</p>\n<ol start=\"3\">\n<li>如何控制事务？</li>\n</ol>\n<p><strong>JDBC：</strong><br>Connection.setAutoCommit(false);<br>Connection.commit();<br>Connection.rollback();<br><strong>Mybatis：</strong><br>Mybatis 自动开启事务<br>sqlSession.commit();，底层还是调用的 Connection<br>sqlSession.rollback();，底层还是调用的 Connection</p>\n<blockquote>\n<p>结论：控制事务的底层，都是通过 Connection 对象完成的</p>\n</blockquote>\n<h3 id=\"4-3-2、spring控制事务的开发\"><a href=\"#4-3-2、spring控制事务的开发\" class=\"headerlink\" title=\"4.3.2、spring控制事务的开发\"></a>4.3.2、spring控制事务的开发</h3><p>spring是通过aop的方式进行事务开发<br><strong>增强功能：</strong>原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法</p>\n<p><strong>切入点：</strong>@Transactional （1）作用于类上（2）作用域方法。&lt;</p>\n<p><strong>组装切面：</strong>tx:annotation-driven transaction-manager&#x3D;”dataSourceTransactionManager”&#x2F;&gt; 自动扫描所有的@Transactional注解</p>\n<ol>\n<li>搭建开发环境</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-tx<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-3、事务的属性\"><a href=\"#4-3-3、事务的属性\" class=\"headerlink\" title=\"4.3.3、事务的属性\"></a>4.3.3、事务的属性</h3><p>5个：隔离属性，传播属性，只读属性，超时属性，异常属性</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-3-1、隔离属性\"><a href=\"#4-3-3-1、隔离属性\" class=\"headerlink\" title=\"4.3.3.1、隔离属性\"></a>4.3.3.1、隔离属性</h4><h5 id=\"4-3-3-1-1、并发问题-解决方案？\"><a href=\"#4-3-3-1-1、并发问题-解决方案？\" class=\"headerlink\" title=\"4.3.3.1.1、并发问题&amp;解决方案？\"></a>4.3.3.1.1、并发问题&amp;解决方案？</h5><p><strong>（1）脏读</strong>：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：读已提交</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）不可重复读</strong>：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了<br>注意：1.不是脏读 2.在一个事务中</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：可重复读</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.REPEATABLE_READ)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>本质：一把行锁（对数据库表的某一行加锁）</p>\n</blockquote>\n<p><strong>（3）幻读</strong>：一个事务中，多次对<strong>整表</strong>进行<strong>查询统计</strong>，但是<strong>结果不一样</strong>，会在本事务中产生数据不一致的问题</p>\n<blockquote>\n<p>查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：序列化</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.SERIALIZABLE)</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本质：表锁（对数据库某个表加锁）</p>\n</blockquote>\n<h5 id=\"4-3-3-1-2、安全与效率对比：\"><a href=\"#4-3-3-1-2、安全与效率对比：\" class=\"headerlink\" title=\"4.3.3.1.2、安全与效率对比：\"></a>4.3.3.1.2、安全与效率对比：</h5><ul>\n<li>并发安全：SERIALIZABLE &gt; READ_ONLY &gt; READ_COMMITTED</li>\n<li>运行效率：READ_COMMITTED &gt; READ_ONLY &gt; SERIALIZABLE</li>\n</ul>\n<h5 id=\"4-3-3-1-3、数据库默认隔离属性\"><a href=\"#4-3-3-1-3、数据库默认隔离属性\" class=\"headerlink\" title=\"4.3.3.1.3、数据库默认隔离属性\"></a>4.3.3.1.3、数据库默认隔离属性</h5><p>mysql：可重复读（REPEATABLE_READ）<br>Oracle：读已提交（READ_COMMITTED）</p>\n<h4 id=\"4-3-3-2、传播属性\"><a href=\"#4-3-3-2、传播属性\" class=\"headerlink\" title=\"4.3.3.2、传播属性\"></a>4.3.3.2、传播属性</h4><h5 id=\"4-3-3-2-1、基本概念\"><a href=\"#4-3-3-2-1、基本概念\" class=\"headerlink\" title=\"4.3.3.2.1、基本概念\"></a>4.3.3.2.1、基本概念</h5><p>传播属性：描述了事务解决 嵌套 问题 的特征<br><strong>事务的嵌套</strong>：指的是一个大的事务中，包含了若干个小的事务。<br><strong>事务嵌套产生的问题</strong>： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）</p>\n<h5 id=\"4-3-3-2-2、传播属性的值及用法\"><a href=\"#4-3-3-2-2、传播属性的值及用法\" class=\"headerlink\" title=\"4.3.3.2.2、传播属性的值及用法\"></a>4.3.3.2.2、传播属性的值及用法</h5><table>\n<thead>\n<tr>\n<th>传播属性的值</th>\n<th>外部不存在事务</th>\n<th>外部存在事务</th>\n<th>用法</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>REQUIRED</td>\n<td>开启新的事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRED)</td>\n<td>增、删、改方法（保证了肯定会有事务的存在）</td>\n</tr>\n<tr>\n<td>REQUIRES_NEW</td>\n<td>开启新的事务</td>\n<td>挂起外部事务，创建新的事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</td>\n<td>日志记录方法中（保证外部事务异常时能正常的记录日志）</td>\n</tr>\n<tr>\n<td>SUPPORTS</td>\n<td>不开启事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.SUPPORTS)</td>\n<td>查询方法</td>\n</tr>\n<tr>\n<td>NOT_SUPPORTED</td>\n<td>不开启事务</td>\n<td>挂起外部事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>NEVER</td>\n<td>不开启事务</td>\n<td>抛出异常</td>\n<td>@Transactional(propagation &#x3D; Propagation.NEVER)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>MANDATORY（强制的）</td>\n<td>抛出异常</td>\n<td>融合到外部事物中</td>\n<td>@Transactional(propagation &#x3D; Propagation.MANDATORY)</td>\n<td>极其不常用</td>\n</tr>\n</tbody></table>\n<p>Spring 中<strong>传播属性的默认值</strong>是：REQUIRED</p>\n<p>推荐传播属性的使用方式：</p>\n<ul>\n<li>增删改 方法：使用默认值 REQUIRED</li>\n<li>查询 方法：显示指定传播属性的值为 SUPPORTS</li>\n</ul>\n<h4 id=\"4-2-2-3、只读属性\"><a href=\"#4-2-2-3、只读属性\" class=\"headerlink\" title=\"4.2.2.3、只读属性\"></a>4.2.2.3、只读属性</h4><p>针对于 <strong>只进行查询操作的业务方法</strong>，可以加入只读属性，提高运行效率。<br>默认值：false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-2-4、超时属性\"><a href=\"#4-2-2-4、超时属性\" class=\"headerlink\" title=\"4.2.2.4、超时属性\"></a>4.2.2.4、超时属性</h4><p>指定了事务等待的最长时间。</p>\n<ol>\n<li>为什么事务会进行等待？</li>\n</ol>\n<p>当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。</p>\n<ol start=\"2\">\n<li>等待时间，单位是 秒</li>\n<li>如何使用：@Transactional(timeout &#x3D; 2)</li>\n<li>超时属性的默认值：-1</li>\n</ol>\n<p>-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）</p>\n<h4 id=\"4-2-2-5、异常属性\"><a href=\"#4-2-2-5、异常属性\" class=\"headerlink\" title=\"4.2.2.5、异常属性\"></a>4.2.2.5、异常属性</h4><p>Spring 事务处理过程中：</p>\n<ul>\n<li>默认对于 RuntimeException 及其子类，采用 <strong>回滚</strong> 的策略。</li>\n<li>默认对于 对于其他类型的异常，采用 <strong>提交</strong> 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"5、spring-mvc\"><a href=\"#5、spring-mvc\" class=\"headerlink\" title=\"5、spring mvc\"></a>5、spring mvc</h1><p>spring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 </p>\n<h2 id=\"5-1、父子容器关系\"><a href=\"#5-1、父子容器关系\" class=\"headerlink\" title=\"5.1、父子容器关系\"></a>5.1、父子容器关系</h2><ol>\n<li>Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）</li>\n<li>Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等</li>\n<li>Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）</li>\n<li>调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止</li>\n</ol>\n<h2 id=\"5-2、为什么要划分父子容器\"><a href=\"#5-2、为什么要划分父子容器\" class=\"headerlink\" title=\"5.2、为什么要划分父子容器\"></a>5.2、为什么要划分父子容器</h2><ol>\n<li>分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）</li>\n<li>性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能</li>\n</ol>\n<h2 id=\"5-3、springBoot舍弃了父子容器的概念\"><a href=\"#5-3、springBoot舍弃了父子容器的概念\" class=\"headerlink\" title=\"5.3、springBoot舍弃了父子容器的概念\"></a>5.3、springBoot舍弃了父子容器的概念</h2><p>SpringBoot只有一个容器。<br>Spring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署</p>\n<h1 id=\"6、注解编程\"><a href=\"#6、注解编程\" class=\"headerlink\" title=\"6、注解编程\"></a>6、注解编程</h1><h2 id=\"6-1、spring基础注解（spring2-X）\"><a href=\"#6-1、spring基础注解（spring2-X）\" class=\"headerlink\" title=\"6.1、spring基础注解（spring2.X）\"></a>6.1、spring基础注解（spring2.X）</h2><h3 id=\"6-1-1、对象创建相关\"><a href=\"#6-1-1、对象创建相关\" class=\"headerlink\" title=\"6.1.1、对象创建相关\"></a>6.1.1、对象创建相关</h3><h4 id=\"6-1-1-1、-Component\"><a href=\"#6-1-1-1、-Component\" class=\"headerlink\" title=\"6.1.1.1、@Component\"></a>6.1.1.1、@Component</h4><ol>\n<li>作用：替换原有Spring配置文件中的 <bean> 标签</li>\n</ol>\n<ul>\n<li>id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO –&gt; userDAO）</li>\n<li>class 属性：通过反射获得的 class 的内容</li>\n</ul>\n<ol start=\"2\">\n<li>细节：如何显式指定工厂创建对象的 id 值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;u&quot;)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-2、-Repository、-Service、-Contoller\"><a href=\"#6-1-1-2、-Repository、-Service、-Contoller\" class=\"headerlink\" title=\"6.1.1.2、@Repository、@Service、@Contoller\"></a>6.1.1.2、@Repository、@Service、@Contoller</h4><p>@Repository、@Service、@Controller 都是 @Component 的 <strong>衍生注解</strong>。<br>本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；<br>它们的存在是为了：<strong>更加准确的表达一个类型的作用</strong></p>\n<h4 id=\"6-1-1-3、-Scope\"><a href=\"#6-1-1-3、-Scope\" class=\"headerlink\" title=\"6.1.1.3、@Scope\"></a>6.1.1.3、@Scope</h4><p>作用：控制简单对象创建次数<br>注意：不添加 @Scope，Spring 提供默认值 singleton</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建单例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;singleton&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建多例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-4、-Lazy\"><a href=\"#6-1-1-4、-Lazy\" class=\"headerlink\" title=\"6.1.1.4、@Lazy\"></a>6.1.1.4、@Lazy</h4><p>作用：延迟创建单实例对象<br>注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Account</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Account</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Account.Account&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-5、-PostConstruct、-PreDestroy\"><a href=\"#6-1-1-5、-PostConstruct、-PreDestroy\" class=\"headerlink\" title=\"6.1.1.5、@PostConstruct、@PreDestroy\"></a>6.1.1.5、@PostConstruct、@PreDestroy</h4><p>初始化相关方法： @PostConstruct</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InitializingBean</span><br><span class=\"line\">&lt;bean init-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>销毁方法：@PreDestory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableBean</span><br><span class=\"line\">&lt;bean destory-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-1-2、注入相关注解\"><a href=\"#6-1-2、注入相关注解\" class=\"headerlink\" title=\"6.1.2、注入相关注解\"></a>6.1.2、注入相关注解</h3><h4 id=\"6-1-2-1、-Autowired（用户自定义类型）\"><a href=\"#6-1-2-1、-Autowired（用户自定义类型）\" class=\"headerlink\" title=\"6.1.2.1、@Autowired（用户自定义类型）\"></a>6.1.2.1、@Autowired（用户自定义类型）</h4><ol>\n<li>@Autowired 注解 <strong>基于类型进行注入</strong> [推荐]：</li>\n</ol>\n<ul>\n<li>注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>@Autowired、@Qualifier 注解联合实现 <strong>基于名字进行注入</strong> [了解]</li>\n</ol>\n<ul>\n<li>注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;userDAOImpl&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@Autowired 注解放置位置：</li>\n</ol>\n<ul>\n<li>放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）</li>\n<li><strong>直接放置在成员变量上</strong>，Spring 通过反射直接对成员变量进行赋值</li>\n</ul>\n<ol start=\"4\">\n<li>JSR提供的@Resource注解</li>\n</ol>\n<blockquote>\n<p>JavaEE 规范中类似功能的注解：</p>\n<ul>\n<li>JSR250 提供的 @Resource(name&#x3D;”xxx”) <strong>基于名字进行注入</strong><br>等价于 @Autowired 与 @Qualifier 联合实现的效果<br>注意：@Resource 注解如果名字没有配对成功，会继续 <strong>按照类型进行注入</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"6-1-2-2、-value、-PropertySource（JDK-类型）\"><a href=\"#6-1-2-2、-value、-PropertySource（JDK-类型）\" class=\"headerlink\" title=\"6.1.2.2、@value、@PropertySource（JDK 类型）\"></a>6.1.2.2、@value、@PropertySource（JDK 类型）</h4><ol>\n<li>@value 注解的基本使用（xml配置）：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 设置xxx.<span class=\"type\">properties</span> </span><br><span class=\"line\">   <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">   name = suns</span><br><span class=\"line\"><span class=\"number\">2.</span> Spring的工厂读取这个配置文件 </span><br><span class=\"line\">   &lt;context:property-placeholder location=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br><span class=\"line\"><span class=\"number\">3.</span> 代码中进行注入</span><br><span class=\"line\">   属性 <span class=\"meta\">@Value(&quot;$&#123;key&#125;&quot;)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 @PropertySource 取代 xml配置</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource(&quot;classpath:/init.properties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;id&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">\t\tcustomer.setId(id);</span><br><span class=\"line\">\t\tcustomer.setName(name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@value 注解使用细节：</li>\n</ol>\n<ul>\n<li>@Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null</li>\n<li>@Value 注解 + Properties 这种方式，不能注入集合类型<br>Spring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"6-2、spring的高级注解（spring3-X及以上）\"><a href=\"#6-2、spring的高级注解（spring3-X及以上）\" class=\"headerlink\" title=\"6.2、spring的高级注解（spring3.X及以上）\"></a>6.2、spring的高级注解（spring3.X及以上）</h2><h3 id=\"6-2-1、-Configuration（配置bean）\"><a href=\"#6-2-1、-Configuration（配置bean）\" class=\"headerlink\" title=\"6.2.1、@Configuration（配置bean）\"></a>6.2.1、@Configuration（配置bean）</h3><ol>\n<li>Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件</li>\n<li>使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法1: 指定配置bean的Class</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\">方法2: 指定配置bean所在的路径(某个包及其子包)</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.yusael&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2、-Bean\"><a href=\"#6-2-2、-Bean\" class=\"headerlink\" title=\"6.2.2、@Bean\"></a>6.2.2、@Bean</h3><p>@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 &lt;bean 标签</p>\n<blockquote>\n<p><strong>简单对象</strong>：直接能够通过 new 方式创建的对象</p>\n<ul>\n<li>User、UserService、UserDAO</li>\n</ul>\n</blockquote>\n<p><strong>复杂对象</strong>：不能通过 new 的方式直接创建的对象</p>\n<blockquote>\n<ul>\n<li>Connection、SqlSessionFactory</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 简单对象</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 复杂对象</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Connection <span class=\"title function_\">conn1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ConnectionFactoryBean</span> <span class=\"variable\">factoryBean</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactoryBean</span>();</span><br><span class=\"line\">      conn = factoryBean.getObject();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-3、-ComponentScan\"><a href=\"#6-2-3、-ComponentScan\" class=\"headerlink\" title=\"6.2.3、@ComponentScan\"></a>6.2.3、@ComponentScan</h3><p>@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <a href=\"context:component-scan\">context:component-scan</a> 标签<br>目的：进行相关注解的扫描（@Component、@Value、@Autowired …)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">               excludeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION, value=&#123;Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = &quot;*..User1&quot;)&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig2</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"abbrlink":0,"_content":"\n\n<table>\n    <tbody>\n    <tr>\n        <th>朝代</th>\n        <th>存在时间</th>\n        <th>都城（今）</th>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">变量引用</td>\n        <td>super</td>\n        <td>父类,超类</td>\n    </tr>\n    <tr>\n        <td>this</td>\n        <td>本类</td>\n    </tr>\n    <tr>\n        <td>void</td>\n        <td>无返回值</td>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">保留关键字</td>\n        <td>goto</td>\n        <td>是关键字，但不能使用</td>\n    </tr>\n    <tr>\n        <td>const</td>\n        <td>是关键字，但不能使用</td>\n    </tr>\n    <tr>\n        <td>null</td>\n        <td>空</td>\n    </tr>\n    </tbody>\n</table>\n\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>\n\t\t\t\t<strong>朝代</strong>\n\t\t\t</th>\n\t\t\t<th></th>\n\t\t\t<th>\n\t\t\t\t<strong>存在时间</strong>\n\t\t\t</th>\n\t\t\t<th></th>\n\t\t\t<th>\n\t\t\t\t<strong>都城（今）</strong>\n\t\t\t</th>\n\t\t\t<th>\n\t\t\t\t<strong>君主</strong>\n\t\t\t</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>“三皇五帝”说</td>\n\t\t\t<td></td>\n\t\t\t<td>前170万年-前2070年</td>\n\t\t\t<td></td>\n\t\t\t<td>无文字记载</td>\n\t\t\t<td>无文字记载</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>夏朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前2070年-前1600年（470年）</td>\n\t\t\t<td></td>\n\t\t\t<td>河南洛阳</td>\n\t\t\t<td>禹 启 太康 仲康 相  少康 杼 槐 芒 泄 不降 扃 廑 孔甲 皋 发 桀（\n\t\t\t\t<strong>17位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>商朝（殷商）</td>\n\t\t\t<td></td>\n\t\t\t<td>前1600年-前1046年（554年）</td>\n\t\t\t<td></td>\n\t\t\t<td>商丘 洛阳 郑州  安阳</td>\n\t\t\t<td>汤 太丁 外丙 中壬 太甲 沃丁 太庚 小甲 雍己 太戊 中丁 外壬 河亶甲 祖乙 祖辛 沃甲 祖丁 南庚 阳甲 盘庚 小辛 小乙 武丁 祖庚 祖甲 廪辛 康丁 武乙 文丁 帝乙 帝辛（纣）（\n\t\t\t\t<strong>30位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西周王朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前1046年-前771年（275年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安（镐京） 洛阳</td>\n\t\t\t<td>（周武王）姬发 姬诵 姬钊 姬瑕 姬满 姬繄扈 姬囏 姬辟方 姬燮 姬胡 周定公 姬静 （周幽王）姬宫湦（\n\t\t\t\t<strong>13位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td  rowspan=\"2\">东周王朝</td>\n\t\t\t<td>春秋</td>\n\t\t\t<td  rowspan=\"2\">前770年-前256年（515年）</td>\n\t\t\t<td>前770年-前476年（295年）</td>\n\t\t\t<td rowspan=\"2\">洛阳</td>\n\t\t\t<td rowspan=\"2\">（周平王）姬宜臼 姬林 姬佗 姬胡齐 姬阆 姬郑 姬壬臣 姬班 姬瑜 姬夷 姬泄心 姬贵 姬猛 姬匄 姬仁 姬介 姬去疾 姬叔 姬嵬 姬午 姬骄 姬喜 姬扁 姬定 （周赧王）姬延（\n\t\t\t\t<strong>25位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>战国</td>\n\t\t\t<td>前475年-前221年（254年）</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>秦朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前221年-前206年（16年）</td>\n\t\t\t<td></td>\n\t\t\t<td>咸阳 西安</td>\n\t\t\t<td>秦始皇 胡亥 子婴（\n\t\t\t\t<strong>3位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西楚</td>\n\t\t\t<td></td>\n\t\t\t<td>前206年-前202年（5年）</td>\n\t\t\t<td></td>\n\t\t\t<td>徐州</td>\n\t\t\t<td>西楚霸王项羽</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西汉</td>\n\t\t\t<td></td>\n\t\t\t<td>前202—公元8年11月（210年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>（汉高祖）刘邦 刘盈 前少帝 刘弘 刘恒 刘启 刘彻 刘弗陵 刘贺 刘询 刘奭 刘骜 刘欣 刘衎 刘婴（\n\t\t\t\t<strong>15位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>新朝</td>\n\t\t\t<td></td>\n\t\t\t<td>公元8年12月-23年10月（16年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>建兴帝王莽</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>玄汉</td>\n\t\t\t<td></td>\n\t\t\t<td>23年10月-25年（2年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>更始帝刘玄</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>东汉</td>\n\t\t\t<td></td>\n\t\t\t<td>25年-220年（195年）</td>\n\t\t\t<td></td>\n\t\t\t<td>洛阳</td>\n\t\t\t<td>光武帝刘秀 刘庄 \n\t\t\t\t刘炟 刘肇 刘隆 刘祜 刘懿 刘保  刘炳 刘缵 刘志 刘宏 刘辩 刘协（\n\t\t\t\t<strong>14位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"3\">三国</td>\n\t\t\t<td>魏</td>\n\t\t\t<td rowspan=\"3\">220年－280年（60年）</td>\n\t\t\t<td>220年-265年（45年）</td>\n\t\t\t<td>洛阳</td>\n\t\t\t<td>魏文帝曹丕  曹叡  曹芳 曹髦 曹奂（\n\t\t\t\t<strong>5位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>蜀汉</td>\n\t\t\t<td>221年-263年（42年）</td>\n\t\t\t<td>成都</td>\n\t\t\t<td>汉昭烈帝刘备 汉怀帝刘禅 （\n\t\t\t\t<strong>2位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>吴</td>\n\t\t\t<td>222年-280年（58年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>吴大帝孙权 孙亮 孙休 孙皓（\n\t\t\t\t<strong>4位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"2\">晋朝</td>\n\t\t\t<td >西晋</td>\n\t\t\t<td rowspan=\"2\">265—420年（155年）</td>\n\t\t\t<td>265年-316年（51年）</td>\n\t\t\t<td>洛阳 西安</td>\n\t\t\t<td>晋武帝 司马炎 司马衷 司马炽 司马邺 （\n\t\t\t\t<strong>4位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>东晋</td>\n\t\t\t<td>317年-420年（103年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>晋元帝司马睿 司马绍 司马衍 司马岳 司马聃 司马丕 司马奕 司马昱 司马曜 司马德宗 司马德文（\n\t\t\t\t<strong>11位</strong>）\n\t\t\t</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>十六国</td>\n\t\t\t<td>前赵（汉赵）   成汉 前凉    后赵 前燕    前秦 后秦    后燕  西秦   后凉  南凉   南燕  西凉   胡夏 北燕    北凉 冉魏    西燕      西蜀（后蜀）</td>\n\t\t\t<td >304年-439年（135年）</td>\n\t\t\t<td></td>\n\t\t\t<td>（多政权存在）</td>\n\t\t\t<td>（多政权存在）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>南北朝</td>\n\t\t\t<td>南朝·宋</td>\n\t\t\t<td>420年—589年（169年）</td>\n\t\t\t<td>420年-479年（59年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>刘裕</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·齐</td>\n\t\t\t<td></td>\n\t\t\t<td>479年-502年（23年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>萧道成</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·梁</td>\n\t\t\t<td></td>\n\t\t\t<td>502年-557年（55年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>萧衍</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·陈</td>\n\t\t\t<td></td>\n\t\t\t<td>557年-589年（32年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>陈霸先</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北魏</td>\n\t\t\t<td></td>\n\t\t\t<td>386年-534年（148年）</td>\n\t\t\t<td>大同 洛阳</td>\n\t\t\t<td>拓跋珪</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·东魏</td>\n\t\t\t<td></td>\n\t\t\t<td>534年-550年（16年）</td>\n\t\t\t<td>安阳</td>\n\t\t\t<td>元善见</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·西魏</td>\n\t\t\t<td></td>\n\t\t\t<td>535年-557年（22年）</td>\n\t\t\t<td>西安</td>\n\t\t\t<td>元宝炬</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北齐</td>\n\t\t\t<td></td>\n\t\t\t<td>550年-577年（27年）</td>\n\t\t\t<td>安阳</td>\n\t\t\t<td>高洋</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北周</td>\n\t\t\t<td></td>\n\t\t\t<td>557年-581年（24年）</td>\n\t\t\t<td>西安</td>\n\t\t\t<td>宇文觉</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>隋朝</td>\n\t\t\t<td></td>\n\t\t\t<td>581年-618年（38年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安 洛阳</td>\n\t\t\t<td>隋文帝杨坚 杨广 杨侑 杨浩 杨昭 杨侗（\n\t\t\t\t<strong>6位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>唐朝</td>\n\t\t\t<td></td>\n\t\t\t<td>618年-907年（289年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安 洛阳</td>\n\t\t\t<td>李渊 李世民 李治 李显 李旦 武则天 李隆基 李亨 李豫 李适 李诵 李纯 李恒 李昂 李炎 李忱 李漼 李儇 李晔 李祝（\n\t\t\t\t<strong>21位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>五代十国</td>\n\t\t\t<td>后梁 后唐 后晋 后汉 后周 前蜀 后蜀 杨吴 南唐 吴越 闽国 马楚 南汉 南平 北汉</td>\n\t\t\t<td>891年-979年（89年）</td>\n\t\t\t<td></td>\n\t\t\t<td>开封 洛阳</td>\n\t\t\t<td>（多政权存在）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>宋朝</td>\n\t\t\t<td >北宋</td>\n\t\t\t<td rowspan=\"2\">960年-1279年（320年）</td>\n\t\t\t<td>960年-1127年（167年）</td>\n\t\t\t<td>开封</td>\n\t\t\t<td>宋太祖赵匡胤 赵光义 赵恒 赵祯 赵曙 赵顼 赵煦 赵佶 赵桓（\n\t\t\t\t<strong>9位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南宋</td>\n\t\t\t<td>1127年-1279年（152年）</td>\n\t\t\t<td>杭州</td>\n\t\t\t<td>宋高宗赵构 赵昚 赵惇 赵扩 赵昀 赵禥 赵㬎 赵昰 赵昺（\n\t\t\t\t<strong>9位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>辽朝</td>\n\t\t\t<td></td>\n\t\t\t<td>916年-1125年（210年）</td>\n\t\t\t<td></td>\n\t\t\t<td>上京</td>\n\t\t\t<td>耶律阿保机</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西夏</td>\n\t\t\t<td></td>\n\t\t\t<td>1038年-1227年（190年）</td>\n\t\t\t<td></td>\n\t\t\t<td>兴庆</td>\n\t\t\t<td>李元昊</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>金朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1115年-1234年（120年）</td>\n\t\t\t<td></td>\n\t\t\t<td>中都 开封</td>\n\t\t\t<td>完颜阿骨打</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"2\">大理国</td>\n\t\t\t<td>前大理</td>\n\t\t\t<td >937年-1094年（157年）</td>\n\t\t\t<td></td>\n\t\t\t<td rowspan=\"2\">云南大理</td>\n\t\t\t<td rowspan=\"2\">段思平</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>后大理</td>\n\t\t\t<td >1096年-1253年（316年）</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>大蒙古国</td>\n\t\t\t<td></td>\n\t\t\t<td>1206年-1271年（66年）</td>\n\t\t\t<td></td>\n\t\t\t<td>大都</td>\n\t\t\t<td>铁木真 窝阔台 贵由 蒙哥（4位）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>元朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1271年-1368年（97年）</td>\n\t\t\t<td></td>\n\t\t\t<td>大都</td>\n\t\t\t<td>元世祖忽必烈 铁穆耳 海山 爱育黎拔力八达 硕德八剌 也孙铁木儿 阿速吉八 图帖睦尔 和世㻋 懿璘质班 妥懽帖睦尔（\n\t\t\t\t<strong>11位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>明朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1368年-1644年（277年）</td>\n\t\t\t<td></td>\n\t\t\t<td>南京 北京</td>\n\t\t\t<td>明太祖朱元璋 朱允炆 朱棣 朱高炽 朱瞻基 朱祁镇 朱祁钰 朱见深 朱祐樘 朱厚照 朱厚熜 朱载垕 朱翊钧 朱常洛 朱由校 朱由检（\n\t\t\t\t<strong>16位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>清朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1636年-1912年（276年）</td>\n\t\t\t<td></td>\n\t\t\t<td>盛京 北京</td>\n\t\t\t<td>努尔哈赤_天命 皇太极_天聪 福临_顺治 玄烨_康熙  胤禛_雍正  弘历_乾隆  颙琰_嘉庆 旻宁_道光  奕詝_咸丰 载淳_同治  载湉_光绪  溥仪_宣统（\n\t\t\t\t<strong>12位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>中华民国</td>\n\t\t\t<td></td>\n\t\t\t<td>1912年-1949年（38年）</td>\n\t\t\t<td></td>\n\t\t\t<td>北京 南京 重庆</td>\n\t\t\t<td>孙中山 袁世凯 冯国璋 徐世昌 周自齐 高凌霨 曹锟 黄郛 段祺瑞 胡惟德 颜惠庆 杜锡圭 顾维钧 张作霖 汪兆铭 谭延闿 胡汉民 蒋介石 林森 李宗仁（\n\t\t\t\t<strong>20位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>中华人民共和国</td>\n\t\t\t<td></td>\n\t\t\t<td>1949以后</td>\n\t\t\t<td></td>\n\t\t\t<td>北京</td>\n\t\t\t<td>毛泽东 刘少奇 董必武 宋庆龄 朱德  叶剑英 李先念 杨尚昆 江泽民 胡锦涛 习近平</td>\n\t\t</tr>\n\t</tbody>\n</table>\n","source":"_posts/中国历史年表.md","raw":"---\nabbrlink: 0\n---\n\n\n<table>\n    <tbody>\n    <tr>\n        <th>朝代</th>\n        <th>存在时间</th>\n        <th>都城（今）</th>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">变量引用</td>\n        <td>super</td>\n        <td>父类,超类</td>\n    </tr>\n    <tr>\n        <td>this</td>\n        <td>本类</td>\n    </tr>\n    <tr>\n        <td>void</td>\n        <td>无返回值</td>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">保留关键字</td>\n        <td>goto</td>\n        <td>是关键字，但不能使用</td>\n    </tr>\n    <tr>\n        <td>const</td>\n        <td>是关键字，但不能使用</td>\n    </tr>\n    <tr>\n        <td>null</td>\n        <td>空</td>\n    </tr>\n    </tbody>\n</table>\n\n\n<table>\n\t<thead>\n\t\t<tr>\n\t\t\t<th>\n\t\t\t\t<strong>朝代</strong>\n\t\t\t</th>\n\t\t\t<th></th>\n\t\t\t<th>\n\t\t\t\t<strong>存在时间</strong>\n\t\t\t</th>\n\t\t\t<th></th>\n\t\t\t<th>\n\t\t\t\t<strong>都城（今）</strong>\n\t\t\t</th>\n\t\t\t<th>\n\t\t\t\t<strong>君主</strong>\n\t\t\t</th>\n\t\t</tr>\n\t</thead>\n\t<tbody>\n\t\t<tr>\n\t\t\t<td>“三皇五帝”说</td>\n\t\t\t<td></td>\n\t\t\t<td>前170万年-前2070年</td>\n\t\t\t<td></td>\n\t\t\t<td>无文字记载</td>\n\t\t\t<td>无文字记载</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>夏朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前2070年-前1600年（470年）</td>\n\t\t\t<td></td>\n\t\t\t<td>河南洛阳</td>\n\t\t\t<td>禹 启 太康 仲康 相  少康 杼 槐 芒 泄 不降 扃 廑 孔甲 皋 发 桀（\n\t\t\t\t<strong>17位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>商朝（殷商）</td>\n\t\t\t<td></td>\n\t\t\t<td>前1600年-前1046年（554年）</td>\n\t\t\t<td></td>\n\t\t\t<td>商丘 洛阳 郑州  安阳</td>\n\t\t\t<td>汤 太丁 外丙 中壬 太甲 沃丁 太庚 小甲 雍己 太戊 中丁 外壬 河亶甲 祖乙 祖辛 沃甲 祖丁 南庚 阳甲 盘庚 小辛 小乙 武丁 祖庚 祖甲 廪辛 康丁 武乙 文丁 帝乙 帝辛（纣）（\n\t\t\t\t<strong>30位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西周王朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前1046年-前771年（275年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安（镐京） 洛阳</td>\n\t\t\t<td>（周武王）姬发 姬诵 姬钊 姬瑕 姬满 姬繄扈 姬囏 姬辟方 姬燮 姬胡 周定公 姬静 （周幽王）姬宫湦（\n\t\t\t\t<strong>13位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td  rowspan=\"2\">东周王朝</td>\n\t\t\t<td>春秋</td>\n\t\t\t<td  rowspan=\"2\">前770年-前256年（515年）</td>\n\t\t\t<td>前770年-前476年（295年）</td>\n\t\t\t<td rowspan=\"2\">洛阳</td>\n\t\t\t<td rowspan=\"2\">（周平王）姬宜臼 姬林 姬佗 姬胡齐 姬阆 姬郑 姬壬臣 姬班 姬瑜 姬夷 姬泄心 姬贵 姬猛 姬匄 姬仁 姬介 姬去疾 姬叔 姬嵬 姬午 姬骄 姬喜 姬扁 姬定 （周赧王）姬延（\n\t\t\t\t<strong>25位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>战国</td>\n\t\t\t<td>前475年-前221年（254年）</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>秦朝</td>\n\t\t\t<td></td>\n\t\t\t<td>前221年-前206年（16年）</td>\n\t\t\t<td></td>\n\t\t\t<td>咸阳 西安</td>\n\t\t\t<td>秦始皇 胡亥 子婴（\n\t\t\t\t<strong>3位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西楚</td>\n\t\t\t<td></td>\n\t\t\t<td>前206年-前202年（5年）</td>\n\t\t\t<td></td>\n\t\t\t<td>徐州</td>\n\t\t\t<td>西楚霸王项羽</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西汉</td>\n\t\t\t<td></td>\n\t\t\t<td>前202—公元8年11月（210年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>（汉高祖）刘邦 刘盈 前少帝 刘弘 刘恒 刘启 刘彻 刘弗陵 刘贺 刘询 刘奭 刘骜 刘欣 刘衎 刘婴（\n\t\t\t\t<strong>15位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>新朝</td>\n\t\t\t<td></td>\n\t\t\t<td>公元8年12月-23年10月（16年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>建兴帝王莽</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>玄汉</td>\n\t\t\t<td></td>\n\t\t\t<td>23年10月-25年（2年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安</td>\n\t\t\t<td>更始帝刘玄</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>东汉</td>\n\t\t\t<td></td>\n\t\t\t<td>25年-220年（195年）</td>\n\t\t\t<td></td>\n\t\t\t<td>洛阳</td>\n\t\t\t<td>光武帝刘秀 刘庄 \n\t\t\t\t刘炟 刘肇 刘隆 刘祜 刘懿 刘保  刘炳 刘缵 刘志 刘宏 刘辩 刘协（\n\t\t\t\t<strong>14位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"3\">三国</td>\n\t\t\t<td>魏</td>\n\t\t\t<td rowspan=\"3\">220年－280年（60年）</td>\n\t\t\t<td>220年-265年（45年）</td>\n\t\t\t<td>洛阳</td>\n\t\t\t<td>魏文帝曹丕  曹叡  曹芳 曹髦 曹奂（\n\t\t\t\t<strong>5位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>蜀汉</td>\n\t\t\t<td>221年-263年（42年）</td>\n\t\t\t<td>成都</td>\n\t\t\t<td>汉昭烈帝刘备 汉怀帝刘禅 （\n\t\t\t\t<strong>2位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>吴</td>\n\t\t\t<td>222年-280年（58年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>吴大帝孙权 孙亮 孙休 孙皓（\n\t\t\t\t<strong>4位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"2\">晋朝</td>\n\t\t\t<td >西晋</td>\n\t\t\t<td rowspan=\"2\">265—420年（155年）</td>\n\t\t\t<td>265年-316年（51年）</td>\n\t\t\t<td>洛阳 西安</td>\n\t\t\t<td>晋武帝 司马炎 司马衷 司马炽 司马邺 （\n\t\t\t\t<strong>4位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>东晋</td>\n\t\t\t<td>317年-420年（103年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>晋元帝司马睿 司马绍 司马衍 司马岳 司马聃 司马丕 司马奕 司马昱 司马曜 司马德宗 司马德文（\n\t\t\t\t<strong>11位</strong>）\n\t\t\t</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>十六国</td>\n\t\t\t<td>前赵（汉赵）   成汉 前凉    后赵 前燕    前秦 后秦    后燕  西秦   后凉  南凉   南燕  西凉   胡夏 北燕    北凉 冉魏    西燕      西蜀（后蜀）</td>\n\t\t\t<td >304年-439年（135年）</td>\n\t\t\t<td></td>\n\t\t\t<td>（多政权存在）</td>\n\t\t\t<td>（多政权存在）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>南北朝</td>\n\t\t\t<td>南朝·宋</td>\n\t\t\t<td>420年—589年（169年）</td>\n\t\t\t<td>420年-479年（59年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>刘裕</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·齐</td>\n\t\t\t<td></td>\n\t\t\t<td>479年-502年（23年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>萧道成</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·梁</td>\n\t\t\t<td></td>\n\t\t\t<td>502年-557年（55年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>萧衍</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南朝·陈</td>\n\t\t\t<td></td>\n\t\t\t<td>557年-589年（32年）</td>\n\t\t\t<td>南京</td>\n\t\t\t<td>陈霸先</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北魏</td>\n\t\t\t<td></td>\n\t\t\t<td>386年-534年（148年）</td>\n\t\t\t<td>大同 洛阳</td>\n\t\t\t<td>拓跋珪</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·东魏</td>\n\t\t\t<td></td>\n\t\t\t<td>534年-550年（16年）</td>\n\t\t\t<td>安阳</td>\n\t\t\t<td>元善见</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·西魏</td>\n\t\t\t<td></td>\n\t\t\t<td>535年-557年（22年）</td>\n\t\t\t<td>西安</td>\n\t\t\t<td>元宝炬</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北齐</td>\n\t\t\t<td></td>\n\t\t\t<td>550年-577年（27年）</td>\n\t\t\t<td>安阳</td>\n\t\t\t<td>高洋</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>北朝·北周</td>\n\t\t\t<td></td>\n\t\t\t<td>557年-581年（24年）</td>\n\t\t\t<td>西安</td>\n\t\t\t<td>宇文觉</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>隋朝</td>\n\t\t\t<td></td>\n\t\t\t<td>581年-618年（38年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安 洛阳</td>\n\t\t\t<td>隋文帝杨坚 杨广 杨侑 杨浩 杨昭 杨侗（\n\t\t\t\t<strong>6位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>唐朝</td>\n\t\t\t<td></td>\n\t\t\t<td>618年-907年（289年）</td>\n\t\t\t<td></td>\n\t\t\t<td>西安 洛阳</td>\n\t\t\t<td>李渊 李世民 李治 李显 李旦 武则天 李隆基 李亨 李豫 李适 李诵 李纯 李恒 李昂 李炎 李忱 李漼 李儇 李晔 李祝（\n\t\t\t\t<strong>21位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>五代十国</td>\n\t\t\t<td>后梁 后唐 后晋 后汉 后周 前蜀 后蜀 杨吴 南唐 吴越 闽国 马楚 南汉 南平 北汉</td>\n\t\t\t<td>891年-979年（89年）</td>\n\t\t\t<td></td>\n\t\t\t<td>开封 洛阳</td>\n\t\t\t<td>（多政权存在）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>宋朝</td>\n\t\t\t<td >北宋</td>\n\t\t\t<td rowspan=\"2\">960年-1279年（320年）</td>\n\t\t\t<td>960年-1127年（167年）</td>\n\t\t\t<td>开封</td>\n\t\t\t<td>宋太祖赵匡胤 赵光义 赵恒 赵祯 赵曙 赵顼 赵煦 赵佶 赵桓（\n\t\t\t\t<strong>9位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td></td>\n\t\t\t<td>南宋</td>\n\t\t\t<td>1127年-1279年（152年）</td>\n\t\t\t<td>杭州</td>\n\t\t\t<td>宋高宗赵构 赵昚 赵惇 赵扩 赵昀 赵禥 赵㬎 赵昰 赵昺（\n\t\t\t\t<strong>9位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>辽朝</td>\n\t\t\t<td></td>\n\t\t\t<td>916年-1125年（210年）</td>\n\t\t\t<td></td>\n\t\t\t<td>上京</td>\n\t\t\t<td>耶律阿保机</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>西夏</td>\n\t\t\t<td></td>\n\t\t\t<td>1038年-1227年（190年）</td>\n\t\t\t<td></td>\n\t\t\t<td>兴庆</td>\n\t\t\t<td>李元昊</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>金朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1115年-1234年（120年）</td>\n\t\t\t<td></td>\n\t\t\t<td>中都 开封</td>\n\t\t\t<td>完颜阿骨打</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td rowspan=\"2\">大理国</td>\n\t\t\t<td>前大理</td>\n\t\t\t<td >937年-1094年（157年）</td>\n\t\t\t<td></td>\n\t\t\t<td rowspan=\"2\">云南大理</td>\n\t\t\t<td rowspan=\"2\">段思平</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>后大理</td>\n\t\t\t<td >1096年-1253年（316年）</td>\n\t\t\t<td></td>\n\t\t\t<td></td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>大蒙古国</td>\n\t\t\t<td></td>\n\t\t\t<td>1206年-1271年（66年）</td>\n\t\t\t<td></td>\n\t\t\t<td>大都</td>\n\t\t\t<td>铁木真 窝阔台 贵由 蒙哥（4位）</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>元朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1271年-1368年（97年）</td>\n\t\t\t<td></td>\n\t\t\t<td>大都</td>\n\t\t\t<td>元世祖忽必烈 铁穆耳 海山 爱育黎拔力八达 硕德八剌 也孙铁木儿 阿速吉八 图帖睦尔 和世㻋 懿璘质班 妥懽帖睦尔（\n\t\t\t\t<strong>11位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>明朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1368年-1644年（277年）</td>\n\t\t\t<td></td>\n\t\t\t<td>南京 北京</td>\n\t\t\t<td>明太祖朱元璋 朱允炆 朱棣 朱高炽 朱瞻基 朱祁镇 朱祁钰 朱见深 朱祐樘 朱厚照 朱厚熜 朱载垕 朱翊钧 朱常洛 朱由校 朱由检（\n\t\t\t\t<strong>16位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>清朝</td>\n\t\t\t<td></td>\n\t\t\t<td>1636年-1912年（276年）</td>\n\t\t\t<td></td>\n\t\t\t<td>盛京 北京</td>\n\t\t\t<td>努尔哈赤_天命 皇太极_天聪 福临_顺治 玄烨_康熙  胤禛_雍正  弘历_乾隆  颙琰_嘉庆 旻宁_道光  奕詝_咸丰 载淳_同治  载湉_光绪  溥仪_宣统（\n\t\t\t\t<strong>12位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>中华民国</td>\n\t\t\t<td></td>\n\t\t\t<td>1912年-1949年（38年）</td>\n\t\t\t<td></td>\n\t\t\t<td>北京 南京 重庆</td>\n\t\t\t<td>孙中山 袁世凯 冯国璋 徐世昌 周自齐 高凌霨 曹锟 黄郛 段祺瑞 胡惟德 颜惠庆 杜锡圭 顾维钧 张作霖 汪兆铭 谭延闿 胡汉民 蒋介石 林森 李宗仁（\n\t\t\t\t<strong>20位</strong>）\n\t\t\t</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>中华人民共和国</td>\n\t\t\t<td></td>\n\t\t\t<td>1949以后</td>\n\t\t\t<td></td>\n\t\t\t<td>北京</td>\n\t\t\t<td>毛泽东 刘少奇 董必武 宋庆龄 朱德  叶剑英 李先念 杨尚昆 江泽民 胡锦涛 习近平</td>\n\t\t</tr>\n\t</tbody>\n</table>\n","slug":"中国历史年表","published":1,"date":"2023-07-28T07:07:42.032Z","updated":"2023-07-28T07:08:06.035Z","_id":"clkm8rto600005wum37xtfx3v","title":"","comments":1,"layout":"post","photos":[],"link":"","content":"<table>\n    <tbody>\n    <tr>\n        <th>朝代</th>\n        <th>存在时间</th>\n        <th>都城（今）</th>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">变量引用</td>\n        <td>super</td>\n        <td>父类,超类</td>\n    </tr>\n    <tr>\n        <td>this</td>\n        <td>本类</td>\n    </tr>\n    <tr>\n        <td>void</td>\n        <td>无返回值</td>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">保留关键字</td>\n        <td>goto</td>\n        <td>是关键字，但不能使用</td>\n    </tr>\n    <tr>\n        <td>const</td>\n        <td>是关键字，但不能使用</td>\n    </tr>\n    <tr>\n        <td>null</td>\n        <td>空</td>\n    </tr>\n    </tbody>\n</table>\n\n\n<table>\n    <thead>\n        <tr>\n            <th>\n                <strong>朝代</strong>\n            </th>\n            <th></th>\n            <th>\n                <strong>存在时间</strong>\n            </th>\n            <th></th>\n            <th>\n                <strong>都城（今）</strong>\n            </th>\n            <th>\n                <strong>君主</strong>\n            </th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>“三皇五帝”说</td>\n            <td></td>\n            <td>前170万年-前2070年</td>\n            <td></td>\n            <td>无文字记载</td>\n            <td>无文字记载</td>\n        </tr>\n        <tr>\n            <td>夏朝</td>\n            <td></td>\n            <td>前2070年-前1600年（470年）</td>\n            <td></td>\n            <td>河南洛阳</td>\n            <td>禹 启 太康 仲康 相  少康 杼 槐 芒 泄 不降 扃 廑 孔甲 皋 发 桀（\n                <strong>17位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>商朝（殷商）</td>\n            <td></td>\n            <td>前1600年-前1046年（554年）</td>\n            <td></td>\n            <td>商丘 洛阳 郑州  安阳</td>\n            <td>汤 太丁 外丙 中壬 太甲 沃丁 太庚 小甲 雍己 太戊 中丁 外壬 河亶甲 祖乙 祖辛 沃甲 祖丁 南庚 阳甲 盘庚 小辛 小乙 武丁 祖庚 祖甲 廪辛 康丁 武乙 文丁 帝乙 帝辛（纣）（\n                <strong>30位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>西周王朝</td>\n            <td></td>\n            <td>前1046年-前771年（275年）</td>\n            <td></td>\n            <td>西安（镐京） 洛阳</td>\n            <td>（周武王）姬发 姬诵 姬钊 姬瑕 姬满 姬繄扈 姬囏 姬辟方 姬燮 姬胡 周定公 姬静 （周幽王）姬宫湦（\n                <strong>13位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td  rowspan=\"2\">东周王朝</td>\n            <td>春秋</td>\n            <td  rowspan=\"2\">前770年-前256年（515年）</td>\n            <td>前770年-前476年（295年）</td>\n            <td rowspan=\"2\">洛阳</td>\n            <td rowspan=\"2\">（周平王）姬宜臼 姬林 姬佗 姬胡齐 姬阆 姬郑 姬壬臣 姬班 姬瑜 姬夷 姬泄心 姬贵 姬猛 姬匄 姬仁 姬介 姬去疾 姬叔 姬嵬 姬午 姬骄 姬喜 姬扁 姬定 （周赧王）姬延（\n                <strong>25位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>战国</td>\n            <td>前475年-前221年（254年）</td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>秦朝</td>\n            <td></td>\n            <td>前221年-前206年（16年）</td>\n            <td></td>\n            <td>咸阳 西安</td>\n            <td>秦始皇 胡亥 子婴（\n                <strong>3位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>西楚</td>\n            <td></td>\n            <td>前206年-前202年（5年）</td>\n            <td></td>\n            <td>徐州</td>\n            <td>西楚霸王项羽</td>\n        </tr>\n        <tr>\n            <td>西汉</td>\n            <td></td>\n            <td>前202—公元8年11月（210年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>（汉高祖）刘邦 刘盈 前少帝 刘弘 刘恒 刘启 刘彻 刘弗陵 刘贺 刘询 刘奭 刘骜 刘欣 刘衎 刘婴（\n                <strong>15位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>新朝</td>\n            <td></td>\n            <td>公元8年12月-23年10月（16年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>建兴帝王莽</td>\n        </tr>\n        <tr>\n            <td>玄汉</td>\n            <td></td>\n            <td>23年10月-25年（2年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>更始帝刘玄</td>\n        </tr>\n        <tr>\n            <td>东汉</td>\n            <td></td>\n            <td>25年-220年（195年）</td>\n            <td></td>\n            <td>洛阳</td>\n            <td>光武帝刘秀 刘庄 \n                刘炟 刘肇 刘隆 刘祜 刘懿 刘保  刘炳 刘缵 刘志 刘宏 刘辩 刘协（\n                <strong>14位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td rowspan=\"3\">三国</td>\n            <td>魏</td>\n            <td rowspan=\"3\">220年－280年（60年）</td>\n            <td>220年-265年（45年）</td>\n            <td>洛阳</td>\n            <td>魏文帝曹丕  曹叡  曹芳 曹髦 曹奂（\n                <strong>5位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>蜀汉</td>\n            <td>221年-263年（42年）</td>\n            <td>成都</td>\n            <td>汉昭烈帝刘备 汉怀帝刘禅 （\n                <strong>2位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>吴</td>\n            <td>222年-280年（58年）</td>\n            <td>南京</td>\n            <td>吴大帝孙权 孙亮 孙休 孙皓（\n                <strong>4位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td rowspan=\"2\">晋朝</td>\n            <td >西晋</td>\n            <td rowspan=\"2\">265—420年（155年）</td>\n            <td>265年-316年（51年）</td>\n            <td>洛阳 西安</td>\n            <td>晋武帝 司马炎 司马衷 司马炽 司马邺 （\n                <strong>4位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>东晋</td>\n            <td>317年-420年（103年）</td>\n            <td>南京</td>\n            <td>晋元帝司马睿 司马绍 司马衍 司马岳 司马聃 司马丕 司马奕 司马昱 司马曜 司马德宗 司马德文（\n                <strong>11位</strong>）\n            </td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>十六国</td>\n            <td>前赵（汉赵）   成汉 前凉    后赵 前燕    前秦 后秦    后燕  西秦   后凉  南凉   南燕  西凉   胡夏 北燕    北凉 冉魏    西燕      西蜀（后蜀）</td>\n            <td >304年-439年（135年）</td>\n            <td></td>\n            <td>（多政权存在）</td>\n            <td>（多政权存在）</td>\n        </tr>\n        <tr>\n            <td>南北朝</td>\n            <td>南朝·宋</td>\n            <td>420年—589年（169年）</td>\n            <td>420年-479年（59年）</td>\n            <td>南京</td>\n            <td>刘裕</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·齐</td>\n            <td></td>\n            <td>479年-502年（23年）</td>\n            <td>南京</td>\n            <td>萧道成</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·梁</td>\n            <td></td>\n            <td>502年-557年（55年）</td>\n            <td>南京</td>\n            <td>萧衍</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·陈</td>\n            <td></td>\n            <td>557年-589年（32年）</td>\n            <td>南京</td>\n            <td>陈霸先</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北魏</td>\n            <td></td>\n            <td>386年-534年（148年）</td>\n            <td>大同 洛阳</td>\n            <td>拓跋珪</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·东魏</td>\n            <td></td>\n            <td>534年-550年（16年）</td>\n            <td>安阳</td>\n            <td>元善见</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·西魏</td>\n            <td></td>\n            <td>535年-557年（22年）</td>\n            <td>西安</td>\n            <td>元宝炬</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北齐</td>\n            <td></td>\n            <td>550年-577年（27年）</td>\n            <td>安阳</td>\n            <td>高洋</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北周</td>\n            <td></td>\n            <td>557年-581年（24年）</td>\n            <td>西安</td>\n            <td>宇文觉</td>\n        </tr>\n        <tr>\n            <td>隋朝</td>\n            <td></td>\n            <td>581年-618年（38年）</td>\n            <td></td>\n            <td>西安 洛阳</td>\n            <td>隋文帝杨坚 杨广 杨侑 杨浩 杨昭 杨侗（\n                <strong>6位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>唐朝</td>\n            <td></td>\n            <td>618年-907年（289年）</td>\n            <td></td>\n            <td>西安 洛阳</td>\n            <td>李渊 李世民 李治 李显 李旦 武则天 李隆基 李亨 李豫 李适 李诵 李纯 李恒 李昂 李炎 李忱 李漼 李儇 李晔 李祝（\n                <strong>21位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>五代十国</td>\n            <td>后梁 后唐 后晋 后汉 后周 前蜀 后蜀 杨吴 南唐 吴越 闽国 马楚 南汉 南平 北汉</td>\n            <td>891年-979年（89年）</td>\n            <td></td>\n            <td>开封 洛阳</td>\n            <td>（多政权存在）</td>\n        </tr>\n        <tr>\n            <td>宋朝</td>\n            <td >北宋</td>\n            <td rowspan=\"2\">960年-1279年（320年）</td>\n            <td>960年-1127年（167年）</td>\n            <td>开封</td>\n            <td>宋太祖赵匡胤 赵光义 赵恒 赵祯 赵曙 赵顼 赵煦 赵佶 赵桓（\n                <strong>9位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南宋</td>\n            <td>1127年-1279年（152年）</td>\n            <td>杭州</td>\n            <td>宋高宗赵构 赵昚 赵惇 赵扩 赵昀 赵禥 赵㬎 赵昰 赵昺（\n                <strong>9位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>辽朝</td>\n            <td></td>\n            <td>916年-1125年（210年）</td>\n            <td></td>\n            <td>上京</td>\n            <td>耶律阿保机</td>\n        </tr>\n        <tr>\n            <td>西夏</td>\n            <td></td>\n            <td>1038年-1227年（190年）</td>\n            <td></td>\n            <td>兴庆</td>\n            <td>李元昊</td>\n        </tr>\n        <tr>\n            <td>金朝</td>\n            <td></td>\n            <td>1115年-1234年（120年）</td>\n            <td></td>\n            <td>中都 开封</td>\n            <td>完颜阿骨打</td>\n        </tr>\n        <tr>\n            <td rowspan=\"2\">大理国</td>\n            <td>前大理</td>\n            <td >937年-1094年（157年）</td>\n            <td></td>\n            <td rowspan=\"2\">云南大理</td>\n            <td rowspan=\"2\">段思平</td>\n        </tr>\n        <tr>\n            <td>后大理</td>\n            <td >1096年-1253年（316年）</td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>大蒙古国</td>\n            <td></td>\n            <td>1206年-1271年（66年）</td>\n            <td></td>\n            <td>大都</td>\n            <td>铁木真 窝阔台 贵由 蒙哥（4位）</td>\n        </tr>\n        <tr>\n            <td>元朝</td>\n            <td></td>\n            <td>1271年-1368年（97年）</td>\n            <td></td>\n            <td>大都</td>\n            <td>元世祖忽必烈 铁穆耳 海山 爱育黎拔力八达 硕德八剌 也孙铁木儿 阿速吉八 图帖睦尔 和世㻋 懿璘质班 妥懽帖睦尔（\n                <strong>11位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>明朝</td>\n            <td></td>\n            <td>1368年-1644年（277年）</td>\n            <td></td>\n            <td>南京 北京</td>\n            <td>明太祖朱元璋 朱允炆 朱棣 朱高炽 朱瞻基 朱祁镇 朱祁钰 朱见深 朱祐樘 朱厚照 朱厚熜 朱载垕 朱翊钧 朱常洛 朱由校 朱由检（\n                <strong>16位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>清朝</td>\n            <td></td>\n            <td>1636年-1912年（276年）</td>\n            <td></td>\n            <td>盛京 北京</td>\n            <td>努尔哈赤_天命 皇太极_天聪 福临_顺治 玄烨_康熙  胤禛_雍正  弘历_乾隆  颙琰_嘉庆 旻宁_道光  奕詝_咸丰 载淳_同治  载湉_光绪  溥仪_宣统（\n                <strong>12位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>中华民国</td>\n            <td></td>\n            <td>1912年-1949年（38年）</td>\n            <td></td>\n            <td>北京 南京 重庆</td>\n            <td>孙中山 袁世凯 冯国璋 徐世昌 周自齐 高凌霨 曹锟 黄郛 段祺瑞 胡惟德 颜惠庆 杜锡圭 顾维钧 张作霖 汪兆铭 谭延闿 胡汉民 蒋介石 林森 李宗仁（\n                <strong>20位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>中华人民共和国</td>\n            <td></td>\n            <td>1949以后</td>\n            <td></td>\n            <td>北京</td>\n            <td>毛泽东 刘少奇 董必武 宋庆龄 朱德  叶剑英 李先念 杨尚昆 江泽民 胡锦涛 习近平</td>\n        </tr>\n    </tbody>\n</table>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<table>\n    <tbody>\n    <tr>\n        <th>朝代</th>\n        <th>存在时间</th>\n        <th>都城（今）</th>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">变量引用</td>\n        <td>super</td>\n        <td>父类,超类</td>\n    </tr>\n    <tr>\n        <td>this</td>\n        <td>本类</td>\n    </tr>\n    <tr>\n        <td>void</td>\n        <td>无返回值</td>\n    </tr>\n    <tr>\n        <td rowspan=\"3\">保留关键字</td>\n        <td>goto</td>\n        <td>是关键字，但不能使用</td>\n    </tr>\n    <tr>\n        <td>const</td>\n        <td>是关键字，但不能使用</td>\n    </tr>\n    <tr>\n        <td>null</td>\n        <td>空</td>\n    </tr>\n    </tbody>\n</table>\n\n\n<table>\n    <thead>\n        <tr>\n            <th>\n                <strong>朝代</strong>\n            </th>\n            <th></th>\n            <th>\n                <strong>存在时间</strong>\n            </th>\n            <th></th>\n            <th>\n                <strong>都城（今）</strong>\n            </th>\n            <th>\n                <strong>君主</strong>\n            </th>\n        </tr>\n    </thead>\n    <tbody>\n        <tr>\n            <td>“三皇五帝”说</td>\n            <td></td>\n            <td>前170万年-前2070年</td>\n            <td></td>\n            <td>无文字记载</td>\n            <td>无文字记载</td>\n        </tr>\n        <tr>\n            <td>夏朝</td>\n            <td></td>\n            <td>前2070年-前1600年（470年）</td>\n            <td></td>\n            <td>河南洛阳</td>\n            <td>禹 启 太康 仲康 相  少康 杼 槐 芒 泄 不降 扃 廑 孔甲 皋 发 桀（\n                <strong>17位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>商朝（殷商）</td>\n            <td></td>\n            <td>前1600年-前1046年（554年）</td>\n            <td></td>\n            <td>商丘 洛阳 郑州  安阳</td>\n            <td>汤 太丁 外丙 中壬 太甲 沃丁 太庚 小甲 雍己 太戊 中丁 外壬 河亶甲 祖乙 祖辛 沃甲 祖丁 南庚 阳甲 盘庚 小辛 小乙 武丁 祖庚 祖甲 廪辛 康丁 武乙 文丁 帝乙 帝辛（纣）（\n                <strong>30位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>西周王朝</td>\n            <td></td>\n            <td>前1046年-前771年（275年）</td>\n            <td></td>\n            <td>西安（镐京） 洛阳</td>\n            <td>（周武王）姬发 姬诵 姬钊 姬瑕 姬满 姬繄扈 姬囏 姬辟方 姬燮 姬胡 周定公 姬静 （周幽王）姬宫湦（\n                <strong>13位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td  rowspan=\"2\">东周王朝</td>\n            <td>春秋</td>\n            <td  rowspan=\"2\">前770年-前256年（515年）</td>\n            <td>前770年-前476年（295年）</td>\n            <td rowspan=\"2\">洛阳</td>\n            <td rowspan=\"2\">（周平王）姬宜臼 姬林 姬佗 姬胡齐 姬阆 姬郑 姬壬臣 姬班 姬瑜 姬夷 姬泄心 姬贵 姬猛 姬匄 姬仁 姬介 姬去疾 姬叔 姬嵬 姬午 姬骄 姬喜 姬扁 姬定 （周赧王）姬延（\n                <strong>25位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>战国</td>\n            <td>前475年-前221年（254年）</td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>秦朝</td>\n            <td></td>\n            <td>前221年-前206年（16年）</td>\n            <td></td>\n            <td>咸阳 西安</td>\n            <td>秦始皇 胡亥 子婴（\n                <strong>3位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>西楚</td>\n            <td></td>\n            <td>前206年-前202年（5年）</td>\n            <td></td>\n            <td>徐州</td>\n            <td>西楚霸王项羽</td>\n        </tr>\n        <tr>\n            <td>西汉</td>\n            <td></td>\n            <td>前202—公元8年11月（210年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>（汉高祖）刘邦 刘盈 前少帝 刘弘 刘恒 刘启 刘彻 刘弗陵 刘贺 刘询 刘奭 刘骜 刘欣 刘衎 刘婴（\n                <strong>15位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>新朝</td>\n            <td></td>\n            <td>公元8年12月-23年10月（16年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>建兴帝王莽</td>\n        </tr>\n        <tr>\n            <td>玄汉</td>\n            <td></td>\n            <td>23年10月-25年（2年）</td>\n            <td></td>\n            <td>西安</td>\n            <td>更始帝刘玄</td>\n        </tr>\n        <tr>\n            <td>东汉</td>\n            <td></td>\n            <td>25年-220年（195年）</td>\n            <td></td>\n            <td>洛阳</td>\n            <td>光武帝刘秀 刘庄 \n                刘炟 刘肇 刘隆 刘祜 刘懿 刘保  刘炳 刘缵 刘志 刘宏 刘辩 刘协（\n                <strong>14位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td rowspan=\"3\">三国</td>\n            <td>魏</td>\n            <td rowspan=\"3\">220年－280年（60年）</td>\n            <td>220年-265年（45年）</td>\n            <td>洛阳</td>\n            <td>魏文帝曹丕  曹叡  曹芳 曹髦 曹奂（\n                <strong>5位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>蜀汉</td>\n            <td>221年-263年（42年）</td>\n            <td>成都</td>\n            <td>汉昭烈帝刘备 汉怀帝刘禅 （\n                <strong>2位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>吴</td>\n            <td>222年-280年（58年）</td>\n            <td>南京</td>\n            <td>吴大帝孙权 孙亮 孙休 孙皓（\n                <strong>4位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td rowspan=\"2\">晋朝</td>\n            <td >西晋</td>\n            <td rowspan=\"2\">265—420年（155年）</td>\n            <td>265年-316年（51年）</td>\n            <td>洛阳 西安</td>\n            <td>晋武帝 司马炎 司马衷 司马炽 司马邺 （\n                <strong>4位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>东晋</td>\n            <td>317年-420年（103年）</td>\n            <td>南京</td>\n            <td>晋元帝司马睿 司马绍 司马衍 司马岳 司马聃 司马丕 司马奕 司马昱 司马曜 司马德宗 司马德文（\n                <strong>11位</strong>）\n            </td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>十六国</td>\n            <td>前赵（汉赵）   成汉 前凉    后赵 前燕    前秦 后秦    后燕  西秦   后凉  南凉   南燕  西凉   胡夏 北燕    北凉 冉魏    西燕      西蜀（后蜀）</td>\n            <td >304年-439年（135年）</td>\n            <td></td>\n            <td>（多政权存在）</td>\n            <td>（多政权存在）</td>\n        </tr>\n        <tr>\n            <td>南北朝</td>\n            <td>南朝·宋</td>\n            <td>420年—589年（169年）</td>\n            <td>420年-479年（59年）</td>\n            <td>南京</td>\n            <td>刘裕</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·齐</td>\n            <td></td>\n            <td>479年-502年（23年）</td>\n            <td>南京</td>\n            <td>萧道成</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·梁</td>\n            <td></td>\n            <td>502年-557年（55年）</td>\n            <td>南京</td>\n            <td>萧衍</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南朝·陈</td>\n            <td></td>\n            <td>557年-589年（32年）</td>\n            <td>南京</td>\n            <td>陈霸先</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北魏</td>\n            <td></td>\n            <td>386年-534年（148年）</td>\n            <td>大同 洛阳</td>\n            <td>拓跋珪</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·东魏</td>\n            <td></td>\n            <td>534年-550年（16年）</td>\n            <td>安阳</td>\n            <td>元善见</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·西魏</td>\n            <td></td>\n            <td>535年-557年（22年）</td>\n            <td>西安</td>\n            <td>元宝炬</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北齐</td>\n            <td></td>\n            <td>550年-577年（27年）</td>\n            <td>安阳</td>\n            <td>高洋</td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>北朝·北周</td>\n            <td></td>\n            <td>557年-581年（24年）</td>\n            <td>西安</td>\n            <td>宇文觉</td>\n        </tr>\n        <tr>\n            <td>隋朝</td>\n            <td></td>\n            <td>581年-618年（38年）</td>\n            <td></td>\n            <td>西安 洛阳</td>\n            <td>隋文帝杨坚 杨广 杨侑 杨浩 杨昭 杨侗（\n                <strong>6位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>唐朝</td>\n            <td></td>\n            <td>618年-907年（289年）</td>\n            <td></td>\n            <td>西安 洛阳</td>\n            <td>李渊 李世民 李治 李显 李旦 武则天 李隆基 李亨 李豫 李适 李诵 李纯 李恒 李昂 李炎 李忱 李漼 李儇 李晔 李祝（\n                <strong>21位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>五代十国</td>\n            <td>后梁 后唐 后晋 后汉 后周 前蜀 后蜀 杨吴 南唐 吴越 闽国 马楚 南汉 南平 北汉</td>\n            <td>891年-979年（89年）</td>\n            <td></td>\n            <td>开封 洛阳</td>\n            <td>（多政权存在）</td>\n        </tr>\n        <tr>\n            <td>宋朝</td>\n            <td >北宋</td>\n            <td rowspan=\"2\">960年-1279年（320年）</td>\n            <td>960年-1127年（167年）</td>\n            <td>开封</td>\n            <td>宋太祖赵匡胤 赵光义 赵恒 赵祯 赵曙 赵顼 赵煦 赵佶 赵桓（\n                <strong>9位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td></td>\n            <td>南宋</td>\n            <td>1127年-1279年（152年）</td>\n            <td>杭州</td>\n            <td>宋高宗赵构 赵昚 赵惇 赵扩 赵昀 赵禥 赵㬎 赵昰 赵昺（\n                <strong>9位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>辽朝</td>\n            <td></td>\n            <td>916年-1125年（210年）</td>\n            <td></td>\n            <td>上京</td>\n            <td>耶律阿保机</td>\n        </tr>\n        <tr>\n            <td>西夏</td>\n            <td></td>\n            <td>1038年-1227年（190年）</td>\n            <td></td>\n            <td>兴庆</td>\n            <td>李元昊</td>\n        </tr>\n        <tr>\n            <td>金朝</td>\n            <td></td>\n            <td>1115年-1234年（120年）</td>\n            <td></td>\n            <td>中都 开封</td>\n            <td>完颜阿骨打</td>\n        </tr>\n        <tr>\n            <td rowspan=\"2\">大理国</td>\n            <td>前大理</td>\n            <td >937年-1094年（157年）</td>\n            <td></td>\n            <td rowspan=\"2\">云南大理</td>\n            <td rowspan=\"2\">段思平</td>\n        </tr>\n        <tr>\n            <td>后大理</td>\n            <td >1096年-1253年（316年）</td>\n            <td></td>\n            <td></td>\n        </tr>\n        <tr>\n            <td>大蒙古国</td>\n            <td></td>\n            <td>1206年-1271年（66年）</td>\n            <td></td>\n            <td>大都</td>\n            <td>铁木真 窝阔台 贵由 蒙哥（4位）</td>\n        </tr>\n        <tr>\n            <td>元朝</td>\n            <td></td>\n            <td>1271年-1368年（97年）</td>\n            <td></td>\n            <td>大都</td>\n            <td>元世祖忽必烈 铁穆耳 海山 爱育黎拔力八达 硕德八剌 也孙铁木儿 阿速吉八 图帖睦尔 和世㻋 懿璘质班 妥懽帖睦尔（\n                <strong>11位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>明朝</td>\n            <td></td>\n            <td>1368年-1644年（277年）</td>\n            <td></td>\n            <td>南京 北京</td>\n            <td>明太祖朱元璋 朱允炆 朱棣 朱高炽 朱瞻基 朱祁镇 朱祁钰 朱见深 朱祐樘 朱厚照 朱厚熜 朱载垕 朱翊钧 朱常洛 朱由校 朱由检（\n                <strong>16位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>清朝</td>\n            <td></td>\n            <td>1636年-1912年（276年）</td>\n            <td></td>\n            <td>盛京 北京</td>\n            <td>努尔哈赤_天命 皇太极_天聪 福临_顺治 玄烨_康熙  胤禛_雍正  弘历_乾隆  颙琰_嘉庆 旻宁_道光  奕詝_咸丰 载淳_同治  载湉_光绪  溥仪_宣统（\n                <strong>12位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>中华民国</td>\n            <td></td>\n            <td>1912年-1949年（38年）</td>\n            <td></td>\n            <td>北京 南京 重庆</td>\n            <td>孙中山 袁世凯 冯国璋 徐世昌 周自齐 高凌霨 曹锟 黄郛 段祺瑞 胡惟德 颜惠庆 杜锡圭 顾维钧 张作霖 汪兆铭 谭延闿 胡汉民 蒋介石 林森 李宗仁（\n                <strong>20位</strong>）\n            </td>\n        </tr>\n        <tr>\n            <td>中华人民共和国</td>\n            <td></td>\n            <td>1949以后</td>\n            <td></td>\n            <td>北京</td>\n            <td>毛泽东 刘少奇 董必武 宋庆龄 朱德  叶剑英 李先念 杨尚昆 江泽民 胡锦涛 习近平</td>\n        </tr>\n    </tbody>\n</table>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clkjau31e0001igumdv7k6phm","category_id":"clkjau31h0003igumhspqcsqz","_id":"clkjau31k0008igumg0bwbid0"},{"post_id":"clkjau31m000eigum2978cac6","category_id":"clkjau31h0003igumhspqcsqz","_id":"clkjau31o000iigum260dctr8"},{"post_id":"clkjau31m000figum7xakc7rp","category_id":"clkjau31h0003igumhspqcsqz","_id":"clkjau31o000jigum10h5c76f"},{"post_id":"clkjau31n000higum54w6e8b0","category_id":"clkjau31h0003igumhspqcsqz","_id":"clkjau31o000ligum2zat7l5e"}],"PostTag":[{"post_id":"clkjau31e0001igumdv7k6phm","tag_id":"clkjau31j0004igum4tv67657","_id":"clkjau31l000aigum070bdbrm"},{"post_id":"clkjau31e0001igumdv7k6phm","tag_id":"clkjau31k0007igum9s603po0","_id":"clkjau31l000bigum52qwfejp"},{"post_id":"clkjau31e0001igumdv7k6phm","tag_id":"clkjau31k0009igum0frh3p94","_id":"clkjau31l000cigum6mshdw0c"},{"post_id":"clkjau31m000eigum2978cac6","tag_id":"clkjau31n000gigumfvgo2se0","_id":"clkjau31p000oigum8g9b183p"},{"post_id":"clkjau31m000eigum2978cac6","tag_id":"clkjau31o000kigum27zg2k36","_id":"clkjau31p000pigum7tqs2189"},{"post_id":"clkjau31m000eigum2978cac6","tag_id":"clkjau31o000migumgnaa82xb","_id":"clkjau31p000rigum3m8n6qr5"},{"post_id":"clkjau31m000figum7xakc7rp","tag_id":"clkjau31p000nigum45ucfhqp","_id":"clkjau31p000sigumffv5bm22"},{"post_id":"clkjau31n000higum54w6e8b0","tag_id":"clkjau31p000qigum5lmad0pl","_id":"clkjau31p000tigum13178nta"}],"Tag":[{"name":"juc","_id":"clkjau31j0004igum4tv67657"},{"name":"多线程","_id":"clkjau31k0007igum9s603po0"},{"name":"并发编程","_id":"clkjau31k0009igum0frh3p94"},{"name":"RabbitMQ","_id":"clkjau31n000gigumfvgo2se0"},{"name":"消息队列","_id":"clkjau31o000kigum27zg2k36"},{"name":"编程基础","_id":"clkjau31o000migumgnaa82xb"},{"name":"nginx","_id":"clkjau31p000nigum45ucfhqp"},{"name":"spring","_id":"clkjau31p000qigum5lmad0pl"}]}}
>>>>>>> 7148fc4a33cb28b296b8cbce42f5eba1ea41390f
