{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/custom.css","path":"css/custom.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/foot.js","path":"js/foot.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/css/LXGWZhenKai.ttf","path":"css/LXGWZhenKai.ttf","modified":0,"renderable":0},{"_id":"source/img/2.jpg","path":"img/2.jpg","modified":0,"renderable":0},{"_id":"source/img/1.jpg","path":"img/1.jpg","modified":0,"renderable":0},{"_id":"source/img/3.jpg","path":"img/3.jpg","modified":0,"renderable":0},{"_id":"source/img/5.jpg","path":"img/5.jpg","modified":0,"renderable":0},{"_id":"source/img/6.jpg","path":"img/6.jpg","modified":0,"renderable":0},{"_id":"source/img/7.jpg","path":"img/7.jpg","modified":0,"renderable":0},{"_id":"source/img/8.jpg","path":"img/8.jpg","modified":0,"renderable":0},{"_id":"source/img/4.jpg","path":"img/4.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/JUC.md","hash":"cdc79b40ab2a734174543f759e3cbd886bc2570f","modified":1689414589112},{"_id":"source/_posts/Nginx.md","hash":"393cb147232181a99a80081703c3562341fb3c52","modified":1689414589112},{"_id":"source/about/index.md","hash":"0d0ba47bdb928b8031eaf230546dae4bf7f9acbc","modified":1689402406684},{"_id":"source/img/3.jpg","hash":"3179c917c87135f463e5188276306246b4c95398","modified":1689404115688},{"_id":"source/img/5.jpg","hash":"45adc346caa9091ee0fae28dababd8f062e3ae08","modified":1689404262735},{"_id":"source/img/6.jpg","hash":"520711bfb0a80d70169abe3ed4dccc81f1eba558","modified":1689404371306},{"_id":"source/img/8.jpg","hash":"2f75d182bcaf73cbda43017927408019c24ae65c","modified":1689404631182},{"_id":"source/categories/index.md","hash":"72c1af26f42030250355df05a4e02fc6b9f2e3a0","modified":1689356715795},{"_id":"source/tags/index.md","hash":"5be498ae77be9fc74bfc4a783219ed27303cc7e4","modified":1689384712879},{"_id":"source/img/7.jpg","hash":"783e5a80f367f165d7fade36baf6cc55d4c61c2a","modified":1689404505853},{"_id":"source/img/4.jpg","hash":"46c3b721ccb4c45049b97075e342d1f16b6a5270","modified":1689404219831},{"_id":"source/css/custom.css","hash":"72b3900fac2a8af003a1bf4abba69dcfa6251f22","modified":1689352661987},{"_id":"source/img/2.jpg","hash":"be17bb99d17e83cb6ab93c86d929148b005492e5","modified":1689407326892},{"_id":"source/img/1.jpg","hash":"c5cd30762bf902374c6db42dabecb1999378052b","modified":1689403836563},{"_id":"themes/butterfly/_config.yml","hash":"d3cfdcd961e78f4651bc14364fc2e5c4c8ac7240","modified":1689414763989},{"_id":"themes/butterfly/package.json","hash":"a6a032654a36408d7b7274bc9cfe21f89946d29c","modified":1689330172968},{"_id":"themes/butterfly/plugins.yml","hash":"6d68dab3b79accb1bceb4710c8aaab724a45053a","modified":1689330172968},{"_id":"themes/butterfly/languages/default.yml","hash":"d444cbb5c5456aaf27f3fb1b4308634689c7bb53","modified":1689330172937},{"_id":"themes/butterfly/languages/en.yml","hash":"4957fd976c99745d3aa24000a85b2955e8d1cf81","modified":1689330172937},{"_id":"themes/butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1689330172938},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"cc8672dc0c2762b694f689cbeb6e34810f1c194e","modified":1689330172938},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"145ec301db185c8a06de1f34a77ca391e1d2729b","modified":1689330172938},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1689330172939},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1689330172966},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1689330172967},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1689330172966},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1689330172967},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.yml","hash":"92683cb785a29e5a73701b33dba73d3afac268c3","modified":1689330172934},{"_id":"themes/butterfly/README_CN.md","hash":"f6ae7f38d016135340fd25c5fd1be65452b6773d","modified":1689330172936},{"_id":"themes/butterfly/README.md","hash":"5ca893c78f8971f512da55c785b8ccbfa9d37cfc","modified":1689330172936},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1689330172935},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/config.yml","hash":"d9ff4bad9c9664e12729c7a531169a05698a3fd1","modified":1689330172934},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1689330172939},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1689330172939},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1689330172940},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"b50b0afdc41c54279587410c3f82c8cb3c5ff46d","modified":1689330172940},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1689330172946},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1689330172944},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1689330172947},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"c55f05400eb27ab051f47396ec8d4249ce6f71ec","modified":1689330172947},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1689330172969},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1689330172969},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1689330172969},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1689330172969},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1689330172970},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1689330172970},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a3323fcb11cfd3f3e21230737341beb5d76b40aa","modified":1689330172971},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1689330172971},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1689330172972},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1689330172972},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"8ff03b35385f9162e1eb54dceb5fa7f781306caf","modified":1689330172972},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"7222102f9919f8e961d4f1688425845fb7775ada","modified":1689330172973},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"6005907245dd74b153f03afdccfae1abb66bb482","modified":1689330172973},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1689330172973},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1689330172974},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1689330172974},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"b8d95ac1851c37f1dce4b1dd4a1d3ffdff501a03","modified":1689330172974},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1689330172975},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1689330172974},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1689330172975},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1689330172975},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"fc5a80707cf522378be3cf8638ef78bccc88c510","modified":1689330172975},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1689330172975},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1689330172976},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1689330172976},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.yml","hash":"6e0f9470b18bd37d4891282ac73d61676b040e8c","modified":1689330172935},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1689330172987},{"_id":"themes/butterfly/source/css/var.styl","hash":"e1e37a2e932163886789b72624c7348545003f1d","modified":1689330172987},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1689330172935},{"_id":"themes/butterfly/.github/workflows/stale.yml","hash":"4040c76547e270aaf184e9b219a44ca41bbb1b9f","modified":1689330172935},{"_id":"themes/butterfly/source/img/avatar.jpg","hash":"bbf597f4a75a617bed638ac124502fd76068f62b","modified":1689340139886},{"_id":"themes/butterfly/source/img/favicon.png","hash":"f17fd89a2e05a689c4f5481be9ea6b09f7b8d945","modified":1689339562887},{"_id":"themes/butterfly/source/js/foot.js","hash":"65cf405d3e3e37682062d948924d8101b566e31b","modified":1689353615196},{"_id":"themes/butterfly/source/js/main.js","hash":"4fd1cd7a02dedcb686caf6149c35fd8e1fbcafc9","modified":1689330172990},{"_id":"themes/butterfly/source/css/custom.css","hash":"941d80e05e34f710eb978e0040ab14e3a6f727bf","modified":1689350115882},{"_id":"themes/butterfly/source/js/utils.js","hash":"13b2b02118a0f4ec2e9e0bb1b90f5b1a30a70f44","modified":1689330172990},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1689330172942},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1689330172942},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1689341431866},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1689330172943},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1689330172943},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1689330172940},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1689330172940},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1689330172941},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"f5207840c96df6b26ad227433babca4f8c362624","modified":1689330172941},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1689330172942},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1689330172941},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1689330172941},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1689330172942},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1689330172942},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1689330172944},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1689330172944},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1689330172944},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1689330172944},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"3adb731465a4ab14529277fd7867889e0800ad16","modified":1689330172945},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1689330172945},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1689330172945},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1689330172945},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1689330172946},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1689330172946},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1689330172946},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1689330172960},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1689330172948},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"82bb447a5d045980789cf3f9de9d49cc32011b13","modified":1689330172961},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1689330172961},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1689330172956},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1689330172964},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1689330172964},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1689330172963},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1689330172963},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1689330172964},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1689330172964},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1689330172965},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1689330172965},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1689330172965},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1689330172965},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1689330172965},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1689330172966},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1689330172966},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"431b4a252443e224872bd6b4f6aa76ed1679a82c","modified":1689330172977},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"ba94ceb40d7c81372a76103d958dcc2cc6a84f00","modified":1689330172966},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1689330172977},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"e43017dbc73e0ce95dcfcb9dfb4fcce0c1715dd4","modified":1689330172977},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1689330172978},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"3969f599e8657adf8c3ce287d83f5d0a23f276a9","modified":1689330172979},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1689330172979},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"20303c0dad28e5c5335ce2fa6582f1fafae5b628","modified":1689330172979},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1689330172979},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1689330172980},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1689330172980},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1689330172980},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc029f5e00d7904c0878efd20dd4e09fc55e1d03","modified":1689330172980},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1689330172980},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1689330172981},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"9066a62e442affce3a923a06a90486bf9d364e0e","modified":1689330172981},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1689330172980},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"824b2b2d2ee72583b9e009c0bb13e29e806534cc","modified":1689330172980},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"4c86c10f8ec0c8fb60b400a5a2f14699d3155be4","modified":1689330172981},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"e2869b71266bd49285f22da89560d875e8c61541","modified":1689353955452},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1689330172982},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1689330172982},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1689330172981},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1689330172982},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1689330172982},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"57d333ef47bfb8fd22da31f600527c9d91e8e322","modified":1689330172982},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1689330172988},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1689330172983},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1689330172983},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1689330172984},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1689330172984},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1689330172984},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"7c463ba25b3b54f0f46dfd75971d792816e942a8","modified":1689330172984},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1689330172984},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1689330172985},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1689330172986},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1689330172984},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1689330172985},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1689330172985},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1689330172986},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1689330172989},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"0010c7a10d265c4329f0fd4db85b4a9ea7ba06b5","modified":1689330172947},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"40e76d6da538cb3c1ef6b79ffc0adfa64fe6b8ba","modified":1689330172990},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1689330172947},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1689330172948},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1689330172948},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1689330172948},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1689330172949},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1689330172949},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1689330172949},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1689330172949},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"c42bbce31fcd8846cf3360f4c383dec9368daeba","modified":1689330172950},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1689330172950},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1689330172950},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1689330172950},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1689330172951},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1689330172951},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"b47698e153c73cb29286b19bec5ddd920cb7ffba","modified":1689330172952},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f8b73bc63ec1b45d86aa3891d8c81ef4d5980943","modified":1689330172952},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1689330172952},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b19b123df682b23491b17dcca386d79062cd8f6e","modified":1689330172953},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a56edeb1ce2f1b1fb0e866a30543f274b9f7d69e","modified":1689330172953},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"1a20b11fa0e6b1943e9b4d81e197a25ca36af66d","modified":1689330172953},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"c5e131d65a7ad30f3cb98ac3b94cd2f6a94c22e9","modified":1689330172954},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"7c7fbe27d82becc9ee509765f1195c69f5864a0b","modified":1689330172953},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1689330172955},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1689330172955},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"386a2b371644c2682560733617561ba6e6bf9ab2","modified":1689330172956},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f618457d62ef35d78a31e7fb1e375a462f64b228","modified":1689330172955},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4bb4cf58e219dfb8787273c931b1ea978b2ab88f","modified":1689330172955},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1689330172956},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1689330172957},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"6b0d28671afd5ed286a714f25ba16256a2e7d880","modified":1689330172956},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1689330172957},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1689330172957},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1689330172958},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"da94966a9650ef3e4c69f3ee93758b30fa42cb78","modified":1689330172958},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1689330172958},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1689330172959},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1689330172959},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1689330172960},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1689330172959},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1689330172960},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"2f3af113713563e34b10bbe998cc15008f81c85a","modified":1689330172960},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1689330172961},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"ba04174d977da988a1d49c06641262c413352346","modified":1689330172961},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1689330172962},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1689330172962},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1689330172962},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1689330172963},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1689330172962},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1689330172963},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1689330172977},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1689330172978},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1689330172983},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"a102a6cacf7b20183946a54580867a964f3674c4","modified":1689330172990},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1689330172978},{"_id":"themes/butterfly/source/js/jquery.js","hash":"aab820a7c9bb693c5df41f9886179eba2649b028","modified":1689353150875},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1689330172978},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"bbe930d8425bdaee2a5ba3cade42b617cee42934","modified":1689330172990},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1689330172978},{"_id":"source/css/LXGWZhenKai.ttf","hash":"3e173155b120631bbf5c7a7921308977bdd48cf2","modified":1689352637215},{"_id":"public/css/custom.css","hash":"d6a18ee419b53590c6c6f241718b63c380658959","modified":1689414586575},{"_id":"public/search.xml","hash":"ae35b054be443eaa977682983de5fc168ab75d0f","modified":1689414586575},{"_id":"public/categories/index.html","hash":"e25d2204844317742b16ef78a67b6fd3a0dde23e","modified":1689688873420},{"_id":"public/tags/index.html","hash":"b69c73de826d96ca9448355bca71ccc6b6b508f3","modified":1689688873420},{"_id":"public/categories/coding/index.html","hash":"d6ff4e1d6c81371d5429c3040f886b22e9a224d3","modified":1689688873420},{"_id":"public/archives/index.html","hash":"b2215f5bf92bfa8122f905ea6a79c1a722bb56ea","modified":1689688873420},{"_id":"public/archives/2023/index.html","hash":"42006facac9de8925c8f12dd18b760c3cff8fdb5","modified":1689688873420},{"_id":"public/archives/2023/07/index.html","hash":"c79fd7c45c1bc7e0ccf8ac265b75867fe8d0cef3","modified":1689688873420},{"_id":"public/tags/juc/index.html","hash":"1f9df98ebd5f3fa443f8570abcd89d39309becb5","modified":1689688873420},{"_id":"public/tags/多线程/index.html","hash":"43f30fee71f6f22734eab0b9a4d31154ce7c41d3","modified":1689688873420},{"_id":"public/tags/并发编程/index.html","hash":"1723c0f6bc445cfda2aad15de5eecd0e234f2bf2","modified":1689688873420},{"_id":"public/tags/nginx/index.html","hash":"0708e64104bcf85b596ae78aa6a2a70f6c304642","modified":1689688873420},{"_id":"public/about/index.html","hash":"49f28888b9ab05058d7ea6a88c90ba5982ae342e","modified":1689688873420},{"_id":"public/posts/42310.html","hash":"44763c1dd7f7fed751ec3c9b9f6e361fb8776e1d","modified":1689687939700},{"_id":"public/posts/58122.html","hash":"f64bada6153c315f51a13c5167dbeaf2c8a8b520","modified":1689687939700},{"_id":"public/index.html","hash":"be622bc4bc8e388184b5189d0070f22bf0e64aa8","modified":1689688873420},{"_id":"public/img/avatar.jpg","hash":"bbf597f4a75a617bed638ac124502fd76068f62b","modified":1689414586575},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1689414586575},{"_id":"public/img/favicon.png","hash":"f17fd89a2e05a689c4f5481be9ea6b09f7b8d945","modified":1689414586575},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1689414586575},{"_id":"public/img/3.jpg","hash":"3179c917c87135f463e5188276306246b4c95398","modified":1689414586575},{"_id":"public/img/6.jpg","hash":"520711bfb0a80d70169abe3ed4dccc81f1eba558","modified":1689414586575},{"_id":"public/img/8.jpg","hash":"2f75d182bcaf73cbda43017927408019c24ae65c","modified":1689414586575},{"_id":"public/img/5.jpg","hash":"45adc346caa9091ee0fae28dababd8f062e3ae08","modified":1689414586575},{"_id":"public/img/4.jpg","hash":"46c3b721ccb4c45049b97075e342d1f16b6a5270","modified":1689414586575},{"_id":"public/img/7.jpg","hash":"783e5a80f367f165d7fade36baf6cc55d4c61c2a","modified":1689414586575},{"_id":"public/js/foot.js","hash":"c5462aab335dca72e6cc7e4427e3e4996b9357c5","modified":1689414586575},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1689414586575},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1689414586575},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1689414586575},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1689414586575},{"_id":"public/css/index.css","hash":"b3e22c48b65075f4ee8c026344f026c25fe18c8d","modified":1689414586575},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1689414586575},{"_id":"public/js/jquery.js","hash":"0fa72756e48c33a6feeace1ffa5d790d58b53729","modified":1689414586575},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1689414586575},{"_id":"public/img/2.jpg","hash":"be17bb99d17e83cb6ab93c86d929148b005492e5","modified":1689414586575},{"_id":"public/img/1.jpg","hash":"c5cd30762bf902374c6db42dabecb1999378052b","modified":1689414586575},{"_id":"public/css/LXGWZhenKai.ttf","hash":"3e173155b120631bbf5c7a7921308977bdd48cf2","modified":1689414586575}],"Category":[{"name":"coding","_id":"clk3ttrq900060suj4rmx5qgn"}],"Data":[],"Page":[{"title":"关于","date":"2023-07-15T01:31:31.000Z","_content":"\n<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，这样内容的广度和深度都会提升\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果我的某篇文章如果对你有些帮助或启发，那我很开心~","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2023-07-15 09:31:31\n---\n\n<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，这样内容的广度和深度都会提升\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果我的某篇文章如果对你有些帮助或启发，那我很开心~","updated":"2023-07-15T06:26:46.684Z","path":"about/index.html","comments":1,"layout":"page","_id":"clk3ttrq200000suj5vryfk52","content":"<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，这样内容的广度和深度都会提升\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果我的某篇文章如果对你有些帮助或启发，那我很开心~","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>&emsp;&emsp;Hi，我是Yancey，一个略懂前端的Java开发工程师。从大学开始，我就很执着于记录笔记和想法，它能给我带来一种安心的感觉，使用的都是Typora，有道云，语雀之类的个人笔记工具，因为只有自己看，所以内容天马行空，追求内容直观简单而不用不在意排版。最近萌生了搭建独立博客的想法，主要有两个原因：\n<p>\n&emsp;&emsp;1、由于写博客会默认去假定会有人去阅读，所以在收集和补充资料时比自己做笔记会更加详细，这样内容的广度和深度都会提升\n<p>\n&emsp;&emsp;2、从上大学到工作这几年，互联网上的前辈可以说是我的五分之四个老师，无论是编程技能，生活技能，还是对这个世界的思考。总有一篇文章文章能让我豁然开朗，走出困惑。所以一直都很感谢这些拥有Geek精神的无私分享者。作为受益者，我也觉得我有义务分享自己的所学，让后来者少走一些弯路。所以如果我的某篇文章如果对你有些帮助或启发，那我很开心~"},{"title":"categories","date":"2023-07-14T17:44:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-07-15 01:44:20\ntype: \"categories\"\n---\n","updated":"2023-07-14T17:45:15.795Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clk3ttrq400010sujaus8g0j4","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"tags","date":"2023-07-15T01:31:31.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-07-15 09:31:31\ntype: \"tags\"\n---\n","updated":"2023-07-15T01:31:52.879Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clk3ttrq500020suje15yf5na","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"_content":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","source":"css/custom.css","raw":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","date":"2023-07-14T16:37:41.987Z","updated":"2023-07-14T16:37:41.987Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"clk3ttrq600030sujfuyrc4vd","content":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","site":{"data":{}},"cover":false,"excerpt":"","more":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}"}],"Post":[{"title":"juc","date":"2023-07-14T16:00:00.000Z","abbrlink":42310,"_content":"# 1、java多线程基本概念\n## 1.1、进程和线程\n\n1. **进程**\n- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 \n- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 \n- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） \n\n2. **线程**\n- 一个进程之内可以分为一到多个线程。 \n- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 \n- **Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器**\n## 1.2、并发和并行\n并发：线程轮流使用CPU\n并行：多核cpu下，多个核同时调度运行线程\n\n## 1.3、多线程的应用\n### 1.3.1、异步调用\n比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 \n### 1.3.2、提升效率\n充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。\n```java\n计算 1 花费 10 ms\n计算 2 花费 11 ms\n计算 3 花费 9 ms\n汇总需要 1 ms\n```\n\n- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms \n- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms \n> 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n\n# 2、java线程\n## 2.1、线程的创建\n### 2.1.1、直接使用Thread\n```java\n// 创建线程对象\nThread t = new Thread() {\n    public void run() {\n        // 要执行的任务\n    }\n};\n// 启动线程\nt.start();\n```\n### 2.1.2、使用 Runnable 配合 Thread \n```java\nRunnable runnable = new Runnable() {\n    public void run(){\n        // 要执行的任务\n    }\n};\n// 创建线程对象\nThread t = new Thread( runnable );\n// 启动线程\nt.start();\n```\njava8可用lambda精简\n```java\n// 创建任务对象\nRunnable task2 = () -> log.debug(\"hello\");\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nThread t2 = new Thread(task2, \"t2\");\nt2.start();\n```\n### 2.1.3、FutureTask 配合 Thread \nFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\n\n```java\n// 创建任务对象\nFutureTask<Integer> task3 = new FutureTask<>(() -> {\n    log.debug(\"hello\");\n    return 100;\n});\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nnew Thread(task3, \"t3\").start();\n\n// 主线程阻塞，同步等待 task 执行完毕的结果\nInteger result = task3.get();\nlog.debug(\"结果是:{}\", result);\n```\n## 2.2、查看进程线程\n### 2.2.1、windows\n\n1. tasklist 查看进程 \n2. taskkill 杀死进程 \n3. netstat -ano|findstr 8080 根据端口查看进程\n### 2.2.2、linux\n\n1. ps -fe 查看所有进程 \n2. kill 杀死进程\n3.  top -Hp <PID> 查看某个进程（PID）的所有线程 \n4. netstat -nlp|grep 8080 根据端口查看进程\n### 2.2.3、JDK\n\n1. jps 命令查看所有 Java 进程\n2.  jstack <PID> 查看某个 Java 进程（PID）的所有线程状态\n3.  jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）\n\n## 2.3、线程运行原理\n\n1. **线程创建**\n\n每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成\n，栈帧对应着每次方法调用所占内存\n\n2. **上下文切换**\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 \n> 线程的 cpu 时间片用完 \n> 垃圾回收 \n> 有更高优先级的线程需要运行 \n> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 \n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 \n\n## 2.4、start与run\n\n- 直接调用 run 是在主线程中执行了 run，没有启动新的线程 \n- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n\n## 2.5、sleep 与 yield \n\n1. **sleep**\n- 1. 调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞） \n- 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException \n- 3. 睡眠结束后的线程未必会立刻得到执行 \n\n2. **yield**\n- 1. 调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程 \n- 2. 具体的实现依赖于操作系统的任务调度器 \n\n## 2.6、join\njoin：t1调用t2的join方法，会先执行t2，然后执行t1\n如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间\n```java\nstatic int r = 0;\npublic static void main(String[] args) throws InterruptedException {\n    test1();\n}\n\nprivate static void test1() throws InterruptedException {\n    log.debug(\"开始\");\n    Thread t1 = new Thread(() -> {\n        log.debug(\"开始\");\n        sleep(1);\n        log.debug(\"结束\");\n        r = 10;\n    });\n    t1.start();\n    // t1.join();\n    log.debug(\"结果为:{}\", r);\n    log.debug(\"结束\");\n}\n```\n> 如果不加t1.join()结果为0，加上以后结果为1\n\n\n## 2.7、interrupt\n### 2.7.1、打断阻塞状态的线程\nsleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断\n```java\nprivate static void test1() throws InterruptedException {\n    Thread t1 = new Thread(()->{\n        sleep(1);\n    }, \"t1\");\n    t1.start();\n    sleep(0.5);\n    t1.interrupt();\n    log.debug(\" 打断状态: {}\", t1.isInterrupted());\n}\n```\n输出\n```java\njava.lang.InterruptedException: sleep interrupted\n     at java.lang.Thread.sleep(Native Method)\n     at java.lang.Thread.sleep(Thread.java:340)\n     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)\n     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)\n     at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)\n     at java.lang.Thread.run(Thread.java:745)\n21:18:10.374 [main] c.TestInterrupt - 打断状态: false\n```\n### 2.7.2、打断正常运行的线程\n打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）\n```java\nprivate static void test2() throws InterruptedException {\n    Thread t2 = new Thread(()->{\n        while(true) {\n            Thread current = Thread.currentThread();\n            boolean interrupted = current.isInterrupted();\n            if(interrupted) {\n                log.debug(\" 打断状态: {}\", interrupted);\n                break;\n            }\n        }\n    }, \"t2\");\n    t2.start();\n    sleep(0.5);\n    t2.interrupt();\n}\n```\n输出\n```java\n20:57:37.964 [t2] c.TestInterrupt - 打断状态: true \n```\n\n## 2.8、主线程与守护线程\n默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 \n\n例\n```java\nlog.debug(\"开始运行...\");\nThread t1 = new Thread(() -> {\n    log.debug(\"开始运行...\");\n    sleep(2);\n    log.debug(\"运行结束...\");\n}, \"daemon\");\n// 设置该线程为守护线程\nt1.setDaemon(true);\nt1.start();\n\nsleep(1);\nlog.debug(\"运行结束...\");\n```\n输出\n```java\n08:26:38.123 [main] c.TestDaemon - 开始运行... \n08:26:38.213 [daemon] c.TestDaemon - 开始运行... \n08:26:39.215 [main] c.TestDaemon - 运行结束...\n```\n\n> **注意 **\n> - 垃圾回收器线程就是一种守护线程 \n> - Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 \n\n\n## 2.9、线程状态\n| 状态   | 说明 |\n| --- | --- |\n| NEW | 初始状态:线程被创建，但还没有调用start()方法 |\n| RUNNABLE | 运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作\"运行\" |\n| BLOCKED | 阻塞状态:表示线程阻塞于锁 |\n| WAITING | 等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) |\n| TIMEWAITING | 超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的 |\n| TERMINATED | 终止状态:表示当前线程已经执行完毕 |\n\n\n![image.png](/img/2.jpg)\n# 3、共享模型之管程\n管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的\n## 3.1、monitor\nMonitor 被翻译为**监视器**或**管程**\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针\n\n### 3.1.1、Monitor结构\n**结构**：owner  entryList  waitSet\n![image.png](/img/3.jpg)\n\n### 3.1.2、Monitor原理\n（1）刚开始monitor中owner为null \n（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程 \n（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞 \n（4）t1执行完会唤醒entrylist中的某个线程（不公平）\n（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n## 3.2、java对象结构\n\n1. **对象头**\n\n包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）\n![image.png](/img/4.jpg)\n\n2. **实例数据**\n\n实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息\n\n3. **对齐填充**\n\n对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。\n## 3.3、synchronized升级\n### 3.3.1、偏向锁\n> 使用场景：如果只有一个线程，就不需要每次的申请释放锁\n\n只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 \n### 3.3.2、轻量级锁\n> 使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化\n\n![](/img/5.jpg)\n\n1. 创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象\n2. 让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录\n3. 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁\n4. 如果 cas 失败，有两种情况 \n\n（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 \n（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）\n\n5. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一\n6. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 \n\n（1）成功，则解锁成功 \n（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\n### 3.3.3、重量级锁\n> 使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁\n\n![](/img/6.jpg)\n\n1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\n2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 \n\n（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 \n（2）然后自己进入 Monitor 的 EntryList阻塞队列\n\n3. 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）\n> 调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n### 3.3.4、自旋锁\n重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)\n\n## 3.4、wait/notify\nOwner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争\n\n### 3.4.1、sleep和wait的区别？\n\n1.  sleep 是 Thread 方法，而 wait 是 Object 的方法 \n2.  sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 \n3.  sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 \n\n## 3.5、park/unpark\n它们是 LockSupport 类中的方法\n```java\n// 暂停当前线程\nLockSupport.park(); \n// 恢复某个线程的运行\nLockSupport.unpark(暂停线程对象)\n```\n\n### 3.5.1、与 Object 的 wait & notify 相比 \n\n- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\n- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 \n- park & unpark 可以先 unpark，而 wait & notify 不能先 notify \n\n### 3.5.2、原理\n每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex \n\n核心部分是counter，我们可以理解为一个标记位。\n当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。\n当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。\n## 3.6、死锁\n多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁\n### 3.6.1、死锁的必要条件\n\n1. 互斥条件：一个资源一次只能被一个进程使用\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放\n3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺\n4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系\n### 3.6.2、死锁的实现\n```java\n/**\n * 实现一个死锁\n * 如果把lock(target, owner);放到上面则不会死锁\n */\npublic class DeadLock {\n    public static void main(String[] args) throws InterruptedException {\n        final Object owner = new Object();\n        final Object target = new Object();\n        //开启一个新线程\n        new Thread(() -> {\n            try {\n                lock(owner, target);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        //主线程\n        lock(target, owner);\n    }\n    public static void lock(Object owner, Object target) throws InterruptedException {\n        synchronized (owner) {\n            Thread.sleep(1000);\n            synchronized (target) {\n                System.out.println(\"success\");\n            }\n        }\n    }\n}\n```\n### 3.6.3、定位死锁\n检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁\n### 3.6.4、哲学家就餐问题\n![image.png](/img/7.jpg)\n有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 \n\n1. 筷子类\n```java\nclass Chopstick {\n    String name;\n    \n    public Chopstick(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return \"筷子{\" + name + '}';\n    }\n}\n```\n\n2. 哲学家类\n```java\nclass Philosopher extends Thread {\n    Chopstick left;\n    Chopstick right;\n    \n    public Philosopher(String name, Chopstick left, Chopstick right) {\n        super(name);\n        this.left = left;\n        this.right = right;\n    }\n    \n    private void eat() {\n        log.debug(\"eating...\");\n        Sleeper.sleep(1);\n    }\n    \n    @Override\n    public void run() {\n        while (true) {\n            // 获得左手筷子\n            synchronized (left) {\n                // 获得右手筷子\n                synchronized (right) {\n                    // 吃饭\n                    eat();\n                }\n                // 放下右手筷子\n            }\n            // 放下左手筷子\n        }\n    }\n}\n```\n\n3. 就餐\n```java\nChopstick c1 = new Chopstick(\"1\");\nChopstick c2 = new Chopstick(\"2\");\nChopstick c3 = new Chopstick(\"3\");\nChopstick c4 = new Chopstick(\"4\");\nChopstick c5 = new Chopstick(\"5\");\n\nnew Philosopher(\"苏格拉底\", c1, c2).start();\nnew Philosopher(\"柏拉图\", c2, c3).start();\nnew Philosopher(\"亚里士多德\", c3, c4).start();\nnew Philosopher(\"赫拉克利特\", c4, c5).start();\nnew Philosopher(\"阿基米德\", c5, c1).start();\n```\n## 3.7、活锁\n两个线程互相改变对方的结束条件导致谁也无法结束\n> eg：共享变量count为10000, t1线程while count > 0, count-- ;t2线程while count < 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行\n\n\n## 3.8、**ReentrantLock**\n相对于 synchronized 它具备如下特点 \n\n1. 可中断 \n2. 可以设置超时时间 \n3. 可以设置为公平锁 （默认不公平）\n4. 支持多个条件变量 \n\n与 synchronized 一样，都支持可重入 \n# 4、共享模型之内存\n## 4.1、java内存模型（jmm）\nJava内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本\n## 4.2、线程安全性的三个体现\n**原子性**：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）\n**可见性**：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）\n**有序性**：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）\n# 5、共享模型之无锁\n## 5.1、CAS\n### 5.1.1、CAS基本概念\nCAS是所有原子类的底层原理，乐观锁主要采用CAS算法。\nCAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。\n> 1. CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性\n> 2. CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果\n\n\n### 5.1.2、CAS问题\n多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。\n\n**解决方案：**\n使用AtomicStampReference \nAtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验\n\n## 5.2、volatile\n### 5.2.1、如何保证可见性和有序性\n\n1. **保证可见性（缓存一致性协议MESI）**\n\n首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用**MESI协议**保证缓存一致性。\n如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu**总线嗅探机制**监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值\n\n> **M 修改** (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中\n**E 独享、互斥** (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。\n**S 共享** (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态\n**I 无效** (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态\n\n\n> 涉及到的指令\nlock(锁定)：将一个变量标识为被一个线程独占状态\nstore(存储)：作用于工作内存的变量,将变量传输到主内存中\nwrite(写入)：将store入主内存的变量,放入到主内存的变量中\n\n\n2. **保证有序性（禁止指令重排优化）**\n\n多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的\n内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序\n\n## 5.3、原子类\n| 类型   | 具体类 |\n| --- | --- |\n| Atomic 基本类型原子类   | AtomicInteger AtomicLong AtomicBoolean |\n| AtomicArray 数组类型原子类 | AtomicIntegerArray  AtomicLongArray AtomicReferenceArray |\n| AtomicReference 引用类型原子类 | AtomicReference AtomicStampedReference AtomicMarkableReference |\n| AtomicFieldUpdate 升级类型原子类 | AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater |\n\n\n# 6、共享模式之工具\n## 6.1、线程池\n### 6.1.1、**ThreadPoolExecutor**\n\n1. **构造方法**\n\n通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建\n\n> 1. corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。\n> 2. maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。\n> 3. keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。\n> 4. unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n> 5. workQueue：缓存队列，用来存放等待被执行的任务。\n> 6. threadFactory 线程工厂\n> 7. handler：拒绝策略\n（1）abortPolicy：抛出异常（默认）\n（2）discardPolicy：放弃本次任务\n（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代\n（4）callerrunPolicy：让调用者运行任务\n\n\n2. **工作原理**\n\n如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n如果当前线程池中正在执行任务的的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；\n如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；\n如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理\n### 6.1.2、Executors类中提供的工厂方法\n根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池\n\n1. **newFixedThreadPool**\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n> 特点：\n> - 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 \n> - 阻塞队列是无界的，可以放任意数量的任务 \n> \n评价：\n> 适用于任务量已知，相对耗时的任务\n\n\n2. **newCachedThreadPool**\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n> 特点 \n> - 核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 \n>    - 全部都是救急线程（60s 后可以回收）\n>    - 救急线程可以无限创建 \n> - 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）\n> \n评价：\n> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程\n> 适合任务数比较密集，但每个任务执行时间较短的情况\n\n\n3. **newSingleThreadExecutor**\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n使用场景： \n希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。\n任务执行完毕，这唯一的线程也不会被释放。 \n\n### 6.1.3、创建多大的线程池\n\n- 过小会导致程序不能充分地利用系统资源、容易导致饥饿 \n- 过大会导致更多的线程上下文切换，影响性能\n\n1. **CPU 密集型运算 **\n\n通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 \n\n2. **I/O密集型**\n\nCPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 \n经验公式如下 ：\n`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间` \n\n## 6.2、锁\n### 6.2.1、AQS\n\n1. 基本概念\n\nAbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...\n\n2. 原理 \n\n它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）\n\n3. 实现\n\n自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n> **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的\n\n### 6.2.2、ReentrantLock\n**实现原理**\n\n1. 首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能\n2. 它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法\n3. 加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列\n4. 持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）\n\n**条件变量——Condition**\nCondition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程\n### 6.2.3、**ReentrantReadWriteLock**\n#### 4.2.3.1、ReentrantReadWriteLock基本概念\nReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用\n#### 4.2.3.2、锁获取过程\n\n1. 获取读锁\n\n如果写锁没有被另一个线程持有，则获取读锁并立即返回。     \n \t如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。\n\n4. 获取写入锁\n\n如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *\n如果当前线程持有写锁，则将写锁计数 +1，然后返回\n如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。\n\n#### 4.2.3.3、常见问题\n\n1. **读锁和写锁的可重入性**\n\n在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加\n\n2. **当前线程获取锁失败，被阻塞的后续操作是什么？**\n\n获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁\n\n3. **锁降级是怎么降级的？**\n\n在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）\n\n## 6.3、工具\n### 6.3.1、Semaphore\n\n1. **概念**\n\nSemaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）\n```java\npublic class DataSourcePool {\n \n    private final CopyOnWriteArrayList<Connection> list;\n    \n    //用到了信号量\n    private final Semaphore semaphore;\n \n    public DataSourcePool(int size) throws SQLException {\n        list = new CopyOnWriteArrayList<>();\n        semaphore = new Semaphore(size);\n        for (int i=0;i<size;i++){\n            Connection connection = DriverManager.getConnection(\"url\");\n            list.add(connection);\n        }\n    }\n    \n    //使用同步方法获取\n    public synchronized Connection getConnection() throws InterruptedException {\n        //先将当前信号量-1，如果为0，将阻塞\n        semaphore.acquire();\n        return list.remove(0);\n    }\n \n    public synchronized void  close(Connection connection){\n        //信号量+1\n        semaphore.release();\n        list.add(connection);\n    }\n}\n```\n\n2. **原理**\n\nSemaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n\n1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。\n2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state=state-1。state<0,令牌数量不足，加入阻塞队列。>=0则获取成功\n3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state=state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程\n### 6.3.2、CountdownLatch\n\n1. **概念**\n\nCountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n    ExecutorService service = Executors.newFixedThreadPool(4);\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(()->{\n        try {\n            log.debug(\"waiting...\");\n            latch.await();\n            log.debug(\"wait end...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n    \n}\n```\n```java\n18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting... \n18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2 \n18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end...\n```\n\n2. **原理**\n\nCountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n1、初始化CountDownLatch实际就是设置了AQS的state为计数的值\n2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值\n3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试\n\n3. **和join的区别？**\n\nCountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成\n\n### 6.3.3、CyclicBarrier\n\n1. **概念**\n\nCyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行\n实现王者荣耀10个人都加载完才开始游戏\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        int count = 10;\n        CyclicBarrier cb = new CyclicBarrier(count, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"全部加载完毕\");\n            }\n        });\n        ExecutorService executorService = Executors.newFixedThreadPool(count);\n        for (int x = 0; x < count; x++) {\n            executorService.execute(new Worker(cb));\n        }\n    }\n}\n\nclass Worker extends Thread {\n    CyclicBarrier cyclicBarrier;\n    public Worker(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" 已加载完\");\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java\npool-1-thread-1 已加载完\npool-1-thread-5 已加载完\npool-1-thread-4 已加载完\npool-1-thread-3 已加载完\npool-1-thread-6 已加载完\npool-1-thread-2 已加载完\npool-1-thread-7 已加载完\npool-1-thread-8 已加载完\npool-1-thread-9 已加载完\npool-1-thread-10 已加载完\n全部加载完毕\n\n```\n\n2. **原理**\n\n1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count\n2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；\n3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；\n4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；\n5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。\n\n## 6.4、线程安全集合类\n### 6.4.1、概述\n![image.png](/img/8.jpg)\n线程安全实现类有三类：\n\n1. 遗留的线程安全集合如 Hashtable ， Vector \n2. 使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）\n>    - Collections.synchronizedCollection \n>    - Collections.synchronizedList \n>    - Collections.synchronizedMap \n>    - Collections.synchronizedSet \n>    - Collections.synchronizedNavigableMap \n>    - Collections.synchronizedNavigableSet\n>    - Collections.synchronizedSortedMap \n>    - Collections.synchronizedSortedSet \n\n2. JUC下的安全集合: Blocking、CopyOnWrite、Concurrent \n> - Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)\n> - CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)\n> - Concurrent 类型的容器 （内部很多操作使用cas优化）\n>    - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 \n>    - 弱一致性 \n>       - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 \n>       - 求大小弱一致性，size 操作未必是 100% 准确 \n>       - 读取弱一致性 \n\n> 遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历\n\n### 6.4.2、concurrentHashMap\n**JDK1.8前**\nConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。\n\n元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部\n\n锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数\n\n\n> ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表\n\n\n**JDK1.8**\n\n在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全\n\n1. 初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 \n2. 插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 \n3. 扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 \n4. 查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。\n\n\n\n### 6.4.3、BlockingQueue\n主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue \n\n1. 区别\n\n（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表\n（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）\n（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现\n\n### 6.4.4、ConcurrentLinkedQueue \nConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）\n\n### 6.4.5、CopyOnWriteArrayList\n\n1. 首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行\n2. 写数据时会加ReentLocak锁，防止并发写入丢失数据的问题\n3. 写操作结束后会把原数组指向新数组\n4. CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景\n\n\n","source":"_posts/JUC.md","raw":"---\ntitle: juc\ndate: 2023/07/15\ncategories:\n  - coding\ntags:\n  - juc\n  - 多线程\n  - 并发编程\nabbrlink: 42310\n---\n# 1、java多线程基本概念\n## 1.1、进程和线程\n\n1. **进程**\n- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 \n- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 \n- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） \n\n2. **线程**\n- 一个进程之内可以分为一到多个线程。 \n- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 \n- **Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器**\n## 1.2、并发和并行\n并发：线程轮流使用CPU\n并行：多核cpu下，多个核同时调度运行线程\n\n## 1.3、多线程的应用\n### 1.3.1、异步调用\n比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 \n### 1.3.2、提升效率\n充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。\n```java\n计算 1 花费 10 ms\n计算 2 花费 11 ms\n计算 3 花费 9 ms\n汇总需要 1 ms\n```\n\n- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms \n- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms \n> 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n\n# 2、java线程\n## 2.1、线程的创建\n### 2.1.1、直接使用Thread\n```java\n// 创建线程对象\nThread t = new Thread() {\n    public void run() {\n        // 要执行的任务\n    }\n};\n// 启动线程\nt.start();\n```\n### 2.1.2、使用 Runnable 配合 Thread \n```java\nRunnable runnable = new Runnable() {\n    public void run(){\n        // 要执行的任务\n    }\n};\n// 创建线程对象\nThread t = new Thread( runnable );\n// 启动线程\nt.start();\n```\njava8可用lambda精简\n```java\n// 创建任务对象\nRunnable task2 = () -> log.debug(\"hello\");\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nThread t2 = new Thread(task2, \"t2\");\nt2.start();\n```\n### 2.1.3、FutureTask 配合 Thread \nFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\n\n```java\n// 创建任务对象\nFutureTask<Integer> task3 = new FutureTask<>(() -> {\n    log.debug(\"hello\");\n    return 100;\n});\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nnew Thread(task3, \"t3\").start();\n\n// 主线程阻塞，同步等待 task 执行完毕的结果\nInteger result = task3.get();\nlog.debug(\"结果是:{}\", result);\n```\n## 2.2、查看进程线程\n### 2.2.1、windows\n\n1. tasklist 查看进程 \n2. taskkill 杀死进程 \n3. netstat -ano|findstr 8080 根据端口查看进程\n### 2.2.2、linux\n\n1. ps -fe 查看所有进程 \n2. kill 杀死进程\n3.  top -Hp <PID> 查看某个进程（PID）的所有线程 \n4. netstat -nlp|grep 8080 根据端口查看进程\n### 2.2.3、JDK\n\n1. jps 命令查看所有 Java 进程\n2.  jstack <PID> 查看某个 Java 进程（PID）的所有线程状态\n3.  jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）\n\n## 2.3、线程运行原理\n\n1. **线程创建**\n\n每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成\n，栈帧对应着每次方法调用所占内存\n\n2. **上下文切换**\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 \n> 线程的 cpu 时间片用完 \n> 垃圾回收 \n> 有更高优先级的线程需要运行 \n> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 \n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 \n\n## 2.4、start与run\n\n- 直接调用 run 是在主线程中执行了 run，没有启动新的线程 \n- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n\n## 2.5、sleep 与 yield \n\n1. **sleep**\n- 1. 调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞） \n- 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException \n- 3. 睡眠结束后的线程未必会立刻得到执行 \n\n2. **yield**\n- 1. 调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程 \n- 2. 具体的实现依赖于操作系统的任务调度器 \n\n## 2.6、join\njoin：t1调用t2的join方法，会先执行t2，然后执行t1\n如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间\n```java\nstatic int r = 0;\npublic static void main(String[] args) throws InterruptedException {\n    test1();\n}\n\nprivate static void test1() throws InterruptedException {\n    log.debug(\"开始\");\n    Thread t1 = new Thread(() -> {\n        log.debug(\"开始\");\n        sleep(1);\n        log.debug(\"结束\");\n        r = 10;\n    });\n    t1.start();\n    // t1.join();\n    log.debug(\"结果为:{}\", r);\n    log.debug(\"结束\");\n}\n```\n> 如果不加t1.join()结果为0，加上以后结果为1\n\n\n## 2.7、interrupt\n### 2.7.1、打断阻塞状态的线程\nsleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断\n```java\nprivate static void test1() throws InterruptedException {\n    Thread t1 = new Thread(()->{\n        sleep(1);\n    }, \"t1\");\n    t1.start();\n    sleep(0.5);\n    t1.interrupt();\n    log.debug(\" 打断状态: {}\", t1.isInterrupted());\n}\n```\n输出\n```java\njava.lang.InterruptedException: sleep interrupted\n     at java.lang.Thread.sleep(Native Method)\n     at java.lang.Thread.sleep(Thread.java:340)\n     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)\n     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)\n     at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)\n     at java.lang.Thread.run(Thread.java:745)\n21:18:10.374 [main] c.TestInterrupt - 打断状态: false\n```\n### 2.7.2、打断正常运行的线程\n打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）\n```java\nprivate static void test2() throws InterruptedException {\n    Thread t2 = new Thread(()->{\n        while(true) {\n            Thread current = Thread.currentThread();\n            boolean interrupted = current.isInterrupted();\n            if(interrupted) {\n                log.debug(\" 打断状态: {}\", interrupted);\n                break;\n            }\n        }\n    }, \"t2\");\n    t2.start();\n    sleep(0.5);\n    t2.interrupt();\n}\n```\n输出\n```java\n20:57:37.964 [t2] c.TestInterrupt - 打断状态: true \n```\n\n## 2.8、主线程与守护线程\n默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 \n\n例\n```java\nlog.debug(\"开始运行...\");\nThread t1 = new Thread(() -> {\n    log.debug(\"开始运行...\");\n    sleep(2);\n    log.debug(\"运行结束...\");\n}, \"daemon\");\n// 设置该线程为守护线程\nt1.setDaemon(true);\nt1.start();\n\nsleep(1);\nlog.debug(\"运行结束...\");\n```\n输出\n```java\n08:26:38.123 [main] c.TestDaemon - 开始运行... \n08:26:38.213 [daemon] c.TestDaemon - 开始运行... \n08:26:39.215 [main] c.TestDaemon - 运行结束...\n```\n\n> **注意 **\n> - 垃圾回收器线程就是一种守护线程 \n> - Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 \n\n\n## 2.9、线程状态\n| 状态   | 说明 |\n| --- | --- |\n| NEW | 初始状态:线程被创建，但还没有调用start()方法 |\n| RUNNABLE | 运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作\"运行\" |\n| BLOCKED | 阻塞状态:表示线程阻塞于锁 |\n| WAITING | 等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) |\n| TIMEWAITING | 超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的 |\n| TERMINATED | 终止状态:表示当前线程已经执行完毕 |\n\n\n![image.png](/img/2.jpg)\n# 3、共享模型之管程\n管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的\n## 3.1、monitor\nMonitor 被翻译为**监视器**或**管程**\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针\n\n### 3.1.1、Monitor结构\n**结构**：owner  entryList  waitSet\n![image.png](/img/3.jpg)\n\n### 3.1.2、Monitor原理\n（1）刚开始monitor中owner为null \n（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程 \n（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞 \n（4）t1执行完会唤醒entrylist中的某个线程（不公平）\n（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n## 3.2、java对象结构\n\n1. **对象头**\n\n包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）\n![image.png](/img/4.jpg)\n\n2. **实例数据**\n\n实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息\n\n3. **对齐填充**\n\n对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。\n## 3.3、synchronized升级\n### 3.3.1、偏向锁\n> 使用场景：如果只有一个线程，就不需要每次的申请释放锁\n\n只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 \n### 3.3.2、轻量级锁\n> 使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化\n\n![](/img/5.jpg)\n\n1. 创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象\n2. 让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录\n3. 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁\n4. 如果 cas 失败，有两种情况 \n\n（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 \n（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）\n\n5. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一\n6. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 \n\n（1）成功，则解锁成功 \n（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\n### 3.3.3、重量级锁\n> 使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁\n\n![](/img/6.jpg)\n\n1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\n2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 \n\n（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 \n（2）然后自己进入 Monitor 的 EntryList阻塞队列\n\n3. 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）\n> 调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n### 3.3.4、自旋锁\n重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)\n\n## 3.4、wait/notify\nOwner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争\n\n### 3.4.1、sleep和wait的区别？\n\n1.  sleep 是 Thread 方法，而 wait 是 Object 的方法 \n2.  sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 \n3.  sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 \n\n## 3.5、park/unpark\n它们是 LockSupport 类中的方法\n```java\n// 暂停当前线程\nLockSupport.park(); \n// 恢复某个线程的运行\nLockSupport.unpark(暂停线程对象)\n```\n\n### 3.5.1、与 Object 的 wait & notify 相比 \n\n- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\n- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 \n- park & unpark 可以先 unpark，而 wait & notify 不能先 notify \n\n### 3.5.2、原理\n每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex \n\n核心部分是counter，我们可以理解为一个标记位。\n当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。\n当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。\n## 3.6、死锁\n多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁\n### 3.6.1、死锁的必要条件\n\n1. 互斥条件：一个资源一次只能被一个进程使用\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放\n3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺\n4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系\n### 3.6.2、死锁的实现\n```java\n/**\n * 实现一个死锁\n * 如果把lock(target, owner);放到上面则不会死锁\n */\npublic class DeadLock {\n    public static void main(String[] args) throws InterruptedException {\n        final Object owner = new Object();\n        final Object target = new Object();\n        //开启一个新线程\n        new Thread(() -> {\n            try {\n                lock(owner, target);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        //主线程\n        lock(target, owner);\n    }\n    public static void lock(Object owner, Object target) throws InterruptedException {\n        synchronized (owner) {\n            Thread.sleep(1000);\n            synchronized (target) {\n                System.out.println(\"success\");\n            }\n        }\n    }\n}\n```\n### 3.6.3、定位死锁\n检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁\n### 3.6.4、哲学家就餐问题\n![image.png](/img/7.jpg)\n有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 \n\n1. 筷子类\n```java\nclass Chopstick {\n    String name;\n    \n    public Chopstick(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return \"筷子{\" + name + '}';\n    }\n}\n```\n\n2. 哲学家类\n```java\nclass Philosopher extends Thread {\n    Chopstick left;\n    Chopstick right;\n    \n    public Philosopher(String name, Chopstick left, Chopstick right) {\n        super(name);\n        this.left = left;\n        this.right = right;\n    }\n    \n    private void eat() {\n        log.debug(\"eating...\");\n        Sleeper.sleep(1);\n    }\n    \n    @Override\n    public void run() {\n        while (true) {\n            // 获得左手筷子\n            synchronized (left) {\n                // 获得右手筷子\n                synchronized (right) {\n                    // 吃饭\n                    eat();\n                }\n                // 放下右手筷子\n            }\n            // 放下左手筷子\n        }\n    }\n}\n```\n\n3. 就餐\n```java\nChopstick c1 = new Chopstick(\"1\");\nChopstick c2 = new Chopstick(\"2\");\nChopstick c3 = new Chopstick(\"3\");\nChopstick c4 = new Chopstick(\"4\");\nChopstick c5 = new Chopstick(\"5\");\n\nnew Philosopher(\"苏格拉底\", c1, c2).start();\nnew Philosopher(\"柏拉图\", c2, c3).start();\nnew Philosopher(\"亚里士多德\", c3, c4).start();\nnew Philosopher(\"赫拉克利特\", c4, c5).start();\nnew Philosopher(\"阿基米德\", c5, c1).start();\n```\n## 3.7、活锁\n两个线程互相改变对方的结束条件导致谁也无法结束\n> eg：共享变量count为10000, t1线程while count > 0, count-- ;t2线程while count < 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行\n\n\n## 3.8、**ReentrantLock**\n相对于 synchronized 它具备如下特点 \n\n1. 可中断 \n2. 可以设置超时时间 \n3. 可以设置为公平锁 （默认不公平）\n4. 支持多个条件变量 \n\n与 synchronized 一样，都支持可重入 \n# 4、共享模型之内存\n## 4.1、java内存模型（jmm）\nJava内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本\n## 4.2、线程安全性的三个体现\n**原子性**：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）\n**可见性**：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）\n**有序性**：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）\n# 5、共享模型之无锁\n## 5.1、CAS\n### 5.1.1、CAS基本概念\nCAS是所有原子类的底层原理，乐观锁主要采用CAS算法。\nCAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。\n> 1. CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性\n> 2. CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果\n\n\n### 5.1.2、CAS问题\n多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。\n\n**解决方案：**\n使用AtomicStampReference \nAtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验\n\n## 5.2、volatile\n### 5.2.1、如何保证可见性和有序性\n\n1. **保证可见性（缓存一致性协议MESI）**\n\n首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用**MESI协议**保证缓存一致性。\n如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu**总线嗅探机制**监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值\n\n> **M 修改** (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中\n**E 独享、互斥** (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。\n**S 共享** (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态\n**I 无效** (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态\n\n\n> 涉及到的指令\nlock(锁定)：将一个变量标识为被一个线程独占状态\nstore(存储)：作用于工作内存的变量,将变量传输到主内存中\nwrite(写入)：将store入主内存的变量,放入到主内存的变量中\n\n\n2. **保证有序性（禁止指令重排优化）**\n\n多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的\n内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序\n\n## 5.3、原子类\n| 类型   | 具体类 |\n| --- | --- |\n| Atomic 基本类型原子类   | AtomicInteger AtomicLong AtomicBoolean |\n| AtomicArray 数组类型原子类 | AtomicIntegerArray  AtomicLongArray AtomicReferenceArray |\n| AtomicReference 引用类型原子类 | AtomicReference AtomicStampedReference AtomicMarkableReference |\n| AtomicFieldUpdate 升级类型原子类 | AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater |\n\n\n# 6、共享模式之工具\n## 6.1、线程池\n### 6.1.1、**ThreadPoolExecutor**\n\n1. **构造方法**\n\n通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建\n\n> 1. corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。\n> 2. maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。\n> 3. keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。\n> 4. unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n> 5. workQueue：缓存队列，用来存放等待被执行的任务。\n> 6. threadFactory 线程工厂\n> 7. handler：拒绝策略\n（1）abortPolicy：抛出异常（默认）\n（2）discardPolicy：放弃本次任务\n（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代\n（4）callerrunPolicy：让调用者运行任务\n\n\n2. **工作原理**\n\n如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n如果当前线程池中正在执行任务的的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；\n如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；\n如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理\n### 6.1.2、Executors类中提供的工厂方法\n根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池\n\n1. **newFixedThreadPool**\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n> 特点：\n> - 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 \n> - 阻塞队列是无界的，可以放任意数量的任务 \n> \n评价：\n> 适用于任务量已知，相对耗时的任务\n\n\n2. **newCachedThreadPool**\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n> 特点 \n> - 核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 \n>    - 全部都是救急线程（60s 后可以回收）\n>    - 救急线程可以无限创建 \n> - 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）\n> \n评价：\n> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程\n> 适合任务数比较密集，但每个任务执行时间较短的情况\n\n\n3. **newSingleThreadExecutor**\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n使用场景： \n希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。\n任务执行完毕，这唯一的线程也不会被释放。 \n\n### 6.1.3、创建多大的线程池\n\n- 过小会导致程序不能充分地利用系统资源、容易导致饥饿 \n- 过大会导致更多的线程上下文切换，影响性能\n\n1. **CPU 密集型运算 **\n\n通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 \n\n2. **I/O密集型**\n\nCPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 \n经验公式如下 ：\n`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间` \n\n## 6.2、锁\n### 6.2.1、AQS\n\n1. 基本概念\n\nAbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...\n\n2. 原理 \n\n它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）\n\n3. 实现\n\n自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n> **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的\n\n### 6.2.2、ReentrantLock\n**实现原理**\n\n1. 首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能\n2. 它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法\n3. 加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列\n4. 持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）\n\n**条件变量——Condition**\nCondition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程\n### 6.2.3、**ReentrantReadWriteLock**\n#### 4.2.3.1、ReentrantReadWriteLock基本概念\nReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用\n#### 4.2.3.2、锁获取过程\n\n1. 获取读锁\n\n如果写锁没有被另一个线程持有，则获取读锁并立即返回。     \n \t如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。\n\n4. 获取写入锁\n\n如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *\n如果当前线程持有写锁，则将写锁计数 +1，然后返回\n如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。\n\n#### 4.2.3.3、常见问题\n\n1. **读锁和写锁的可重入性**\n\n在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加\n\n2. **当前线程获取锁失败，被阻塞的后续操作是什么？**\n\n获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁\n\n3. **锁降级是怎么降级的？**\n\n在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）\n\n## 6.3、工具\n### 6.3.1、Semaphore\n\n1. **概念**\n\nSemaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）\n```java\npublic class DataSourcePool {\n \n    private final CopyOnWriteArrayList<Connection> list;\n    \n    //用到了信号量\n    private final Semaphore semaphore;\n \n    public DataSourcePool(int size) throws SQLException {\n        list = new CopyOnWriteArrayList<>();\n        semaphore = new Semaphore(size);\n        for (int i=0;i<size;i++){\n            Connection connection = DriverManager.getConnection(\"url\");\n            list.add(connection);\n        }\n    }\n    \n    //使用同步方法获取\n    public synchronized Connection getConnection() throws InterruptedException {\n        //先将当前信号量-1，如果为0，将阻塞\n        semaphore.acquire();\n        return list.remove(0);\n    }\n \n    public synchronized void  close(Connection connection){\n        //信号量+1\n        semaphore.release();\n        list.add(connection);\n    }\n}\n```\n\n2. **原理**\n\nSemaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n\n1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。\n2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state=state-1。state<0,令牌数量不足，加入阻塞队列。>=0则获取成功\n3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state=state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程\n### 6.3.2、CountdownLatch\n\n1. **概念**\n\nCountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n    ExecutorService service = Executors.newFixedThreadPool(4);\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(()->{\n        try {\n            log.debug(\"waiting...\");\n            latch.await();\n            log.debug(\"wait end...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n    \n}\n```\n```java\n18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting... \n18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2 \n18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end...\n```\n\n2. **原理**\n\nCountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n1、初始化CountDownLatch实际就是设置了AQS的state为计数的值\n2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值\n3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试\n\n3. **和join的区别？**\n\nCountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成\n\n### 6.3.3、CyclicBarrier\n\n1. **概念**\n\nCyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行\n实现王者荣耀10个人都加载完才开始游戏\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        int count = 10;\n        CyclicBarrier cb = new CyclicBarrier(count, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"全部加载完毕\");\n            }\n        });\n        ExecutorService executorService = Executors.newFixedThreadPool(count);\n        for (int x = 0; x < count; x++) {\n            executorService.execute(new Worker(cb));\n        }\n    }\n}\n\nclass Worker extends Thread {\n    CyclicBarrier cyclicBarrier;\n    public Worker(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" 已加载完\");\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java\npool-1-thread-1 已加载完\npool-1-thread-5 已加载完\npool-1-thread-4 已加载完\npool-1-thread-3 已加载完\npool-1-thread-6 已加载完\npool-1-thread-2 已加载完\npool-1-thread-7 已加载完\npool-1-thread-8 已加载完\npool-1-thread-9 已加载完\npool-1-thread-10 已加载完\n全部加载完毕\n\n```\n\n2. **原理**\n\n1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count\n2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；\n3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；\n4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；\n5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。\n\n## 6.4、线程安全集合类\n### 6.4.1、概述\n![image.png](/img/8.jpg)\n线程安全实现类有三类：\n\n1. 遗留的线程安全集合如 Hashtable ， Vector \n2. 使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）\n>    - Collections.synchronizedCollection \n>    - Collections.synchronizedList \n>    - Collections.synchronizedMap \n>    - Collections.synchronizedSet \n>    - Collections.synchronizedNavigableMap \n>    - Collections.synchronizedNavigableSet\n>    - Collections.synchronizedSortedMap \n>    - Collections.synchronizedSortedSet \n\n2. JUC下的安全集合: Blocking、CopyOnWrite、Concurrent \n> - Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)\n> - CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)\n> - Concurrent 类型的容器 （内部很多操作使用cas优化）\n>    - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 \n>    - 弱一致性 \n>       - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 \n>       - 求大小弱一致性，size 操作未必是 100% 准确 \n>       - 读取弱一致性 \n\n> 遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历\n\n### 6.4.2、concurrentHashMap\n**JDK1.8前**\nConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。\n\n元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部\n\n锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数\n\n\n> ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表\n\n\n**JDK1.8**\n\n在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全\n\n1. 初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 \n2. 插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 \n3. 扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 \n4. 查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。\n\n\n\n### 6.4.3、BlockingQueue\n主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue \n\n1. 区别\n\n（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表\n（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）\n（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现\n\n### 6.4.4、ConcurrentLinkedQueue \nConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）\n\n### 6.4.5、CopyOnWriteArrayList\n\n1. 首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行\n2. 写数据时会加ReentLocak锁，防止并发写入丢失数据的问题\n3. 写操作结束后会把原数组指向新数组\n4. CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景\n\n\n","slug":"JUC","published":1,"updated":"2023-07-15T09:49:49.112Z","_id":"clk3ttrq600040suj0h7l8qbx","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1、java多线程基本概念\"><a href=\"#1、java多线程基本概念\" class=\"headerlink\" title=\"1、java多线程基本概念\"></a>1、java多线程基本概念</h1><h2 id=\"1-1、进程和线程\"><a href=\"#1-1、进程和线程\" class=\"headerlink\" title=\"1.1、进程和线程\"></a>1.1、进程和线程</h2><ol>\n<li><strong>进程</strong></li>\n</ol>\n<ul>\n<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li>\n<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>\n<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>\n</ul>\n<ol start=\"2\">\n<li><strong>线程</strong></li>\n</ol>\n<ul>\n<li>一个进程之内可以分为一到多个线程。 </li>\n<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li>\n<li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li>\n</ul>\n<h2 id=\"1-2、并发和并行\"><a href=\"#1-2、并发和并行\" class=\"headerlink\" title=\"1.2、并发和并行\"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p>\n<h2 id=\"1-3、多线程的应用\"><a href=\"#1-3、多线程的应用\" class=\"headerlink\" title=\"1.3、多线程的应用\"></a>1.3、多线程的应用</h2><h3 id=\"1-3-1、异步调用\"><a href=\"#1-3-1、异步调用\" class=\"headerlink\" title=\"1.3.1、异步调用\"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p>\n<h3 id=\"1-3-2、提升效率\"><a href=\"#1-3-2、提升效率\" class=\"headerlink\" title=\"1.3.2、提升效率\"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算 <span class=\"number\">1</span> 花费 <span class=\"number\">10</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">2</span> 花费 <span class=\"number\">11</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">3</span> 花费 <span class=\"number\">9</span> ms</span><br><span class=\"line\">汇总需要 <span class=\"number\">1</span> ms</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li>\n<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms <blockquote>\n<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"2、java线程\"><a href=\"#2、java线程\" class=\"headerlink\" title=\"2、java线程\"></a>2、java线程</h1><h2 id=\"2-1、线程的创建\"><a href=\"#2-1、线程的创建\" class=\"headerlink\" title=\"2.1、线程的创建\"></a>2.1、线程的创建</h2><h3 id=\"2-1-1、直接使用Thread\"><a href=\"#2-1-1、直接使用Thread\" class=\"headerlink\" title=\"2.1.1、直接使用Thread\"></a>2.1.1、直接使用Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、使用-Runnable-配合-Thread\"><a href=\"#2-1-2、使用-Runnable-配合-Thread\" class=\"headerlink\" title=\"2.1.2、使用 Runnable 配合 Thread\"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>( runnable );</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<p>java8可用lambda精简</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">task2</span> <span class=\"operator\">=</span> () -&gt; log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task2, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">t2.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3、FutureTask-配合-Thread\"><a href=\"#2-1-3、FutureTask-配合-Thread\" class=\"headerlink\" title=\"2.1.3、FutureTask 配合 Thread\"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\">FutureTask&lt;Integer&gt; task3 = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task3, <span class=\"string\">&quot;t3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> task3.get();</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、查看进程线程\"><a href=\"#2-2、查看进程线程\" class=\"headerlink\" title=\"2.2、查看进程线程\"></a>2.2、查看进程线程</h2><h3 id=\"2-2-1、windows\"><a href=\"#2-2-1、windows\" class=\"headerlink\" title=\"2.2.1、windows\"></a>2.2.1、windows</h3><ol>\n<li>tasklist 查看进程 </li>\n<li>taskkill 杀死进程 </li>\n<li>netstat -ano|findstr 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-2、linux\"><a href=\"#2-2-2、linux\" class=\"headerlink\" title=\"2.2.2、linux\"></a>2.2.2、linux</h3><ol>\n<li>ps -fe 查看所有进程 </li>\n<li>kill 杀死进程</li>\n<li>top -Hp <PID> 查看某个进程（PID）的所有线程 </li>\n<li>netstat -nlp|grep 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-3、JDK\"><a href=\"#2-2-3、JDK\" class=\"headerlink\" title=\"2.2.3、JDK\"></a>2.2.3、JDK</h3><ol>\n<li>jps 命令查看所有 Java 进程</li>\n<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>\n<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>\n</ol>\n<h2 id=\"2-3、线程运行原理\"><a href=\"#2-3、线程运行原理\" class=\"headerlink\" title=\"2.3、线程运行原理\"></a>2.3、线程运行原理</h2><ol>\n<li><strong>线程创建</strong></li>\n</ol>\n<p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成<br>，栈帧对应着每次方法调用所占内存</p>\n<ol start=\"2\">\n<li><strong>上下文切换</strong></li>\n</ol>\n<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p>\n<blockquote>\n<p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p>\n</blockquote>\n<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p>\n<h2 id=\"2-4、start与run\"><a href=\"#2-4、start与run\" class=\"headerlink\" title=\"2.4、start与run\"></a>2.4、start与run</h2><ul>\n<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>\n<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>\n</ul>\n<h2 id=\"2-5、sleep-与-yield\"><a href=\"#2-5、sleep-与-yield\" class=\"headerlink\" title=\"2.5、sleep 与 yield\"></a>2.5、sleep 与 yield</h2><ol>\n<li><strong>sleep</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>睡眠结束后的线程未必会立刻得到执行</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>yield</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>具体的实现依赖于操作系统的任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-6、join\"><a href=\"#2-6、join\" class=\"headerlink\" title=\"2.6、join\"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    test1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">        r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"comment\">// t1.join();</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不加t1.join()结果为0，加上以后结果为1</p>\n</blockquote>\n<h2 id=\"2-7、interrupt\"><a href=\"#2-7、interrupt\" class=\"headerlink\" title=\"2.7、interrupt\"></a>2.7、interrupt</h2><h3 id=\"2-7-1、打断阻塞状态的线程\"><a href=\"#2-7-1、打断阻塞状态的线程\" class=\"headerlink\" title=\"2.7.1、打断阻塞状态的线程\"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t1.interrupt();</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">     at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">     at java.lang.Thread.sleep(Thread.java:<span class=\"number\">340</span>)</span><br><span class=\"line\">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class=\"number\">386</span>)</span><br><span class=\"line\">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class=\"number\">3</span>(TestInterrupt.java:<span class=\"number\">59</span>)</span><br><span class=\"line\">     at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">18</span>:<span class=\"number\">10.374</span> [main] c.TestInterrupt - 打断状态: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-2、打断正常运行的线程\"><a href=\"#2-7-2、打断正常运行的线程\" class=\"headerlink\" title=\"2.7.2、打断正常运行的线程\"></a>2.7.2、打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> current.isInterrupted();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(interrupted) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t2.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class=\"literal\">true</span> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8、主线程与守护线程\"><a href=\"#2-8、主线程与守护线程\" class=\"headerlink\" title=\"2.8、主线程与守护线程\"></a>2.8、主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </p>\n<p>例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;daemon&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置该线程为守护线程</span></span><br><span class=\"line\">t1.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>**注意 **</p>\n<ul>\n<li>垃圾回收器线程就是一种守护线程 </li>\n<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>\n</ul>\n</blockquote>\n<h2 id=\"2-9、线程状态\"><a href=\"#2-9、线程状态\" class=\"headerlink\" title=\"2.9、线程状态\"></a>2.9、线程状态</h2><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NEW</td>\n<td>初始状态:线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>阻塞状态:表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td>WAITING</td>\n<td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>\n</tr>\n<tr>\n<td>TIMEWAITING</td>\n<td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>终止状态:表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p><img src=\"/img/2.jpg\" alt=\"image.png\"></p>\n<h1 id=\"3、共享模型之管程\"><a href=\"#3、共享模型之管程\" class=\"headerlink\" title=\"3、共享模型之管程\"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p>\n<h2 id=\"3-1、monitor\"><a href=\"#3-1、monitor\" class=\"headerlink\" title=\"3.1、monitor\"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>\n<h3 id=\"3-1-1、Monitor结构\"><a href=\"#3-1-1、Monitor结构\" class=\"headerlink\" title=\"3.1.1、Monitor结构\"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet<br><img src=\"/img/3.jpg\" alt=\"image.png\"></p>\n<h3 id=\"3-1-2、Monitor原理\"><a href=\"#3-1-2、Monitor原理\" class=\"headerlink\" title=\"3.1.2、Monitor原理\"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n<h2 id=\"3-2、java对象结构\"><a href=\"#3-2、java对象结构\" class=\"headerlink\" title=\"3.2、java对象结构\"></a>3.2、java对象结构</h2><ol>\n<li><strong>对象头</strong></li>\n</ol>\n<p>包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）<br><img src=\"/img/4.jpg\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>实例数据</strong></li>\n</ol>\n<p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p>\n<ol start=\"3\">\n<li><strong>对齐填充</strong></li>\n</ol>\n<p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>\n<h2 id=\"3-3、synchronized升级\"><a href=\"#3-3、synchronized升级\" class=\"headerlink\" title=\"3.3、synchronized升级\"></a>3.3、synchronized升级</h2><h3 id=\"3-3-1、偏向锁\"><a href=\"#3-3-1、偏向锁\" class=\"headerlink\" title=\"3.3.1、偏向锁\"></a>3.3.1、偏向锁</h3><blockquote>\n<p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p>\n</blockquote>\n<p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>\n<h3 id=\"3-3-2、轻量级锁\"><a href=\"#3-3-2、轻量级锁\" class=\"headerlink\" title=\"3.3.2、轻量级锁\"></a>3.3.2、轻量级锁</h3><blockquote>\n<p>使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>\n</blockquote>\n<p><img src=\"/img/5.jpg\"></p>\n<ol>\n<li>创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象</li>\n<li>让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>\n<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>\n<li>如果 cas 失败，有两种情况</li>\n</ol>\n<p>（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程<br>（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）</p>\n<ol start=\"5\">\n<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>\n<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</li>\n</ol>\n<p>（1）成功，则解锁成功<br>（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>\n<h3 id=\"3-3-3、重量级锁\"><a href=\"#3-3-3、重量级锁\" class=\"headerlink\" title=\"3.3.3、重量级锁\"></a>3.3.3、重量级锁</h3><blockquote>\n<p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>\n</blockquote>\n<p><img src=\"/img/6.jpg\"></p>\n<ol>\n<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>\n<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</li>\n</ol>\n<p>（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<br>（2）然后自己进入 Monitor 的 EntryList阻塞队列</p>\n<ol start=\"3\">\n<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）<blockquote>\n<p>调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"3-3-4、自旋锁\"><a href=\"#3-3-4、自旋锁\" class=\"headerlink\" title=\"3.3.4、自旋锁\"></a>3.3.4、自旋锁</h3><p>重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)</p>\n<h2 id=\"3-4、wait-notify\"><a href=\"#3-4、wait-notify\" class=\"headerlink\" title=\"3.4、wait&#x2F;notify\"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p>\n<h3 id=\"3-4-1、sleep和wait的区别？\"><a href=\"#3-4-1、sleep和wait的区别？\" class=\"headerlink\" title=\"3.4.1、sleep和wait的区别？\"></a>3.4.1、sleep和wait的区别？</h3><ol>\n<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>\n<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>\n<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>\n</ol>\n<h2 id=\"3-5、park-unpark\"><a href=\"#3-5、park-unpark\" class=\"headerlink\" title=\"3.5、park&#x2F;unpark\"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂停当前线程</span></span><br><span class=\"line\">LockSupport.park(); </span><br><span class=\"line\"><span class=\"comment\">// 恢复某个线程的运行</span></span><br><span class=\"line\">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-1、与-Object-的-wait-notify-相比\"><a href=\"#3-5-1、与-Object-的-wait-notify-相比\" class=\"headerlink\" title=\"3.5.1、与 Object 的 wait &amp; notify 相比\"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul>\n<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>\n<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>\n<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>\n</ul>\n<h3 id=\"3-5-2、原理\"><a href=\"#3-5-2、原理\" class=\"headerlink\" title=\"3.5.2、原理\"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p>\n<p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p>\n<h2 id=\"3-6、死锁\"><a href=\"#3-6、死锁\" class=\"headerlink\" title=\"3.6、死锁\"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p>\n<h3 id=\"3-6-1、死锁的必要条件\"><a href=\"#3-6-1、死锁的必要条件\" class=\"headerlink\" title=\"3.6.1、死锁的必要条件\"></a>3.6.1、死锁的必要条件</h3><ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h3 id=\"3-6-2、死锁的实现\"><a href=\"#3-6-2、死锁的实现\" class=\"headerlink\" title=\"3.6.2、死锁的实现\"></a>3.6.2、死锁的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">owner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"comment\">//开启一个新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                lock(owner, target);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"comment\">//主线程</span></span><br><span class=\"line\">        lock(target, owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">(Object owner, Object target)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (owner) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (target) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;success&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-3、定位死锁\"><a href=\"#3-6-3、定位死锁\" class=\"headerlink\" title=\"3.6.3、定位死锁\"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p>\n<h3 id=\"3-6-4、哲学家就餐问题\"><a href=\"#3-6-4、哲学家就餐问题\" class=\"headerlink\" title=\"3.6.4、哲学家就餐问题\"></a>3.6.4、哲学家就餐问题</h3><p><img src=\"/img/7.jpg\" alt=\"image.png\"><br>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p>\n<ol>\n<li><p>筷子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chopstick</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Chopstick</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;筷子&#123;&quot;</span> + name + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>哲学家类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Philosopher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    Chopstick left;</span><br><span class=\"line\">    Chopstick right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Philosopher</span><span class=\"params\">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;eating...&quot;</span>);</span><br><span class=\"line\">        Sleeper.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得左手筷子</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (left) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获得右手筷子</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (right) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">                    eat();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 放下右手筷子</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 放下左手筷子</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>就餐</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c5</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"3-7、活锁\"><a href=\"#3-7、活锁\" class=\"headerlink\" title=\"3.7、活锁\"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p>\n<blockquote>\n<p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p>\n</blockquote>\n<h2 id=\"3-8、ReentrantLock\"><a href=\"#3-8、ReentrantLock\" class=\"headerlink\" title=\"3.8、ReentrantLock\"></a>3.8、<strong>ReentrantLock</strong></h2><p>相对于 synchronized 它具备如下特点 </p>\n<ol>\n<li>可中断 </li>\n<li>可以设置超时时间 </li>\n<li>可以设置为公平锁 （默认不公平）</li>\n<li>支持多个条件变量</li>\n</ol>\n<p>与 synchronized 一样，都支持可重入 </p>\n<h1 id=\"4、共享模型之内存\"><a href=\"#4、共享模型之内存\" class=\"headerlink\" title=\"4、共享模型之内存\"></a>4、共享模型之内存</h1><h2 id=\"4-1、java内存模型（jmm）\"><a href=\"#4-1、java内存模型（jmm）\" class=\"headerlink\" title=\"4.1、java内存模型（jmm）\"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p>\n<h2 id=\"4-2、线程安全性的三个体现\"><a href=\"#4-2、线程安全性的三个体现\" class=\"headerlink\" title=\"4.2、线程安全性的三个体现\"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）<br><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）<br><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）</p>\n<h1 id=\"5、共享模型之无锁\"><a href=\"#5、共享模型之无锁\" class=\"headerlink\" title=\"5、共享模型之无锁\"></a>5、共享模型之无锁</h1><h2 id=\"5-1、CAS\"><a href=\"#5-1、CAS\" class=\"headerlink\" title=\"5.1、CAS\"></a>5.1、CAS</h2><h3 id=\"5-1-1、CAS基本概念\"><a href=\"#5-1-1、CAS基本概念\" class=\"headerlink\" title=\"5.1.1、CAS基本概念\"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>\n<blockquote>\n<ol>\n<li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li>\n<li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li>\n</ol>\n</blockquote>\n<h3 id=\"5-1-2、CAS问题\"><a href=\"#5-1-2、CAS问题\" class=\"headerlink\" title=\"5.1.2、CAS问题\"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p>\n<p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p>\n<h2 id=\"5-2、volatile\"><a href=\"#5-2、volatile\" class=\"headerlink\" title=\"5.2、volatile\"></a>5.2、volatile</h2><h3 id=\"5-2-1、如何保证可见性和有序性\"><a href=\"#5-2-1、如何保证可见性和有序性\" class=\"headerlink\" title=\"5.2.1、如何保证可见性和有序性\"></a>5.2.1、如何保证可见性和有序性</h3><ol>\n<li><strong>保证可见性（缓存一致性协议MESI）</strong></li>\n</ol>\n<p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p>\n<blockquote>\n<p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p>\n</blockquote>\n<blockquote>\n<p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>保证有序性（禁止指令重排优化）</strong></li>\n</ol>\n<p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p>\n<h2 id=\"5-3、原子类\"><a href=\"#5-3、原子类\" class=\"headerlink\" title=\"5.3、原子类\"></a>5.3、原子类</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>具体类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic 基本类型原子类</td>\n<td>AtomicInteger AtomicLong AtomicBoolean</td>\n</tr>\n<tr>\n<td>AtomicArray 数组类型原子类</td>\n<td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td>\n</tr>\n<tr>\n<td>AtomicReference 引用类型原子类</td>\n<td>AtomicReference AtomicStampedReference AtomicMarkableReference</td>\n</tr>\n<tr>\n<td>AtomicFieldUpdate 升级类型原子类</td>\n<td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td>\n</tr>\n</tbody></table>\n<h1 id=\"6、共享模式之工具\"><a href=\"#6、共享模式之工具\" class=\"headerlink\" title=\"6、共享模式之工具\"></a>6、共享模式之工具</h1><h2 id=\"6-1、线程池\"><a href=\"#6-1、线程池\" class=\"headerlink\" title=\"6.1、线程池\"></a>6.1、线程池</h2><h3 id=\"6-1-1、ThreadPoolExecutor\"><a href=\"#6-1-1、ThreadPoolExecutor\" class=\"headerlink\" title=\"6.1.1、ThreadPoolExecutor\"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol>\n<li><strong>构造方法</strong></li>\n</ol>\n<p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p>\n<blockquote>\n<ol>\n<li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li>\n<li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li>\n<li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li>\n<li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>\n<li>workQueue：缓存队列，用来存放等待被执行的任务。</li>\n<li>threadFactory 线程工厂</li>\n<li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>\n<h3 id=\"6-1-2、Executors类中提供的工厂方法\"><a href=\"#6-1-2、Executors类中提供的工厂方法\" class=\"headerlink\" title=\"6.1.2、Executors类中提供的工厂方法\"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p>\n<ol>\n<li><p><strong>newFixedThreadPool</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newFixedThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>特点：</p>\n<ul>\n<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>\n<li>阻塞队列是无界的，可以放任意数量的任务</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>适用于任务量已知，相对耗时的任务</p>\n</blockquote>\n</li>\n<li><p><strong>newCachedThreadPool</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newCachedThreadPool</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>特点 </p>\n<ul>\n<li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul>\n<li>全部都是救急线程（60s 后可以回收）</li>\n<li>救急线程可以无限创建</li>\n</ul>\n</li>\n<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p>\n</blockquote>\n</li>\n<li><p><strong>newSingleThreadExecutor</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newSingleThreadExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\">        (<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。</p>\n</li>\n</ol>\n<h3 id=\"6-1-3、创建多大的线程池\"><a href=\"#6-1-3、创建多大的线程池\" class=\"headerlink\" title=\"6.1.3、创建多大的线程池\"></a>6.1.3、创建多大的线程池</h3><ul>\n<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>\n<li>过大会导致更多的线程上下文切换，影响性能</li>\n</ul>\n<ol>\n<li>**CPU 密集型运算 **</li>\n</ol>\n<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>\n<ol start=\"2\">\n<li><strong>I&#x2F;O密集型</strong></li>\n</ol>\n<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>\n<h2 id=\"6-2、锁\"><a href=\"#6-2、锁\" class=\"headerlink\" title=\"6.2、锁\"></a>6.2、锁</h2><h3 id=\"6-2-1、AQS\"><a href=\"#6-2-1、AQS\" class=\"headerlink\" title=\"6.2.1、AQS\"></a>6.2.1、AQS</h3><ol>\n<li>基本概念</li>\n</ol>\n<p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p>\n<ol start=\"2\">\n<li>原理</li>\n</ol>\n<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>\n<blockquote>\n<p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>\n</blockquote>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p>\n<h3 id=\"6-2-2、ReentrantLock\"><a href=\"#6-2-2、ReentrantLock\" class=\"headerlink\" title=\"6.2.2、ReentrantLock\"></a>6.2.2、ReentrantLock</h3><p><strong>实现原理</strong></p>\n<ol>\n<li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li>\n<li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li>\n<li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li>\n<li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li>\n</ol>\n<p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p>\n<h3 id=\"6-2-3、ReentrantReadWriteLock\"><a href=\"#6-2-3、ReentrantReadWriteLock\" class=\"headerlink\" title=\"6.2.3、ReentrantReadWriteLock\"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id=\"4-2-3-1、ReentrantReadWriteLock基本概念\"><a href=\"#4-2-3-1、ReentrantReadWriteLock基本概念\" class=\"headerlink\" title=\"4.2.3.1、ReentrantReadWriteLock基本概念\"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p>\n<h4 id=\"4-2-3-2、锁获取过程\"><a href=\"#4-2-3-2、锁获取过程\" class=\"headerlink\" title=\"4.2.3.2、锁获取过程\"></a>4.2.3.2、锁获取过程</h4><ol>\n<li>获取读锁</li>\n</ol>\n<p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>     如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。</p>\n<ol start=\"4\">\n<li>获取写入锁</li>\n</ol>\n<p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p>\n<h4 id=\"4-2-3-3、常见问题\"><a href=\"#4-2-3-3、常见问题\" class=\"headerlink\" title=\"4.2.3.3、常见问题\"></a>4.2.3.3、常见问题</h4><ol>\n<li><strong>读锁和写锁的可重入性</strong></li>\n</ol>\n<p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p>\n<ol start=\"2\">\n<li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li>\n</ol>\n<p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p>\n<ol start=\"3\">\n<li><strong>锁降级是怎么降级的？</strong></li>\n</ol>\n<p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p>\n<h2 id=\"6-3、工具\"><a href=\"#6-3、工具\" class=\"headerlink\" title=\"6.3、工具\"></a>6.3、工具</h2><h3 id=\"6-3-1、Semaphore\"><a href=\"#6-3-1、Semaphore\" class=\"headerlink\" title=\"6.3.1、Semaphore\"></a>6.3.1、Semaphore</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourcePool</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//用到了信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DataSourcePool</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">        list = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        semaphore = <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">            list.add(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用同步方法获取</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class=\"line\">        semaphore.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">close</span><span class=\"params\">(Connection connection)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//信号量+1</span></span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">        list.add(connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p>\n<p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p>\n<h3 id=\"6-3-2、CountdownLatch\"><a href=\"#6-3-2、CountdownLatch\" class=\"headerlink\" title=\"6.3.2、CountdownLatch\"></a>6.3.2、CountdownLatch</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ExecutorService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1.5</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;wait end...&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - waiting... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">26.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - end..<span class=\"number\">.2</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.335</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - end..<span class=\"number\">.1</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - end..<span class=\"number\">.0</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - wait end...</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p>\n<ol start=\"3\">\n<li><strong>和join的区别？</strong></li>\n</ol>\n<p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p>\n<h3 id=\"6-3-3、CyclicBarrier\"><a href=\"#6-3-3、CyclicBarrier\" class=\"headerlink\" title=\"6.3.3、CyclicBarrier\"></a>6.3.3、CyclicBarrier</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(count, <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;全部加载完毕&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; x &lt; count; x++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(cb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    CyclicBarrier cyclicBarrier;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已加载完&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            cyclicBarrier.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">6</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">7</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">8</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">9</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">10</span> 已加载完</span><br><span class=\"line\">全部加载完毕</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p>\n<h2 id=\"6-4、线程安全集合类\"><a href=\"#6-4、线程安全集合类\" class=\"headerlink\" title=\"6.4、线程安全集合类\"></a>6.4、线程安全集合类</h2><h3 id=\"6-4-1、概述\"><a href=\"#6-4-1、概述\" class=\"headerlink\" title=\"6.4.1、概述\"></a>6.4.1、概述</h3><p><img src=\"/img/8.jpg\" alt=\"image.png\"><br>线程安全实现类有三类：</p>\n<ol>\n<li><p>遗留的线程安全集合如 Hashtable ， Vector </p>\n</li>\n<li><p>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</p>\n<blockquote>\n<ul>\n<li>Collections.synchronizedCollection </li>\n<li>Collections.synchronizedList </li>\n<li>Collections.synchronizedMap </li>\n<li>Collections.synchronizedSet </li>\n<li>Collections.synchronizedNavigableMap </li>\n<li>Collections.synchronizedNavigableSet</li>\n<li>Collections.synchronizedSortedMap </li>\n<li>Collections.synchronizedSortedSet</li>\n</ul>\n</blockquote>\n</li>\n<li><p>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent </p>\n<blockquote>\n<ul>\n<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li>\n<li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li>\n<li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul>\n<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>\n<li>弱一致性 <ul>\n<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<pre><code>  - 求大小弱一致性，size 操作未必是 100% 准确 \n  - 读取弱一致性 \n</code></pre>\n</blockquote>\n<blockquote>\n<p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p>\n</blockquote>\n<h3 id=\"6-4-2、concurrentHashMap\"><a href=\"#6-4-2、concurrentHashMap\" class=\"headerlink\" title=\"6.4.2、concurrentHashMap\"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p>\n<p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p>\n<p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p>\n<blockquote>\n<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p>\n</blockquote>\n<p><strong>JDK1.8</strong></p>\n<p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p>\n<ol>\n<li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li>\n<li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li>\n<li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li>\n<li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li>\n</ol>\n<h3 id=\"6-4-3、BlockingQueue\"><a href=\"#6-4-3、BlockingQueue\" class=\"headerlink\" title=\"6.4.3、BlockingQueue\"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p>\n<ol>\n<li>区别</li>\n</ol>\n<p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p>\n<h3 id=\"6-4-4、ConcurrentLinkedQueue\"><a href=\"#6-4-4、ConcurrentLinkedQueue\" class=\"headerlink\" title=\"6.4.4、ConcurrentLinkedQueue\"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p>\n<h3 id=\"6-4-5、CopyOnWriteArrayList\"><a href=\"#6-4-5、CopyOnWriteArrayList\" class=\"headerlink\" title=\"6.4.5、CopyOnWriteArrayList\"></a>6.4.5、CopyOnWriteArrayList</h3><ol>\n<li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li>\n<li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li>\n<li>写操作结束后会把原数组指向新数组</li>\n<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、java多线程基本概念\"><a href=\"#1、java多线程基本概念\" class=\"headerlink\" title=\"1、java多线程基本概念\"></a>1、java多线程基本概念</h1><h2 id=\"1-1、进程和线程\"><a href=\"#1-1、进程和线程\" class=\"headerlink\" title=\"1.1、进程和线程\"></a>1.1、进程和线程</h2><ol>\n<li><strong>进程</strong></li>\n</ol>\n<ul>\n<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li>\n<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>\n<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>\n</ul>\n<ol start=\"2\">\n<li><strong>线程</strong></li>\n</ol>\n<ul>\n<li>一个进程之内可以分为一到多个线程。 </li>\n<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li>\n<li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li>\n</ul>\n<h2 id=\"1-2、并发和并行\"><a href=\"#1-2、并发和并行\" class=\"headerlink\" title=\"1.2、并发和并行\"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p>\n<h2 id=\"1-3、多线程的应用\"><a href=\"#1-3、多线程的应用\" class=\"headerlink\" title=\"1.3、多线程的应用\"></a>1.3、多线程的应用</h2><h3 id=\"1-3-1、异步调用\"><a href=\"#1-3-1、异步调用\" class=\"headerlink\" title=\"1.3.1、异步调用\"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p>\n<h3 id=\"1-3-2、提升效率\"><a href=\"#1-3-2、提升效率\" class=\"headerlink\" title=\"1.3.2、提升效率\"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算 <span class=\"number\">1</span> 花费 <span class=\"number\">10</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">2</span> 花费 <span class=\"number\">11</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">3</span> 花费 <span class=\"number\">9</span> ms</span><br><span class=\"line\">汇总需要 <span class=\"number\">1</span> ms</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li>\n<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms <blockquote>\n<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"2、java线程\"><a href=\"#2、java线程\" class=\"headerlink\" title=\"2、java线程\"></a>2、java线程</h1><h2 id=\"2-1、线程的创建\"><a href=\"#2-1、线程的创建\" class=\"headerlink\" title=\"2.1、线程的创建\"></a>2.1、线程的创建</h2><h3 id=\"2-1-1、直接使用Thread\"><a href=\"#2-1-1、直接使用Thread\" class=\"headerlink\" title=\"2.1.1、直接使用Thread\"></a>2.1.1、直接使用Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、使用-Runnable-配合-Thread\"><a href=\"#2-1-2、使用-Runnable-配合-Thread\" class=\"headerlink\" title=\"2.1.2、使用 Runnable 配合 Thread\"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>( runnable );</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<p>java8可用lambda精简</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">task2</span> <span class=\"operator\">=</span> () -&gt; log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task2, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">t2.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3、FutureTask-配合-Thread\"><a href=\"#2-1-3、FutureTask-配合-Thread\" class=\"headerlink\" title=\"2.1.3、FutureTask 配合 Thread\"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\">FutureTask&lt;Integer&gt; task3 = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task3, <span class=\"string\">&quot;t3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> task3.get();</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、查看进程线程\"><a href=\"#2-2、查看进程线程\" class=\"headerlink\" title=\"2.2、查看进程线程\"></a>2.2、查看进程线程</h2><h3 id=\"2-2-1、windows\"><a href=\"#2-2-1、windows\" class=\"headerlink\" title=\"2.2.1、windows\"></a>2.2.1、windows</h3><ol>\n<li>tasklist 查看进程 </li>\n<li>taskkill 杀死进程 </li>\n<li>netstat -ano|findstr 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-2、linux\"><a href=\"#2-2-2、linux\" class=\"headerlink\" title=\"2.2.2、linux\"></a>2.2.2、linux</h3><ol>\n<li>ps -fe 查看所有进程 </li>\n<li>kill 杀死进程</li>\n<li>top -Hp <PID> 查看某个进程（PID）的所有线程 </li>\n<li>netstat -nlp|grep 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-3、JDK\"><a href=\"#2-2-3、JDK\" class=\"headerlink\" title=\"2.2.3、JDK\"></a>2.2.3、JDK</h3><ol>\n<li>jps 命令查看所有 Java 进程</li>\n<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>\n<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>\n</ol>\n<h2 id=\"2-3、线程运行原理\"><a href=\"#2-3、线程运行原理\" class=\"headerlink\" title=\"2.3、线程运行原理\"></a>2.3、线程运行原理</h2><ol>\n<li><strong>线程创建</strong></li>\n</ol>\n<p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成<br>，栈帧对应着每次方法调用所占内存</p>\n<ol start=\"2\">\n<li><strong>上下文切换</strong></li>\n</ol>\n<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p>\n<blockquote>\n<p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p>\n</blockquote>\n<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p>\n<h2 id=\"2-4、start与run\"><a href=\"#2-4、start与run\" class=\"headerlink\" title=\"2.4、start与run\"></a>2.4、start与run</h2><ul>\n<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>\n<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>\n</ul>\n<h2 id=\"2-5、sleep-与-yield\"><a href=\"#2-5、sleep-与-yield\" class=\"headerlink\" title=\"2.5、sleep 与 yield\"></a>2.5、sleep 与 yield</h2><ol>\n<li><strong>sleep</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>睡眠结束后的线程未必会立刻得到执行</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>yield</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>具体的实现依赖于操作系统的任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-6、join\"><a href=\"#2-6、join\" class=\"headerlink\" title=\"2.6、join\"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    test1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">        r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"comment\">// t1.join();</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不加t1.join()结果为0，加上以后结果为1</p>\n</blockquote>\n<h2 id=\"2-7、interrupt\"><a href=\"#2-7、interrupt\" class=\"headerlink\" title=\"2.7、interrupt\"></a>2.7、interrupt</h2><h3 id=\"2-7-1、打断阻塞状态的线程\"><a href=\"#2-7-1、打断阻塞状态的线程\" class=\"headerlink\" title=\"2.7.1、打断阻塞状态的线程\"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t1.interrupt();</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">     at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">     at java.lang.Thread.sleep(Thread.java:<span class=\"number\">340</span>)</span><br><span class=\"line\">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class=\"number\">386</span>)</span><br><span class=\"line\">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class=\"number\">3</span>(TestInterrupt.java:<span class=\"number\">59</span>)</span><br><span class=\"line\">     at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">18</span>:<span class=\"number\">10.374</span> [main] c.TestInterrupt - 打断状态: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-2、打断正常运行的线程\"><a href=\"#2-7-2、打断正常运行的线程\" class=\"headerlink\" title=\"2.7.2、打断正常运行的线程\"></a>2.7.2、打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> current.isInterrupted();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(interrupted) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t2.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class=\"literal\">true</span> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8、主线程与守护线程\"><a href=\"#2-8、主线程与守护线程\" class=\"headerlink\" title=\"2.8、主线程与守护线程\"></a>2.8、主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </p>\n<p>例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;daemon&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置该线程为守护线程</span></span><br><span class=\"line\">t1.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>**注意 **</p>\n<ul>\n<li>垃圾回收器线程就是一种守护线程 </li>\n<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>\n</ul>\n</blockquote>\n<h2 id=\"2-9、线程状态\"><a href=\"#2-9、线程状态\" class=\"headerlink\" title=\"2.9、线程状态\"></a>2.9、线程状态</h2><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NEW</td>\n<td>初始状态:线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>阻塞状态:表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td>WAITING</td>\n<td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>\n</tr>\n<tr>\n<td>TIMEWAITING</td>\n<td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>终止状态:表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p><img src=\"/img/2.jpg\" alt=\"image.png\"></p>\n<h1 id=\"3、共享模型之管程\"><a href=\"#3、共享模型之管程\" class=\"headerlink\" title=\"3、共享模型之管程\"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p>\n<h2 id=\"3-1、monitor\"><a href=\"#3-1、monitor\" class=\"headerlink\" title=\"3.1、monitor\"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>\n<h3 id=\"3-1-1、Monitor结构\"><a href=\"#3-1-1、Monitor结构\" class=\"headerlink\" title=\"3.1.1、Monitor结构\"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet<br><img src=\"/img/3.jpg\" alt=\"image.png\"></p>\n<h3 id=\"3-1-2、Monitor原理\"><a href=\"#3-1-2、Monitor原理\" class=\"headerlink\" title=\"3.1.2、Monitor原理\"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n<h2 id=\"3-2、java对象结构\"><a href=\"#3-2、java对象结构\" class=\"headerlink\" title=\"3.2、java对象结构\"></a>3.2、java对象结构</h2><ol>\n<li><strong>对象头</strong></li>\n</ol>\n<p>包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）<br><img src=\"/img/4.jpg\" alt=\"image.png\"></p>\n<ol start=\"2\">\n<li><strong>实例数据</strong></li>\n</ol>\n<p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p>\n<ol start=\"3\">\n<li><strong>对齐填充</strong></li>\n</ol>\n<p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>\n<h2 id=\"3-3、synchronized升级\"><a href=\"#3-3、synchronized升级\" class=\"headerlink\" title=\"3.3、synchronized升级\"></a>3.3、synchronized升级</h2><h3 id=\"3-3-1、偏向锁\"><a href=\"#3-3-1、偏向锁\" class=\"headerlink\" title=\"3.3.1、偏向锁\"></a>3.3.1、偏向锁</h3><blockquote>\n<p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p>\n</blockquote>\n<p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>\n<h3 id=\"3-3-2、轻量级锁\"><a href=\"#3-3-2、轻量级锁\" class=\"headerlink\" title=\"3.3.2、轻量级锁\"></a>3.3.2、轻量级锁</h3><blockquote>\n<p>使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>\n</blockquote>\n<p><img src=\"/img/5.jpg\"></p>\n<ol>\n<li>创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象</li>\n<li>让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>\n<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>\n<li>如果 cas 失败，有两种情况</li>\n</ol>\n<p>（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程<br>（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）</p>\n<ol start=\"5\">\n<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>\n<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</li>\n</ol>\n<p>（1）成功，则解锁成功<br>（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>\n<h3 id=\"3-3-3、重量级锁\"><a href=\"#3-3-3、重量级锁\" class=\"headerlink\" title=\"3.3.3、重量级锁\"></a>3.3.3、重量级锁</h3><blockquote>\n<p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>\n</blockquote>\n<p><img src=\"/img/6.jpg\"></p>\n<ol>\n<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>\n<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</li>\n</ol>\n<p>（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<br>（2）然后自己进入 Monitor 的 EntryList阻塞队列</p>\n<ol start=\"3\">\n<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）<blockquote>\n<p>调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"3-3-4、自旋锁\"><a href=\"#3-3-4、自旋锁\" class=\"headerlink\" title=\"3.3.4、自旋锁\"></a>3.3.4、自旋锁</h3><p>重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)</p>\n<h2 id=\"3-4、wait-notify\"><a href=\"#3-4、wait-notify\" class=\"headerlink\" title=\"3.4、wait&#x2F;notify\"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p>\n<h3 id=\"3-4-1、sleep和wait的区别？\"><a href=\"#3-4-1、sleep和wait的区别？\" class=\"headerlink\" title=\"3.4.1、sleep和wait的区别？\"></a>3.4.1、sleep和wait的区别？</h3><ol>\n<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>\n<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>\n<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>\n</ol>\n<h2 id=\"3-5、park-unpark\"><a href=\"#3-5、park-unpark\" class=\"headerlink\" title=\"3.5、park&#x2F;unpark\"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂停当前线程</span></span><br><span class=\"line\">LockSupport.park(); </span><br><span class=\"line\"><span class=\"comment\">// 恢复某个线程的运行</span></span><br><span class=\"line\">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-1、与-Object-的-wait-notify-相比\"><a href=\"#3-5-1、与-Object-的-wait-notify-相比\" class=\"headerlink\" title=\"3.5.1、与 Object 的 wait &amp; notify 相比\"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul>\n<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>\n<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>\n<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>\n</ul>\n<h3 id=\"3-5-2、原理\"><a href=\"#3-5-2、原理\" class=\"headerlink\" title=\"3.5.2、原理\"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p>\n<p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p>\n<h2 id=\"3-6、死锁\"><a href=\"#3-6、死锁\" class=\"headerlink\" title=\"3.6、死锁\"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p>\n<h3 id=\"3-6-1、死锁的必要条件\"><a href=\"#3-6-1、死锁的必要条件\" class=\"headerlink\" title=\"3.6.1、死锁的必要条件\"></a>3.6.1、死锁的必要条件</h3><ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h3 id=\"3-6-2、死锁的实现\"><a href=\"#3-6-2、死锁的实现\" class=\"headerlink\" title=\"3.6.2、死锁的实现\"></a>3.6.2、死锁的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">owner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"comment\">//开启一个新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                lock(owner, target);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"comment\">//主线程</span></span><br><span class=\"line\">        lock(target, owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">(Object owner, Object target)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (owner) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (target) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;success&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-3、定位死锁\"><a href=\"#3-6-3、定位死锁\" class=\"headerlink\" title=\"3.6.3、定位死锁\"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p>\n<h3 id=\"3-6-4、哲学家就餐问题\"><a href=\"#3-6-4、哲学家就餐问题\" class=\"headerlink\" title=\"3.6.4、哲学家就餐问题\"></a>3.6.4、哲学家就餐问题</h3><p><img src=\"/img/7.jpg\" alt=\"image.png\"><br>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p>\n<ol>\n<li><p>筷子类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chopstick</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Chopstick</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;筷子&#123;&quot;</span> + name + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>哲学家类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Philosopher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    Chopstick left;</span><br><span class=\"line\">    Chopstick right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Philosopher</span><span class=\"params\">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;eating...&quot;</span>);</span><br><span class=\"line\">        Sleeper.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得左手筷子</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (left) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获得右手筷子</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (right) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">                    eat();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 放下右手筷子</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 放下左手筷子</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>就餐</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c5</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"3-7、活锁\"><a href=\"#3-7、活锁\" class=\"headerlink\" title=\"3.7、活锁\"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p>\n<blockquote>\n<p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p>\n</blockquote>\n<h2 id=\"3-8、ReentrantLock\"><a href=\"#3-8、ReentrantLock\" class=\"headerlink\" title=\"3.8、ReentrantLock\"></a>3.8、<strong>ReentrantLock</strong></h2><p>相对于 synchronized 它具备如下特点 </p>\n<ol>\n<li>可中断 </li>\n<li>可以设置超时时间 </li>\n<li>可以设置为公平锁 （默认不公平）</li>\n<li>支持多个条件变量</li>\n</ol>\n<p>与 synchronized 一样，都支持可重入 </p>\n<h1 id=\"4、共享模型之内存\"><a href=\"#4、共享模型之内存\" class=\"headerlink\" title=\"4、共享模型之内存\"></a>4、共享模型之内存</h1><h2 id=\"4-1、java内存模型（jmm）\"><a href=\"#4-1、java内存模型（jmm）\" class=\"headerlink\" title=\"4.1、java内存模型（jmm）\"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p>\n<h2 id=\"4-2、线程安全性的三个体现\"><a href=\"#4-2、线程安全性的三个体现\" class=\"headerlink\" title=\"4.2、线程安全性的三个体现\"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）<br><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）<br><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）</p>\n<h1 id=\"5、共享模型之无锁\"><a href=\"#5、共享模型之无锁\" class=\"headerlink\" title=\"5、共享模型之无锁\"></a>5、共享模型之无锁</h1><h2 id=\"5-1、CAS\"><a href=\"#5-1、CAS\" class=\"headerlink\" title=\"5.1、CAS\"></a>5.1、CAS</h2><h3 id=\"5-1-1、CAS基本概念\"><a href=\"#5-1-1、CAS基本概念\" class=\"headerlink\" title=\"5.1.1、CAS基本概念\"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>\n<blockquote>\n<ol>\n<li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li>\n<li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li>\n</ol>\n</blockquote>\n<h3 id=\"5-1-2、CAS问题\"><a href=\"#5-1-2、CAS问题\" class=\"headerlink\" title=\"5.1.2、CAS问题\"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p>\n<p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p>\n<h2 id=\"5-2、volatile\"><a href=\"#5-2、volatile\" class=\"headerlink\" title=\"5.2、volatile\"></a>5.2、volatile</h2><h3 id=\"5-2-1、如何保证可见性和有序性\"><a href=\"#5-2-1、如何保证可见性和有序性\" class=\"headerlink\" title=\"5.2.1、如何保证可见性和有序性\"></a>5.2.1、如何保证可见性和有序性</h3><ol>\n<li><strong>保证可见性（缓存一致性协议MESI）</strong></li>\n</ol>\n<p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p>\n<blockquote>\n<p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p>\n</blockquote>\n<blockquote>\n<p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>保证有序性（禁止指令重排优化）</strong></li>\n</ol>\n<p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p>\n<h2 id=\"5-3、原子类\"><a href=\"#5-3、原子类\" class=\"headerlink\" title=\"5.3、原子类\"></a>5.3、原子类</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>具体类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic 基本类型原子类</td>\n<td>AtomicInteger AtomicLong AtomicBoolean</td>\n</tr>\n<tr>\n<td>AtomicArray 数组类型原子类</td>\n<td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td>\n</tr>\n<tr>\n<td>AtomicReference 引用类型原子类</td>\n<td>AtomicReference AtomicStampedReference AtomicMarkableReference</td>\n</tr>\n<tr>\n<td>AtomicFieldUpdate 升级类型原子类</td>\n<td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td>\n</tr>\n</tbody></table>\n<h1 id=\"6、共享模式之工具\"><a href=\"#6、共享模式之工具\" class=\"headerlink\" title=\"6、共享模式之工具\"></a>6、共享模式之工具</h1><h2 id=\"6-1、线程池\"><a href=\"#6-1、线程池\" class=\"headerlink\" title=\"6.1、线程池\"></a>6.1、线程池</h2><h3 id=\"6-1-1、ThreadPoolExecutor\"><a href=\"#6-1-1、ThreadPoolExecutor\" class=\"headerlink\" title=\"6.1.1、ThreadPoolExecutor\"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol>\n<li><strong>构造方法</strong></li>\n</ol>\n<p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p>\n<blockquote>\n<ol>\n<li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li>\n<li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li>\n<li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li>\n<li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>\n<li>workQueue：缓存队列，用来存放等待被执行的任务。</li>\n<li>threadFactory 线程工厂</li>\n<li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>\n<h3 id=\"6-1-2、Executors类中提供的工厂方法\"><a href=\"#6-1-2、Executors类中提供的工厂方法\" class=\"headerlink\" title=\"6.1.2、Executors类中提供的工厂方法\"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p>\n<ol>\n<li><p><strong>newFixedThreadPool</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newFixedThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>特点：</p>\n<ul>\n<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>\n<li>阻塞队列是无界的，可以放任意数量的任务</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>适用于任务量已知，相对耗时的任务</p>\n</blockquote>\n</li>\n<li><p><strong>newCachedThreadPool</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newCachedThreadPool</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>特点 </p>\n<ul>\n<li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul>\n<li>全部都是救急线程（60s 后可以回收）</li>\n<li>救急线程可以无限创建</li>\n</ul>\n</li>\n<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p>\n</blockquote>\n</li>\n<li><p><strong>newSingleThreadExecutor</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newSingleThreadExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\">        (<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。</p>\n</li>\n</ol>\n<h3 id=\"6-1-3、创建多大的线程池\"><a href=\"#6-1-3、创建多大的线程池\" class=\"headerlink\" title=\"6.1.3、创建多大的线程池\"></a>6.1.3、创建多大的线程池</h3><ul>\n<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>\n<li>过大会导致更多的线程上下文切换，影响性能</li>\n</ul>\n<ol>\n<li>**CPU 密集型运算 **</li>\n</ol>\n<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>\n<ol start=\"2\">\n<li><strong>I&#x2F;O密集型</strong></li>\n</ol>\n<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>\n<h2 id=\"6-2、锁\"><a href=\"#6-2、锁\" class=\"headerlink\" title=\"6.2、锁\"></a>6.2、锁</h2><h3 id=\"6-2-1、AQS\"><a href=\"#6-2-1、AQS\" class=\"headerlink\" title=\"6.2.1、AQS\"></a>6.2.1、AQS</h3><ol>\n<li>基本概念</li>\n</ol>\n<p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p>\n<ol start=\"2\">\n<li>原理</li>\n</ol>\n<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>\n<blockquote>\n<p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>\n</blockquote>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p>\n<h3 id=\"6-2-2、ReentrantLock\"><a href=\"#6-2-2、ReentrantLock\" class=\"headerlink\" title=\"6.2.2、ReentrantLock\"></a>6.2.2、ReentrantLock</h3><p><strong>实现原理</strong></p>\n<ol>\n<li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li>\n<li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li>\n<li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li>\n<li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li>\n</ol>\n<p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p>\n<h3 id=\"6-2-3、ReentrantReadWriteLock\"><a href=\"#6-2-3、ReentrantReadWriteLock\" class=\"headerlink\" title=\"6.2.3、ReentrantReadWriteLock\"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id=\"4-2-3-1、ReentrantReadWriteLock基本概念\"><a href=\"#4-2-3-1、ReentrantReadWriteLock基本概念\" class=\"headerlink\" title=\"4.2.3.1、ReentrantReadWriteLock基本概念\"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p>\n<h4 id=\"4-2-3-2、锁获取过程\"><a href=\"#4-2-3-2、锁获取过程\" class=\"headerlink\" title=\"4.2.3.2、锁获取过程\"></a>4.2.3.2、锁获取过程</h4><ol>\n<li>获取读锁</li>\n</ol>\n<p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>     如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。</p>\n<ol start=\"4\">\n<li>获取写入锁</li>\n</ol>\n<p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p>\n<h4 id=\"4-2-3-3、常见问题\"><a href=\"#4-2-3-3、常见问题\" class=\"headerlink\" title=\"4.2.3.3、常见问题\"></a>4.2.3.3、常见问题</h4><ol>\n<li><strong>读锁和写锁的可重入性</strong></li>\n</ol>\n<p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p>\n<ol start=\"2\">\n<li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li>\n</ol>\n<p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p>\n<ol start=\"3\">\n<li><strong>锁降级是怎么降级的？</strong></li>\n</ol>\n<p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p>\n<h2 id=\"6-3、工具\"><a href=\"#6-3、工具\" class=\"headerlink\" title=\"6.3、工具\"></a>6.3、工具</h2><h3 id=\"6-3-1、Semaphore\"><a href=\"#6-3-1、Semaphore\" class=\"headerlink\" title=\"6.3.1、Semaphore\"></a>6.3.1、Semaphore</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourcePool</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//用到了信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DataSourcePool</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">        list = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        semaphore = <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">            list.add(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用同步方法获取</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class=\"line\">        semaphore.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">close</span><span class=\"params\">(Connection connection)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//信号量+1</span></span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">        list.add(connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p>\n<p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p>\n<h3 id=\"6-3-2、CountdownLatch\"><a href=\"#6-3-2、CountdownLatch\" class=\"headerlink\" title=\"6.3.2、CountdownLatch\"></a>6.3.2、CountdownLatch</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ExecutorService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1.5</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;wait end...&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - waiting... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">26.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - end..<span class=\"number\">.2</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.335</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - end..<span class=\"number\">.1</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - end..<span class=\"number\">.0</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - wait end...</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p>\n<ol start=\"3\">\n<li><strong>和join的区别？</strong></li>\n</ol>\n<p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p>\n<h3 id=\"6-3-3、CyclicBarrier\"><a href=\"#6-3-3、CyclicBarrier\" class=\"headerlink\" title=\"6.3.3、CyclicBarrier\"></a>6.3.3、CyclicBarrier</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(count, <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;全部加载完毕&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; x &lt; count; x++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(cb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    CyclicBarrier cyclicBarrier;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已加载完&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            cyclicBarrier.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">6</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">7</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">8</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">9</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">10</span> 已加载完</span><br><span class=\"line\">全部加载完毕</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p>\n<h2 id=\"6-4、线程安全集合类\"><a href=\"#6-4、线程安全集合类\" class=\"headerlink\" title=\"6.4、线程安全集合类\"></a>6.4、线程安全集合类</h2><h3 id=\"6-4-1、概述\"><a href=\"#6-4-1、概述\" class=\"headerlink\" title=\"6.4.1、概述\"></a>6.4.1、概述</h3><p><img src=\"/img/8.jpg\" alt=\"image.png\"><br>线程安全实现类有三类：</p>\n<ol>\n<li><p>遗留的线程安全集合如 Hashtable ， Vector </p>\n</li>\n<li><p>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</p>\n<blockquote>\n<ul>\n<li>Collections.synchronizedCollection </li>\n<li>Collections.synchronizedList </li>\n<li>Collections.synchronizedMap </li>\n<li>Collections.synchronizedSet </li>\n<li>Collections.synchronizedNavigableMap </li>\n<li>Collections.synchronizedNavigableSet</li>\n<li>Collections.synchronizedSortedMap </li>\n<li>Collections.synchronizedSortedSet</li>\n</ul>\n</blockquote>\n</li>\n<li><p>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent </p>\n<blockquote>\n<ul>\n<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li>\n<li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li>\n<li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul>\n<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>\n<li>弱一致性 <ul>\n<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<pre><code>  - 求大小弱一致性，size 操作未必是 100% 准确 \n  - 读取弱一致性 \n</code></pre>\n</blockquote>\n<blockquote>\n<p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p>\n</blockquote>\n<h3 id=\"6-4-2、concurrentHashMap\"><a href=\"#6-4-2、concurrentHashMap\" class=\"headerlink\" title=\"6.4.2、concurrentHashMap\"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p>\n<p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p>\n<p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p>\n<blockquote>\n<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p>\n</blockquote>\n<p><strong>JDK1.8</strong></p>\n<p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p>\n<ol>\n<li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li>\n<li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li>\n<li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li>\n<li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li>\n</ol>\n<h3 id=\"6-4-3、BlockingQueue\"><a href=\"#6-4-3、BlockingQueue\" class=\"headerlink\" title=\"6.4.3、BlockingQueue\"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p>\n<ol>\n<li>区别</li>\n</ol>\n<p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p>\n<h3 id=\"6-4-4、ConcurrentLinkedQueue\"><a href=\"#6-4-4、ConcurrentLinkedQueue\" class=\"headerlink\" title=\"6.4.4、ConcurrentLinkedQueue\"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p>\n<h3 id=\"6-4-5、CopyOnWriteArrayList\"><a href=\"#6-4-5、CopyOnWriteArrayList\" class=\"headerlink\" title=\"6.4.5、CopyOnWriteArrayList\"></a>6.4.5、CopyOnWriteArrayList</h3><ol>\n<li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li>\n<li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li>\n<li>写操作结束后会把原数组指向新数组</li>\n<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>\n</ol>\n"},{"title":"nginx","date":"2023-07-14T16:00:00.000Z","abbrlink":58122,"_content":"# 1、nginx简介\n## 1.1、nginx概述\nNginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。\n## 1.2、正向代理\nnginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能\n正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【**代理客户端，服务端不知道实际发起请求的客户端**】\n> 例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色\n\n## 1.3、反向代理\n反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【**代理服务端，客户端不知道实际提供服务的服务端**】\n> 例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在\n\n## 1.4、负载均衡\n增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 \n## 1.5、动静分离\n为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力\n> 静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，**但是 tomcat 本身处理静态资源的效率并不高**，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 \n\n\n# 2、nginx安装\n\n1. **安装pcre依赖**\n\n（1）联网下载 pcre 压缩文件依赖：\n```shell\nwget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n```\n（2）解压压缩文件\n```shell\ntar –xvf pcre-8.37.tar.gz\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）查看\n```shell\npcre-config --version\n```\n\n2. **安装安装 openssl 、zlib 、 gcc 依赖**\n\n```shell\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n3. **安装nginx**\n\n（1）解压\n```shell\ntar -xvf nginx-1.12.2.tar.gz\n```\n（2）进入解压后目录，执行config命令\n```shell\n./configure\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）启动nginx\n```shell\n# 进入进入目录 /usr/local/nginx/sbin/nginx\n./nginx\n# 停止\n./nginx -s stop\n# 重启\n./nginx -s reload\n\n```\n\n# 3、nginx配置文件\nNginx配置文件分为三大块：全局块，events块，http块\n\n1. 从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等\n2. events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024\n3. http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等\n\n```shell\n\n#================ 全局快 ==================#\n#定义Nginx运行的用户和用户组\nuser  nginx;\n# 工作进程数，一般配置成和CPU数一样\nworker_processes  auto;\n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log  /var/log/nginx/error.log notice;\n#进程pid文件\npid        /var/run/nginx.pid;\n\n#=============== events块 ================#\nevents {\n    # 标识单个woker进程最大并发数\n    worker_connections  1024;\n}\n\n#=============== http块 =================#\nhttp {\n    #文件扩展名与文件类型映射表\n    include       /etc/nginx/mime.types;\n    #默认文件类型\n    default_type  application/octet-stream;\n    #日志格式设定\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #定义本虚拟主机的访问日志\n    access_log  /var/log/nginx/access.log  main;\n     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载\n    sendfile        on;\n    #长连接超时时间，单位是秒\n    keepalive_timeout  65;\n    #包括多个server块，而每个server块就相当于一个虚拟主机\n    server {\n          listen       80;\n          server_name  localhost;\n          # 对特定地址进行处理，地址定向\n          location / {\n              root   html;\n              index  index.html index.htm;\n          }\n  \n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   html;\n      }\n}\n```\n\n# 4、反向代理实现\n实现效果：使用 Nginx 反向代理，访问www.123.com直接跳转到127.0.0.1:8080\n> 注意：此处如果要想从www.123.com跳转到本机指定的ip，需要修改本机的hosts文件。此处略过\n\n```shell\nserver {\n  #\t监听端口80 即当访问服务器的端口是80时，进入这个server块处理\n\tlisten       80;\n  # server_name当配置了listen时不起作用 \n\tserver_name  xxx;\n  # location后面代表访问路径 当是/ 请求时 代理到的地址\n\tlocation / {\n\t\troot   html;\n\t\tindex  index.html index.htm;\n    # 使用 proxy_pass（固定写法）后面跟要代理服务器地址 \n\t\tproxy_pass  http://127.0.0.1:8080\n\t}\n}\n\n```\n# 5、正向代理实现\n场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题\n场景2：内网机器访问外网，就需要正向代理，类似VPN\n```shell\nserver {\n\tlisten 8090;\n\t\n\tlocation / {\n    # resolver后面填写dns地址，可以多个，将以轮询方式请求\n\t\tresolver 218.85.157.99 218.85.152.99;\n    # resolver_timeout 解析超时时间\n\t\tresolver_timeout 30s;\n    # 代理服务器地址（即要请求的地址）\n\t\tproxy_pass http://$host$request_uri;\n\t}\n\taccess_log /data/httplogs/proxy-$host-aceess.log;\n}\n\n```\n# 6、负载均衡实现\n## 6.1、轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除\n```shell\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    upstream webservers{\n      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n \n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n             #转发到负载服务上\n            proxy_pass http://webservers/api/;\n         }\n    }\n}\n```\n## 6.2、weight\nweight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。\n```shell\n\n    upstream webservers{\n      server  192.168.9.134:8081 weight=8;\n      server  192.168.9.134:8082 weight=2;\n    }\n```\n## 6.3、ip_hash\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\n> 使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题\n\n```shell\n    upstream webservers{\n      ip_hash;\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n```\n## 6.4、fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```shell\nupstream webservers{\n        server 192.168.9.134:8081;\n        server 192.168.9.134:8082;\n        fair;\n}\n```\n## 6.5、url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n> 相同的url会被分配到同一个节点，主要为了提高缓存命中率\n\n```shell\nupstream webservers{\n    hash &request_uri;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n## 6.6、least_conn\n按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况\n```shell\nupstream webservers{\n    least_conn;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n# 7、动静分离\n利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能\n```shell\n#所有js,css相关的静态资源文件的请求由Nginx处理\nlocation ~.*\\.(js|css)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     12h; #过期时间为12小时\n}\n#所有图片等多媒体相关静态资源文件的请求由Nginx处理\nlocation ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     7d; #过期时间为7天\n}\n```\n","source":"_posts/Nginx.md","raw":"---\ntitle: nginx\ndate: 2023/07/15\ncategories:\n  - coding\ntags:\n  - nginx\nabbrlink: 58122\n---\n# 1、nginx简介\n## 1.1、nginx概述\nNginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。\n## 1.2、正向代理\nnginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能\n正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【**代理客户端，服务端不知道实际发起请求的客户端**】\n> 例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色\n\n## 1.3、反向代理\n反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【**代理服务端，客户端不知道实际提供服务的服务端**】\n> 例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在\n\n## 1.4、负载均衡\n增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 \n## 1.5、动静分离\n为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力\n> 静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，**但是 tomcat 本身处理静态资源的效率并不高**，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 \n\n\n# 2、nginx安装\n\n1. **安装pcre依赖**\n\n（1）联网下载 pcre 压缩文件依赖：\n```shell\nwget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n```\n（2）解压压缩文件\n```shell\ntar –xvf pcre-8.37.tar.gz\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）查看\n```shell\npcre-config --version\n```\n\n2. **安装安装 openssl 、zlib 、 gcc 依赖**\n\n```shell\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n3. **安装nginx**\n\n（1）解压\n```shell\ntar -xvf nginx-1.12.2.tar.gz\n```\n（2）进入解压后目录，执行config命令\n```shell\n./configure\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）启动nginx\n```shell\n# 进入进入目录 /usr/local/nginx/sbin/nginx\n./nginx\n# 停止\n./nginx -s stop\n# 重启\n./nginx -s reload\n\n```\n\n# 3、nginx配置文件\nNginx配置文件分为三大块：全局块，events块，http块\n\n1. 从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等\n2. events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024\n3. http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等\n\n```shell\n\n#================ 全局快 ==================#\n#定义Nginx运行的用户和用户组\nuser  nginx;\n# 工作进程数，一般配置成和CPU数一样\nworker_processes  auto;\n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log  /var/log/nginx/error.log notice;\n#进程pid文件\npid        /var/run/nginx.pid;\n\n#=============== events块 ================#\nevents {\n    # 标识单个woker进程最大并发数\n    worker_connections  1024;\n}\n\n#=============== http块 =================#\nhttp {\n    #文件扩展名与文件类型映射表\n    include       /etc/nginx/mime.types;\n    #默认文件类型\n    default_type  application/octet-stream;\n    #日志格式设定\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #定义本虚拟主机的访问日志\n    access_log  /var/log/nginx/access.log  main;\n     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载\n    sendfile        on;\n    #长连接超时时间，单位是秒\n    keepalive_timeout  65;\n    #包括多个server块，而每个server块就相当于一个虚拟主机\n    server {\n          listen       80;\n          server_name  localhost;\n          # 对特定地址进行处理，地址定向\n          location / {\n              root   html;\n              index  index.html index.htm;\n          }\n  \n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   html;\n      }\n}\n```\n\n# 4、反向代理实现\n实现效果：使用 Nginx 反向代理，访问www.123.com直接跳转到127.0.0.1:8080\n> 注意：此处如果要想从www.123.com跳转到本机指定的ip，需要修改本机的hosts文件。此处略过\n\n```shell\nserver {\n  #\t监听端口80 即当访问服务器的端口是80时，进入这个server块处理\n\tlisten       80;\n  # server_name当配置了listen时不起作用 \n\tserver_name  xxx;\n  # location后面代表访问路径 当是/ 请求时 代理到的地址\n\tlocation / {\n\t\troot   html;\n\t\tindex  index.html index.htm;\n    # 使用 proxy_pass（固定写法）后面跟要代理服务器地址 \n\t\tproxy_pass  http://127.0.0.1:8080\n\t}\n}\n\n```\n# 5、正向代理实现\n场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题\n场景2：内网机器访问外网，就需要正向代理，类似VPN\n```shell\nserver {\n\tlisten 8090;\n\t\n\tlocation / {\n    # resolver后面填写dns地址，可以多个，将以轮询方式请求\n\t\tresolver 218.85.157.99 218.85.152.99;\n    # resolver_timeout 解析超时时间\n\t\tresolver_timeout 30s;\n    # 代理服务器地址（即要请求的地址）\n\t\tproxy_pass http://$host$request_uri;\n\t}\n\taccess_log /data/httplogs/proxy-$host-aceess.log;\n}\n\n```\n# 6、负载均衡实现\n## 6.1、轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除\n```shell\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    upstream webservers{\n      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n \n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n             #转发到负载服务上\n            proxy_pass http://webservers/api/;\n         }\n    }\n}\n```\n## 6.2、weight\nweight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。\n```shell\n\n    upstream webservers{\n      server  192.168.9.134:8081 weight=8;\n      server  192.168.9.134:8082 weight=2;\n    }\n```\n## 6.3、ip_hash\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\n> 使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题\n\n```shell\n    upstream webservers{\n      ip_hash;\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n```\n## 6.4、fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```shell\nupstream webservers{\n        server 192.168.9.134:8081;\n        server 192.168.9.134:8082;\n        fair;\n}\n```\n## 6.5、url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n> 相同的url会被分配到同一个节点，主要为了提高缓存命中率\n\n```shell\nupstream webservers{\n    hash &request_uri;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n## 6.6、least_conn\n按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况\n```shell\nupstream webservers{\n    least_conn;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n# 7、动静分离\n利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能\n```shell\n#所有js,css相关的静态资源文件的请求由Nginx处理\nlocation ~.*\\.(js|css)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     12h; #过期时间为12小时\n}\n#所有图片等多媒体相关静态资源文件的请求由Nginx处理\nlocation ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     7d; #过期时间为7天\n}\n```\n","slug":"Nginx","published":1,"updated":"2023-07-15T09:49:49.112Z","_id":"clk3ttrq800050suj29az4sv5","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1、nginx简介\"><a href=\"#1、nginx简介\" class=\"headerlink\" title=\"1、nginx简介\"></a>1、nginx简介</h1><h2 id=\"1-1、nginx概述\"><a href=\"#1-1、nginx概述\" class=\"headerlink\" title=\"1.1、nginx概述\"></a>1.1、nginx概述</h2><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。</p>\n<h2 id=\"1-2、正向代理\"><a href=\"#1-2、正向代理\" class=\"headerlink\" title=\"1.2、正向代理\"></a>1.2、正向代理</h2><p>nginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能<br>正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【<strong>代理客户端，服务端不知道实际发起请求的客户端</strong>】</p>\n<blockquote>\n<p>例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色</p>\n</blockquote>\n<h2 id=\"1-3、反向代理\"><a href=\"#1-3、反向代理\" class=\"headerlink\" title=\"1.3、反向代理\"></a>1.3、反向代理</h2><p>反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【<strong>代理服务端，客户端不知道实际提供服务的服务端</strong>】</p>\n<blockquote>\n<p>例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在</p>\n</blockquote>\n<h2 id=\"1-4、负载均衡\"><a href=\"#1-4、负载均衡\" class=\"headerlink\" title=\"1.4、负载均衡\"></a>1.4、负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 </p>\n<h2 id=\"1-5、动静分离\"><a href=\"#1-5、动静分离\" class=\"headerlink\" title=\"1.5、动静分离\"></a>1.5、动静分离</h2><p>为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p>\n<blockquote>\n<p>静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，<strong>但是 tomcat 本身处理静态资源的效率并不高</strong>，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 </p>\n</blockquote>\n<h1 id=\"2、nginx安装\"><a href=\"#2、nginx安装\" class=\"headerlink\" title=\"2、nginx安装\"></a>2、nginx安装</h1><ol>\n<li><strong>安装pcre依赖</strong></li>\n</ol>\n<p>（1）联网下载 pcre 压缩文件依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）解压压缩文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar –xvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcre-config --version</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>安装安装 openssl 、zlib 、 gcc 依赖</strong></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>安装nginx</strong></li>\n</ol>\n<p>（1）解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）进入解压后目录，执行config命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入进入目录 /usr/local/nginx/sbin/nginx</span></span><br><span class=\"line\">./nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止</span></span><br><span class=\"line\">./nginx -s stop</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">./nginx -s reload</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、nginx配置文件\"><a href=\"#3、nginx配置文件\" class=\"headerlink\" title=\"3、nginx配置文件\"></a>3、nginx配置文件</h1><p>Nginx配置文件分为三大块：全局块，events块，http块</p>\n<ol>\n<li>从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等</li>\n<li>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024</li>\n<li>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">================ 全局快 ==================<span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">定义Nginx运行的用户和用户组</span></span><br><span class=\"line\">user  nginx;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作进程数，一般配置成和CPU数一样</span></span><br><span class=\"line\">worker_processes  auto;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class=\"line\">error_log  /var/log/nginx/error.log notice;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">进程pid文件</span></span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== events块 ================<span class=\"comment\">#</span></span></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 标识单个woker进程最大并发数</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== http块 =================<span class=\"comment\">#</span></span></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    #文件扩展名与文件类型映射表</span><br><span class=\"line\">    include       /etc/nginx/mime.types;</span><br><span class=\"line\">    #默认文件类型</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    #日志格式设定</span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\">    #定义本虚拟主机的访问日志</span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\">     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #长连接超时时间，单位是秒</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    #包括多个server块，而每个server块就相当于一个虚拟主机</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">          listen       80;</span><br><span class=\"line\">          server_name  localhost;</span><br><span class=\"line\">          # 对特定地址进行处理，地址定向</span><br><span class=\"line\">          location / &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">              index  index.html index.htm;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">          location = /50x.html &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、反向代理实现\"><a href=\"#4、反向代理实现\" class=\"headerlink\" title=\"4、反向代理实现\"></a>4、反向代理实现</h1><p>实现效果：使用 Nginx 反向代理，访问<a href=\"http://www.123.com直接跳转到127.0.0.1:8080\">www.123.com直接跳转到127.0.0.1:8080</a></p>\n<blockquote>\n<p>注意：此处如果要想从<a href=\"http://www.123.com跳转到本机指定的ip,需要修改本机的hosts文件.此处略过/\">www.123.com跳转到本机指定的ip，需要修改本机的hosts文件。此处略过</a></p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">\t监听端口80 即当访问服务器的端口是80时，进入这个server块处理</span></span><br><span class=\"line\">\tlisten       80;</span><br><span class=\"line\"><span class=\"meta prompt_\">  # </span><span class=\"language-bash\">server_name当配置了listen时不起作用</span> </span><br><span class=\"line\">\tserver_name  xxx;</span><br><span class=\"line\"><span class=\"meta prompt_\">  # </span><span class=\"language-bash\">location后面代表访问路径 当是/ 请求时 代理到的地址</span></span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\troot   html;</span><br><span class=\"line\">\t\tindex  index.html index.htm;</span><br><span class=\"line\">    # 使用 proxy_pass（固定写法）后面跟要代理服务器地址 </span><br><span class=\"line\">\t\tproxy_pass  http://127.0.0.1:8080</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"5、正向代理实现\"><a href=\"#5、正向代理实现\" class=\"headerlink\" title=\"5、正向代理实现\"></a>5、正向代理实现</h1><p>场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题<br>场景2：内网机器访问外网，就需要正向代理，类似VPN</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 8090;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">    # resolver后面填写dns地址，可以多个，将以轮询方式请求</span><br><span class=\"line\">\t\tresolver 218.85.157.99 218.85.152.99;</span><br><span class=\"line\">    # resolver_timeout 解析超时时间</span><br><span class=\"line\">\t\tresolver_timeout 30s;</span><br><span class=\"line\">    # 代理服务器地址（即要请求的地址）</span><br><span class=\"line\">\t\tproxy_pass http://$host$request_uri;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taccess_log /data/httplogs/proxy-$host-aceess.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、负载均衡实现\"><a href=\"#6、负载均衡实现\" class=\"headerlink\" title=\"6、负载均衡实现\"></a>6、负载均衡实现</h1><h2 id=\"6-1、轮询（默认）\"><a href=\"#6-1、轮询（默认）\" class=\"headerlink\" title=\"6.1、轮询（默认）\"></a>6.1、轮询（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    upstream webservers&#123;</span><br><span class=\"line\">      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问</span><br><span class=\"line\">      server  192.168.9.134:8081;</span><br><span class=\"line\">      server  192.168.9.134:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">             #转发到负载服务上</span><br><span class=\"line\">            proxy_pass http://webservers/api/;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2、weight\"><a href=\"#6-2、weight\" class=\"headerlink\" title=\"6.2、weight\"></a>6.2、weight</h2><p>weight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  server  192.168.9.134:8081 weight=8;</span><br><span class=\"line\">  server  192.168.9.134:8082 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3、ip-hash\"><a href=\"#6-3、ip-hash\" class=\"headerlink\" title=\"6.3、ip_hash\"></a>6.3、ip_hash</h2><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>\n<blockquote>\n<p>使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server  192.168.9.134:8081;</span><br><span class=\"line\">  server  192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-4、fair\"><a href=\"#6-4、fair\" class=\"headerlink\" title=\"6.4、fair\"></a>6.4、fair</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">        server 192.168.9.134:8081;</span><br><span class=\"line\">        server 192.168.9.134:8082;</span><br><span class=\"line\">        fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、url-hash\"><a href=\"#6-5、url-hash\" class=\"headerlink\" title=\"6.5、url_hash\"></a>6.5、url_hash</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<blockquote>\n<p>相同的url会被分配到同一个节点，主要为了提高缓存命中率</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    hash &amp;request_uri;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-6、least-conn\"><a href=\"#6-6、least-conn\" class=\"headerlink\" title=\"6.6、least_conn\"></a>6.6、least_conn</h2><p>按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、动静分离\"><a href=\"#7、动静分离\" class=\"headerlink\" title=\"7、动静分离\"></a>7、动静分离</h1><p>利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有js,css相关的静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(js|css)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     12h; #过期时间为12小时</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有图片等多媒体相关静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     7d; #过期时间为7天</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、nginx简介\"><a href=\"#1、nginx简介\" class=\"headerlink\" title=\"1、nginx简介\"></a>1、nginx简介</h1><h2 id=\"1-1、nginx概述\"><a href=\"#1-1、nginx概述\" class=\"headerlink\" title=\"1.1、nginx概述\"></a>1.1、nginx概述</h2><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。</p>\n<h2 id=\"1-2、正向代理\"><a href=\"#1-2、正向代理\" class=\"headerlink\" title=\"1.2、正向代理\"></a>1.2、正向代理</h2><p>nginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能<br>正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【<strong>代理客户端，服务端不知道实际发起请求的客户端</strong>】</p>\n<blockquote>\n<p>例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色</p>\n</blockquote>\n<h2 id=\"1-3、反向代理\"><a href=\"#1-3、反向代理\" class=\"headerlink\" title=\"1.3、反向代理\"></a>1.3、反向代理</h2><p>反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【<strong>代理服务端，客户端不知道实际提供服务的服务端</strong>】</p>\n<blockquote>\n<p>例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在</p>\n</blockquote>\n<h2 id=\"1-4、负载均衡\"><a href=\"#1-4、负载均衡\" class=\"headerlink\" title=\"1.4、负载均衡\"></a>1.4、负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 </p>\n<h2 id=\"1-5、动静分离\"><a href=\"#1-5、动静分离\" class=\"headerlink\" title=\"1.5、动静分离\"></a>1.5、动静分离</h2><p>为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p>\n<blockquote>\n<p>静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，<strong>但是 tomcat 本身处理静态资源的效率并不高</strong>，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 </p>\n</blockquote>\n<h1 id=\"2、nginx安装\"><a href=\"#2、nginx安装\" class=\"headerlink\" title=\"2、nginx安装\"></a>2、nginx安装</h1><ol>\n<li><strong>安装pcre依赖</strong></li>\n</ol>\n<p>（1）联网下载 pcre 压缩文件依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）解压压缩文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar –xvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcre-config --version</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>安装安装 openssl 、zlib 、 gcc 依赖</strong></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>安装nginx</strong></li>\n</ol>\n<p>（1）解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）进入解压后目录，执行config命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入进入目录 /usr/local/nginx/sbin/nginx</span></span><br><span class=\"line\">./nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止</span></span><br><span class=\"line\">./nginx -s stop</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">./nginx -s reload</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、nginx配置文件\"><a href=\"#3、nginx配置文件\" class=\"headerlink\" title=\"3、nginx配置文件\"></a>3、nginx配置文件</h1><p>Nginx配置文件分为三大块：全局块，events块，http块</p>\n<ol>\n<li>从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等</li>\n<li>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024</li>\n<li>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">================ 全局快 ==================<span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">定义Nginx运行的用户和用户组</span></span><br><span class=\"line\">user  nginx;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作进程数，一般配置成和CPU数一样</span></span><br><span class=\"line\">worker_processes  auto;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class=\"line\">error_log  /var/log/nginx/error.log notice;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">进程pid文件</span></span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== events块 ================<span class=\"comment\">#</span></span></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 标识单个woker进程最大并发数</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== http块 =================<span class=\"comment\">#</span></span></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    #文件扩展名与文件类型映射表</span><br><span class=\"line\">    include       /etc/nginx/mime.types;</span><br><span class=\"line\">    #默认文件类型</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    #日志格式设定</span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\">    #定义本虚拟主机的访问日志</span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\">     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #长连接超时时间，单位是秒</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    #包括多个server块，而每个server块就相当于一个虚拟主机</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">          listen       80;</span><br><span class=\"line\">          server_name  localhost;</span><br><span class=\"line\">          # 对特定地址进行处理，地址定向</span><br><span class=\"line\">          location / &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">              index  index.html index.htm;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">          location = /50x.html &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、反向代理实现\"><a href=\"#4、反向代理实现\" class=\"headerlink\" title=\"4、反向代理实现\"></a>4、反向代理实现</h1><p>实现效果：使用 Nginx 反向代理，访问<a href=\"http://www.123.com直接跳转到127.0.0.1:8080\">www.123.com直接跳转到127.0.0.1:8080</a></p>\n<blockquote>\n<p>注意：此处如果要想从<a href=\"http://www.123.com跳转到本机指定的ip,需要修改本机的hosts文件.此处略过/\">www.123.com跳转到本机指定的ip，需要修改本机的hosts文件。此处略过</a></p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\"><span class=\"meta prompt_\">  #</span><span class=\"language-bash\">\t监听端口80 即当访问服务器的端口是80时，进入这个server块处理</span></span><br><span class=\"line\">\tlisten       80;</span><br><span class=\"line\"><span class=\"meta prompt_\">  # </span><span class=\"language-bash\">server_name当配置了listen时不起作用</span> </span><br><span class=\"line\">\tserver_name  xxx;</span><br><span class=\"line\"><span class=\"meta prompt_\">  # </span><span class=\"language-bash\">location后面代表访问路径 当是/ 请求时 代理到的地址</span></span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">\t\troot   html;</span><br><span class=\"line\">\t\tindex  index.html index.htm;</span><br><span class=\"line\">    # 使用 proxy_pass（固定写法）后面跟要代理服务器地址 </span><br><span class=\"line\">\t\tproxy_pass  http://127.0.0.1:8080</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"5、正向代理实现\"><a href=\"#5、正向代理实现\" class=\"headerlink\" title=\"5、正向代理实现\"></a>5、正向代理实现</h1><p>场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题<br>场景2：内网机器访问外网，就需要正向代理，类似VPN</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 8090;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">    # resolver后面填写dns地址，可以多个，将以轮询方式请求</span><br><span class=\"line\">\t\tresolver 218.85.157.99 218.85.152.99;</span><br><span class=\"line\">    # resolver_timeout 解析超时时间</span><br><span class=\"line\">\t\tresolver_timeout 30s;</span><br><span class=\"line\">    # 代理服务器地址（即要请求的地址）</span><br><span class=\"line\">\t\tproxy_pass http://$host$request_uri;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taccess_log /data/httplogs/proxy-$host-aceess.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、负载均衡实现\"><a href=\"#6、负载均衡实现\" class=\"headerlink\" title=\"6、负载均衡实现\"></a>6、负载均衡实现</h1><h2 id=\"6-1、轮询（默认）\"><a href=\"#6-1、轮询（默认）\" class=\"headerlink\" title=\"6.1、轮询（默认）\"></a>6.1、轮询（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    upstream webservers&#123;</span><br><span class=\"line\">      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问</span><br><span class=\"line\">      server  192.168.9.134:8081;</span><br><span class=\"line\">      server  192.168.9.134:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">             #转发到负载服务上</span><br><span class=\"line\">            proxy_pass http://webservers/api/;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2、weight\"><a href=\"#6-2、weight\" class=\"headerlink\" title=\"6.2、weight\"></a>6.2、weight</h2><p>weight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  server  192.168.9.134:8081 weight=8;</span><br><span class=\"line\">  server  192.168.9.134:8082 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3、ip-hash\"><a href=\"#6-3、ip-hash\" class=\"headerlink\" title=\"6.3、ip_hash\"></a>6.3、ip_hash</h2><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>\n<blockquote>\n<p>使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server  192.168.9.134:8081;</span><br><span class=\"line\">  server  192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-4、fair\"><a href=\"#6-4、fair\" class=\"headerlink\" title=\"6.4、fair\"></a>6.4、fair</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">        server 192.168.9.134:8081;</span><br><span class=\"line\">        server 192.168.9.134:8082;</span><br><span class=\"line\">        fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、url-hash\"><a href=\"#6-5、url-hash\" class=\"headerlink\" title=\"6.5、url_hash\"></a>6.5、url_hash</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<blockquote>\n<p>相同的url会被分配到同一个节点，主要为了提高缓存命中率</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    hash &amp;request_uri;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-6、least-conn\"><a href=\"#6-6、least-conn\" class=\"headerlink\" title=\"6.6、least_conn\"></a>6.6、least_conn</h2><p>按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、动静分离\"><a href=\"#7、动静分离\" class=\"headerlink\" title=\"7、动静分离\"></a>7、动静分离</h1><p>利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有js,css相关的静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(js|css)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     12h; #过期时间为12小时</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有图片等多媒体相关静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     7d; #过期时间为7天</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clk3ttrq600040suj0h7l8qbx","category_id":"clk3ttrq900060suj4rmx5qgn","_id":"clk3ttrqb000a0suj9gp4hty8"},{"post_id":"clk3ttrq800050suj29az4sv5","category_id":"clk3ttrq900060suj4rmx5qgn","_id":"clk3ttrqc000c0suj47xke9ay"}],"PostTag":[{"post_id":"clk3ttrq600040suj0h7l8qbx","tag_id":"clk3ttrqa00070sujheiwghkt","_id":"clk3ttrqd000e0sujcoaye65k"},{"post_id":"clk3ttrq600040suj0h7l8qbx","tag_id":"clk3ttrqa00090suj8gvd5brv","_id":"clk3ttrqd000f0sujfw7p1le5"},{"post_id":"clk3ttrq600040suj0h7l8qbx","tag_id":"clk3ttrqb000b0suj30pz3afl","_id":"clk3ttrqd000g0suja8tlhv3z"},{"post_id":"clk3ttrq800050suj29az4sv5","tag_id":"clk3ttrqc000d0suj1wlyfa1q","_id":"clk3ttrqd000h0suj5ypc5eyf"}],"Tag":[{"name":"juc","_id":"clk3ttrqa00070sujheiwghkt"},{"name":"多线程","_id":"clk3ttrqa00090suj8gvd5brv"},{"name":"并发编程","_id":"clk3ttrqb000b0suj30pz3afl"},{"name":"nginx","_id":"clk3ttrqc000d0suj1wlyfa1q"}]}}