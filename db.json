{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/custom.css","path":"css/custom.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/foot.js","path":"js/foot.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/css/LXGWZhenKai.ttf","path":"css/LXGWZhenKai.ttf","modified":0,"renderable":0}],"Cache":[{"_id":"source/README.md","hash":"3cf29680a7f1c21572333cf7cf2029c6c567e670","modified":1690291154793},{"_id":"source/CNAME","hash":"0ba2ea8a346b2e193945de5bc8f9d9aa4a81461b","modified":1690291154793},{"_id":"source/about/index.md","hash":"85030780f80671822c6a757e5a7f2b29019b2604","modified":1690899888047},{"_id":"source/_posts/JUC.md","hash":"8aaf0db24ff40f8cad44a994372cc47879194a57","modified":1690291154794},{"_id":"source/_posts/java core.md","hash":"444f78f3c6e56efd96b2c0b5813384a906f0c7f8","modified":1698766015107},{"_id":"source/_posts/RabbitMQ.md","hash":"7c60db4b71f6c72d4f3759e932aa34e2fa5479ae","modified":1690814177201},{"_id":"source/_posts/Nginx.md","hash":"859f0713169b5d093cfe86cab01455ff30281b57","modified":1690291154796},{"_id":"source/_posts/PBRTQC质控功能实现.md","hash":"2e6c31fca8fdb953e0f295481e3b6f52aba04132","modified":1697720257898},{"_id":"source/_posts/jvm.md","hash":"6cee72e37f1455a30a1437233cae1fd2a004f6ab","modified":1697986106461},{"_id":"source/_posts/dubbo.md","hash":"9ea8cb94b6032fc20904ad0c63e1db55db5da7b7","modified":1691227593560},{"_id":"source/_posts/redis.md","hash":"a3c62ce322df034d4a3752a75a40090824c70285","modified":1691598177638},{"_id":"source/_posts/sharding-jdbc.md","hash":"3c38b22173d0890703346fd42061bc4c0486108d","modified":1694857506697},{"_id":"source/_posts/sharding-jdbc实现自动按月分表.md","hash":"5194f161d32fdcf04760fd2487c64cfbf4e99c2e","modified":1697720257904},{"_id":"source/_posts/shiro.md","hash":"b95881942bfa09894369f89b56ab9da0b7adb72a","modified":1694857506697},{"_id":"source/_posts/mysql.md","hash":"44f3b4a80e1fa3ea5497384ea172de8190937aee","modified":1693399192855},{"_id":"source/_posts/中国古代史.md","hash":"80fb5b19e296cb9b1cf49e149ea1d9a00ed7b452","modified":1698670282931},{"_id":"source/_posts/spring.md","hash":"5c440b91d0bbc87e07d6ab7a0ab3a430978259fd","modified":1690291154801},{"_id":"source/_posts/西方哲学史.md","hash":"9d8a018fdfca843067d754510d2a0da35e1fcba6","modified":1698670282923},{"_id":"source/_posts/快乐源泉.md","hash":"be38ad696c85a4d2067d01657245560110413027","modified":1694005831996},{"_id":"source/_posts/springCloud.md","hash":"962b9c9154ffebe288d3611cae8495d81ac0b4b8","modified":1690610956800},{"_id":"source/_posts/thymeleaf.md","hash":"6dcfa3771dcf8211a2c57cf675733a7e924a2df3","modified":1694005832004},{"_id":"source/_posts/认知.md","hash":"04bd0b93a2ce397838ef482e578953b543d57709","modified":1694917803375},{"_id":"source/categories/index.md","hash":"2f5289cf24818f4762f158fd603bdc47ca3cf1bf","modified":1690291154802},{"_id":"source/css/custom.css","hash":"72b3900fac2a8af003a1bf4abba69dcfa6251f22","modified":1690291154845},{"_id":"source/tags/index.md","hash":"537fa92c4d8d77af6f4a699df28695fe0c9a6565","modified":1690291154845},{"_id":"themes/butterfly/package.json","hash":"a6a032654a36408d7b7274bc9cfe21f89946d29c","modified":1690291154861},{"_id":"themes/butterfly/_config.yml","hash":"2acd15800f625f6321b15f44d5078eeec2ba9a6b","modified":1691284241549},{"_id":"themes/butterfly/plugins.yml","hash":"6d68dab3b79accb1bceb4710c8aaab724a45053a","modified":1690291154861},{"_id":"themes/butterfly/languages/en.yml","hash":"4957fd976c99745d3aa24000a85b2955e8d1cf81","modified":1690291154847},{"_id":"themes/butterfly/languages/default.yml","hash":"d444cbb5c5456aaf27f3fb1b4308634689c7bb53","modified":1690291154847},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"cc8672dc0c2762b694f689cbeb6e34810f1c194e","modified":1690291154847},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"145ec301db185c8a06de1f34a77ca391e1d2729b","modified":1690291154847},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1690291154848},{"_id":"themes/butterfly/layout/archive.pug","hash":"115fa5ee8864e5c97549eff91a17c66101d724ab","modified":1690291154847},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1690291154860},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1690291154860},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1690291154861},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1690291154861},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1690291154862},{"_id":"themes/butterfly/scripts/events/comment.js","hash":"95479790234c291b064d031577d71214cdd1d820","modified":1690291154862},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1690291154861},{"_id":"themes/butterfly/scripts/events/cdn.js","hash":"7864ba45716c51aef8d8b04fd4bc212e0008ce3b","modified":1690291154862},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"a3323fcb11cfd3f3e21230737341beb5d76b40aa","modified":1690291154862},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"f59e10305fef59ea3e62a7395106c0927582879d","modified":1690291154862},{"_id":"themes/butterfly/scripts/events/init.js","hash":"ce68e84a9ccfcf91100befbaa9afc392a0cd93bb","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1690291154862},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"6005907245dd74b153f03afdccfae1abb66bb482","modified":1690291154863},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/findArchiveLength.js","hash":"8ff03b35385f9162e1eb54dceb5fa7f781306caf","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"7222102f9919f8e961d4f1688425845fb7775ada","modified":1690291154862},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"76343ac8422c9c8539082e77eda6ffee4b877eb2","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"b8d95ac1851c37f1dce4b1dd4a1d3ffdff501a03","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1690291154863},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"56a5d41487d74654b75305c5325167a116495900","modified":1690291154864},{"_id":"themes/butterfly/scripts/tag/score.js","hash":"fc5a80707cf522378be3cf8638ef78bccc88c510","modified":1690291154864},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1690291154864},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1690291154864},{"_id":"themes/butterfly/source/css/custom.css","hash":"941d80e05e34f710eb978e0040ab14e3a6f727bf","modified":1690291154869},{"_id":"themes/butterfly/README_CN.md","hash":"f6ae7f38d016135340fd25c5fd1be65452b6773d","modified":1690291154846},{"_id":"themes/butterfly/README.md","hash":"5ca893c78f8971f512da55c785b8ccbfa9d37cfc","modified":1690291154846},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1690291154846},{"_id":"themes/butterfly/source/css/index.styl","hash":"b13d96924a5534bff91d75566b196ac87b4fac22","modified":1690291154869},{"_id":"themes/butterfly/source/js/foot.js","hash":"f34bd2010f21c3d9d0751cb5e534218b8c457afd","modified":1691073857011},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"a102a6cacf7b20183946a54580867a964f3674c4","modified":1690291154873},{"_id":"themes/butterfly/source/css/var.styl","hash":"e1e37a2e932163886789b72624c7348545003f1d","modified":1690291154869},{"_id":"themes/butterfly/source/js/utils.js","hash":"13b2b02118a0f4ec2e9e0bb1b90f5b1a30a70f44","modified":1690291154873},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1690291154870},{"_id":"themes/butterfly/source/js/main.js","hash":"4fd1cd7a02dedcb686caf6149c35fd8e1fbcafc9","modified":1690291154872},{"_id":"themes/butterfly/source/img/avatar.jpg","hash":"bbf597f4a75a617bed638ac124502fd76068f62b","modified":1690291154870},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1690291154848},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"50eea5aa78cdeb6c72dd22f0aeabc407cc0f712e","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"e334a2688ca1ae9095dd4058710fc5eaf1353cca","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"96df62e34661d8ca4a45267286127479e5178a79","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"c5c58714fb3cb839653e5c32e6094784c8662935","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"c55f05400eb27ab051f47396ec8d4249ce6f71ec","modified":1690291154852},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"9277fead4c29dbe93976f078adaa26e8f9253da3","modified":1690291154852},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1690291154871},{"_id":"themes/butterfly/source/img/favicon.png","hash":"f17fd89a2e05a689c4f5481be9ea6b09f7b8d945","modified":1690291154870},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"431b4a252443e224872bd6b4f6aa76ed1679a82c","modified":1690291154864},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"9066a62e442affce3a923a06a90486bf9d364e0e","modified":1690291154866},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"9893656128c347d1c09c90784627c84c979b326f","modified":1690291154864},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"3969f599e8657adf8c3ce287d83f5d0a23f276a9","modified":1690291154865},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"4c86c10f8ec0c8fb60b400a5a2f14699d3155be4","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"792a04d36de32f230ca3256ad87a90fe8392f333","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"e2869b71266bd49285f22da89560d875e8c61541","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"20303c0dad28e5c5335ce2fa6582f1fafae5b628","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"f0b01bbf321c2c24fdccaee367dd9fd448031a72","modified":1690291154865},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"fc029f5e00d7904c0878efd20dd4e09fc55e1d03","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"15ea7564b2e3bf46bc91fb6e49c94d057b37caaf","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7e9b65dcae7ac54e0183bc841fea0f4bd4d78e5c","modified":1690291154866},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"824b2b2d2ee72583b9e009c0bb13e29e806534cc","modified":1690291154866},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"e43017dbc73e0ce95dcfcb9dfb4fcce0c1715dd4","modified":1690291154864},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"5dd1ba997741d02894ff846eda939ad8051c0bb2","modified":1690291154867},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1690291154864},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"df7a51fcabbadab5aa31770e3202a47c9599bbb7","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"57d333ef47bfb8fd22da31f600527c9d91e8e322","modified":1690291154867},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1690291154867},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"37db99299af380e9111dce2a78a5049b301b13e0","modified":1690291154867},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"0b23010154e19f37f0c4af0110f9f834d6d41a13","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"7c463ba25b3b54f0f46dfd75971d792816e942a8","modified":1690291154868},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"cf90ea339fbb7f345212319627fcd68964024e40","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"331c89ecfb79fab68466944a43e9e3d0ff49c646","modified":1690291154868},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1690291154869},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c7666a10448edd93f5ace37296051b7670495f1b","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"c8dbdfe6145a0bc6f7691c9551be8169a2698f0a","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"f5207840c96df6b26ad227433babca4f8c362624","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fd55f0e09827ef40c53c48d184a553464aac3e03","modified":1690291154849},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"1bef867c799ba158c5417272fb137539951aa120","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"7a641b5dd45b970e1dafd1433eb32ea149e55cf2","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"962ee70a35e60a13c31eea47d16b9f98069fe417","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"50b4b9c7f6a4771910be4198639cfcfc6d7b8925","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/loading/index.pug","hash":"00ae419f527d8225a2dc03d4f977cec737248423","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/loading/fullpage-loading.pug","hash":"766baca6ddce49d1724a02312387b292ff2d0bdc","modified":1690291154850},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"9155f01d4c644a2e19b2b13b2d3c6d5e34dd0abf","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/loading/pace.pug","hash":"a6fde4835d6460ce7baf792fd5e1977fad73db25","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e37681bc9c169d4220f26ecda2b3d5c02b6b9a0f","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"cc1f7ae8a7ce5445277215821092e712ec8cc296","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"12be059c536490af216a397e8f2a7abbf6d4610e","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4e37535c63149708ecbedb262336014524ad8723","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"e939344fd389aeb11864ee697d5fd9b036d8325f","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"3adb731465a4ab14529277fd7867889e0800ad16","modified":1690291154851},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"f0898509da70388b5c532f19e762756d74080200","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"08979afbfecb4476a5ae8e360947b92624d285b8","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"82bb447a5d045980789cf3f9de9d49cc32011b13","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"dfb5e16a7e7106bb20b2ac2d0df1251d0fc79609","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"ab037bf5794638bd30da4cf7cf106e5d03b5f696","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"8e22f53886a57a68286970d8af8b4c950fd4a1d7","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"bb842d2aa6469d65bf06af1372f0a19a9e4ef44c","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"12185713f9ca08984fc74e3b69d8cd6828d23da8","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"842b772a387b576550fa127030e1c2e9bf65716d","modified":1690291154860},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"ba94ceb40d7c81372a76103d958dcc2cc6a84f00","modified":1690291154860},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1690291154869},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1690291154864},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"bbe930d8425bdaee2a5ba3cade42b617cee42934","modified":1690291154872},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1690291154864},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"40e76d6da538cb3c1ef6b79ffc0adfa64fe6b8ba","modified":1690291154872},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/abcjs.pug","hash":"0010c7a10d265c4329f0fd4db85b4a9ea7ba06b5","modified":1690291154852},{"_id":"themes/butterfly/layout/includes/third-party/abcjs/index.pug","hash":"58f37823f6cd9a194fb50f7ca7c2233e49939034","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"0d960849d5b05d27ec87627b983ca35f2411b9e8","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"09d2ab2570b67e6f09244a898ccab5567cb82ace","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"6d40b521eec4136f6742c548a4445ed593470b1b","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"08a85e52fc800d3562df869e5e2613313e76fce6","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/messenger.pug","hash":"799da8f3015e6fe440681b21644bcb3810a5518c","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"1157118db9f5d7c0c5a0fc7c346f6e934ca00d52","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/artalk.pug","hash":"19b5cfa1f77781246e02967cefe149f19170e45f","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4b98145d6584d586cabf033493282afc72ae816a","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"846cabae287ae31b3bbfac3da022475713dd5ecc","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/remark42.pug","hash":"716dc463fe4ef5112e7018ed60804125fdfa5cad","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/comments/artalk.pug","hash":"b47698e153c73cb29286b19bec5ddd920cb7ffba","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"7e233f872aea6fd6beccdc9efd86b1bf9ec9f12d","modified":1690291154853},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"cd4fc9c5a61608a5dedf645c1295430a1623040f","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"c42bbce31fcd8846cf3360f4c383dec9368daeba","modified":1690291154854},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f8b73bc63ec1b45d86aa3891d8c81ef4d5980943","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b19b123df682b23491b17dcca386d79062cd8f6e","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a56edeb1ce2f1b1fb0e866a30543f274b9f7d69e","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"7c7fbe27d82becc9ee509765f1195c69f5864a0b","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"1a20b11fa0e6b1943e9b4d81e197a25ca36af66d","modified":1690291154855},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"c5e131d65a7ad30f3cb98ac3b94cd2f6a94c22e9","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"3abbaaa4ea575c45b3cebffd40bad1acc6ffce84","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"4bb4cf58e219dfb8787273c931b1ea978b2ab88f","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"386a2b371644c2682560733617561ba6e6bf9ab2","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"cba55cbbd0962bf84b8956195e686b0e158ed247","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/comments/remark42.pug","hash":"f618457d62ef35d78a31e7fb1e375a462f64b228","modified":1690291154856},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"6b0d28671afd5ed286a714f25ba16256a2e7d880","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1690291154857},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1690291154864},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/artalk.pug","hash":"cfcfaed3a52fa47fff4cc65a053a2f025fb3b7b6","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"bb944185f4bb9f9a9b9d70ee215f66ccd6d4c6cf","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"da94966a9650ef3e4c69f3ee93758b30fa42cb78","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"a6be932d1f64c6190f5d03b5b77fba09fa0fd6b8","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f0d3eddd2bed68e5517274b3530bfe0fa5057d8e","modified":1690291154857},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"4f8bd22c5c32d5430cbe08ab4e861b6f8b86f820","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/remark42.pug","hash":"4fb998a05e51ef2302775945883307ee3039a544","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"edd4ebf76a79fb74cfae03a286fab90f74324dbd","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f8b65460c399973090c1fb7ab81e3708c252e7cc","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"ce4ab79c85df9f77395269eb01e9a023d7f96376","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"90338ac4cd114d324fe1caaaeea8be9ca05d6a46","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"2f3af113713563e34b10bbe998cc15008f81c85a","modified":1690291154858},{"_id":"themes/butterfly/layout/includes/third-party/search/docsearch.pug","hash":"ba04174d977da988a1d49c06641262c413352346","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"3adcf28a8d205ea3ee19828eda0e668702fac07a","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"4b9c35375e0eb9cf99ad246d5ca838eca64a635d","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"1f02a26730e5f36cc2dfec7ff4d5c93a099ed5ba","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1690291154859},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"8106bd031586f075a994956ee4438eb13be25d7b","modified":1690291154859},{"_id":"themes/butterfly/source/js/jquery.js","hash":"aab820a7c9bb693c5df41f9886179eba2649b028","modified":1690291154872},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1690291154864},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1690291154864},{"_id":"source/css/LXGWZhenKai.ttf","hash":"3e173155b120631bbf5c7a7921308977bdd48cf2","modified":1690291154844},{"_id":"public/css/custom.css","hash":"d6a18ee419b53590c6c6f241718b63c380658959","modified":1698746485693},{"_id":"public/baidusitemap.xml","hash":"60187dfcb9f11003350af0ee9f01a97e7da6375f","modified":1698766095035},{"_id":"public/sitemap.xml","hash":"477141991420f355587f3db2f31700540d3e6159","modified":1698766095035},{"_id":"public/search.xml","hash":"a3e0645a20dc9c44757e6c8bf262e7247d08c45e","modified":1698766095035},{"_id":"public/about/index.html","hash":"2e6189a8dad72572bb42696ee859b992a88a672e","modified":1698766095035},{"_id":"public/README.html","hash":"71911a42cf119cd03a2e9b0740e68e57e59f76f2","modified":1698766095035},{"_id":"public/categories/index.html","hash":"6e65c297da39774b41ecb367acc2d2f307914804","modified":1698766095035},{"_id":"public/tags/index.html","hash":"540ff61295f41a5f8e6472f45d697b3f6ec93463","modified":1698766095035},{"_id":"public/posts/40984.html","hash":"3510ab86e59d6386c754e70d5fd249868a46c76b","modified":1698746485693},{"_id":"public/posts/37319.html","hash":"cf2f123fa5797f09220896b786136cbbcfad6b9a","modified":1698746485693},{"_id":"public/posts/53776.html","hash":"c9343084577bab2585d40a3b0c22249a11abeb47","modified":1698746485693},{"_id":"public/posts/22105.html","hash":"edc6b55b990ddd14254bebfb8db824d3c2b952b1","modified":1698746485693},{"_id":"public/posts/43456.html","hash":"69ad93dc37b1b6760589adb089ca4bd0a33681d5","modified":1698746485693},{"_id":"public/posts/15277.html","hash":"a83dd6bfa809d79bf11dc9b271c4bd9bc1705074","modified":1698746485693},{"_id":"public/posts/2904.html","hash":"b0b4f41c5e7c952c3fee37b309fd2afb8fda3278","modified":1698746485693},{"_id":"public/posts/58693.html","hash":"04c67e47a8acb9654d1f6a9935cb5d62180565a3","modified":1698766095035},{"_id":"public/posts/31940.html","hash":"4d10f894c1ad7027332c9075d5d6221a314be4ce","modified":1698746485693},{"_id":"public/posts/13153.html","hash":"015ac02bfa3c2ef785d773201efea727fe321d09","modified":1698746485693},{"_id":"public/posts/20848.html","hash":"affb04426e31b79b5a3cbef6da630c313b08e39c","modified":1698746485693},{"_id":"public/posts/44296.html","hash":"e4cebcbb0eec189a4253a65230bdad932eea2de7","modified":1698746485693},{"_id":"public/posts/60552.html","hash":"0c8becc53f2b1e2f6079f8f1ee081053b9042651","modified":1698746485693},{"_id":"public/posts/22179.html","hash":"c39c32879714984d5a263e0c450f04064e60cc02","modified":1698746485693},{"_id":"public/posts/26325.html","hash":"9a922551f62d2b077dde7e32e47b0ca76d7e23f8","modified":1698746485693},{"_id":"public/posts/33708.html","hash":"016f6f455abf000735968b2660c7c072db921d87","modified":1698746485693},{"_id":"public/posts/9964.html","hash":"3622c4f2e7d8f0959387d5d79a3eaf15af8375c4","modified":1698746485693},{"_id":"public/posts/58122.html","hash":"a024b4550bd49b97442877c75325100ab197ec9c","modified":1698746485693},{"_id":"public/posts/42310.html","hash":"7ddde0c4eee8befc33eb08f76a488cea8024a345","modified":1698746485693},{"_id":"public/categories/coding/index.html","hash":"99af31e2b346da9e668c04902a4f69917c32bcc3","modified":1698766095035},{"_id":"public/index.html","hash":"3770d38afea23bd79a79d2e2201c72060c67871b","modified":1698766095035},{"_id":"public/categories/coding/page/2/index.html","hash":"61f102a59740d11115391da63cab0f228632507d","modified":1698766095035},{"_id":"public/categories/生活/index.html","hash":"c5eaeb9762371da01acc33a0e04b72bc8e519070","modified":1698766095035},{"_id":"public/page/2/index.html","hash":"9a308a63cc916c55f48fc237c59f4fe0c8e241cf","modified":1698766095035},{"_id":"public/archives/index.html","hash":"113b85274e733b62cc648370c20f2e7fe10e2c98","modified":1698766095035},{"_id":"public/archives/page/2/index.html","hash":"a84219ae6b21b8998ac25564b1061e04bf606fa7","modified":1698766095035},{"_id":"public/archives/2023/index.html","hash":"dd2a5055c119ea9e69411c0c92cc6994edf26c9e","modified":1698766095035},{"_id":"public/archives/2023/page/2/index.html","hash":"74dd08bb2450cac62d339f8caf219cf2d6e32f20","modified":1698766095035},{"_id":"public/archives/2023/07/index.html","hash":"ccc5c60a7dfac18a17b2e073e11ac9b60f371e66","modified":1698766095035},{"_id":"public/archives/2023/08/index.html","hash":"6811a9a1fcf5b1f27ca62061bad83c0db54f578e","modified":1698766095035},{"_id":"public/archives/2023/09/index.html","hash":"09cc41c4f13e342b03057ad4d7f67976ea2d22f6","modified":1698766095035},{"_id":"public/archives/2023/10/index.html","hash":"7343bfbac6254627e4c821e94e21ae61725c2348","modified":1698766095035},{"_id":"public/tags/juc/index.html","hash":"904f9a0a0e6e2284b514820413dd6a22cc104b60","modified":1698766095035},{"_id":"public/tags/多线程/index.html","hash":"fa3b2b5677fc2bcaf24c160a562edc58b8a6e264","modified":1698766095035},{"_id":"public/tags/并发编程/index.html","hash":"f2b4b9c6ad5efdba2e4e445fd3e5a90ce3412fda","modified":1698766095035},{"_id":"public/tags/nginx/index.html","hash":"2cb88a23739c01d8e55d8272b6b51ced990e7c54","modified":1698766095035},{"_id":"public/tags/java-core/index.html","hash":"db5e56f08dc785461670a7cc983b746f875cd3d7","modified":1698766095035},{"_id":"public/tags/编程基础/index.html","hash":"79b6a3e4cc0bcc4dabd5c52ec62f8f6e5edfc49f","modified":1698766095035},{"_id":"public/tags/RabbitMQ/index.html","hash":"9d4635c71ffedd98c54bee5659d2b734104de037","modified":1698766095035},{"_id":"public/tags/消息队列/index.html","hash":"d776e876d6fd960a491f3c8e9301a9790c2e838f","modified":1698766095035},{"_id":"public/tags/PBRTQC/index.html","hash":"50d0c0dcd2b746a5b9fe72766ae4ce7dce157ed9","modified":1698766095035},{"_id":"public/tags/技术文章/index.html","hash":"d81244bfecf911588286138628c7801a994b8cae","modified":1698766095035},{"_id":"public/tags/jvm/index.html","hash":"ad5f646f5f76f2b928b2ec9ec7eb1e4ed59225e5","modified":1698766095035},{"_id":"public/tags/dubbo/index.html","hash":"dc8761de8de61daca5e151e334d0c9d099bd185c","modified":1698766095035},{"_id":"public/tags/redis/index.html","hash":"44320bc76c56a8e5853234e4480095ebadc5ed14","modified":1698766095035},{"_id":"public/tags/缓存中间件/index.html","hash":"bbc155a04926840bce62371552ddc711b82cd520","modified":1698766095035},{"_id":"public/tags/mysql/index.html","hash":"d610a27239f94326941737e13b1d0fb9af245baa","modified":1698766095035},{"_id":"public/tags/数据库/index.html","hash":"96042c69726b1bb026ba992fd33e12046557d844","modified":1698766095035},{"_id":"public/tags/shiro/index.html","hash":"bca0de5db427988eb2e4e863d621dd065af2eb6b","modified":1698766095035},{"_id":"public/tags/sharding-jdbc/index.html","hash":"d324016d61b79a8caad4bc6bc4eb9560508ea4cd","modified":1698766095035},{"_id":"public/tags/分库分表/index.html","hash":"52454b7e62b352f2dd598862d7689470d4a069aa","modified":1698766095035},{"_id":"public/tags/springCloud/index.html","hash":"564b8d50e87c831646c31bece2b9aec7e9cb58a9","modified":1698766095035},{"_id":"public/tags/thymeleaf/index.html","hash":"fd0a25ceb441009ff1839f91fd70fafb5f824769","modified":1698766095035},{"_id":"public/tags/spring/index.html","hash":"d2414a039538d94ce5c08a7a15fd10d6aa2817e9","modified":1698766095035},{"_id":"public/tags/段子/index.html","hash":"adefcad10941c69cb78a660d6bdebe8a6d166924","modified":1698766095035},{"_id":"public/tags/沙雕图/index.html","hash":"47dff9b83d6bf694e67f5fb6c9aa622153b88858","modified":1698766095035},{"_id":"public/tags/哲学/index.html","hash":"4fc293db9abbfc63d7e07e1b2b223777a69a9444","modified":1698766095035},{"_id":"public/tags/西方哲学/index.html","hash":"62b822982d4f05cec7fe7bb79cc2f9b415b80c5a","modified":1698766095035},{"_id":"public/tags/中国古代史/index.html","hash":"973777f80ce9eabcd2b326439832e60b715ea3f7","modified":1698766095035},{"_id":"public/tags/常识/index.html","hash":"2910128c5aac7e936cedc11cccbbba54bae580b7","modified":1698766095035},{"_id":"public/tags/思考/index.html","hash":"aa84814fba6f166d4455584ebe2097ea8b948402","modified":1698766095035},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1698746485693},{"_id":"public/CNAME","hash":"0ba2ea8a346b2e193945de5bc8f9d9aa4a81461b","modified":1698746485693},{"_id":"public/img/favicon.png","hash":"f17fd89a2e05a689c4f5481be9ea6b09f7b8d945","modified":1698746485693},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1698746485693},{"_id":"public/img/avatar.jpg","hash":"bbf597f4a75a617bed638ac124502fd76068f62b","modified":1698746485693},{"_id":"public/js/foot.js","hash":"129b54a05c57c88b8f4108055bfe6030dcdebc9e","modified":1698746485693},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1698746485693},{"_id":"public/js/utils.js","hash":"aaaedc207440095da1ffabcad870fc2641befb0e","modified":1698746485693},{"_id":"public/js/search/algolia.js","hash":"fd86281d4f0f99ce173e49c1a0df3507fe268d37","modified":1698746485693},{"_id":"public/js/search/local-search.js","hash":"8509cbd954ee9e099dcfbbfdafba70893a56e9ae","modified":1698746485693},{"_id":"public/js/jquery.js","hash":"0fa72756e48c33a6feeace1ffa5d790d58b53729","modified":1698746485693},{"_id":"public/css/index.css","hash":"b3e22c48b65075f4ee8c026344f026c25fe18c8d","modified":1698746485693},{"_id":"public/js/main.js","hash":"0227b5bd233a3c66582e0ee820cdb353ce52ece1","modified":1698746485693},{"_id":"public/js/tw_cn.js","hash":"42b106354d72a0ea1fe62587b313a5b7de3cc393","modified":1698746485693},{"_id":"public/css/LXGWZhenKai.ttf","hash":"3e173155b120631bbf5c7a7921308977bdd48cf2","modified":1698746485693}],"Category":[{"name":"coding","_id":"cloe5sr9h000400ujh3l54r69"},{"name":"生活","_id":"cloe5sra6002w00uj1mna8iry"}],"Data":[],"Page":[{"title":"关于","date":"2023-07-15T01:31:31.000Z","_content":"<p>&emsp;&emsp;我，后端开发工程师，想在这个世界留下一些痕迹，所以有了这个小破站\n<p>&emsp;&emsp;在这里做单纯记录和分享，如果对你有所帮助，那非常荣幸！\n<p>\n&emsp;&emsp;并非所有内容都为原创，部分内容是从互联网收集的资料整理而来，所以如果有错误或侵权行为，请评论或发送邮件，将会第一时间处理\n<p>\n&emsp;&emsp;邮箱：guoyancheng1022@163.com\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2023-07-15 09:31:31\n---\n<p>&emsp;&emsp;我，后端开发工程师，想在这个世界留下一些痕迹，所以有了这个小破站\n<p>&emsp;&emsp;在这里做单纯记录和分享，如果对你有所帮助，那非常荣幸！\n<p>\n&emsp;&emsp;并非所有内容都为原创，部分内容是从互联网收集的资料整理而来，所以如果有错误或侵权行为，请评论或发送邮件，将会第一时间处理\n<p>\n&emsp;&emsp;邮箱：guoyancheng1022@163.com\n","updated":"2023-08-01T14:24:48.047Z","path":"about/index.html","comments":1,"layout":"page","_id":"cloe5sr9b000000uj7k73b7la","content":"<p>&emsp;&emsp;我，后端开发工程师，想在这个世界留下一些痕迹，所以有了这个小破站\n<p>&emsp;&emsp;在这里做单纯记录和分享，如果对你有所帮助，那非常荣幸！\n<p>\n&emsp;&emsp;并非所有内容都为原创，部分内容是从互联网收集的资料整理而来，所以如果有错误或侵权行为，请评论或发送邮件，将会第一时间处理\n<p>\n&emsp;&emsp;邮箱：guoyancheng1022@163.com\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>&emsp;&emsp;我，后端开发工程师，想在这个世界留下一些痕迹，所以有了这个小破站\n<p>&emsp;&emsp;在这里做单纯记录和分享，如果对你有所帮助，那非常荣幸！\n<p>\n&emsp;&emsp;并非所有内容都为原创，部分内容是从互联网收集的资料整理而来，所以如果有错误或侵权行为，请评论或发送邮件，将会第一时间处理\n<p>\n&emsp;&emsp;邮箱：guoyancheng1022@163.com\n"},{"_content":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","source":"css/custom.css","raw":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","date":"2023-07-25T13:19:14.845Z","updated":"2023-07-25T13:19:14.845Z","path":"css/custom.css","layout":"false","title":"","comments":1,"_id":"cloe5sr9f000200ujdsbe8x1c","content":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}","site":{"data":{}},"cover":false,"excerpt":"","more":"/* 一级菜单居中 */\n#nav .menus_items {\n  position: absolute !important;\n  width: fit-content !important;\n  left: 50% !important;\n  transform: translateX(-50%) !important;\n}\n/* 子菜单横向展示 */\n#nav .menus_items .menus_item:hover .menus_item_child {\n  display: flex !important;\n}\n/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */\n.menus_items .menus_item:nth-child(2) .menus_item_child {\n  left: -125px;\n}\n\n@font-face {\n    /*字体名称，名字可以随便起，但是注意要一致，建议英文*/\n    font-family: 'PMZDCST';\n    font-display: swap;\n    src: url('./LXGWZhenKai.ttf') format(\"truetype\");\n  }\n\n.nav-fixed #nav{\n    transform: translateY(58px)!important;\n    -webkit-transform: translateY(58px)!important;\n    -moz-transform: translateY(58px)!important;\n    -ms-transform: translateY(58px)!important;\n    -o-transform: translateY(58px)!important;\n}\n#nav{\n    transition: none!important;\n    -webkit-transition: none!important;\n    -moz-transition: none!important;\n    -ms-transition: none!important;\n    -o-transition: none!important;\n}"},{"_content":"my blog","source":"README.md","raw":"my blog","date":"2023-07-25T13:19:14.793Z","updated":"2023-07-25T13:19:14.793Z","path":"README.html","title":"","comments":1,"layout":"page","_id":"cloe5sr9i000600ujbh7x7lg3","content":"<p>my blog</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<p>my blog</p>\n"},{"title":"categories","date":"2023-07-14T17:44:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-07-15 01:44:20\ntype: \"categories\"\n---\n","updated":"2023-07-25T13:19:14.802Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cloe5sr9j000800uj74il1bji","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""},{"title":"tags","date":"2023-07-15T01:31:31.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-07-15 09:31:31\ntype: \"tags\"\n---\n","updated":"2023-07-25T13:19:14.845Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cloe5sr9j000a00uj49mmhn5t","content":"","site":{"data":{}},"cover":false,"excerpt":"","more":""}],"Post":[{"title":"juc","date":"2023-07-14T16:00:00.000Z","abbrlink":42310,"_content":"# 1、java多线程基本概念\n## 1.1、进程和线程\n\n1. **进程**\n- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 \n- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 \n- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） \n\n2. **线程**\n- 一个进程之内可以分为一到多个线程。 \n- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 \n- **Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器**\n## 1.2、并发和并行\n并发：线程轮流使用CPU\n并行：多核cpu下，多个核同时调度运行线程\n\n## 1.3、多线程的应用\n### 1.3.1、异步调用\n比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 \n### 1.3.2、提升效率\n充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。\n```java\n计算 1 花费 10 ms\n计算 2 花费 11 ms\n计算 3 花费 9 ms\n汇总需要 1 ms\n```\n\n- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms \n- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms \n\n> 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n\n# 2、java线程\n## 2.1、线程的创建\n### 2.1.1、直接使用Thread\n```java\n// 创建线程对象\nThread t = new Thread() {\n    public void run() {\n        // 要执行的任务\n    }\n};\n// 启动线程\nt.start();\n```\n### 2.1.2、使用 Runnable 配合 Thread \n```java\nRunnable runnable = new Runnable() {\n    public void run(){\n        // 要执行的任务\n    }\n};\n// 创建线程对象\nThread t = new Thread( runnable );\n// 启动线程\nt.start();\n```\njava8可用lambda精简\n```java\n// 创建任务对象\nRunnable task2 = () -> log.debug(\"hello\");\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nThread t2 = new Thread(task2, \"t2\");\nt2.start();\n```\n### 2.1.3、FutureTask 配合 Thread \nFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\n\n```java\n// 创建任务对象\nFutureTask<Integer> task3 = new FutureTask<>(() -> {\n    log.debug(\"hello\");\n    return 100;\n});\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nnew Thread(task3, \"t3\").start();\n\n// 主线程阻塞，同步等待 task 执行完毕的结果\nInteger result = task3.get();\nlog.debug(\"结果是:{}\", result);\n```\n## 2.2、查看进程线程\n### 2.2.1、windows\n\n1. tasklist 查看进程 \n2. taskkill 杀死进程 \n3. netstat -ano|findstr 8080 根据端口查看进程\n### 2.2.2、linux\n\n1. ps -fe 查看所有进程 \n2. kill 杀死进程\n3.  top -Hp <PID> 查看某个进程（PID）的所有线程 \n4. netstat -nlp|grep 8080 根据端口查看进程\n### 2.2.3、JDK\n\n1. jps 命令查看所有 Java 进程\n2.  jstack <PID> 查看某个 Java 进程（PID）的所有线程状态\n3.  jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）\n\n## 2.3、线程运行原理\n\n1. **线程创建**\n\n每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成\n，栈帧对应着每次方法调用所占内存\n\n2. **上下文切换**\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 \n> 线程的 cpu 时间片用完 \n> 垃圾回收 \n> 有更高优先级的线程需要运行 \n> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 \n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 \n\n##  2.4、start与run\n\n- 直接调用 run 是在主线程中执行了 run，没有启动新的线程 \n- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n\n## 2.5、sleep 与 yield \n\n1. **sleep**\n- 1. 调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞） \n- 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException \n- 3. 睡眠结束后的线程未必会立刻得到执行 \n\n2. **yield**\n- 1. 调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程 \n- 2. 具体的实现依赖于操作系统的任务调度器 \n\n## 2.6、join\njoin：t1调用t2的join方法，会先执行t2，然后执行t1\n如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间\n```java\nstatic int r = 0;\npublic static void main(String[] args) throws InterruptedException {\n    test1();\n}\n\nprivate static void test1() throws InterruptedException {\n    log.debug(\"开始\");\n    Thread t1 = new Thread(() -> {\n        log.debug(\"开始\");\n        sleep(1);\n        log.debug(\"结束\");\n        r = 10;\n    });\n    t1.start();\n    // t1.join();\n    log.debug(\"结果为:{}\", r);\n    log.debug(\"结束\");\n}\n```\n> 如果不加t1.join()结果为0，加上以后结果为1\n\n\n## 2.7、interrupt\n### 2.7.1、打断阻塞状态的线程\nsleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断\n```java\nprivate static void test1() throws InterruptedException {\n    Thread t1 = new Thread(()->{\n        sleep(1);\n    }, \"t1\");\n    t1.start();\n    sleep(0.5);\n    t1.interrupt();\n    log.debug(\" 打断状态: {}\", t1.isInterrupted());\n}\n```\n输出\n```java\njava.lang.InterruptedException: sleep interrupted\n     at java.lang.Thread.sleep(Native Method)\n     at java.lang.Thread.sleep(Thread.java:340)\n     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)\n     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)\n     at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)\n     at java.lang.Thread.run(Thread.java:745)\n21:18:10.374 [main] c.TestInterrupt - 打断状态: false\n```\n### 2.7.2、打断正常运行的线程\n打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）\n```java\nprivate static void test2() throws InterruptedException {\n    Thread t2 = new Thread(()->{\n        while(true) {\n            Thread current = Thread.currentThread();\n            boolean interrupted = current.isInterrupted();\n            if(interrupted) {\n                log.debug(\" 打断状态: {}\", interrupted);\n                break;\n            }\n        }\n    }, \"t2\");\n    t2.start();\n    sleep(0.5);\n    t2.interrupt();\n}\n```\n输出\n```java\n20:57:37.964 [t2] c.TestInterrupt - 打断状态: true \n```\n\n## 2.8、主线程与守护线程\n默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 \n\n例\n```java\nlog.debug(\"开始运行...\");\nThread t1 = new Thread(() -> {\n    log.debug(\"开始运行...\");\n    sleep(2);\n    log.debug(\"运行结束...\");\n}, \"daemon\");\n// 设置该线程为守护线程\nt1.setDaemon(true);\nt1.start();\n\nsleep(1);\nlog.debug(\"运行结束...\");\n```\n输出\n```java\n08:26:38.123 [main] c.TestDaemon - 开始运行... \n08:26:38.213 [daemon] c.TestDaemon - 开始运行... \n08:26:39.215 [main] c.TestDaemon - 运行结束...\n```\n\n> **注意 **\n> - 垃圾回收器线程就是一种守护线程 \n> - Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 \n\n\n## 2.9、线程状态\n| 状态   | 说明 |\n| --- | --- |\n| NEW | 初始状态:线程被创建，但还没有调用start()方法 |\n| RUNNABLE | 运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作\"运行\" |\n| BLOCKED | 阻塞状态:表示线程阻塞于锁 |\n| WAITING | 等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) |\n| TIMEWAITING | 超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的 |\n| TERMINATED | 终止状态:表示当前线程已经执行完毕 |\n\n![线程状态](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg)\n\n\n# 3、共享模型之管程\n管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的\n## 3.1、monitor\nMonitor 被翻译为**监视器**或**管程**\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针\n\n### 3.1.1、Monitor结构\n**结构**：owner  entryList  waitSet\n\n![monitor结构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg)\n\n\n### 3.1.2、Monitor原理\n（1）刚开始monitor中owner为null \n（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程 \n（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞 \n（4）t1执行完会唤醒entrylist中的某个线程（不公平）\n（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n## 3.2、java对象结构\n\n1. **对象头**\n\n包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）\n\n![java对象头](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg)\n\n\n2. **实例数据**\n\n实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息\n\n3. **对齐填充**\n\n对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。\n## 3.3、synchronized升级\n### 3.3.1、偏向锁\n> 使用场景：如果只有一个线程，就不需要每次的申请释放锁\n\n只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 \n### 3.3.2、轻量级锁\n> 使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化\n\n![轻量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg)\n\n\n\n1. 创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象\n2. 让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录\n3. 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁\n4. 如果 cas 失败，有两种情况  \n\n（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 \n（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）\n\n5. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一\n6. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 \n\n（1）成功，则解锁成功 \n（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\n### 3.3.3、重量级锁\n> 使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁\n\n![重量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg)\n\n\n1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\n2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 \n\n（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 \n（2）然后自己进入 Monitor 的 EntryList阻塞队列\n\n3. 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）\n\n> 调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n### 3.3.4、自旋锁\n重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)\n\n## 3.4、wait/notify\nOwner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争\n\n### 3.4.1、sleep和wait的区别？\n\n1.  sleep 是 Thread 方法，而 wait 是 Object 的方法 \n2.  sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 \n3.  sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 \n\n## 3.5、park/unpark\n它们是 LockSupport 类中的方法\n```java\n// 暂停当前线程\nLockSupport.park(); \n// 恢复某个线程的运行\nLockSupport.unpark(暂停线程对象)\n```\n\n### 3.5.1、与 Object 的 wait & notify 相比 \n\n- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\n- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 \n- park & unpark 可以先 unpark，而 wait & notify 不能先 notify \n\n### 3.5.2、原理\n每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex \n\n核心部分是counter，我们可以理解为一个标记位。\n当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。\n当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。\n## 3.6、死锁\n多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁\n### 3.6.1、死锁的必要条件\n\n1. 互斥条件：一个资源一次只能被一个进程使用\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放\n3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺\n4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系\n### 3.6.2、死锁的实现\n```java\n/**\n * 实现一个死锁\n * 如果把lock(target, owner);放到上面则不会死锁\n */\npublic class DeadLock {\n    public static void main(String[] args) throws InterruptedException {\n        final Object owner = new Object();\n        final Object target = new Object();\n        //开启一个新线程\n        new Thread(() -> {\n            try {\n                lock(owner, target);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        //主线程\n        lock(target, owner);\n    }\n    public static void lock(Object owner, Object target) throws InterruptedException {\n        synchronized (owner) {\n            Thread.sleep(1000);\n            synchronized (target) {\n                System.out.println(\"success\");\n            }\n        }\n    }\n}\n```\n### 3.6.3、定位死锁\n检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁\n### 3.6.4、哲学家就餐问题\n\n![哲学家就餐问题](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg)\n\n\n有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 \n\n1. 筷子类\n\n```java\nclass Chopstick {\n    String name;\n    \n    public Chopstick(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return \"筷子{\" + name + '}';\n    }\n}\n```\n\n2. 哲学家类\n\n```java\nclass Philosopher extends Thread {\n    Chopstick left;\n    Chopstick right;\n    \n    public Philosopher(String name, Chopstick left, Chopstick right) {\n        super(name);\n        this.left = left;\n        this.right = right;\n    }\n    \n    private void eat() {\n        log.debug(\"eating...\");\n        Sleeper.sleep(1);\n    }\n    \n    @Override\n    public void run() {\n        while (true) {\n            // 获得左手筷子\n            synchronized (left) {\n                // 获得右手筷子\n                synchronized (right) {\n                    // 吃饭\n                    eat();\n                }\n                // 放下右手筷子\n            }\n            // 放下左手筷子\n        }\n    }\n}\n```\n\n3. 就餐\n\n```java\nChopstick c1 = new Chopstick(\"1\");\nChopstick c2 = new Chopstick(\"2\");\nChopstick c3 = new Chopstick(\"3\");\nChopstick c4 = new Chopstick(\"4\");\nChopstick c5 = new Chopstick(\"5\");\n\nnew Philosopher(\"苏格拉底\", c1, c2).start();\nnew Philosopher(\"柏拉图\", c2, c3).start();\nnew Philosopher(\"亚里士多德\", c3, c4).start();\nnew Philosopher(\"赫拉克利特\", c4, c5).start();\nnew Philosopher(\"阿基米德\", c5, c1).start();\n```\n## 3.7、活锁\n两个线程互相改变对方的结束条件导致谁也无法结束\n> eg：共享变量count为10000, t1线程while count > 0, count-- ;t2线程while count < 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行\n\n\n## 3.8、**ReentrantLock**\n相对于 synchronized 它具备如下特点 \n\n1. 可中断 \n2. 可以设置超时时间 \n3. 可以设置为公平锁 （默认不公平）\n4. 支持多个条件变量 \n\n与 synchronized 一样，都支持可重入 \n# 4、共享模型之内存\n## 4.1、java内存模型（jmm）\nJava内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本\n## 4.2、线程安全性的三个体现\n**原子性**：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）\n**可见性**：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）\n**有序性**：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）\n# 5、共享模型之无锁\n## 5.1、CAS\n### 5.1.1、CAS基本概念\nCAS是所有原子类的底层原理，乐观锁主要采用CAS算法。\nCAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。\n> 1. CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性\n> 2. CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果\n\n\n### 5.1.2、CAS问题\n多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。\n\n**解决方案：**\n使用AtomicStampReference \nAtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验\n\n## 5.2、volatile\n### 5.2.1、如何保证可见性和有序性\n\n1. **保证可见性（缓存一致性协议MESI）**\n\n首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用**MESI协议**保证缓存一致性。\n如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu**总线嗅探机制**监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值\n\n> **M 修改** (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中\n**E 独享、互斥** (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。\n**S 共享** (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态\n**I 无效** (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态\n\n\n> 涉及到的指令\nlock(锁定)：将一个变量标识为被一个线程独占状态\nstore(存储)：作用于工作内存的变量,将变量传输到主内存中\nwrite(写入)：将store入主内存的变量,放入到主内存的变量中\n\n\n2. **保证有序性（禁止指令重排优化）**\n\n多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的\n内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序\n\n## 5.3、原子类\n| 类型   | 具体类 |\n| --- | --- |\n| Atomic 基本类型原子类   | AtomicInteger AtomicLong AtomicBoolean |\n| AtomicArray 数组类型原子类 | AtomicIntegerArray  AtomicLongArray AtomicReferenceArray |\n| AtomicReference 引用类型原子类 | AtomicReference AtomicStampedReference AtomicMarkableReference |\n| AtomicFieldUpdate 升级类型原子类 | AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater |\n\n\n# 6、共享模式之工具\n## 6.1、线程池\n### 6.1.1、**ThreadPoolExecutor**\n\n1. **构造方法**\n\n通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建\n\n> 1. corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。\n> 2. maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。\n> 3. keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。\n> 4. unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n> 5. workQueue：缓存队列，用来存放等待被执行的任务。\n> 6. threadFactory 线程工厂\n> 7. handler：拒绝策略\n（1）abortPolicy：抛出异常（默认）\n（2）discardPolicy：放弃本次任务\n（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代\n（4）callerrunPolicy：让调用者运行任务\n\n\n2. **工作原理**\n\n如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n如果当前线程池中正在执行任务的的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；\n如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；\n如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理\n### 6.1.2、Executors类中提供的工厂方法\n根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池\n\n1. **newFixedThreadPool**\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n> 特点：\n> - 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 \n> - 阻塞队列是无界的，可以放任意数量的任务 \n> \n评价：\n> 适用于任务量已知，相对耗时的任务\n\n\n2. **newCachedThreadPool**\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n> 特点 \n> - 核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 \n>    - 全部都是救急线程（60s 后可以回收）\n>    - 救急线程可以无限创建 \n> - 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）\n> \n评价：\n> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程\n> 适合任务数比较密集，但每个任务执行时间较短的情况\n\n\n3. newSingleThreadExecutor\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n使用场景： \n希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。\n任务执行完毕，这唯一的线程也不会被释放。 \n\n### 6.1.3、创建多大的线程池\n\n- 过小会导致程序不能充分地利用系统资源、容易导致饥饿 \n- 过大会导致更多的线程上下文切换，影响性能\n\n1. **CPU 密集型运算 **\n\n通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 \n\n2. **I/O密集型**\n\nCPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 \n经验公式如下 ：\n`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间` \n\n## 6.2、锁\n### 6.2.1、AQS\n\n1. 基本概念\n\nAbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...\n\n2. 原理 \n\n它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）\n\n3. 实现\n\n自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n> **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的\n\n### 6.2.2、ReentrantLock\n**实现原理**\n\n1. 首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能\n2. 它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法\n3. 加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列\n4. 持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）\n\n**条件变量——Condition**\nCondition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程\n### 6.2.3、**ReentrantReadWriteLock**\n#### 4.2.3.1、ReentrantReadWriteLock基本概念\nReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用\n#### 4.2.3.2、锁获取过程\n\n1. 获取读锁\n\n如果写锁没有被另一个线程持有，则获取读锁并立即返回。     \n \t如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。\n\n4. 获取写入锁\n\n如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *\n如果当前线程持有写锁，则将写锁计数 +1，然后返回\n如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。\n\n#### 4.2.3.3、常见问题\n\n1. **读锁和写锁的可重入性**\n\n在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加\n\n2. **当前线程获取锁失败，被阻塞的后续操作是什么？**\n\n获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁\n\n3. **锁降级是怎么降级的？**\n\n在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）\n\n## 6.3、工具\n### 6.3.1、Semaphore\n\n1. **概念**\n\nSemaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）\n```java\npublic class DataSourcePool {\n \n    private final CopyOnWriteArrayList<Connection> list;\n    \n    //用到了信号量\n    private final Semaphore semaphore;\n \n    public DataSourcePool(int size) throws SQLException {\n        list = new CopyOnWriteArrayList<>();\n        semaphore = new Semaphore(size);\n        for (int i=0;i<size;i++){\n            Connection connection = DriverManager.getConnection(\"url\");\n            list.add(connection);\n        }\n    }\n    \n    //使用同步方法获取\n    public synchronized Connection getConnection() throws InterruptedException {\n        //先将当前信号量-1，如果为0，将阻塞\n        semaphore.acquire();\n        return list.remove(0);\n    }\n \n    public synchronized void  close(Connection connection){\n        //信号量+1\n        semaphore.release();\n        list.add(connection);\n    }\n}\n```\n\n2. **原理**\n\nSemaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n\n1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。\n2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state=state-1。state<0,令牌数量不足，加入阻塞队列。>=0则获取成功\n3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state=state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程\n### 6.3.2、CountdownLatch\n\n1. **概念**\n\nCountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n    ExecutorService service = Executors.newFixedThreadPool(4);\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(()->{\n        try {\n            log.debug(\"waiting...\");\n            latch.await();\n            log.debug(\"wait end...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n    \n}\n```\n```java\n18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting... \n18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2 \n18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end...\n```\n\n2. **原理**\n\nCountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n1、初始化CountDownLatch实际就是设置了AQS的state为计数的值\n2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值\n3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试\n\n3. **和join的区别？**\n\nCountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成\n\n### 6.3.3、CyclicBarrier\n\n1. **概念**\n\nCyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行\n实现王者荣耀10个人都加载完才开始游戏\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        int count = 10;\n        CyclicBarrier cb = new CyclicBarrier(count, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"全部加载完毕\");\n            }\n        });\n        ExecutorService executorService = Executors.newFixedThreadPool(count);\n        for (int x = 0; x < count; x++) {\n            executorService.execute(new Worker(cb));\n        }\n    }\n}\n\nclass Worker extends Thread {\n    CyclicBarrier cyclicBarrier;\n    public Worker(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" 已加载完\");\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java\npool-1-thread-1 已加载完\npool-1-thread-5 已加载完\npool-1-thread-4 已加载完\npool-1-thread-3 已加载完\npool-1-thread-6 已加载完\npool-1-thread-2 已加载完\npool-1-thread-7 已加载完\npool-1-thread-8 已加载完\npool-1-thread-9 已加载完\npool-1-thread-10 已加载完\n全部加载完毕\n\n```\n\n2. **原理**\n\n1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count\n2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；\n3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；\n4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；\n5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。\n\n## 6.4、线程安全集合类\n### 6.4.1、概述\n\t\t\t\t\t\t  \n线程安全实现类有三类：\n\n1. 遗留的线程安全集合如 Hashtable ， Vector \n2. 使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）\n\n>    - Collections.synchronizedCollection \n>    - Collections.synchronizedList \n>    - Collections.synchronizedMap \n>    - Collections.synchronizedSet \n>    - Collections.synchronizedNavigableMap \n>    - Collections.synchronizedNavigableSet\n>    - Collections.synchronizedSortedMap \n>    - Collections.synchronizedSortedSet \n\n4. JUC下的安全集合: Blocking、CopyOnWrite、Concurrent \n\n> - Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)\n> - CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)\n> - Concurrent 类型的容器 （内部很多操作使用cas优化）\n>    - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 \n>    - 弱一致性 \n>       - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 \n>       - 求大小弱一致性，size 操作未必是 100% 准确 \n>       - 读取弱一致性 \n\n> 遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历\n\n### 6.4.2、concurrentHashMap\n**JDK1.8前**\nConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。\n\n元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部\n\n锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数\n\n\n> ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表\n\n\n**JDK1.8**\n\n在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全\n\n1. 初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 \n2. 插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 \n3. 扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 \n4. 查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。\n\n\n\n### 6.4.3、BlockingQueue\n主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue \n\n1. 区别\n\n（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表\n（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）\n（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现\n\n### 6.4.4、ConcurrentLinkedQueue \nConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）\n\n### 6.4.5、CopyOnWriteArrayList\n\n1. 首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行\n2. 写数据时会加ReentLocak锁，防止并发写入丢失数据的问题\n3. 写操作结束后会把原数组指向新数组\n4. CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景\n\n\n","source":"_posts/JUC.md","raw":"---\ntitle: juc\ndate: 2023/07/15\ncategories:\n  - coding\ntags:\n  - juc\n  - 多线程\n  - 并发编程\nabbrlink: 42310\n---\n# 1、java多线程基本概念\n## 1.1、进程和线程\n\n1. **进程**\n- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 \n- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 \n- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） \n\n2. **线程**\n- 一个进程之内可以分为一到多个线程。 \n- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 \n- **Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器**\n## 1.2、并发和并行\n并发：线程轮流使用CPU\n并行：多核cpu下，多个核同时调度运行线程\n\n## 1.3、多线程的应用\n### 1.3.1、异步调用\n比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 \n### 1.3.2、提升效率\n充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。\n```java\n计算 1 花费 10 ms\n计算 2 花费 11 ms\n计算 3 花费 9 ms\n汇总需要 1 ms\n```\n\n- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms \n- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms \n\n> 需要在多核 cpu 才能提高效率，单核仍然时是轮流执行\n\n# 2、java线程\n## 2.1、线程的创建\n### 2.1.1、直接使用Thread\n```java\n// 创建线程对象\nThread t = new Thread() {\n    public void run() {\n        // 要执行的任务\n    }\n};\n// 启动线程\nt.start();\n```\n### 2.1.2、使用 Runnable 配合 Thread \n```java\nRunnable runnable = new Runnable() {\n    public void run(){\n        // 要执行的任务\n    }\n};\n// 创建线程对象\nThread t = new Thread( runnable );\n// 启动线程\nt.start();\n```\njava8可用lambda精简\n```java\n// 创建任务对象\nRunnable task2 = () -> log.debug(\"hello\");\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nThread t2 = new Thread(task2, \"t2\");\nt2.start();\n```\n### 2.1.3、FutureTask 配合 Thread \nFutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况\n\n```java\n// 创建任务对象\nFutureTask<Integer> task3 = new FutureTask<>(() -> {\n    log.debug(\"hello\");\n    return 100;\n});\n\n// 参数1 是任务对象; 参数2 是线程名字，推荐\nnew Thread(task3, \"t3\").start();\n\n// 主线程阻塞，同步等待 task 执行完毕的结果\nInteger result = task3.get();\nlog.debug(\"结果是:{}\", result);\n```\n## 2.2、查看进程线程\n### 2.2.1、windows\n\n1. tasklist 查看进程 \n2. taskkill 杀死进程 \n3. netstat -ano|findstr 8080 根据端口查看进程\n### 2.2.2、linux\n\n1. ps -fe 查看所有进程 \n2. kill 杀死进程\n3.  top -Hp <PID> 查看某个进程（PID）的所有线程 \n4. netstat -nlp|grep 8080 根据端口查看进程\n### 2.2.3、JDK\n\n1. jps 命令查看所有 Java 进程\n2.  jstack <PID> 查看某个 Java 进程（PID）的所有线程状态\n3.  jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）\n\n## 2.3、线程运行原理\n\n1. **线程创建**\n\n每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成\n，栈帧对应着每次方法调用所占内存\n\n2. **上下文切换**\n\n因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 \n> 线程的 cpu 时间片用完 \n> 垃圾回收 \n> 有更高优先级的线程需要运行 \n> 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 \n\n当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 \n\n##  2.4、start与run\n\n- 直接调用 run 是在主线程中执行了 run，没有启动新的线程 \n- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码\n\n## 2.5、sleep 与 yield \n\n1. **sleep**\n- 1. 调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞） \n- 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException \n- 3. 睡眠结束后的线程未必会立刻得到执行 \n\n2. **yield**\n- 1. 调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程 \n- 2. 具体的实现依赖于操作系统的任务调度器 \n\n## 2.6、join\njoin：t1调用t2的join方法，会先执行t2，然后执行t1\n如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间\n```java\nstatic int r = 0;\npublic static void main(String[] args) throws InterruptedException {\n    test1();\n}\n\nprivate static void test1() throws InterruptedException {\n    log.debug(\"开始\");\n    Thread t1 = new Thread(() -> {\n        log.debug(\"开始\");\n        sleep(1);\n        log.debug(\"结束\");\n        r = 10;\n    });\n    t1.start();\n    // t1.join();\n    log.debug(\"结果为:{}\", r);\n    log.debug(\"结束\");\n}\n```\n> 如果不加t1.join()结果为0，加上以后结果为1\n\n\n## 2.7、interrupt\n### 2.7.1、打断阻塞状态的线程\nsleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断\n```java\nprivate static void test1() throws InterruptedException {\n    Thread t1 = new Thread(()->{\n        sleep(1);\n    }, \"t1\");\n    t1.start();\n    sleep(0.5);\n    t1.interrupt();\n    log.debug(\" 打断状态: {}\", t1.isInterrupted());\n}\n```\n输出\n```java\njava.lang.InterruptedException: sleep interrupted\n     at java.lang.Thread.sleep(Native Method)\n     at java.lang.Thread.sleep(Thread.java:340)\n     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)\n     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)\n     at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)\n     at java.lang.Thread.run(Thread.java:745)\n21:18:10.374 [main] c.TestInterrupt - 打断状态: false\n```\n### 2.7.2、打断正常运行的线程\n打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）\n```java\nprivate static void test2() throws InterruptedException {\n    Thread t2 = new Thread(()->{\n        while(true) {\n            Thread current = Thread.currentThread();\n            boolean interrupted = current.isInterrupted();\n            if(interrupted) {\n                log.debug(\" 打断状态: {}\", interrupted);\n                break;\n            }\n        }\n    }, \"t2\");\n    t2.start();\n    sleep(0.5);\n    t2.interrupt();\n}\n```\n输出\n```java\n20:57:37.964 [t2] c.TestInterrupt - 打断状态: true \n```\n\n## 2.8、主线程与守护线程\n默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 \n\n例\n```java\nlog.debug(\"开始运行...\");\nThread t1 = new Thread(() -> {\n    log.debug(\"开始运行...\");\n    sleep(2);\n    log.debug(\"运行结束...\");\n}, \"daemon\");\n// 设置该线程为守护线程\nt1.setDaemon(true);\nt1.start();\n\nsleep(1);\nlog.debug(\"运行结束...\");\n```\n输出\n```java\n08:26:38.123 [main] c.TestDaemon - 开始运行... \n08:26:38.213 [daemon] c.TestDaemon - 开始运行... \n08:26:39.215 [main] c.TestDaemon - 运行结束...\n```\n\n> **注意 **\n> - 垃圾回收器线程就是一种守护线程 \n> - Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 \n\n\n## 2.9、线程状态\n| 状态   | 说明 |\n| --- | --- |\n| NEW | 初始状态:线程被创建，但还没有调用start()方法 |\n| RUNNABLE | 运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作\"运行\" |\n| BLOCKED | 阻塞状态:表示线程阻塞于锁 |\n| WAITING | 等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) |\n| TIMEWAITING | 超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的 |\n| TERMINATED | 终止状态:表示当前线程已经执行完毕 |\n\n![线程状态](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg)\n\n\n# 3、共享模型之管程\n管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的\n## 3.1、monitor\nMonitor 被翻译为**监视器**或**管程**\n每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针\n\n### 3.1.1、Monitor结构\n**结构**：owner  entryList  waitSet\n\n![monitor结构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg)\n\n\n### 3.1.2、Monitor原理\n（1）刚开始monitor中owner为null \n（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程 \n（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞 \n（4）t1执行完会唤醒entrylist中的某个线程（不公平）\n（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n## 3.2、java对象结构\n\n1. **对象头**\n\n包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）\n\n![java对象头](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg)\n\n\n2. **实例数据**\n\n实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息\n\n3. **对齐填充**\n\n对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。\n## 3.3、synchronized升级\n### 3.3.1、偏向锁\n> 使用场景：如果只有一个线程，就不需要每次的申请释放锁\n\n只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 \n### 3.3.2、轻量级锁\n> 使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化\n\n![轻量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg)\n\n\n\n1. 创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象\n2. 让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录\n3. 如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁\n4. 如果 cas 失败，有两种情况  \n\n（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程 \n（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）\n\n5. 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一\n6. 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 \n\n（1）成功，则解锁成功 \n（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\n### 3.3.3、重量级锁\n> 使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁\n\n![重量级锁](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg)\n\n\n1. 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁\n2. 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 \n\n（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 \n（2）然后自己进入 Monitor 的 EntryList阻塞队列\n\n3. 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）\n\n> 调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权\n\n### 3.3.4、自旋锁\n重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)\n\n## 3.4、wait/notify\nOwner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争\n\n### 3.4.1、sleep和wait的区别？\n\n1.  sleep 是 Thread 方法，而 wait 是 Object 的方法 \n2.  sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 \n3.  sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 \n\n## 3.5、park/unpark\n它们是 LockSupport 类中的方法\n```java\n// 暂停当前线程\nLockSupport.park(); \n// 恢复某个线程的运行\nLockSupport.unpark(暂停线程对象)\n```\n\n### 3.5.1、与 Object 的 wait & notify 相比 \n\n- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必\n- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 \n- park & unpark 可以先 unpark，而 wait & notify 不能先 notify \n\n### 3.5.2、原理\n每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex \n\n核心部分是counter，我们可以理解为一个标记位。\n当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。\n当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。\n## 3.6、死锁\n多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁\n### 3.6.1、死锁的必要条件\n\n1. 互斥条件：一个资源一次只能被一个进程使用\n2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放\n3. 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺\n4. 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系\n### 3.6.2、死锁的实现\n```java\n/**\n * 实现一个死锁\n * 如果把lock(target, owner);放到上面则不会死锁\n */\npublic class DeadLock {\n    public static void main(String[] args) throws InterruptedException {\n        final Object owner = new Object();\n        final Object target = new Object();\n        //开启一个新线程\n        new Thread(() -> {\n            try {\n                lock(owner, target);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }).start();\n        //主线程\n        lock(target, owner);\n    }\n    public static void lock(Object owner, Object target) throws InterruptedException {\n        synchronized (owner) {\n            Thread.sleep(1000);\n            synchronized (target) {\n                System.out.println(\"success\");\n            }\n        }\n    }\n}\n```\n### 3.6.3、定位死锁\n检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁\n### 3.6.4、哲学家就餐问题\n\n![哲学家就餐问题](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg)\n\n\n有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 \n\n1. 筷子类\n\n```java\nclass Chopstick {\n    String name;\n    \n    public Chopstick(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return \"筷子{\" + name + '}';\n    }\n}\n```\n\n2. 哲学家类\n\n```java\nclass Philosopher extends Thread {\n    Chopstick left;\n    Chopstick right;\n    \n    public Philosopher(String name, Chopstick left, Chopstick right) {\n        super(name);\n        this.left = left;\n        this.right = right;\n    }\n    \n    private void eat() {\n        log.debug(\"eating...\");\n        Sleeper.sleep(1);\n    }\n    \n    @Override\n    public void run() {\n        while (true) {\n            // 获得左手筷子\n            synchronized (left) {\n                // 获得右手筷子\n                synchronized (right) {\n                    // 吃饭\n                    eat();\n                }\n                // 放下右手筷子\n            }\n            // 放下左手筷子\n        }\n    }\n}\n```\n\n3. 就餐\n\n```java\nChopstick c1 = new Chopstick(\"1\");\nChopstick c2 = new Chopstick(\"2\");\nChopstick c3 = new Chopstick(\"3\");\nChopstick c4 = new Chopstick(\"4\");\nChopstick c5 = new Chopstick(\"5\");\n\nnew Philosopher(\"苏格拉底\", c1, c2).start();\nnew Philosopher(\"柏拉图\", c2, c3).start();\nnew Philosopher(\"亚里士多德\", c3, c4).start();\nnew Philosopher(\"赫拉克利特\", c4, c5).start();\nnew Philosopher(\"阿基米德\", c5, c1).start();\n```\n## 3.7、活锁\n两个线程互相改变对方的结束条件导致谁也无法结束\n> eg：共享变量count为10000, t1线程while count > 0, count-- ;t2线程while count < 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行\n\n\n## 3.8、**ReentrantLock**\n相对于 synchronized 它具备如下特点 \n\n1. 可中断 \n2. 可以设置超时时间 \n3. 可以设置为公平锁 （默认不公平）\n4. 支持多个条件变量 \n\n与 synchronized 一样，都支持可重入 \n# 4、共享模型之内存\n## 4.1、java内存模型（jmm）\nJava内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本\n## 4.2、线程安全性的三个体现\n**原子性**：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）\n**可见性**：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）\n**有序性**：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）\n# 5、共享模型之无锁\n## 5.1、CAS\n### 5.1.1、CAS基本概念\nCAS是所有原子类的底层原理，乐观锁主要采用CAS算法。\nCAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。\n> 1. CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性\n> 2. CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果\n\n\n### 5.1.2、CAS问题\n多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。\n\n**解决方案：**\n使用AtomicStampReference \nAtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验\n\n## 5.2、volatile\n### 5.2.1、如何保证可见性和有序性\n\n1. **保证可见性（缓存一致性协议MESI）**\n\n首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用**MESI协议**保证缓存一致性。\n如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu**总线嗅探机制**监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值\n\n> **M 修改** (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中\n**E 独享、互斥** (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。\n**S 共享** (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态\n**I 无效** (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态\n\n\n> 涉及到的指令\nlock(锁定)：将一个变量标识为被一个线程独占状态\nstore(存储)：作用于工作内存的变量,将变量传输到主内存中\nwrite(写入)：将store入主内存的变量,放入到主内存的变量中\n\n\n2. **保证有序性（禁止指令重排优化）**\n\n多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的\n内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序\n\n## 5.3、原子类\n| 类型   | 具体类 |\n| --- | --- |\n| Atomic 基本类型原子类   | AtomicInteger AtomicLong AtomicBoolean |\n| AtomicArray 数组类型原子类 | AtomicIntegerArray  AtomicLongArray AtomicReferenceArray |\n| AtomicReference 引用类型原子类 | AtomicReference AtomicStampedReference AtomicMarkableReference |\n| AtomicFieldUpdate 升级类型原子类 | AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater |\n\n\n# 6、共享模式之工具\n## 6.1、线程池\n### 6.1.1、**ThreadPoolExecutor**\n\n1. **构造方法**\n\n通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建\n\n> 1. corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。\n> 2. maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。\n> 3. keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。\n> 4. unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等\n> 5. workQueue：缓存队列，用来存放等待被执行的任务。\n> 6. threadFactory 线程工厂\n> 7. handler：拒绝策略\n（1）abortPolicy：抛出异常（默认）\n（2）discardPolicy：放弃本次任务\n（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代\n（4）callerrunPolicy：让调用者运行任务\n\n\n2. **工作原理**\n\n如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；\n如果当前线程池中正在执行任务的的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；\n如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；\n如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理\n### 6.1.2、Executors类中提供的工厂方法\n根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池\n\n1. **newFixedThreadPool**\n\n```java\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n                                  0L, TimeUnit.MILLISECONDS,\n                                  new LinkedBlockingQueue<Runnable>());\n}\n```\n\n> 特点：\n> - 核心线程数 == 最大线程数（没有救急线程被创建），因此也无需超时时间 \n> - 阻塞队列是无界的，可以放任意数量的任务 \n> \n评价：\n> 适用于任务量已知，相对耗时的任务\n\n\n2. **newCachedThreadPool**\n\n```java\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                  60L, TimeUnit.SECONDS,\n                                  new SynchronousQueue<Runnable>());\n}\n```\n\n> 特点 \n> - 核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 \n>    - 全部都是救急线程（60s 后可以回收）\n>    - 救急线程可以无限创建 \n> - 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）\n> \n评价：\n> 整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程\n> 适合任务数比较密集，但每个任务执行时间较短的情况\n\n\n3. newSingleThreadExecutor\n\n```java\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n        (new ThreadPoolExecutor(1, 1,\n                                0L, TimeUnit.MILLISECONDS,\n                                new LinkedBlockingQueue<Runnable>()));\n}\n```\n使用场景： \n希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。\n任务执行完毕，这唯一的线程也不会被释放。 \n\n### 6.1.3、创建多大的线程池\n\n- 过小会导致程序不能充分地利用系统资源、容易导致饥饿 \n- 过大会导致更多的线程上下文切换，影响性能\n\n1. **CPU 密集型运算 **\n\n通常采用 `cpu 核数 + 1` 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 \n\n2. **I/O密集型**\n\nCPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I/O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。 \n经验公式如下 ：\n`线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间` \n\n## 6.2、锁\n### 6.2.1、AQS\n\n1. 基本概念\n\nAbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock/Semaphore/CountDownLatch...\n\n2. 原理 \n\n它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中\nAQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）\n\n3. 实现\n\n自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：\n> **isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。\n**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。\n**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。\n**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。\n\n\n以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的\n\n### 6.2.2、ReentrantLock\n**实现原理**\n\n1. 首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能\n2. 它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法\n3. 加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列\n4. 持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）\n\n**条件变量——Condition**\nCondition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程\n### 6.2.3、**ReentrantReadWriteLock**\n#### 4.2.3.1、ReentrantReadWriteLock基本概念\nReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用\n#### 4.2.3.2、锁获取过程\n\n1. 获取读锁\n\n如果写锁没有被另一个线程持有，则获取读锁并立即返回。     \n \t如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。\n\n4. 获取写入锁\n\n如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *\n如果当前线程持有写锁，则将写锁计数 +1，然后返回\n如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。\n\n#### 4.2.3.3、常见问题\n\n1. **读锁和写锁的可重入性**\n\n在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加\n\n2. **当前线程获取锁失败，被阻塞的后续操作是什么？**\n\n获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁\n\n3. **锁降级是怎么降级的？**\n\n在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）\n\n## 6.3、工具\n### 6.3.1、Semaphore\n\n1. **概念**\n\nSemaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）\n```java\npublic class DataSourcePool {\n \n    private final CopyOnWriteArrayList<Connection> list;\n    \n    //用到了信号量\n    private final Semaphore semaphore;\n \n    public DataSourcePool(int size) throws SQLException {\n        list = new CopyOnWriteArrayList<>();\n        semaphore = new Semaphore(size);\n        for (int i=0;i<size;i++){\n            Connection connection = DriverManager.getConnection(\"url\");\n            list.add(connection);\n        }\n    }\n    \n    //使用同步方法获取\n    public synchronized Connection getConnection() throws InterruptedException {\n        //先将当前信号量-1，如果为0，将阻塞\n        semaphore.acquire();\n        return list.remove(0);\n    }\n \n    public synchronized void  close(Connection connection){\n        //信号量+1\n        semaphore.release();\n        list.add(connection);\n    }\n}\n```\n\n2. **原理**\n\nSemaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n\n1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。\n2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state=state-1。state<0,令牌数量不足，加入阻塞队列。>=0则获取成功\n3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state=state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程\n### 6.3.2、CountdownLatch\n\n1. **概念**\n\nCountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一\n```java\npublic static void main(String[] args) throws InterruptedException {\n    CountDownLatch latch = new CountDownLatch(3);\n    ExecutorService service = Executors.newFixedThreadPool(4);\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(1.5);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(() -> {\n        log.debug(\"begin...\");\n        sleep(2);\n        latch.countDown();\n        log.debug(\"end...{}\", latch.getCount());\n    });\n    \n    service.submit(()->{\n        try {\n            log.debug(\"waiting...\");\n            latch.await();\n            log.debug(\"wait end...\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    });\n    \n}\n```\n```java\n18:52:25.831 c.TestCountDownLatch [pool-1-thread-3] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-1] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-2] - begin... \n18:52:25.831 c.TestCountDownLatch [pool-1-thread-4] - waiting... \n18:52:26.835 c.TestCountDownLatch [pool-1-thread-1] - end...2 \n18:52:27.335 c.TestCountDownLatch [pool-1-thread-2] - end...1 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-3] - end...0 \n18:52:27.835 c.TestCountDownLatch [pool-1-thread-4] - wait end...\n```\n\n2. **原理**\n\nCountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的\n1、初始化CountDownLatch实际就是设置了AQS的state为计数的值\n2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值\n3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试\n\n3. **和join的区别？**\n\nCountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成\n\n### 6.3.3、CyclicBarrier\n\n1. **概念**\n\nCyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行\n实现王者荣耀10个人都加载完才开始游戏\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        int count = 10;\n        CyclicBarrier cb = new CyclicBarrier(count, new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(\"全部加载完毕\");\n            }\n        });\n        ExecutorService executorService = Executors.newFixedThreadPool(count);\n        for (int x = 0; x < count; x++) {\n            executorService.execute(new Worker(cb));\n        }\n    }\n}\n\nclass Worker extends Thread {\n    CyclicBarrier cyclicBarrier;\n    public Worker(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName() + \" 已加载完\");\n        try {\n            cyclicBarrier.await();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n```java\npool-1-thread-1 已加载完\npool-1-thread-5 已加载完\npool-1-thread-4 已加载完\npool-1-thread-3 已加载完\npool-1-thread-6 已加载完\npool-1-thread-2 已加载完\npool-1-thread-7 已加载完\npool-1-thread-8 已加载完\npool-1-thread-9 已加载完\npool-1-thread-10 已加载完\n全部加载完毕\n\n```\n\n2. **原理**\n\n1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count\n2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；\n3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；\n4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；\n5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。\n\n## 6.4、线程安全集合类\n### 6.4.1、概述\n\t\t\t\t\t\t  \n线程安全实现类有三类：\n\n1. 遗留的线程安全集合如 Hashtable ， Vector \n2. 使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）\n\n>    - Collections.synchronizedCollection \n>    - Collections.synchronizedList \n>    - Collections.synchronizedMap \n>    - Collections.synchronizedSet \n>    - Collections.synchronizedNavigableMap \n>    - Collections.synchronizedNavigableSet\n>    - Collections.synchronizedSortedMap \n>    - Collections.synchronizedSortedSet \n\n4. JUC下的安全集合: Blocking、CopyOnWrite、Concurrent \n\n> - Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)\n> - CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)\n> - Concurrent 类型的容器 （内部很多操作使用cas优化）\n>    - 内部很多操作使用 cas 优化，一般可以提供较高吞吐量 \n>    - 弱一致性 \n>       - 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 \n>       - 求大小弱一致性，size 操作未必是 100% 准确 \n>       - 读取弱一致性 \n\n> 遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历\n\n### 6.4.2、concurrentHashMap\n**JDK1.8前**\nConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。\n\n元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部\n\n锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数\n\n\n> ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表\n\n\n**JDK1.8**\n\n在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全\n\n1. 初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 \n2. 插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 \n3. 扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 \n4. 查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。\n\n\n\n### 6.4.3、BlockingQueue\n主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue \n\n1. 区别\n\n（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表\n（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）\n（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现\n\n### 6.4.4、ConcurrentLinkedQueue \nConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）\n\n### 6.4.5、CopyOnWriteArrayList\n\n1. 首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行\n2. 写数据时会加ReentLocak锁，防止并发写入丢失数据的问题\n3. 写操作结束后会把原数组指向新数组\n4. CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景\n\n\n","slug":"JUC","published":1,"updated":"2023-07-25T13:19:14.794Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9e000100ujeaxa5fn3","content":"<h1 id=\"1、java多线程基本概念\"><a href=\"#1、java多线程基本概念\" class=\"headerlink\" title=\"1、java多线程基本概念\"></a>1、java多线程基本概念</h1><h2 id=\"1-1、进程和线程\"><a href=\"#1-1、进程和线程\" class=\"headerlink\" title=\"1.1、进程和线程\"></a>1.1、进程和线程</h2><ol>\n<li><strong>进程</strong></li>\n</ol>\n<ul>\n<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li>\n<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>\n<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>\n</ul>\n<ol start=\"2\">\n<li><strong>线程</strong></li>\n</ol>\n<ul>\n<li>一个进程之内可以分为一到多个线程。 </li>\n<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li>\n<li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li>\n</ul>\n<h2 id=\"1-2、并发和并行\"><a href=\"#1-2、并发和并行\" class=\"headerlink\" title=\"1.2、并发和并行\"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p>\n<h2 id=\"1-3、多线程的应用\"><a href=\"#1-3、多线程的应用\" class=\"headerlink\" title=\"1.3、多线程的应用\"></a>1.3、多线程的应用</h2><h3 id=\"1-3-1、异步调用\"><a href=\"#1-3-1、异步调用\" class=\"headerlink\" title=\"1.3.1、异步调用\"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p>\n<h3 id=\"1-3-2、提升效率\"><a href=\"#1-3-2、提升效率\" class=\"headerlink\" title=\"1.3.2、提升效率\"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算 <span class=\"number\">1</span> 花费 <span class=\"number\">10</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">2</span> 花费 <span class=\"number\">11</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">3</span> 花费 <span class=\"number\">9</span> ms</span><br><span class=\"line\">汇总需要 <span class=\"number\">1</span> ms</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li>\n<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms</li>\n</ul>\n<blockquote>\n<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>\n</blockquote>\n<h1 id=\"2、java线程\"><a href=\"#2、java线程\" class=\"headerlink\" title=\"2、java线程\"></a>2、java线程</h1><h2 id=\"2-1、线程的创建\"><a href=\"#2-1、线程的创建\" class=\"headerlink\" title=\"2.1、线程的创建\"></a>2.1、线程的创建</h2><h3 id=\"2-1-1、直接使用Thread\"><a href=\"#2-1-1、直接使用Thread\" class=\"headerlink\" title=\"2.1.1、直接使用Thread\"></a>2.1.1、直接使用Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、使用-Runnable-配合-Thread\"><a href=\"#2-1-2、使用-Runnable-配合-Thread\" class=\"headerlink\" title=\"2.1.2、使用 Runnable 配合 Thread\"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>( runnable );</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<p>java8可用lambda精简</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">task2</span> <span class=\"operator\">=</span> () -&gt; log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task2, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">t2.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3、FutureTask-配合-Thread\"><a href=\"#2-1-3、FutureTask-配合-Thread\" class=\"headerlink\" title=\"2.1.3、FutureTask 配合 Thread\"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\">FutureTask&lt;Integer&gt; task3 = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task3, <span class=\"string\">&quot;t3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> task3.get();</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、查看进程线程\"><a href=\"#2-2、查看进程线程\" class=\"headerlink\" title=\"2.2、查看进程线程\"></a>2.2、查看进程线程</h2><h3 id=\"2-2-1、windows\"><a href=\"#2-2-1、windows\" class=\"headerlink\" title=\"2.2.1、windows\"></a>2.2.1、windows</h3><ol>\n<li>tasklist 查看进程 </li>\n<li>taskkill 杀死进程 </li>\n<li>netstat -ano|findstr 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-2、linux\"><a href=\"#2-2-2、linux\" class=\"headerlink\" title=\"2.2.2、linux\"></a>2.2.2、linux</h3><ol>\n<li>ps -fe 查看所有进程 </li>\n<li>kill 杀死进程</li>\n<li>top -Hp <PID> 查看某个进程（PID）的所有线程 </li>\n<li>netstat -nlp|grep 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-3、JDK\"><a href=\"#2-2-3、JDK\" class=\"headerlink\" title=\"2.2.3、JDK\"></a>2.2.3、JDK</h3><ol>\n<li>jps 命令查看所有 Java 进程</li>\n<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>\n<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>\n</ol>\n<h2 id=\"2-3、线程运行原理\"><a href=\"#2-3、线程运行原理\" class=\"headerlink\" title=\"2.3、线程运行原理\"></a>2.3、线程运行原理</h2><ol>\n<li><strong>线程创建</strong></li>\n</ol>\n<p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成<br>，栈帧对应着每次方法调用所占内存</p>\n<ol start=\"2\">\n<li><strong>上下文切换</strong></li>\n</ol>\n<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p>\n<blockquote>\n<p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p>\n</blockquote>\n<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p>\n<h2 id=\"2-4、start与run\"><a href=\"#2-4、start与run\" class=\"headerlink\" title=\"2.4、start与run\"></a>2.4、start与run</h2><ul>\n<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>\n<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>\n</ul>\n<h2 id=\"2-5、sleep-与-yield\"><a href=\"#2-5、sleep-与-yield\" class=\"headerlink\" title=\"2.5、sleep 与 yield\"></a>2.5、sleep 与 yield</h2><ol>\n<li><strong>sleep</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>睡眠结束后的线程未必会立刻得到执行</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>yield</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>具体的实现依赖于操作系统的任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-6、join\"><a href=\"#2-6、join\" class=\"headerlink\" title=\"2.6、join\"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    test1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">        r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"comment\">// t1.join();</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不加t1.join()结果为0，加上以后结果为1</p>\n</blockquote>\n<h2 id=\"2-7、interrupt\"><a href=\"#2-7、interrupt\" class=\"headerlink\" title=\"2.7、interrupt\"></a>2.7、interrupt</h2><h3 id=\"2-7-1、打断阻塞状态的线程\"><a href=\"#2-7-1、打断阻塞状态的线程\" class=\"headerlink\" title=\"2.7.1、打断阻塞状态的线程\"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t1.interrupt();</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">     at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">     at java.lang.Thread.sleep(Thread.java:<span class=\"number\">340</span>)</span><br><span class=\"line\">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class=\"number\">386</span>)</span><br><span class=\"line\">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class=\"number\">3</span>(TestInterrupt.java:<span class=\"number\">59</span>)</span><br><span class=\"line\">     at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">18</span>:<span class=\"number\">10.374</span> [main] c.TestInterrupt - 打断状态: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-2、打断正常运行的线程\"><a href=\"#2-7-2、打断正常运行的线程\" class=\"headerlink\" title=\"2.7.2、打断正常运行的线程\"></a>2.7.2、打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> current.isInterrupted();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(interrupted) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t2.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class=\"literal\">true</span> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8、主线程与守护线程\"><a href=\"#2-8、主线程与守护线程\" class=\"headerlink\" title=\"2.8、主线程与守护线程\"></a>2.8、主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </p>\n<p>例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;daemon&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置该线程为守护线程</span></span><br><span class=\"line\">t1.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>**注意 **</p>\n<ul>\n<li>垃圾回收器线程就是一种守护线程 </li>\n<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>\n</ul>\n</blockquote>\n<h2 id=\"2-9、线程状态\"><a href=\"#2-9、线程状态\" class=\"headerlink\" title=\"2.9、线程状态\"></a>2.9、线程状态</h2><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NEW</td>\n<td>初始状态:线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>阻塞状态:表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td>WAITING</td>\n<td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>\n</tr>\n<tr>\n<td>TIMEWAITING</td>\n<td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>终止状态:表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg\" alt=\"线程状态\"></p>\n<h1 id=\"3、共享模型之管程\"><a href=\"#3、共享模型之管程\" class=\"headerlink\" title=\"3、共享模型之管程\"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p>\n<h2 id=\"3-1、monitor\"><a href=\"#3-1、monitor\" class=\"headerlink\" title=\"3.1、monitor\"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>\n<h3 id=\"3-1-1、Monitor结构\"><a href=\"#3-1-1、Monitor结构\" class=\"headerlink\" title=\"3.1.1、Monitor结构\"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg\" alt=\"monitor结构\"></p>\n<h3 id=\"3-1-2、Monitor原理\"><a href=\"#3-1-2、Monitor原理\" class=\"headerlink\" title=\"3.1.2、Monitor原理\"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n<h2 id=\"3-2、java对象结构\"><a href=\"#3-2、java对象结构\" class=\"headerlink\" title=\"3.2、java对象结构\"></a>3.2、java对象结构</h2><ol>\n<li><strong>对象头</strong></li>\n</ol>\n<p>包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg\" alt=\"java对象头\"></p>\n<ol start=\"2\">\n<li><strong>实例数据</strong></li>\n</ol>\n<p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p>\n<ol start=\"3\">\n<li><strong>对齐填充</strong></li>\n</ol>\n<p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>\n<h2 id=\"3-3、synchronized升级\"><a href=\"#3-3、synchronized升级\" class=\"headerlink\" title=\"3.3、synchronized升级\"></a>3.3、synchronized升级</h2><h3 id=\"3-3-1、偏向锁\"><a href=\"#3-3-1、偏向锁\" class=\"headerlink\" title=\"3.3.1、偏向锁\"></a>3.3.1、偏向锁</h3><blockquote>\n<p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p>\n</blockquote>\n<p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>\n<h3 id=\"3-3-2、轻量级锁\"><a href=\"#3-3-2、轻量级锁\" class=\"headerlink\" title=\"3.3.2、轻量级锁\"></a>3.3.2、轻量级锁</h3><blockquote>\n<p>使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg\" alt=\"轻量级锁\"></p>\n<ol>\n<li>创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象</li>\n<li>让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>\n<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>\n<li>如果 cas 失败，有两种情况</li>\n</ol>\n<p>（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程<br>（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）</p>\n<ol start=\"5\">\n<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>\n<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</li>\n</ol>\n<p>（1）成功，则解锁成功<br>（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>\n<h3 id=\"3-3-3、重量级锁\"><a href=\"#3-3-3、重量级锁\" class=\"headerlink\" title=\"3.3.3、重量级锁\"></a>3.3.3、重量级锁</h3><blockquote>\n<p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg\" alt=\"重量级锁\"></p>\n<ol>\n<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>\n<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</li>\n</ol>\n<p>（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<br>（2）然后自己进入 Monitor 的 EntryList阻塞队列</p>\n<ol start=\"3\">\n<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）</li>\n</ol>\n<blockquote>\n<p>调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n</blockquote>\n<h3 id=\"3-3-4、自旋锁\"><a href=\"#3-3-4、自旋锁\" class=\"headerlink\" title=\"3.3.4、自旋锁\"></a>3.3.4、自旋锁</h3><p>重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)</p>\n<h2 id=\"3-4、wait-notify\"><a href=\"#3-4、wait-notify\" class=\"headerlink\" title=\"3.4、wait&#x2F;notify\"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p>\n<h3 id=\"3-4-1、sleep和wait的区别？\"><a href=\"#3-4-1、sleep和wait的区别？\" class=\"headerlink\" title=\"3.4.1、sleep和wait的区别？\"></a>3.4.1、sleep和wait的区别？</h3><ol>\n<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>\n<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>\n<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>\n</ol>\n<h2 id=\"3-5、park-unpark\"><a href=\"#3-5、park-unpark\" class=\"headerlink\" title=\"3.5、park&#x2F;unpark\"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂停当前线程</span></span><br><span class=\"line\">LockSupport.park(); </span><br><span class=\"line\"><span class=\"comment\">// 恢复某个线程的运行</span></span><br><span class=\"line\">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-1、与-Object-的-wait-notify-相比\"><a href=\"#3-5-1、与-Object-的-wait-notify-相比\" class=\"headerlink\" title=\"3.5.1、与 Object 的 wait &amp; notify 相比\"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul>\n<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>\n<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>\n<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>\n</ul>\n<h3 id=\"3-5-2、原理\"><a href=\"#3-5-2、原理\" class=\"headerlink\" title=\"3.5.2、原理\"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p>\n<p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p>\n<h2 id=\"3-6、死锁\"><a href=\"#3-6、死锁\" class=\"headerlink\" title=\"3.6、死锁\"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p>\n<h3 id=\"3-6-1、死锁的必要条件\"><a href=\"#3-6-1、死锁的必要条件\" class=\"headerlink\" title=\"3.6.1、死锁的必要条件\"></a>3.6.1、死锁的必要条件</h3><ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h3 id=\"3-6-2、死锁的实现\"><a href=\"#3-6-2、死锁的实现\" class=\"headerlink\" title=\"3.6.2、死锁的实现\"></a>3.6.2、死锁的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">owner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"comment\">//开启一个新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                lock(owner, target);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"comment\">//主线程</span></span><br><span class=\"line\">        lock(target, owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">(Object owner, Object target)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (owner) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (target) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;success&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-3、定位死锁\"><a href=\"#3-6-3、定位死锁\" class=\"headerlink\" title=\"3.6.3、定位死锁\"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p>\n<h3 id=\"3-6-4、哲学家就餐问题\"><a href=\"#3-6-4、哲学家就餐问题\" class=\"headerlink\" title=\"3.6.4、哲学家就餐问题\"></a>3.6.4、哲学家就餐问题</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg\" alt=\"哲学家就餐问题\"></p>\n<p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p>\n<ol>\n<li>筷子类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chopstick</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Chopstick</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;筷子&#123;&quot;</span> + name + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>哲学家类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Philosopher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    Chopstick left;</span><br><span class=\"line\">    Chopstick right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Philosopher</span><span class=\"params\">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;eating...&quot;</span>);</span><br><span class=\"line\">        Sleeper.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得左手筷子</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (left) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获得右手筷子</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (right) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">                    eat();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 放下右手筷子</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 放下左手筷子</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>就餐</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c5</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、活锁\"><a href=\"#3-7、活锁\" class=\"headerlink\" title=\"3.7、活锁\"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p>\n<blockquote>\n<p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p>\n</blockquote>\n<h2 id=\"3-8、ReentrantLock\"><a href=\"#3-8、ReentrantLock\" class=\"headerlink\" title=\"3.8、ReentrantLock\"></a>3.8、<strong>ReentrantLock</strong></h2><p>相对于 synchronized 它具备如下特点 </p>\n<ol>\n<li>可中断 </li>\n<li>可以设置超时时间 </li>\n<li>可以设置为公平锁 （默认不公平）</li>\n<li>支持多个条件变量</li>\n</ol>\n<p>与 synchronized 一样，都支持可重入 </p>\n<h1 id=\"4、共享模型之内存\"><a href=\"#4、共享模型之内存\" class=\"headerlink\" title=\"4、共享模型之内存\"></a>4、共享模型之内存</h1><h2 id=\"4-1、java内存模型（jmm）\"><a href=\"#4-1、java内存模型（jmm）\" class=\"headerlink\" title=\"4.1、java内存模型（jmm）\"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p>\n<h2 id=\"4-2、线程安全性的三个体现\"><a href=\"#4-2、线程安全性的三个体现\" class=\"headerlink\" title=\"4.2、线程安全性的三个体现\"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）<br><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）<br><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）</p>\n<h1 id=\"5、共享模型之无锁\"><a href=\"#5、共享模型之无锁\" class=\"headerlink\" title=\"5、共享模型之无锁\"></a>5、共享模型之无锁</h1><h2 id=\"5-1、CAS\"><a href=\"#5-1、CAS\" class=\"headerlink\" title=\"5.1、CAS\"></a>5.1、CAS</h2><h3 id=\"5-1-1、CAS基本概念\"><a href=\"#5-1-1、CAS基本概念\" class=\"headerlink\" title=\"5.1.1、CAS基本概念\"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>\n<blockquote>\n<ol>\n<li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li>\n<li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li>\n</ol>\n</blockquote>\n<h3 id=\"5-1-2、CAS问题\"><a href=\"#5-1-2、CAS问题\" class=\"headerlink\" title=\"5.1.2、CAS问题\"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p>\n<p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p>\n<h2 id=\"5-2、volatile\"><a href=\"#5-2、volatile\" class=\"headerlink\" title=\"5.2、volatile\"></a>5.2、volatile</h2><h3 id=\"5-2-1、如何保证可见性和有序性\"><a href=\"#5-2-1、如何保证可见性和有序性\" class=\"headerlink\" title=\"5.2.1、如何保证可见性和有序性\"></a>5.2.1、如何保证可见性和有序性</h3><ol>\n<li><strong>保证可见性（缓存一致性协议MESI）</strong></li>\n</ol>\n<p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p>\n<blockquote>\n<p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p>\n</blockquote>\n<blockquote>\n<p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>保证有序性（禁止指令重排优化）</strong></li>\n</ol>\n<p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p>\n<h2 id=\"5-3、原子类\"><a href=\"#5-3、原子类\" class=\"headerlink\" title=\"5.3、原子类\"></a>5.3、原子类</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>具体类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic 基本类型原子类</td>\n<td>AtomicInteger AtomicLong AtomicBoolean</td>\n</tr>\n<tr>\n<td>AtomicArray 数组类型原子类</td>\n<td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td>\n</tr>\n<tr>\n<td>AtomicReference 引用类型原子类</td>\n<td>AtomicReference AtomicStampedReference AtomicMarkableReference</td>\n</tr>\n<tr>\n<td>AtomicFieldUpdate 升级类型原子类</td>\n<td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td>\n</tr>\n</tbody></table>\n<h1 id=\"6、共享模式之工具\"><a href=\"#6、共享模式之工具\" class=\"headerlink\" title=\"6、共享模式之工具\"></a>6、共享模式之工具</h1><h2 id=\"6-1、线程池\"><a href=\"#6-1、线程池\" class=\"headerlink\" title=\"6.1、线程池\"></a>6.1、线程池</h2><h3 id=\"6-1-1、ThreadPoolExecutor\"><a href=\"#6-1-1、ThreadPoolExecutor\" class=\"headerlink\" title=\"6.1.1、ThreadPoolExecutor\"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol>\n<li><strong>构造方法</strong></li>\n</ol>\n<p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p>\n<blockquote>\n<ol>\n<li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li>\n<li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li>\n<li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li>\n<li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>\n<li>workQueue：缓存队列，用来存放等待被执行的任务。</li>\n<li>threadFactory 线程工厂</li>\n<li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>\n<h3 id=\"6-1-2、Executors类中提供的工厂方法\"><a href=\"#6-1-2、Executors类中提供的工厂方法\" class=\"headerlink\" title=\"6.1.2、Executors类中提供的工厂方法\"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p>\n<ol>\n<li><strong>newFixedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newFixedThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点：</p>\n<ul>\n<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>\n<li>阻塞队列是无界的，可以放任意数量的任务</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>适用于任务量已知，相对耗时的任务</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>newCachedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newCachedThreadPool</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点 </p>\n<ul>\n<li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul>\n<li>全部都是救急线程（60s 后可以回收）</li>\n<li>救急线程可以无限创建</li>\n</ul>\n</li>\n<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p>\n</blockquote>\n<ol start=\"3\">\n<li>newSingleThreadExecutor</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newSingleThreadExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\">        (<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。 </p>\n<h3 id=\"6-1-3、创建多大的线程池\"><a href=\"#6-1-3、创建多大的线程池\" class=\"headerlink\" title=\"6.1.3、创建多大的线程池\"></a>6.1.3、创建多大的线程池</h3><ul>\n<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>\n<li>过大会导致更多的线程上下文切换，影响性能</li>\n</ul>\n<ol>\n<li>**CPU 密集型运算 **</li>\n</ol>\n<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>\n<ol start=\"2\">\n<li><strong>I&#x2F;O密集型</strong></li>\n</ol>\n<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>\n<h2 id=\"6-2、锁\"><a href=\"#6-2、锁\" class=\"headerlink\" title=\"6.2、锁\"></a>6.2、锁</h2><h3 id=\"6-2-1、AQS\"><a href=\"#6-2-1、AQS\" class=\"headerlink\" title=\"6.2.1、AQS\"></a>6.2.1、AQS</h3><ol>\n<li>基本概念</li>\n</ol>\n<p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p>\n<ol start=\"2\">\n<li>原理</li>\n</ol>\n<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>\n<blockquote>\n<p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>\n</blockquote>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p>\n<h3 id=\"6-2-2、ReentrantLock\"><a href=\"#6-2-2、ReentrantLock\" class=\"headerlink\" title=\"6.2.2、ReentrantLock\"></a>6.2.2、ReentrantLock</h3><p><strong>实现原理</strong></p>\n<ol>\n<li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li>\n<li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li>\n<li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li>\n<li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li>\n</ol>\n<p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p>\n<h3 id=\"6-2-3、ReentrantReadWriteLock\"><a href=\"#6-2-3、ReentrantReadWriteLock\" class=\"headerlink\" title=\"6.2.3、ReentrantReadWriteLock\"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id=\"4-2-3-1、ReentrantReadWriteLock基本概念\"><a href=\"#4-2-3-1、ReentrantReadWriteLock基本概念\" class=\"headerlink\" title=\"4.2.3.1、ReentrantReadWriteLock基本概念\"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p>\n<h4 id=\"4-2-3-2、锁获取过程\"><a href=\"#4-2-3-2、锁获取过程\" class=\"headerlink\" title=\"4.2.3.2、锁获取过程\"></a>4.2.3.2、锁获取过程</h4><ol>\n<li>获取读锁</li>\n</ol>\n<p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>     如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。</p>\n<ol start=\"4\">\n<li>获取写入锁</li>\n</ol>\n<p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p>\n<h4 id=\"4-2-3-3、常见问题\"><a href=\"#4-2-3-3、常见问题\" class=\"headerlink\" title=\"4.2.3.3、常见问题\"></a>4.2.3.3、常见问题</h4><ol>\n<li><strong>读锁和写锁的可重入性</strong></li>\n</ol>\n<p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p>\n<ol start=\"2\">\n<li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li>\n</ol>\n<p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p>\n<ol start=\"3\">\n<li><strong>锁降级是怎么降级的？</strong></li>\n</ol>\n<p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p>\n<h2 id=\"6-3、工具\"><a href=\"#6-3、工具\" class=\"headerlink\" title=\"6.3、工具\"></a>6.3、工具</h2><h3 id=\"6-3-1、Semaphore\"><a href=\"#6-3-1、Semaphore\" class=\"headerlink\" title=\"6.3.1、Semaphore\"></a>6.3.1、Semaphore</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourcePool</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//用到了信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DataSourcePool</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">        list = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        semaphore = <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">            list.add(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用同步方法获取</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class=\"line\">        semaphore.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">close</span><span class=\"params\">(Connection connection)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//信号量+1</span></span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">        list.add(connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p>\n<p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p>\n<h3 id=\"6-3-2、CountdownLatch\"><a href=\"#6-3-2、CountdownLatch\" class=\"headerlink\" title=\"6.3.2、CountdownLatch\"></a>6.3.2、CountdownLatch</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ExecutorService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1.5</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;wait end...&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - waiting... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">26.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - end..<span class=\"number\">.2</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.335</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - end..<span class=\"number\">.1</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - end..<span class=\"number\">.0</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - wait end...</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p>\n<ol start=\"3\">\n<li><strong>和join的区别？</strong></li>\n</ol>\n<p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p>\n<h3 id=\"6-3-3、CyclicBarrier\"><a href=\"#6-3-3、CyclicBarrier\" class=\"headerlink\" title=\"6.3.3、CyclicBarrier\"></a>6.3.3、CyclicBarrier</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(count, <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;全部加载完毕&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; x &lt; count; x++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(cb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    CyclicBarrier cyclicBarrier;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已加载完&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            cyclicBarrier.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">6</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">7</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">8</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">9</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">10</span> 已加载完</span><br><span class=\"line\">全部加载完毕</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p>\n<h2 id=\"6-4、线程安全集合类\"><a href=\"#6-4、线程安全集合类\" class=\"headerlink\" title=\"6.4、线程安全集合类\"></a>6.4、线程安全集合类</h2><h3 id=\"6-4-1、概述\"><a href=\"#6-4-1、概述\" class=\"headerlink\" title=\"6.4.1、概述\"></a>6.4.1、概述</h3><p>线程安全实现类有三类：</p>\n<ol>\n<li>遗留的线程安全集合如 Hashtable ， Vector </li>\n<li>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</li>\n</ol>\n<blockquote>\n<ul>\n<li>Collections.synchronizedCollection </li>\n<li>Collections.synchronizedList </li>\n<li>Collections.synchronizedMap </li>\n<li>Collections.synchronizedSet </li>\n<li>Collections.synchronizedNavigableMap </li>\n<li>Collections.synchronizedNavigableSet</li>\n<li>Collections.synchronizedSortedMap </li>\n<li>Collections.synchronizedSortedSet</li>\n</ul>\n</blockquote>\n<ol start=\"4\">\n<li>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent</li>\n</ol>\n<blockquote>\n<ul>\n<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li>\n<li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li>\n<li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul>\n<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>\n<li>弱一致性 <ul>\n<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li>\n<li>求大小弱一致性，size 操作未必是 100% 准确 </li>\n<li>读取弱一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p>\n</blockquote>\n<h3 id=\"6-4-2、concurrentHashMap\"><a href=\"#6-4-2、concurrentHashMap\" class=\"headerlink\" title=\"6.4.2、concurrentHashMap\"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p>\n<p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p>\n<p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p>\n<blockquote>\n<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p>\n</blockquote>\n<p><strong>JDK1.8</strong></p>\n<p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p>\n<ol>\n<li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li>\n<li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li>\n<li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li>\n<li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li>\n</ol>\n<h3 id=\"6-4-3、BlockingQueue\"><a href=\"#6-4-3、BlockingQueue\" class=\"headerlink\" title=\"6.4.3、BlockingQueue\"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p>\n<ol>\n<li>区别</li>\n</ol>\n<p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p>\n<h3 id=\"6-4-4、ConcurrentLinkedQueue\"><a href=\"#6-4-4、ConcurrentLinkedQueue\" class=\"headerlink\" title=\"6.4.4、ConcurrentLinkedQueue\"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p>\n<h3 id=\"6-4-5、CopyOnWriteArrayList\"><a href=\"#6-4-5、CopyOnWriteArrayList\" class=\"headerlink\" title=\"6.4.5、CopyOnWriteArrayList\"></a>6.4.5、CopyOnWriteArrayList</h3><ol>\n<li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li>\n<li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li>\n<li>写操作结束后会把原数组指向新数组</li>\n<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>\n</ol>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、java多线程基本概念\"><a href=\"#1、java多线程基本概念\" class=\"headerlink\" title=\"1、java多线程基本概念\"></a>1、java多线程基本概念</h1><h2 id=\"1-1、进程和线程\"><a href=\"#1-1、进程和线程\" class=\"headerlink\" title=\"1.1、进程和线程\"></a>1.1、进程和线程</h2><ol>\n<li><strong>进程</strong></li>\n</ol>\n<ul>\n<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li>\n<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>\n<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>\n</ul>\n<ol start=\"2\">\n<li><strong>线程</strong></li>\n</ol>\n<ul>\n<li>一个进程之内可以分为一到多个线程。 </li>\n<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li>\n<li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li>\n</ul>\n<h2 id=\"1-2、并发和并行\"><a href=\"#1-2、并发和并行\" class=\"headerlink\" title=\"1.2、并发和并行\"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p>\n<h2 id=\"1-3、多线程的应用\"><a href=\"#1-3、多线程的应用\" class=\"headerlink\" title=\"1.3、多线程的应用\"></a>1.3、多线程的应用</h2><h3 id=\"1-3-1、异步调用\"><a href=\"#1-3-1、异步调用\" class=\"headerlink\" title=\"1.3.1、异步调用\"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p>\n<h3 id=\"1-3-2、提升效率\"><a href=\"#1-3-2、提升效率\" class=\"headerlink\" title=\"1.3.2、提升效率\"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">计算 <span class=\"number\">1</span> 花费 <span class=\"number\">10</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">2</span> 花费 <span class=\"number\">11</span> ms</span><br><span class=\"line\">计算 <span class=\"number\">3</span> 花费 <span class=\"number\">9</span> ms</span><br><span class=\"line\">汇总需要 <span class=\"number\">1</span> ms</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li>\n<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms</li>\n</ul>\n<blockquote>\n<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>\n</blockquote>\n<h1 id=\"2、java线程\"><a href=\"#2、java线程\" class=\"headerlink\" title=\"2、java线程\"></a>2、java线程</h1><h2 id=\"2-1、线程的创建\"><a href=\"#2-1、线程的创建\" class=\"headerlink\" title=\"2.1、线程的创建\"></a>2.1、线程的创建</h2><h3 id=\"2-1-1、直接使用Thread\"><a href=\"#2-1-1、直接使用Thread\" class=\"headerlink\" title=\"2.1.1、直接使用Thread\"></a>2.1.1、直接使用Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、使用-Runnable-配合-Thread\"><a href=\"#2-1-2、使用-Runnable-配合-Thread\" class=\"headerlink\" title=\"2.1.2、使用 Runnable 配合 Thread\"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">runnable</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 要执行的任务</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// 创建线程对象</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>( runnable );</span><br><span class=\"line\"><span class=\"comment\">// 启动线程</span></span><br><span class=\"line\">t.start();</span><br></pre></td></tr></table></figure>\n<p>java8可用lambda精简</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\"><span class=\"type\">Runnable</span> <span class=\"variable\">task2</span> <span class=\"operator\">=</span> () -&gt; log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task2, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">t2.start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-3、FutureTask-配合-Thread\"><a href=\"#2-1-3、FutureTask-配合-Thread\" class=\"headerlink\" title=\"2.1.3、FutureTask 配合 Thread\"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建任务对象</span></span><br><span class=\"line\">FutureTask&lt;Integer&gt; task3 = <span class=\"keyword\">new</span> <span class=\"title class_\">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(task3, <span class=\"string\">&quot;t3&quot;</span>).start();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class=\"line\"><span class=\"type\">Integer</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> task3.get();</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、查看进程线程\"><a href=\"#2-2、查看进程线程\" class=\"headerlink\" title=\"2.2、查看进程线程\"></a>2.2、查看进程线程</h2><h3 id=\"2-2-1、windows\"><a href=\"#2-2-1、windows\" class=\"headerlink\" title=\"2.2.1、windows\"></a>2.2.1、windows</h3><ol>\n<li>tasklist 查看进程 </li>\n<li>taskkill 杀死进程 </li>\n<li>netstat -ano|findstr 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-2、linux\"><a href=\"#2-2-2、linux\" class=\"headerlink\" title=\"2.2.2、linux\"></a>2.2.2、linux</h3><ol>\n<li>ps -fe 查看所有进程 </li>\n<li>kill 杀死进程</li>\n<li>top -Hp <PID> 查看某个进程（PID）的所有线程 </li>\n<li>netstat -nlp|grep 8080 根据端口查看进程</li>\n</ol>\n<h3 id=\"2-2-3、JDK\"><a href=\"#2-2-3、JDK\" class=\"headerlink\" title=\"2.2.3、JDK\"></a>2.2.3、JDK</h3><ol>\n<li>jps 命令查看所有 Java 进程</li>\n<li>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</li>\n<li>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</li>\n</ol>\n<h2 id=\"2-3、线程运行原理\"><a href=\"#2-3、线程运行原理\" class=\"headerlink\" title=\"2.3、线程运行原理\"></a>2.3、线程运行原理</h2><ol>\n<li><strong>线程创建</strong></li>\n</ol>\n<p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成<br>，栈帧对应着每次方法调用所占内存</p>\n<ol start=\"2\">\n<li><strong>上下文切换</strong></li>\n</ol>\n<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p>\n<blockquote>\n<p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p>\n</blockquote>\n<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p>\n<h2 id=\"2-4、start与run\"><a href=\"#2-4、start与run\" class=\"headerlink\" title=\"2.4、start与run\"></a>2.4、start与run</h2><ul>\n<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>\n<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>\n</ul>\n<h2 id=\"2-5、sleep-与-yield\"><a href=\"#2-5、sleep-与-yield\" class=\"headerlink\" title=\"2.5、sleep 与 yield\"></a>2.5、sleep 与 yield</h2><ol>\n<li><strong>sleep</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>\n</ol>\n</li>\n<li><ol start=\"3\">\n<li>睡眠结束后的线程未必会立刻得到执行</li>\n</ol>\n</li>\n</ul>\n<ol start=\"2\">\n<li><strong>yield</strong></li>\n</ol>\n<ul>\n<li><ol>\n<li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li>\n</ol>\n</li>\n<li><ol start=\"2\">\n<li>具体的实现依赖于操作系统的任务调度器</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"2-6、join\"><a href=\"#2-6、join\" class=\"headerlink\" title=\"2.6、join\"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"type\">int</span> <span class=\"variable\">r</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    test1();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;开始&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">        r = <span class=\"number\">10</span>;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    <span class=\"comment\">// t1.join();</span></span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;结束&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果不加t1.join()结果为0，加上以后结果为1</p>\n</blockquote>\n<h2 id=\"2-7、interrupt\"><a href=\"#2-7、interrupt\" class=\"headerlink\" title=\"2.7、interrupt\"></a>2.7、interrupt</h2><h3 id=\"2-7-1、打断阻塞状态的线程\"><a href=\"#2-7-1、打断阻塞状态的线程\" class=\"headerlink\" title=\"2.7.1、打断阻塞状态的线程\"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，打断 这几个状态 的线程, 会中断</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t1&quot;</span>);</span><br><span class=\"line\">    t1.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t1.interrupt();</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java.lang.InterruptedException: sleep interrupted</span><br><span class=\"line\">     at java.lang.Thread.sleep(Native Method)</span><br><span class=\"line\">     at java.lang.Thread.sleep(Thread.java:<span class=\"number\">340</span>)</span><br><span class=\"line\">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class=\"number\">386</span>)</span><br><span class=\"line\">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class=\"number\">8</span>)</span><br><span class=\"line\">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class=\"number\">3</span>(TestInterrupt.java:<span class=\"number\">59</span>)</span><br><span class=\"line\">     at java.lang.Thread.run(Thread.java:<span class=\"number\">745</span>)</span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">18</span>:<span class=\"number\">10.374</span> [main] c.TestInterrupt - 打断状态: <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-7-2、打断正常运行的线程\"><a href=\"#2-7-2、打断正常运行的线程\" class=\"headerlink\" title=\"2.7.2、打断正常运行的线程\"></a>2.7.2、打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断运行（此时我们需要通过打断状态来中止）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test2</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">Thread</span> <span class=\"variable\">t2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Thread</span> <span class=\"variable\">current</span> <span class=\"operator\">=</span> Thread.currentThread();</span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">interrupted</span> <span class=\"operator\">=</span> current.isInterrupted();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(interrupted) &#123;</span><br><span class=\"line\">                log.debug(<span class=\"string\">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;, <span class=\"string\">&quot;t2&quot;</span>);</span><br><span class=\"line\">    t2.start();</span><br><span class=\"line\">    sleep(<span class=\"number\">0.5</span>);</span><br><span class=\"line\">    t2.interrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">57</span>:<span class=\"number\">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class=\"literal\">true</span> </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-8、主线程与守护线程\"><a href=\"#2-8、主线程与守护线程\" class=\"headerlink\" title=\"2.8、主线程与守护线程\"></a>2.8、主线程与守护线程</h2><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </p>\n<p>例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Thread</span> <span class=\"variable\">t1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;开始运行...&quot;</span>);</span><br><span class=\"line\">    sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">    log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br><span class=\"line\">&#125;, <span class=\"string\">&quot;daemon&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 设置该线程为守护线程</span></span><br><span class=\"line\">t1.setDaemon(<span class=\"literal\">true</span>);</span><br><span class=\"line\">t1.start();</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">log.debug(<span class=\"string\">&quot;运行结束...&quot;</span>);</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class=\"line\">08:<span class=\"number\">26</span>:<span class=\"number\">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>**注意 **</p>\n<ul>\n<li>垃圾回收器线程就是一种守护线程 </li>\n<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>\n</ul>\n</blockquote>\n<h2 id=\"2-9、线程状态\"><a href=\"#2-9、线程状态\" class=\"headerlink\" title=\"2.9、线程状态\"></a>2.9、线程状态</h2><table>\n<thead>\n<tr>\n<th>状态</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>NEW</td>\n<td>初始状态:线程被创建，但还没有调用start()方法</td>\n</tr>\n<tr>\n<td>RUNNABLE</td>\n<td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td>\n</tr>\n<tr>\n<td>BLOCKED</td>\n<td>阻塞状态:表示线程阻塞于锁</td>\n</tr>\n<tr>\n<td>WAITING</td>\n<td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>\n</tr>\n<tr>\n<td>TIMEWAITING</td>\n<td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td>\n</tr>\n<tr>\n<td>TERMINATED</td>\n<td>终止状态:表示当前线程已经执行完毕</td>\n</tr>\n</tbody></table>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg\" alt=\"线程状态\"></p>\n<h1 id=\"3、共享模型之管程\"><a href=\"#3、共享模型之管程\" class=\"headerlink\" title=\"3、共享模型之管程\"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p>\n<h2 id=\"3-1、monitor\"><a href=\"#3-1、monitor\" class=\"headerlink\" title=\"3.1、monitor\"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>\n<h3 id=\"3-1-1、Monitor结构\"><a href=\"#3-1-1、Monitor结构\" class=\"headerlink\" title=\"3.1.1、Monitor结构\"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg\" alt=\"monitor结构\"></p>\n<h3 id=\"3-1-2、Monitor原理\"><a href=\"#3-1-2、Monitor原理\" class=\"headerlink\" title=\"3.1.2、Monitor原理\"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n<h2 id=\"3-2、java对象结构\"><a href=\"#3-2、java对象结构\" class=\"headerlink\" title=\"3.2、java对象结构\"></a>3.2、java对象结构</h2><ol>\n<li><strong>对象头</strong></li>\n</ol>\n<p>包括：对象头：Mark Word（标记字段）、Class Pointer（类型指针）,数组长度（如果是数组）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg\" alt=\"java对象头\"></p>\n<ol start=\"2\">\n<li><strong>实例数据</strong></li>\n</ol>\n<p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p>\n<ol start=\"3\">\n<li><strong>对齐填充</strong></li>\n</ol>\n<p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>\n<h2 id=\"3-3、synchronized升级\"><a href=\"#3-3、synchronized升级\" class=\"headerlink\" title=\"3.3、synchronized升级\"></a>3.3、synchronized升级</h2><h3 id=\"3-3-1、偏向锁\"><a href=\"#3-3-1、偏向锁\" class=\"headerlink\" title=\"3.3.1、偏向锁\"></a>3.3.1、偏向锁</h3><blockquote>\n<p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p>\n</blockquote>\n<p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>\n<h3 id=\"3-3-2、轻量级锁\"><a href=\"#3-3-2、轻量级锁\" class=\"headerlink\" title=\"3.3.2、轻量级锁\"></a>3.3.2、轻量级锁</h3><blockquote>\n<p>使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg\" alt=\"轻量级锁\"></p>\n<ol>\n<li>创建 锁记录（Lock Record）对象，内部存储锁记录地址和状态00，还有对象引用指向锁对象</li>\n<li>让锁记录中引用 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录</li>\n<li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁</li>\n<li>如果 cas 失败，有两种情况</li>\n</ol>\n<p>（1）如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程<br>（2）如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（取值为null）</p>\n<ol start=\"5\">\n<li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li>\n<li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头</li>\n</ol>\n<p>（1）成功，则解锁成功<br>（2）失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</p>\n<h3 id=\"3-3-3、重量级锁\"><a href=\"#3-3-3、重量级锁\" class=\"headerlink\" title=\"3.3.3、重量级锁\"></a>3.3.3、重量级锁</h3><blockquote>\n<p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg\" alt=\"重量级锁\"></p>\n<ol>\n<li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li>\n<li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程</li>\n</ol>\n<p>（1）为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址<br>（2）然后自己进入 Monitor 的 EntryList阻塞队列</p>\n<ol start=\"3\">\n<li>当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中阻塞线程（不公平）</li>\n</ol>\n<blockquote>\n<p>调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>\n</blockquote>\n<h3 id=\"3-3-4、自旋锁\"><a href=\"#3-3-4、自旋锁\" class=\"headerlink\" title=\"3.3.4、自旋锁\"></a>3.3.4、自旋锁</h3><p>重量级锁竞争的时候，还可以使用自旋(循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)</p>\n<h2 id=\"3-4、wait-notify\"><a href=\"#3-4、wait-notify\" class=\"headerlink\" title=\"3.4、wait&#x2F;notify\"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p>\n<h3 id=\"3-4-1、sleep和wait的区别？\"><a href=\"#3-4-1、sleep和wait的区别？\" class=\"headerlink\" title=\"3.4.1、sleep和wait的区别？\"></a>3.4.1、sleep和wait的区别？</h3><ol>\n<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>\n<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>\n<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>\n</ol>\n<h2 id=\"3-5、park-unpark\"><a href=\"#3-5、park-unpark\" class=\"headerlink\" title=\"3.5、park&#x2F;unpark\"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 暂停当前线程</span></span><br><span class=\"line\">LockSupport.park(); </span><br><span class=\"line\"><span class=\"comment\">// 恢复某个线程的运行</span></span><br><span class=\"line\">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-5-1、与-Object-的-wait-notify-相比\"><a href=\"#3-5-1、与-Object-的-wait-notify-相比\" class=\"headerlink\" title=\"3.5.1、与 Object 的 wait &amp; notify 相比\"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul>\n<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>\n<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>\n<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>\n</ul>\n<h3 id=\"3-5-2、原理\"><a href=\"#3-5-2、原理\" class=\"headerlink\" title=\"3.5.2、原理\"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p>\n<p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p>\n<h2 id=\"3-6、死锁\"><a href=\"#3-6、死锁\" class=\"headerlink\" title=\"3.6、死锁\"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p>\n<h3 id=\"3-6-1、死锁的必要条件\"><a href=\"#3-6-1、死锁的必要条件\" class=\"headerlink\" title=\"3.6.1、死锁的必要条件\"></a>3.6.1、死锁的必要条件</h3><ol>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ol>\n<h3 id=\"3-6-2、死锁的实现\"><a href=\"#3-6-2、死锁的实现\" class=\"headerlink\" title=\"3.6.2、死锁的实现\"></a>3.6.2、死锁的实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现一个死锁</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DeadLock</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">owner</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"type\">Object</span> <span class=\"variable\">target</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Object</span>();</span><br><span class=\"line\">        <span class=\"comment\">//开启一个新线程</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> <span class=\"title class_\">Thread</span>(() -&gt; &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                lock(owner, target);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;).start();</span><br><span class=\"line\">        <span class=\"comment\">//主线程</span></span><br><span class=\"line\">        lock(target, owner);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">lock</span><span class=\"params\">(Object owner, Object target)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">synchronized</span> (owner) &#123;</span><br><span class=\"line\">            Thread.sleep(<span class=\"number\">1000</span>);</span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (target) &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;success&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-6-3、定位死锁\"><a href=\"#3-6-3、定位死锁\" class=\"headerlink\" title=\"3.6.3、定位死锁\"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p>\n<h3 id=\"3-6-4、哲学家就餐问题\"><a href=\"#3-6-4、哲学家就餐问题\" class=\"headerlink\" title=\"3.6.4、哲学家就餐问题\"></a>3.6.4、哲学家就餐问题</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg\" alt=\"哲学家就餐问题\"></p>\n<p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p>\n<ol>\n<li>筷子类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Chopstick</span> &#123;</span><br><span class=\"line\">    String name;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Chopstick</span><span class=\"params\">(String name)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">toString</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;筷子&#123;&quot;</span> + name + <span class=\"string\">&#x27;&#125;&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>哲学家类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Philosopher</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    Chopstick left;</span><br><span class=\"line\">    Chopstick right;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Philosopher</span><span class=\"params\">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name);</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.left = left;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.right = right;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">eat</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;eating...&quot;</span>);</span><br><span class=\"line\">        Sleeper.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 获得左手筷子</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (left) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 获得右手筷子</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (right) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 吃饭</span></span><br><span class=\"line\">                    eat();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 放下右手筷子</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 放下左手筷子</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>就餐</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;1&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;2&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c3</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;3&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c4</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;4&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">Chopstick</span> <span class=\"variable\">c5</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Chopstick</span>(<span class=\"string\">&quot;5&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title class_\">Philosopher</span>(<span class=\"string\">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、活锁\"><a href=\"#3-7、活锁\" class=\"headerlink\" title=\"3.7、活锁\"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p>\n<blockquote>\n<p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p>\n</blockquote>\n<h2 id=\"3-8、ReentrantLock\"><a href=\"#3-8、ReentrantLock\" class=\"headerlink\" title=\"3.8、ReentrantLock\"></a>3.8、<strong>ReentrantLock</strong></h2><p>相对于 synchronized 它具备如下特点 </p>\n<ol>\n<li>可中断 </li>\n<li>可以设置超时时间 </li>\n<li>可以设置为公平锁 （默认不公平）</li>\n<li>支持多个条件变量</li>\n</ol>\n<p>与 synchronized 一样，都支持可重入 </p>\n<h1 id=\"4、共享模型之内存\"><a href=\"#4、共享模型之内存\" class=\"headerlink\" title=\"4、共享模型之内存\"></a>4、共享模型之内存</h1><h2 id=\"4-1、java内存模型（jmm）\"><a href=\"#4-1、java内存模型（jmm）\" class=\"headerlink\" title=\"4.1、java内存模型（jmm）\"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p>\n<h2 id=\"4-2、线程安全性的三个体现\"><a href=\"#4-2、线程安全性的三个体现\" class=\"headerlink\" title=\"4.2、线程安全性的三个体现\"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）<br><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）<br><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行（happens-before原则）</p>\n<h1 id=\"5、共享模型之无锁\"><a href=\"#5、共享模型之无锁\" class=\"headerlink\" title=\"5、共享模型之无锁\"></a>5、共享模型之无锁</h1><h2 id=\"5-1、CAS\"><a href=\"#5-1、CAS\" class=\"headerlink\" title=\"5.1、CAS\"></a>5.1、CAS</h2><h3 id=\"5-1-1、CAS基本概念\"><a href=\"#5-1-1、CAS基本概念\" class=\"headerlink\" title=\"5.1.1、CAS基本概念\"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>\n<blockquote>\n<ol>\n<li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li>\n<li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li>\n</ol>\n</blockquote>\n<h3 id=\"5-1-2、CAS问题\"><a href=\"#5-1-2、CAS问题\" class=\"headerlink\" title=\"5.1.2、CAS问题\"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p>\n<p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p>\n<h2 id=\"5-2、volatile\"><a href=\"#5-2、volatile\" class=\"headerlink\" title=\"5.2、volatile\"></a>5.2、volatile</h2><h3 id=\"5-2-1、如何保证可见性和有序性\"><a href=\"#5-2-1、如何保证可见性和有序性\" class=\"headerlink\" title=\"5.2.1、如何保证可见性和有序性\"></a>5.2.1、如何保证可见性和有序性</h3><ol>\n<li><strong>保证可见性（缓存一致性协议MESI）</strong></li>\n</ol>\n<p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p>\n<blockquote>\n<p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p>\n</blockquote>\n<blockquote>\n<p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>保证有序性（禁止指令重排优化）</strong></li>\n</ol>\n<p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p>\n<h2 id=\"5-3、原子类\"><a href=\"#5-3、原子类\" class=\"headerlink\" title=\"5.3、原子类\"></a>5.3、原子类</h2><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>具体类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Atomic 基本类型原子类</td>\n<td>AtomicInteger AtomicLong AtomicBoolean</td>\n</tr>\n<tr>\n<td>AtomicArray 数组类型原子类</td>\n<td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td>\n</tr>\n<tr>\n<td>AtomicReference 引用类型原子类</td>\n<td>AtomicReference AtomicStampedReference AtomicMarkableReference</td>\n</tr>\n<tr>\n<td>AtomicFieldUpdate 升级类型原子类</td>\n<td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td>\n</tr>\n</tbody></table>\n<h1 id=\"6、共享模式之工具\"><a href=\"#6、共享模式之工具\" class=\"headerlink\" title=\"6、共享模式之工具\"></a>6、共享模式之工具</h1><h2 id=\"6-1、线程池\"><a href=\"#6-1、线程池\" class=\"headerlink\" title=\"6.1、线程池\"></a>6.1、线程池</h2><h3 id=\"6-1-1、ThreadPoolExecutor\"><a href=\"#6-1-1、ThreadPoolExecutor\" class=\"headerlink\" title=\"6.1.1、ThreadPoolExecutor\"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol>\n<li><strong>构造方法</strong></li>\n</ol>\n<p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p>\n<blockquote>\n<ol>\n<li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li>\n<li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li>\n<li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li>\n<li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>\n<li>workQueue：缓存队列，用来存放等待被执行的任务。</li>\n<li>threadFactory 线程工厂</li>\n<li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li><strong>工作原理</strong></li>\n</ol>\n<p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>\n<h3 id=\"6-1-2、Executors类中提供的工厂方法\"><a href=\"#6-1-2、Executors类中提供的工厂方法\" class=\"headerlink\" title=\"6.1.2、Executors类中提供的工厂方法\"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p>\n<ol>\n<li><strong>newFixedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newFixedThreadPool</span><span class=\"params\">(<span class=\"type\">int</span> nThreads)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class=\"line\">                                  <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点：</p>\n<ul>\n<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>\n<li>阻塞队列是无界的，可以放任意数量的任务</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>适用于任务量已知，相对耗时的任务</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>newCachedThreadPool</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newCachedThreadPool</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                  <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                  <span class=\"keyword\">new</span> <span class=\"title class_\">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>特点 </p>\n<ul>\n<li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul>\n<li>全部都是救急线程（60s 后可以回收）</li>\n<li>救急线程可以无限创建</li>\n</ul>\n</li>\n<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>\n</ul>\n</blockquote>\n<p>评价：</p>\n<blockquote>\n<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p>\n</blockquote>\n<ol start=\"3\">\n<li>newSingleThreadExecutor</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title function_\">newSingleThreadExecutor</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FinalizableDelegatedExecutorService</span></span><br><span class=\"line\">        (<span class=\"keyword\">new</span> <span class=\"title class_\">ThreadPoolExecutor</span>(<span class=\"number\">1</span>, <span class=\"number\">1</span>,</span><br><span class=\"line\">                                <span class=\"number\">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class=\"line\">                                <span class=\"keyword\">new</span> <span class=\"title class_\">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。 </p>\n<h3 id=\"6-1-3、创建多大的线程池\"><a href=\"#6-1-3、创建多大的线程池\" class=\"headerlink\" title=\"6.1.3、创建多大的线程池\"></a>6.1.3、创建多大的线程池</h3><ul>\n<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>\n<li>过大会导致更多的线程上下文切换，影响性能</li>\n</ul>\n<ol>\n<li>**CPU 密集型运算 **</li>\n</ol>\n<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>\n<ol start=\"2\">\n<li><strong>I&#x2F;O密集型</strong></li>\n</ol>\n<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>\n<h2 id=\"6-2、锁\"><a href=\"#6-2、锁\" class=\"headerlink\" title=\"6.2、锁\"></a>6.2、锁</h2><h3 id=\"6-2-1、AQS\"><a href=\"#6-2-1、AQS\" class=\"headerlink\" title=\"6.2.1、AQS\"></a>6.2.1、AQS</h3><ol>\n<li>基本概念</li>\n</ol>\n<p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p>\n<ol start=\"2\">\n<li>原理</li>\n</ol>\n<p>它维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到队列中<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）</p>\n<ol start=\"3\">\n<li>实现</li>\n</ol>\n<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>\n<blockquote>\n<p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>\n</blockquote>\n<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p>\n<h3 id=\"6-2-2、ReentrantLock\"><a href=\"#6-2-2、ReentrantLock\" class=\"headerlink\" title=\"6.2.2、ReentrantLock\"></a>6.2.2、ReentrantLock</h3><p><strong>实现原理</strong></p>\n<ol>\n<li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li>\n<li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li>\n<li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li>\n<li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li>\n</ol>\n<p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p>\n<h3 id=\"6-2-3、ReentrantReadWriteLock\"><a href=\"#6-2-3、ReentrantReadWriteLock\" class=\"headerlink\" title=\"6.2.3、ReentrantReadWriteLock\"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id=\"4-2-3-1、ReentrantReadWriteLock基本概念\"><a href=\"#4-2-3-1、ReentrantReadWriteLock基本概念\" class=\"headerlink\" title=\"4.2.3.1、ReentrantReadWriteLock基本概念\"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p>\n<h4 id=\"4-2-3-2、锁获取过程\"><a href=\"#4-2-3-2、锁获取过程\" class=\"headerlink\" title=\"4.2.3.2、锁获取过程\"></a>4.2.3.2、锁获取过程</h4><ol>\n<li>获取读锁</li>\n</ol>\n<p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>     如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直\t到获取读锁为止。</p>\n<ol start=\"4\">\n<li>获取写入锁</li>\n</ol>\n<p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1。     *<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p>\n<h4 id=\"4-2-3-3、常见问题\"><a href=\"#4-2-3-3、常见问题\" class=\"headerlink\" title=\"4.2.3.3、常见问题\"></a>4.2.3.3、常见问题</h4><ol>\n<li><strong>读锁和写锁的可重入性</strong></li>\n</ol>\n<p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p>\n<ol start=\"2\">\n<li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li>\n</ol>\n<p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p>\n<ol start=\"3\">\n<li><strong>锁降级是怎么降级的？</strong></li>\n</ol>\n<p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p>\n<h2 id=\"6-3、工具\"><a href=\"#6-3、工具\" class=\"headerlink\" title=\"6.3、工具\"></a>6.3、工具</h2><h3 id=\"6-3-1、Semaphore\"><a href=\"#6-3-1、Semaphore\" class=\"headerlink\" title=\"6.3.1、Semaphore\"></a>6.3.1、Semaphore</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">DataSourcePool</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//用到了信号量</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Semaphore semaphore;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">DataSourcePool</span><span class=\"params\">(<span class=\"type\">int</span> size)</span> <span class=\"keyword\">throws</span> SQLException &#123;</span><br><span class=\"line\">        list = <span class=\"keyword\">new</span> <span class=\"title class_\">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class=\"line\">        semaphore = <span class=\"keyword\">new</span> <span class=\"title class_\">Semaphore</span>(size);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;size;i++)&#123;</span><br><span class=\"line\">            <span class=\"type\">Connection</span> <span class=\"variable\">connection</span> <span class=\"operator\">=</span> DriverManager.getConnection(<span class=\"string\">&quot;url&quot;</span>);</span><br><span class=\"line\">            list.add(connection);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//使用同步方法获取</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> Connection <span class=\"title function_\">getConnection</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class=\"line\">        semaphore.acquire();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> list.remove(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">void</span>  <span class=\"title function_\">close</span><span class=\"params\">(Connection connection)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//信号量+1</span></span><br><span class=\"line\">        semaphore.release();</span><br><span class=\"line\">        list.add(connection);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p>\n<p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p>\n<h3 id=\"6-3-2、CountdownLatch\"><a href=\"#6-3-2、CountdownLatch\" class=\"headerlink\" title=\"6.3.2、CountdownLatch\"></a>6.3.2、CountdownLatch</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"type\">CountDownLatch</span> <span class=\"variable\">latch</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CountDownLatch</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"type\">ExecutorService</span> <span class=\"variable\">service</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(<span class=\"number\">4</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">1.5</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(() -&gt; &#123;</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;begin...&quot;</span>);</span><br><span class=\"line\">        sleep(<span class=\"number\">2</span>);</span><br><span class=\"line\">        latch.countDown();</span><br><span class=\"line\">        log.debug(<span class=\"string\">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    service.submit(()-&gt;&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;waiting...&quot;</span>);</span><br><span class=\"line\">            latch.await();</span><br><span class=\"line\">            log.debug(<span class=\"string\">&quot;wait end...&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - begin... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">25.831</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - waiting... </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">26.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span>] - end..<span class=\"number\">.2</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.335</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span>] - end..<span class=\"number\">.1</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span>] - end..<span class=\"number\">.0</span> </span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">52</span>:<span class=\"number\">27.835</span> c.TestCountDownLatch [pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span>] - wait end...</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p>\n<ol start=\"3\">\n<li><strong>和join的区别？</strong></li>\n</ol>\n<p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p>\n<h3 id=\"6-3-3、CyclicBarrier\"><a href=\"#6-3-3、CyclicBarrier\" class=\"headerlink\" title=\"6.3.3、CyclicBarrier\"></a>6.3.3、CyclicBarrier</h3><ol>\n<li><strong>概念</strong></li>\n</ol>\n<p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CyclicBarrierDemo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\">        <span class=\"type\">CyclicBarrier</span> <span class=\"variable\">cb</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CyclicBarrier</span>(count, <span class=\"keyword\">new</span> <span class=\"title class_\">Runnable</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;全部加载完毕&quot;</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"type\">ExecutorService</span> <span class=\"variable\">executorService</span> <span class=\"operator\">=</span> Executors.newFixedThreadPool(count);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">x</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; x &lt; count; x++) &#123;</span><br><span class=\"line\">            executorService.execute(<span class=\"keyword\">new</span> <span class=\"title class_\">Worker</span>(cb));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">Thread</span> &#123;</span><br><span class=\"line\">    CyclicBarrier cyclicBarrier;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Worker</span><span class=\"params\">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">run</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(Thread.currentThread().getName() + <span class=\"string\">&quot; 已加载完&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            cyclicBarrier.await();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (BrokenBarrierException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">1</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">5</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">4</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">3</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">6</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">2</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">7</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">8</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">9</span> 已加载完</span><br><span class=\"line\">pool-<span class=\"number\">1</span>-thread-<span class=\"number\">10</span> 已加载完</span><br><span class=\"line\">全部加载完毕</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>原理</strong></li>\n</ol>\n<p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p>\n<h2 id=\"6-4、线程安全集合类\"><a href=\"#6-4、线程安全集合类\" class=\"headerlink\" title=\"6.4、线程安全集合类\"></a>6.4、线程安全集合类</h2><h3 id=\"6-4-1、概述\"><a href=\"#6-4-1、概述\" class=\"headerlink\" title=\"6.4.1、概述\"></a>6.4.1、概述</h3><p>线程安全实现类有三类：</p>\n<ol>\n<li>遗留的线程安全集合如 Hashtable ， Vector </li>\n<li>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</li>\n</ol>\n<blockquote>\n<ul>\n<li>Collections.synchronizedCollection </li>\n<li>Collections.synchronizedList </li>\n<li>Collections.synchronizedMap </li>\n<li>Collections.synchronizedSet </li>\n<li>Collections.synchronizedNavigableMap </li>\n<li>Collections.synchronizedNavigableSet</li>\n<li>Collections.synchronizedSortedMap </li>\n<li>Collections.synchronizedSortedSet</li>\n</ul>\n</blockquote>\n<ol start=\"4\">\n<li>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent</li>\n</ol>\n<blockquote>\n<ul>\n<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li>\n<li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li>\n<li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul>\n<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>\n<li>弱一致性 <ul>\n<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li>\n<li>求大小弱一致性，size 操作未必是 100% 准确 </li>\n<li>读取弱一致性</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p>\n</blockquote>\n<h3 id=\"6-4-2、concurrentHashMap\"><a href=\"#6-4-2、concurrentHashMap\" class=\"headerlink\" title=\"6.4.2、concurrentHashMap\"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p>\n<p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p>\n<p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p>\n<blockquote>\n<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p>\n</blockquote>\n<p><strong>JDK1.8</strong></p>\n<p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p>\n<ol>\n<li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li>\n<li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li>\n<li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li>\n<li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li>\n</ol>\n<h3 id=\"6-4-3、BlockingQueue\"><a href=\"#6-4-3、BlockingQueue\" class=\"headerlink\" title=\"6.4.3、BlockingQueue\"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p>\n<ol>\n<li>区别</li>\n</ol>\n<p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；\tLinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p>\n<h3 id=\"6-4-4、ConcurrentLinkedQueue\"><a href=\"#6-4-4、ConcurrentLinkedQueue\" class=\"headerlink\" title=\"6.4.4、ConcurrentLinkedQueue\"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p>\n<h3 id=\"6-4-5、CopyOnWriteArrayList\"><a href=\"#6-4-5、CopyOnWriteArrayList\" class=\"headerlink\" title=\"6.4.5、CopyOnWriteArrayList\"></a>6.4.5、CopyOnWriteArrayList</h3><ol>\n<li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li>\n<li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li>\n<li>写操作结束后会把原数组指向新数组</li>\n<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>\n</ol>\n"},{"title":"nginx","date":"2023-07-14T16:00:00.000Z","abbrlink":58122,"_content":"# 1、nginx简介\n## 1.1、nginx概述\nNginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。\n## 1.2、正向代理\nnginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能\n正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【**代理客户端，服务端不知道实际发起请求的客户端**】\n> 例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色\n\n## 1.3、反向代理\n反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【**代理服务端，客户端不知道实际提供服务的服务端**】\n> 例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在\n\n## 1.4、负载均衡\n增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 \n## 1.5、动静分离\n为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力\n> 静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，**但是 tomcat 本身处理静态资源的效率并不高**，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 \n\n\n# 2、nginx安装\n\n1. **安装pcre依赖**\n\n（1）联网下载 pcre 压缩文件依赖：\n```shell\nwget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n```\n（2）解压压缩文件\n```shell\ntar –xvf pcre-8.37.tar.gz\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）查看\n```shell\npcre-config --version\n```\n\n2. **安装安装 openssl 、zlib 、 gcc 依赖**\n\n```shell\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n3. **安装nginx**\n\n（1）解压\n```shell\ntar -xvf nginx-1.12.2.tar.gz\n```\n（2）进入解压后目录，执行config命令\n```shell\n./configure\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）启动nginx\n```shell\n# 进入进入目录 /usr/local/nginx/sbin/nginx\n./nginx\n# 停止\n./nginx -s stop\n# 重启\n./nginx -s reload\n\n```\n\n# 3、nginx配置文件\nNginx配置文件分为三大块：全局块，events块，http块\n\n1. 从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等\n2. events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024\n3. http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等\n\n```shell\n\n#================ 全局快 ==================#\n#定义Nginx运行的用户和用户组\nuser  nginx;\n# 工作进程数，一般配置成和CPU数一样\nworker_processes  auto;\n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log  /var/log/nginx/error.log notice;\n#进程pid文件\npid        /var/run/nginx.pid;\n\n#=============== events块 ================#\nevents {\n    # 标识单个woker进程最大并发数\n    worker_connections  1024;\n}\n\n#=============== http块 =================#\nhttp {\n    #文件扩展名与文件类型映射表\n    include       /etc/nginx/mime.types;\n    #默认文件类型\n    default_type  application/octet-stream;\n    #日志格式设定\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #定义本虚拟主机的访问日志\n    access_log  /var/log/nginx/access.log  main;\n     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载\n    sendfile        on;\n    #长连接超时时间，单位是秒\n    keepalive_timeout  65;\n    #包括多个server块，而每个server块就相当于一个虚拟主机\n    server {\n          listen       80;\n          server_name  localhost;\n          # 对特定地址进行处理，地址定向\n          location / {\n              root   html;\n              index  index.html index.htm;\n          }\n  \n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   html;\n      }\n}\n```\n\n# 4、反向代理实现\n实现效果：输入 http://www.test.com, 自动跳转到百度首页\n\n\n```shell\nserver {\n         listen          80;\n         server_name     www.test.com;  #你的域名\n         location / {\n               proxy_pass          http://www.baidu.com/;  #需要反代的域名\n               proxy_redirect      off;\n               proxy_set_header    X-Real-IP      $remote_addr;\n               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n}\n\n```\n# 5、正向代理实现\n场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题\n场景2：内网机器访问外网，就需要正向代理，类似VPN\n```shell\nserver {\n\tlisten 8090;\n\t\n\tlocation / {\n    # resolver后面填写dns地址，可以多个，将以轮询方式请求\n\t\tresolver 218.85.157.99 218.85.152.99;\n    # resolver_timeout 解析超时时间\n\t\tresolver_timeout 30s;\n    # 代理服务器地址（即要请求的地址）\n\t\tproxy_pass http://$host$request_uri;\n\t}\n\taccess_log /data/httplogs/proxy-$host-aceess.log;\n}\n\n```\n# 6、负载均衡实现\n## 6.1、轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除\n```shell\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    upstream webservers{\n      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n \n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n             #转发到负载服务上\n            proxy_pass http://webservers/api/;\n         }\n    }\n}\n```\n## 6.2、weight\nweight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。\n```shell\n\n    upstream webservers{\n      server  192.168.9.134:8081 weight=8;\n      server  192.168.9.134:8082 weight=2;\n    }\n```\n## 6.3、ip_hash\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\n> 使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题\n\n```shell\n    upstream webservers{\n      ip_hash;\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n```\n## 6.4、fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```shell\nupstream webservers{\n        server 192.168.9.134:8081;\n        server 192.168.9.134:8082;\n        fair;\n}\n```\n## 6.5、url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n> 相同的url会被分配到同一个节点，主要为了提高缓存命中率\n\n```shell\nupstream webservers{\n    hash &request_uri;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n## 6.6、least_conn\n按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况\n```shell\nupstream webservers{\n    least_conn;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n# 7、动静分离\n利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能\n```shell\n#所有js,css相关的静态资源文件的请求由Nginx处理\nlocation ~.*\\.(js|css)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     12h; #过期时间为12小时\n}\n#所有图片等多媒体相关静态资源文件的请求由Nginx处理\nlocation ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     7d; #过期时间为7天\n}\n```\n","source":"_posts/Nginx.md","raw":"---\ntitle: nginx\ndate: 2023/07/15\ncategories:\n  - coding\ntags:\n  - nginx\nabbrlink: 58122\n---\n# 1、nginx简介\n## 1.1、nginx概述\nNginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。\n## 1.2、正向代理\nnginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能\n正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【**代理客户端，服务端不知道实际发起请求的客户端**】\n> 例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色\n\n## 1.3、反向代理\n反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【**代理服务端，客户端不知道实际提供服务的服务端**】\n> 例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在\n\n## 1.4、负载均衡\n增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 \n## 1.5、动静分离\n为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力\n> 静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，**但是 tomcat 本身处理静态资源的效率并不高**，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 \n\n\n# 2、nginx安装\n\n1. **安装pcre依赖**\n\n（1）联网下载 pcre 压缩文件依赖：\n```shell\nwget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz\n```\n（2）解压压缩文件\n```shell\ntar –xvf pcre-8.37.tar.gz\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）查看\n```shell\npcre-config --version\n```\n\n2. **安装安装 openssl 、zlib 、 gcc 依赖**\n\n```shell\nyum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel\n```\n\n3. **安装nginx**\n\n（1）解压\n```shell\ntar -xvf nginx-1.12.2.tar.gz\n```\n（2）进入解压后目录，执行config命令\n```shell\n./configure\n```\n（3）编译\n```shell\nmake && make install\n```\n（4）启动nginx\n```shell\n# 进入进入目录 /usr/local/nginx/sbin/nginx\n./nginx\n# 停止\n./nginx -s stop\n# 重启\n./nginx -s reload\n\n```\n\n# 3、nginx配置文件\nNginx配置文件分为三大块：全局块，events块，http块\n\n1. 从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等\n2. events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024\n3. http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等\n\n```shell\n\n#================ 全局快 ==================#\n#定义Nginx运行的用户和用户组\nuser  nginx;\n# 工作进程数，一般配置成和CPU数一样\nworker_processes  auto;\n#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]\nerror_log  /var/log/nginx/error.log notice;\n#进程pid文件\npid        /var/run/nginx.pid;\n\n#=============== events块 ================#\nevents {\n    # 标识单个woker进程最大并发数\n    worker_connections  1024;\n}\n\n#=============== http块 =================#\nhttp {\n    #文件扩展名与文件类型映射表\n    include       /etc/nginx/mime.types;\n    #默认文件类型\n    default_type  application/octet-stream;\n    #日志格式设定\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    #定义本虚拟主机的访问日志\n    access_log  /var/log/nginx/access.log  main;\n     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载\n    sendfile        on;\n    #长连接超时时间，单位是秒\n    keepalive_timeout  65;\n    #包括多个server块，而每个server块就相当于一个虚拟主机\n    server {\n          listen       80;\n          server_name  localhost;\n          # 对特定地址进行处理，地址定向\n          location / {\n              root   html;\n              index  index.html index.htm;\n          }\n  \n          error_page   500 502 503 504  /50x.html;\n          location = /50x.html {\n              root   html;\n      }\n}\n```\n\n# 4、反向代理实现\n实现效果：输入 http://www.test.com, 自动跳转到百度首页\n\n\n```shell\nserver {\n         listen          80;\n         server_name     www.test.com;  #你的域名\n         location / {\n               proxy_pass          http://www.baidu.com/;  #需要反代的域名\n               proxy_redirect      off;\n               proxy_set_header    X-Real-IP      $remote_addr;\n               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;\n        }\n}\n\n```\n# 5、正向代理实现\n场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题\n场景2：内网机器访问外网，就需要正向代理，类似VPN\n```shell\nserver {\n\tlisten 8090;\n\t\n\tlocation / {\n    # resolver后面填写dns地址，可以多个，将以轮询方式请求\n\t\tresolver 218.85.157.99 218.85.152.99;\n    # resolver_timeout 解析超时时间\n\t\tresolver_timeout 30s;\n    # 代理服务器地址（即要请求的地址）\n\t\tproxy_pass http://$host$request_uri;\n\t}\n\taccess_log /data/httplogs/proxy-$host-aceess.log;\n}\n\n```\n# 6、负载均衡实现\n## 6.1、轮询（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除\n```shell\n\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n    sendfile        on;\n    keepalive_timeout  65;\n    upstream webservers{\n      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n \n    server {\n        listen       80;\n        server_name  localhost;\n\n        location / {\n             #转发到负载服务上\n            proxy_pass http://webservers/api/;\n         }\n    }\n}\n```\n## 6.2、weight\nweight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。\n```shell\n\n    upstream webservers{\n      server  192.168.9.134:8081 weight=8;\n      server  192.168.9.134:8082 weight=2;\n    }\n```\n## 6.3、ip_hash\n每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器\n> 使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题\n\n```shell\n    upstream webservers{\n      ip_hash;\n      server  192.168.9.134:8081;\n      server  192.168.9.134:8082;\n    }\n```\n## 6.4、fair\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n```shell\nupstream webservers{\n        server 192.168.9.134:8081;\n        server 192.168.9.134:8082;\n        fair;\n}\n```\n## 6.5、url_hash\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n> 相同的url会被分配到同一个节点，主要为了提高缓存命中率\n\n```shell\nupstream webservers{\n    hash &request_uri;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n## 6.6、least_conn\n按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况\n```shell\nupstream webservers{\n    least_conn;\n    server 192.168.9.134:8081;\n    server 192.168.9.134:8082;\n}\n```\n# 7、动静分离\n利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能\n```shell\n#所有js,css相关的静态资源文件的请求由Nginx处理\nlocation ~.*\\.(js|css)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     12h; #过期时间为12小时\n}\n#所有图片等多媒体相关静态资源文件的请求由Nginx处理\nlocation ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ {\n    root    /opt/static-resources; #指定文件路径\n    expires     7d; #过期时间为7天\n}\n```\n","slug":"Nginx","published":1,"updated":"2023-07-25T13:19:14.796Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9g000300uj34a2gxpq","content":"<h1 id=\"1、nginx简介\"><a href=\"#1、nginx简介\" class=\"headerlink\" title=\"1、nginx简介\"></a>1、nginx简介</h1><h2 id=\"1-1、nginx概述\"><a href=\"#1-1、nginx概述\" class=\"headerlink\" title=\"1.1、nginx概述\"></a>1.1、nginx概述</h2><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。</p>\n<h2 id=\"1-2、正向代理\"><a href=\"#1-2、正向代理\" class=\"headerlink\" title=\"1.2、正向代理\"></a>1.2、正向代理</h2><p>nginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能<br>正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【<strong>代理客户端，服务端不知道实际发起请求的客户端</strong>】</p>\n<blockquote>\n<p>例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色</p>\n</blockquote>\n<h2 id=\"1-3、反向代理\"><a href=\"#1-3、反向代理\" class=\"headerlink\" title=\"1.3、反向代理\"></a>1.3、反向代理</h2><p>反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【<strong>代理服务端，客户端不知道实际提供服务的服务端</strong>】</p>\n<blockquote>\n<p>例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在</p>\n</blockquote>\n<h2 id=\"1-4、负载均衡\"><a href=\"#1-4、负载均衡\" class=\"headerlink\" title=\"1.4、负载均衡\"></a>1.4、负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 </p>\n<h2 id=\"1-5、动静分离\"><a href=\"#1-5、动静分离\" class=\"headerlink\" title=\"1.5、动静分离\"></a>1.5、动静分离</h2><p>为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p>\n<blockquote>\n<p>静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，<strong>但是 tomcat 本身处理静态资源的效率并不高</strong>，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 </p>\n</blockquote>\n<h1 id=\"2、nginx安装\"><a href=\"#2、nginx安装\" class=\"headerlink\" title=\"2、nginx安装\"></a>2、nginx安装</h1><ol>\n<li><strong>安装pcre依赖</strong></li>\n</ol>\n<p>（1）联网下载 pcre 压缩文件依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）解压压缩文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar –xvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcre-config --version</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>安装安装 openssl 、zlib 、 gcc 依赖</strong></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>安装nginx</strong></li>\n</ol>\n<p>（1）解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）进入解压后目录，执行config命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入进入目录 /usr/local/nginx/sbin/nginx</span></span><br><span class=\"line\">./nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止</span></span><br><span class=\"line\">./nginx -s stop</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">./nginx -s reload</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、nginx配置文件\"><a href=\"#3、nginx配置文件\" class=\"headerlink\" title=\"3、nginx配置文件\"></a>3、nginx配置文件</h1><p>Nginx配置文件分为三大块：全局块，events块，http块</p>\n<ol>\n<li>从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等</li>\n<li>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024</li>\n<li>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">================ 全局快 ==================<span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">定义Nginx运行的用户和用户组</span></span><br><span class=\"line\">user  nginx;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作进程数，一般配置成和CPU数一样</span></span><br><span class=\"line\">worker_processes  auto;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class=\"line\">error_log  /var/log/nginx/error.log notice;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">进程pid文件</span></span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== events块 ================<span class=\"comment\">#</span></span></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 标识单个woker进程最大并发数</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== http块 =================<span class=\"comment\">#</span></span></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    #文件扩展名与文件类型映射表</span><br><span class=\"line\">    include       /etc/nginx/mime.types;</span><br><span class=\"line\">    #默认文件类型</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    #日志格式设定</span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\">    #定义本虚拟主机的访问日志</span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\">     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #长连接超时时间，单位是秒</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    #包括多个server块，而每个server块就相当于一个虚拟主机</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">          listen       80;</span><br><span class=\"line\">          server_name  localhost;</span><br><span class=\"line\">          # 对特定地址进行处理，地址定向</span><br><span class=\"line\">          location / &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">              index  index.html index.htm;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">          location = /50x.html &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、反向代理实现\"><a href=\"#4、反向代理实现\" class=\"headerlink\" title=\"4、反向代理实现\"></a>4、反向代理实现</h1><p>实现效果：输入 <a href=\"http://www.test.com/\">http://www.test.com</a>, 自动跳转到百度首页</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">         listen          80;</span><br><span class=\"line\">         server_name     www.test.com;  #你的域名</span><br><span class=\"line\">         location / &#123;</span><br><span class=\"line\">               proxy_pass          http://www.baidu.com/;  #需要反代的域名</span><br><span class=\"line\">               proxy_redirect      off;</span><br><span class=\"line\">               proxy_set_header    X-Real-IP      $remote_addr;</span><br><span class=\"line\">               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"5、正向代理实现\"><a href=\"#5、正向代理实现\" class=\"headerlink\" title=\"5、正向代理实现\"></a>5、正向代理实现</h1><p>场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题<br>场景2：内网机器访问外网，就需要正向代理，类似VPN</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 8090;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">    # resolver后面填写dns地址，可以多个，将以轮询方式请求</span><br><span class=\"line\">\t\tresolver 218.85.157.99 218.85.152.99;</span><br><span class=\"line\">    # resolver_timeout 解析超时时间</span><br><span class=\"line\">\t\tresolver_timeout 30s;</span><br><span class=\"line\">    # 代理服务器地址（即要请求的地址）</span><br><span class=\"line\">\t\tproxy_pass http://$host$request_uri;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taccess_log /data/httplogs/proxy-$host-aceess.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、负载均衡实现\"><a href=\"#6、负载均衡实现\" class=\"headerlink\" title=\"6、负载均衡实现\"></a>6、负载均衡实现</h1><h2 id=\"6-1、轮询（默认）\"><a href=\"#6-1、轮询（默认）\" class=\"headerlink\" title=\"6.1、轮询（默认）\"></a>6.1、轮询（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    upstream webservers&#123;</span><br><span class=\"line\">      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问</span><br><span class=\"line\">      server  192.168.9.134:8081;</span><br><span class=\"line\">      server  192.168.9.134:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">             #转发到负载服务上</span><br><span class=\"line\">            proxy_pass http://webservers/api/;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2、weight\"><a href=\"#6-2、weight\" class=\"headerlink\" title=\"6.2、weight\"></a>6.2、weight</h2><p>weight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  server  192.168.9.134:8081 weight=8;</span><br><span class=\"line\">  server  192.168.9.134:8082 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3、ip-hash\"><a href=\"#6-3、ip-hash\" class=\"headerlink\" title=\"6.3、ip_hash\"></a>6.3、ip_hash</h2><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>\n<blockquote>\n<p>使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server  192.168.9.134:8081;</span><br><span class=\"line\">  server  192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-4、fair\"><a href=\"#6-4、fair\" class=\"headerlink\" title=\"6.4、fair\"></a>6.4、fair</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">        server 192.168.9.134:8081;</span><br><span class=\"line\">        server 192.168.9.134:8082;</span><br><span class=\"line\">        fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、url-hash\"><a href=\"#6-5、url-hash\" class=\"headerlink\" title=\"6.5、url_hash\"></a>6.5、url_hash</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<blockquote>\n<p>相同的url会被分配到同一个节点，主要为了提高缓存命中率</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    hash &amp;request_uri;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-6、least-conn\"><a href=\"#6-6、least-conn\" class=\"headerlink\" title=\"6.6、least_conn\"></a>6.6、least_conn</h2><p>按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、动静分离\"><a href=\"#7、动静分离\" class=\"headerlink\" title=\"7、动静分离\"></a>7、动静分离</h1><p>利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有js,css相关的静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(js|css)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     12h; #过期时间为12小时</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有图片等多媒体相关静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     7d; #过期时间为7天</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、nginx简介\"><a href=\"#1、nginx简介\" class=\"headerlink\" title=\"1、nginx简介\"></a>1、nginx简介</h1><h2 id=\"1-1、nginx概述\"><a href=\"#1-1、nginx概述\" class=\"headerlink\" title=\"1.1、nginx概述\"></a>1.1、nginx概述</h2><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。</p>\n<h2 id=\"1-2、正向代理\"><a href=\"#1-2、正向代理\" class=\"headerlink\" title=\"1.2、正向代理\"></a>1.2、正向代理</h2><p>nginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能<br>正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【<strong>代理客户端，服务端不知道实际发起请求的客户端</strong>】</p>\n<blockquote>\n<p>例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色</p>\n</blockquote>\n<h2 id=\"1-3、反向代理\"><a href=\"#1-3、反向代理\" class=\"headerlink\" title=\"1.3、反向代理\"></a>1.3、反向代理</h2><p>反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【<strong>代理服务端，客户端不知道实际提供服务的服务端</strong>】</p>\n<blockquote>\n<p>例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在</p>\n</blockquote>\n<h2 id=\"1-4、负载均衡\"><a href=\"#1-4、负载均衡\" class=\"headerlink\" title=\"1.4、负载均衡\"></a>1.4、负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 </p>\n<h2 id=\"1-5、动静分离\"><a href=\"#1-5、动静分离\" class=\"headerlink\" title=\"1.5、动静分离\"></a>1.5、动静分离</h2><p>为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p>\n<blockquote>\n<p>静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，<strong>但是 tomcat 本身处理静态资源的效率并不高</strong>，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 </p>\n</blockquote>\n<h1 id=\"2、nginx安装\"><a href=\"#2、nginx安装\" class=\"headerlink\" title=\"2、nginx安装\"></a>2、nginx安装</h1><ol>\n<li><strong>安装pcre依赖</strong></li>\n</ol>\n<p>（1）联网下载 pcre 压缩文件依赖：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）解压压缩文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar –xvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）查看</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pcre-config --version</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>安装安装 openssl 、zlib 、 gcc 依赖</strong></li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>安装nginx</strong></li>\n</ol>\n<p>（1）解压</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tar -xvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure>\n<p>（2）进入解压后目录，执行config命令</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./configure</span><br></pre></td></tr></table></figure>\n<p>（3）编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>\n<p>（4）启动nginx</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">进入进入目录 /usr/local/nginx/sbin/nginx</span></span><br><span class=\"line\">./nginx</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">停止</span></span><br><span class=\"line\">./nginx -s stop</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">重启</span></span><br><span class=\"line\">./nginx -s reload</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、nginx配置文件\"><a href=\"#3、nginx配置文件\" class=\"headerlink\" title=\"3、nginx配置文件\"></a>3、nginx配置文件</h1><p>Nginx配置文件分为三大块：全局块，events块，http块</p>\n<ol>\n<li>从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等</li>\n<li>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024</li>\n<li>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">================ 全局快 ==================<span class=\"comment\">#</span></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">定义Nginx运行的用户和用户组</span></span><br><span class=\"line\">user  nginx;</span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">工作进程数，一般配置成和CPU数一样</span></span><br><span class=\"line\">worker_processes  auto;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class=\"line\">error_log  /var/log/nginx/error.log notice;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">进程pid文件</span></span><br><span class=\"line\">pid        /var/run/nginx.pid;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== events块 ================<span class=\"comment\">#</span></span></span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">    # 标识单个woker进程最大并发数</span><br><span class=\"line\">    worker_connections  1024;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">=============== http块 =================<span class=\"comment\">#</span></span></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    #文件扩展名与文件类型映射表</span><br><span class=\"line\">    include       /etc/nginx/mime.types;</span><br><span class=\"line\">    #默认文件类型</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    #日志格式设定</span><br><span class=\"line\">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class=\"line\">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class=\"line\">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class=\"line\">    #定义本虚拟主机的访问日志</span><br><span class=\"line\">    access_log  /var/log/nginx/access.log  main;</span><br><span class=\"line\">     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    #长连接超时时间，单位是秒</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    #包括多个server块，而每个server块就相当于一个虚拟主机</span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">          listen       80;</span><br><span class=\"line\">          server_name  localhost;</span><br><span class=\"line\">          # 对特定地址进行处理，地址定向</span><br><span class=\"line\">          location / &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">              index  index.html index.htm;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">          error_page   500 502 503 504  /50x.html;</span><br><span class=\"line\">          location = /50x.html &#123;</span><br><span class=\"line\">              root   html;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、反向代理实现\"><a href=\"#4、反向代理实现\" class=\"headerlink\" title=\"4、反向代理实现\"></a>4、反向代理实现</h1><p>实现效果：输入 <a href=\"http://www.test.com/\">http://www.test.com</a>, 自动跳转到百度首页</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">         listen          80;</span><br><span class=\"line\">         server_name     www.test.com;  #你的域名</span><br><span class=\"line\">         location / &#123;</span><br><span class=\"line\">               proxy_pass          http://www.baidu.com/;  #需要反代的域名</span><br><span class=\"line\">               proxy_redirect      off;</span><br><span class=\"line\">               proxy_set_header    X-Real-IP      $remote_addr;</span><br><span class=\"line\">               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"5、正向代理实现\"><a href=\"#5、正向代理实现\" class=\"headerlink\" title=\"5、正向代理实现\"></a>5、正向代理实现</h1><p>场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题<br>场景2：内网机器访问外网，就需要正向代理，类似VPN</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">\tlisten 8090;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tlocation / &#123;</span><br><span class=\"line\">    # resolver后面填写dns地址，可以多个，将以轮询方式请求</span><br><span class=\"line\">\t\tresolver 218.85.157.99 218.85.152.99;</span><br><span class=\"line\">    # resolver_timeout 解析超时时间</span><br><span class=\"line\">\t\tresolver_timeout 30s;</span><br><span class=\"line\">    # 代理服务器地址（即要请求的地址）</span><br><span class=\"line\">\t\tproxy_pass http://$host$request_uri;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\taccess_log /data/httplogs/proxy-$host-aceess.log;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、负载均衡实现\"><a href=\"#6、负载均衡实现\" class=\"headerlink\" title=\"6、负载均衡实现\"></a>6、负载均衡实现</h1><h2 id=\"6-1、轮询（默认）\"><a href=\"#6-1、轮询（默认）\" class=\"headerlink\" title=\"6.1、轮询（默认）\"></a>6.1、轮询（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">    include       mime.types;</span><br><span class=\"line\">    default_type  application/octet-stream;</span><br><span class=\"line\">    sendfile        on;</span><br><span class=\"line\">    keepalive_timeout  65;</span><br><span class=\"line\">    upstream webservers&#123;</span><br><span class=\"line\">      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问</span><br><span class=\"line\">      server  192.168.9.134:8081;</span><br><span class=\"line\">      server  192.168.9.134:8082;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">             #转发到负载服务上</span><br><span class=\"line\">            proxy_pass http://webservers/api/;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-2、weight\"><a href=\"#6-2、weight\" class=\"headerlink\" title=\"6.2、weight\"></a>6.2、weight</h2><p>weight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  server  192.168.9.134:8081 weight=8;</span><br><span class=\"line\">  server  192.168.9.134:8082 weight=2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-3、ip-hash\"><a href=\"#6-3、ip-hash\" class=\"headerlink\" title=\"6.3、ip_hash\"></a>6.3、ip_hash</h2><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p>\n<blockquote>\n<p>使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">  ip_hash;</span><br><span class=\"line\">  server  192.168.9.134:8081;</span><br><span class=\"line\">  server  192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-4、fair\"><a href=\"#6-4、fair\" class=\"headerlink\" title=\"6.4、fair\"></a>6.4、fair</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">        server 192.168.9.134:8081;</span><br><span class=\"line\">        server 192.168.9.134:8082;</span><br><span class=\"line\">        fair;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、url-hash\"><a href=\"#6-5、url-hash\" class=\"headerlink\" title=\"6.5、url_hash\"></a>6.5、url_hash</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<blockquote>\n<p>相同的url会被分配到同一个节点，主要为了提高缓存命中率</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    hash &amp;request_uri;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-6、least-conn\"><a href=\"#6-6、least-conn\" class=\"headerlink\" title=\"6.6、least_conn\"></a>6.6、least_conn</h2><p>按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream webservers&#123;</span><br><span class=\"line\">    least_conn;</span><br><span class=\"line\">    server 192.168.9.134:8081;</span><br><span class=\"line\">    server 192.168.9.134:8082;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、动静分离\"><a href=\"#7、动静分离\" class=\"headerlink\" title=\"7、动静分离\"></a>7、动静分离</h1><p>利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有js,css相关的静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(js|css)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     12h; #过期时间为12小时</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta prompt_\">#</span><span class=\"language-bash\">所有图片等多媒体相关静态资源文件的请求由Nginx处理</span></span><br><span class=\"line\">location ~.*\\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ &#123;</span><br><span class=\"line\">    root    /opt/static-resources; #指定文件路径</span><br><span class=\"line\">    expires     7d; #过期时间为7天</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"java core","date":"2023-08-21T16:00:00.000Z","_content":"#  1、Java概述\n## 1.1、java特点\n\n1. Java 语言是面向对象的(oop) \n2. Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证\n3. Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]\n4. java是一种半编译，半解释型语言。 . Java-->. class是由 Javac 编译，这个过程符合编译型语言的特点。而. class-->对应平台机器码 的这一过程 是由Java解释执行 \n# 2、变量\n## 2.1、java基本数据类型\njava基本数据类型 - 四类八种\n\n1. **整型**\n\nbyte 、short 、int 、long\n\n2. **浮点型**\n\nfloat 、 double\n\n3. **字符型**\n\nchar\n\n4. **布尔型**\n\nboolean\n\n| 数据类型名称 | 占用字节 | 范围 | 封装器类 |\n| --- | --- | --- | --- |\n| byte（字节型） | 1 | -（2^7）~2^7-1（-128~127） | Byte |\n| shot（短整型） | 2 | -（2^15）~2^15-1(-32768~32767) | Short |\n| int（整形） | 4 | -（2^31）~2^31-1（-2147483648~2147483647） | Integer |\n| long（长整型） | 8 | -（2^63）~2^63-1 | Long |\n| float（浮点型） | 4 | -3.403E8~3.403E38 | Float |\n| double（双精度浮点型） | 8 | -1.798E308~1.798E308 | Double |\n| boolean（布尔型） | 1 |  | Boolean |\n| char（字符型） | 2 |  | **Character** |\n\n> 注意：计算机的数值是用二进制补码表示的，二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1\n\n\n## 2.2、基本数据类型转换\n### 2.2.1、自动类型转换\n\n当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换\n精度由小到大排序：\n\nbyte short int long float double\n\n```java\n//自动类型转换细节\npublic class AutoConvertDetail {\n    public static void main(String[] args) {\n    //细节 1： 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算\n    int n1 = 10; //ok\n    float d1 = n1 + 1.1;//错误 n1 + 1.1 => 结果类型是 double\n    double d1 = n1 + 1.1;//对 n1 + 1.1 => 结果类型是 double\n    float d1 = n1 + 1.1F;//对 n1 + 1.1 => 结果类型是 float\n    //细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，就会报错，反之就会进行自动类型转换。\n    int n2 = 1.1;//错误 double -> int\n    //细节 3: (byte, short) 和 char 之间不会相互自动转换\n     byte b1 = 10; //对 , -128-127\n     char c1 = b1; //错误， 原因 byte 不能自动转成 char\n    //细节 4：自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型\n    byte b4 = 1;\n    short s3 = 100;\n    int num200 = 1;\n    float num300 = 1.1F;\n    float num500 = b4 + s3 + num200 + num300; \n}\n```\n\n>floatf=3.4;是否正确？\n不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换floatf=(float)3.4;或者写成floatf=3.4F;\n\n### 2.2.2、强制类型转换\n\n将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符( )，但可能造成精度降低或溢出,格外要注意。\n\n### 2.2.3、基本数据类型和String转换\n\n1. 基本数据类型转String类型\n\n（1）将基本类型的值加 \"\" 即可\n（2）String.valueOf(基本数据类型)\n\n2. String转基本数据类型\n\n（1）基本类型包装类调用parseXX方法即可\n\n# 3、运算符\n## 4.1、算数运算符\n算数运算符是对数值变量进行运算的，在java程序种使用非常多\n\n![java算数运算符](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231601761.png)\n\n\n```java\n// 题目1\nint i = 1;\ni = i++; // 规则会使用临时变量(1)temp=i(2)i=i+1(3)i=temp\nSystem.out.println(i); // 1\n\n// 题目2\nint i = 1;\ni = ++i; // 规则会使用临时变量(1)i=i+1(2)temp=i(3)i=temp\nSystem.out.println(i); // 2\n\n```\n## 4.2、关系运算符\n\n关系运算符的结果都是boolean型，也就是要么是true，要么是false\n\n![java关系运算符](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231605071.png)\n\n\n## 4.3、逻辑运算符\n\n用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值\n\n![逻辑运算符](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231608353.png)\n\n\n>   a^b: 叫逻辑异或  ：当 a 和 b 不同时，则结果为 true, 否则为 false  \n>   &&短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高\n>   & 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低  \n\n## 4.4、赋值运算符\n\n基本赋值运算符 = （ int a = 10;） \n复合赋值运算符 += ，-= ，*= ， /= ，%= 等\n\n## 4.5、三元运算符\n条件表达式 ? 表达式 1: 表达式 2; \n\n1. 如果条件表达式为 true，运算后的结果是表达式 1；\n2. 如果条件表达式为 false，运算后的结果是表达式 2；\n\n## 4.6、进制转换（为位运算准备）\n\n对于整数，有四种表示方式：\n二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。\n十进制：0-9 ，满 10 进 1。\n八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。\n十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写\n\n![进制转换](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231612057.png)\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1659315826387-ed7e7bab-8366-4fd2-8353-b82acde62fa2.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=243&id=uc4b6c469&originHeight=470&originWidth=664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126331&status=done&style=none&taskId=u69461551-0d4d-415e-bdd3-fb02621b29f&title=&width=343)\n\n### 4.6.1、其它进制转十进制\n\n1. 二进制转十进制\n\n规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和\n\n> 案例：将ob1011转成十进制数\n> 1+2+8=11\n\n\n2. 八进制转十进制\n\n规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和\n\n> 案例：0234转成十进制\n> 4\\*1+3\\*8+2\\*64=156\n\n\n3. 十六进制转十进制\n\n规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和\n\n> 案例：0x23A\n> 10\\*1+3\\*16+2\\*512=570\n\n\n### 4.6.2、十进制转其他进制\n\n1. 十进制转二进制\n\n规则：将该数不断除以2.直到商为0为止，然后将每步余数倒过来，就是对应二进制\n\n> 案例：34转为对应二进制 = 0B00100010\n\n![十进制转二进制](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231618617.png)\n\n\n2. 十进制转八进制\n\n规则：将该数不断除以8.直到商为0为止，然后将每步余数倒过来，就是对应二进制\n\n> 案例：131转为8进制\n\n![十进制转八进制](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231620590.png)\n\n\n\n### 4.6.3、二进制转其它进制\n\n1. 二进制转八进制\n\n规则：从低位开始，将二进制数每三位一组，转成对应的八进制\n\n> 案例：0b11010101转成八进制\n> 0325\n\n\n2. 二进制转十六进制\n\n规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可\n\n> 案例：0b11010101转成十六进制\n> D5\n\n### 4.6.4、其它进制转二进制\n\n1. 八进制转二进制\n\n规则：将八进制数每1位。转成对应的一个3位的二进制数即可\n\n> 案例：将0237转成二进制\n> 0b10011111\n\n2. 十六进制转二进制\n\n规则：将十六进制数每1位。转成对应的一个4位的二进制数即可\n\n> 案例：请将0x23B转成二进制\n> 0b001000111011\n\n## 4.7、位运算符\n### 4.6.1、原码反码补码\n\n1. 进制的最高位是符号位: 0表示正数1表示负数\n2. 正数的原码，反码，补码都一样\n3. 负数的反码=它的原码符号位不变，其它位取反.负数的补码=它的反码+1\n4. 0的反码，补码都是0\n5. 在计算机运算的时候，都是以补码的方式来运算的\n6. 补码的补码就是原码\n\n> 为什么计算机通过补码进行运算？\n> 通过使用补码，无需单独的符号位判断来执行加法和减法运算。计算机可以直接对补码进行位运算，而不需要额外的逻辑电路来处理符号位\n\n### 4.6.2、位运算\n\njava种有7个位运算 &（按位与）,|（按位或）,^（按位异或）,~（按位取反），<<（左移），>>（带符号右移），>>>（无符号右移）\n\n#### 4.6.2.1、& （按位与）\n\n两位全为1，结果为1，否则为0\n\n```asciidoc\n  10  (2)\n& 11  (3)\n------\n  10  (2)\n```\n\n#### 4.6.2.2、|（按位或）\n\n两位一个为1，结果为1，否则为0\n\n```asciidoc\n  10  (2)\n| 11  (3)\n------\n  11  (3)\n```\n\n#### 4.6.2.3、 ^（按位异或）\n\n两位一个为0，结果为1，否则为0\n\n```asciidoc\n  10  (2)\n^ 11  (3)\n------\n  01  (1)\n```\n\n\n#### 4.6.2.4、~（按位取反）\n\n0->1, 1->0\n\n```asciidoc\n~2 \n原码：00000010\n按位取反：11111101\n补码表示：10000011 = 3\n```\n\n#### 4.6.2.5、>>（算数右移）\n\n低位溢出，符号位不变，并用符号位补溢出的高位\n\n```asciidoc\n1 >> 2\n1的补码：00000001\n右移两位，并用符号位填充：00000000\n原码结果为：0\n\n-1 >> 2\n-1的补码：11111111\n右移两位，并用符号位填充：11111111\n原码结果为：100000001 = -1\n```\n\n#### 4.6.2.6、>> （算数左移）\n\n符号位不变，低位补0\n\n```asciidoc\n1 << 2\n0001 << 2 = 0100 = 4\n\n-1 << 3\n11111111 << 3 = 11111000\n原码结果为：10001000 = -8\n```\n\n#### 4.6.2.7、>>> （逻辑右移 或叫 无符号右移）\n\n低位溢出，高位补0\n\n```asciidoc\n8 >>> 2\n1000 >>> 2 = 0010 = 2\n```\n\n# 4、面向对象\n## 4.1、面向对象三大特征\n### 4.1.1、封装\n\n**封装**：尽量避免向外部暴露实现细节，只提供个别接口让使用方调用，降低耦合性。这样做的话，当自身的逻辑发生变化时，不会破坏使用方的逻辑，或是强制使用方修改自身的逻辑，而是只需要修改自身的代码就可以了\n### 4.1.2、继承\n\n**继承**：子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法。以降低代码编写的冗余度\n### 4.1.3、多态\n\n**多态**：父类的引用指向子类的对象。它的意义是可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，而这些方法通过一个抽象类或者接口来实现，多态就是提供父类调用子类代码的一个手段而已\n\n## 4.2、内部类\n\n如果定义类在局部位置(方法中/代码块) :(1) 局部内部类 (2) 匿名内部类 \n如果定义在成员位置 (1) 成员内部类 (2) 静态内部类  \n### 4.2.1、局部内部类\n\n局部内部类是定义在外部类的局部位置，比如方法中，并且有类名数据\n\n> 说明：\n> 1. 可以直接访问外部类的所有成员，包括私有\n> 2. 不能添加访问修饰符，因为他就是一个局部变量，局部变量不能使用修饰符\n> 3. 作用域：仅在定义它的方法或代码块中\n> 4. 局部内部类访问外部类的成员：直接访问。外部类访问局部内部类的成员，创建对象再访问\n\n```java\npublic class OuterClass {\n    private int outerData = 10;\n\n    public void outerMethod() {\n        int localVar = 5;\n        class LocalInnerClass {\n            public void innerMethod() {\n                System.out.println(\"访问外部类数据：\" + outerData);\n                System.out.println(\"访问局部变量：\" + localVar);\n            }\n        }\n        LocalInnerClass innerObj = new LocalInnerClass();\n        innerObj.innerMethod();\n    }\n\n    public static void main(String[] args) {\n        OuterClass outerObj = new OuterClass();\n        outerObj.outerMethod();\n    }\n}\n```\n### 4.2.2、匿名内部类\n\n匿名内部类是一种没有显式定义类名的内部类，定义在外部类的局部位置，比如方法中，它通常用于创建实现某个接口或继承某个类的匿名对象\n\n> 说明：\n> 1. 匿名内部类运行类型：外部类名称$1\n\n\n1. 基于接口的匿名内部类\n\n```java\ninterface IA{\n    void cry();\n}\n\nclass Outer {\n\tpublic void sayHello() {\n\t\t// 编译类型为IA，运行类型为匿名内部类Outer$1\n       // jdk 底层在创建匿名内部类 Outer$1,立即马上就创建了 Outer$1 实例，并且把地址返回给 tiger\n\t    IA tiger = new IA() {\n\t        @Override public void cry() { \n\t            System.out.println(\"老虎叫...\"); \n\t        } \n\t    };\n\t}\n}\n```\n\n2. 基于类的匿名内部类\n\n```java\nclass Father {\n    public void test(){}\n}\n\nclass Outer{\n\tpublic void sayHello() {\n\t\t// father 编译类型 Father, father 运行类型 Outer$1\n\t    Father father = new Father(\"jack\"){\n\t        @Override\n\t        public void test() {\n\t            System.out.println(\"匿名内部类重写了 test 方法\");\n\t        }\n\t    };\n\t}\n    \n}\n```\n\n\n### 4.2.3、成员内部类\n\n成员内部类是定义在外部类的成员位置，并且没有static修饰\n\n> 说明：\n> 1. 可以直接访问外部类的所有成员，包括私有的\n> 2. 可以添加任何修饰符，因为它的地位就是一个成员\n\n```java\npublic static void main(String[] args) {\n    Outer08.Inner08 inner08Instance = outer08.getInner08Instance();\n    inner08Instance.say();\n}\n\nclass Outer08 { //外部类\n    public class Inner08 {//成员内部类\n        public void say() {\n            //可以直接访问外部类的所有成员，包含私有的\n            //如果成员内部类的成员和外部类的成员重名，会遵守就近原则. \n            //可以通过 外部类名.this.属性 来访问外部类的成员\n            System.out.println(\"n1 = \" + n1 + \" name = \" + name + \" 外部类的 n1=\" + Outer08.this.n1);\n            hi();\n        }\n    }    \n}\n```\n### 4.2.4、静态内部类\n\n成员内部类是定义再外部类的成员位置，有static修饰\n\n```java\npublic static void main(String[] args) {\n    Outer10.Inner10 inner10 = new Outer10.Inner10();\n    inner10.say();\n}\nclass Outer10 { //外部类\n    static class Inner10 {\n        private static String name = \"卡卡\";\n        public void say() {\n            cry();\n        }\n    }\n}\n```\n\n## 4.3、重载和重写\n\n**重载**发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载\n**重写**，子类重写父类方法，返回值（JDK7以后，被重写的方法返回值类型可以不同，但是必须是父类返回值的派生类）和形参都不能改变\n\n> 不能根据返回类型来区分重载\n> float max(int a, int b);\n> int max(int a, int b);\n> 上面两个方法名称和参数都一致，如果在同一个类中，别的地方调用的时候都是max（1，2），不能区分出想调用哪个方法\n\n## 4.4、抽象类和接口\n\n1、接口的设计目的，是对类的行为进行约束。也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制\n2、而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为。可以在抽象类中实现这种行为。这样它所有的子类就无需重复实现。达到代码复用的目的\n\n## 4.5、Object类常用方法\n\n1. hashcode（）：将对象的16进制地址值，经过hash算法换算成整值\n2. toString（）：返回该对象的字符串对象\n3. equals（）：比较两个对象的地址值是否相同\n4. clone（）：实现对象的浅拷贝\n5. getclass（）：获取该对象的字节码文件（该对象运行时的类）Class\n6. wait（）notify（）notifyAll（）：wait（）让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法\n\n> void notify()：唤醒一个正在等待该对象的线程。\n  void notifyAll()：唤醒所有正在等待该对象的线程\n\n> 1. equals()没有被重写的情况下等同于 ==\n  Object的equals()方法源码：\n    public boolean equals(Object obj) {\n        return (this == obj);\n    }\n  这用情况= =和equals（）都是引用比较 \n  2. string重写了Object的equals（）方法这种情况equals（）是值比较\n\n## 4.6、深拷贝和浅拷贝\n**浅拷贝**：基本数据类型复制值，引用数据类型复制地址，即拷贝出来的对象与被拷贝出来的对象中的引用的对象是同一个（java默认）：clone方法\n**深拷贝**：基本数据类型复制值，引用数据类型，创建一个新的对象，并复制其内容\n\n```java\n// 使用对象序列化来实现克隆\npublic class Room implements Serializable {\n    Desk desk;\n \n    public Room deepClone() throws Exception{\n        //序列化\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);\n        objectOutputStream.writeObject(this);\n        //反序列化\n        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());\n        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);\n        Room roomClone = (Room)objectInputStream.readObject();\n        return roomClone;\n        \n    }\n}\n```\n\n\n## 4.7、面向对象和面向过程的理解\n\n是两种不同的处理问题的角度。面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做什么\n\n> 比如：洗衣机洗衣服\n  **面向过程**：会将任务拆解成一系列的步骤（函数），1、打开洗衣机 2、放衣服3、放洗衣粉4、清洗 5、烘干\n  **面向对象**：会拆出人和洗衣机两个对象：人：打开洗衣机，放衣服，放洗衣粉 洗衣机：清洗，烘干\n\n从以上例子能看出，面向过程比较简单直接，而面向对象更易于复用、扩展和维护\n\n## 4.8、sleep（）和wait（）区别\n\n1. 所属的类型不同 \n- wait()是Object类的实例方法,调用该方法的线程将进入WTING状态。 \n- sleep()是Thread类的静态方法,调用该方法的线程将进入TIMED_WTING状态\n\n1. 对锁的依赖不同 \n- wait()依赖于synchronized锁,通过监视器进行调用,调用后线程会释放锁。\n- sleep()不依赖于任何锁,所以在调用后它也不会释放锁。\n\n1. 返回的条件不同 \n- 调用wait()进入等待状态的线程,需要由notify()/notifyAll()唤醒,从而返回。 \n- 调用sleep()进入超时等待的线程,需要在超时时间到达后自动返回。\n\n\n# 5、枚举\n## 5.1、实现方式\n 枚举是一组常量的集合。 可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象  \n### 5.1.1、 自定义类实现枚举  \n\n1. 不需提供set方法，因为枚举对象值通常为只读\n2. 对枚举对象/属性使用final+static共同修饰，实现底层优化\n3. 枚举 对象名通常使用全部大写，常量的命名规范\n\n```java\nclass Season {//类\n    private String name;\n    private String desc;//描述\n\n    public static final Season SPRING = new Season(\"春天\", \"温暖\");\n    public static final Season WINTER = new Season(\"冬天\", \"寒冷\");\n    public static final Season AUTUMN = new Season(\"秋天\", \"凉爽\");\n    public static final Season SUMMER = new Season(\"夏天\", \"炎热\");\n}\n\npublic class Enumeration02 {\n    public static void main(String[] args) {\n        System.out.println(Season.AUTUMN);\n        System.out.println(Season.SPRING);\n    }\n}\n\n```\n### 5.1.2、enum关键字实现枚举\n\n1. 当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类,  这样我们就可以使用 Enum 类相关的方法  \n2. 如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略\n3. 当有多个枚举对象时，使用,间隔，最后有一个分号结尾\n4. 枚举对象必须放在枚举类的行首  \n\n```java\npublic class Enumeration03 {\n    public static void main(String[] args) {\n        System.out.println(Season2.AUTUMN);\n        System.out.println(Season2.SUMMER);\n    }\n}\n\n//演示使用 enum 关键字来实现枚举类\nenum Season2 {//类\n\n    //3. 如果有多个常量(对象)， 使用 ,号间隔即可\n    //4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面\n    //5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()\n    SPRING(\"春天\", \"温暖\"), \n    WINTER(\"冬天\", \"寒冷\"), \n    AUTUMN(\"秋天\", \"凉爽\"), \n    SUMMER(\"夏天\", \"炎热\");\n    \n    private String name;\n    private String desc;//描述\n    \n    private Season2() {//无参构造器\n    }\n    private Season2(String name, String desc) {//有参构造器\n        this.name = name;\n        this.desc = desc;\n    }\n}\n```\n# 6、注解\n\n \t注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息 。和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息  \n## 6.1、基本注解介绍\n\n 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 \n \n 三个基本的 Annotation:  \n \n1) @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法 \n2) @Deprecated: 用于表示某个程序元素(类, 方法等)已过时 \n3) @SuppressWarnings: 抑制编译器警告（当不希望看到某些警告使用该注解，都不想看到使用all）\n\n\n## 6.2、自定义注解\n\n修饰符：访问修饰符必须为public,不写默认为pubic；\n关键字：关键字为@interface；\n注解名称： 注解名称为自定义注解的名称，使用时还会用到；\n注解类型元素：注解属性 ( 接口方法 ) 返回值类型要求 ,可以使用default来进行赋默认值；\n```java\npublic @interface Info { \n    String value() default \"tracy\"; \n    boolean isDelete(); \n}\n```\n\n## 6.3、元注解\n\n所谓元注解，其主要作用就是负责注解其他注解，为其他注解提供了相关的解释说明。\nJava中存在五个元注解，分别是 @Target、@Retention、@Documented、@Inherited、@Repeatable\n\n1. **Target**：描述了注解修饰的对象范围，取值在java.lang.annotation.ElementType定义，常用包括：\n\n> METHOD：用于描述方法\n> PACKAGE：用于描述包\n> PARAMETER：用于描述方法变量\n> TYPE：用于描述类、接口或enum类型\n\n2. **Retention**：表述注解保留时间的长短，取值在java.lang.annotation.RetentionPolicy中，取值：\n\n> SOURCE：在源文件中有效，编译过程中会被忽略\n> CLASS：随源文件一起编译在class文件中，运行时忽略\n> RUNTIME：在运行时有效(只有定义为RetentionPolicy.RUNTIME时，我们才能通过注解反射获取注解)\n\n3. **Document**：表明这个注解应该被 javadoc文档注释工具记录，正常情况下javadoc中不包含注解的，@Documented属于标志注解\n\n4. **Inherited**:被该注解注解的元注解注解某个类时，子类继承该注解\n\n5. @Repeatable 是 Java 8 引入的一个注解，用于在同一个元素上多次使用相同的注解。通过使用 @Repeatable 注解，可以使得某个注解可以重复应用于同一目标上，而无需使用容器注解或数组\n\n```java\n    @Color(\"Red\")\n    @Color(\"Blue\")\n    public void printColors() {\n        // ...\n    }\n```\n\n## 6.4、案例-自定义注解实现日志功能\n\n1. 定义一个注解\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Loggable {\n}\n```\n\n2. 创建切面类，使用 @Before 注解和 @AfterReturning 注解分别标记了在方法执行前和方法执行后执行的通知方法\n\n```java\n@Aspect\npublic class LoggingAspect {\n    @Before(\"@annotation(Loggable)\")\n    public void beforeMethodExecution(JoinPoint joinPoint) {\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(\"Entering method: \" + methodName);\n    }\n\n    @AfterReturning(\"@annotation(Loggable)\")\n    public void afterMethodExecution(JoinPoint joinPoint) {\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(\"Exiting method: \" + methodName);\n    }\n}\n```\n\n3. 在需要进行日志记录的方法上添加 @Loggable 注解即可\n\n```java\npublic class MyClass {\n    @Loggable\n    public void doSomething() {\n        // ...\n    }\n\n    public void doAnotherThing() {\n        // ...\n    }\n}\n```\n# 7、异常\n\n![异常分类](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251414029.png)\n\n\n## 7.1、**Error（错误）**\n\n程序本身不能处理的异常，只能靠外接干预 （常见的如**内存溢出**，j**vm虚拟机自身的非正常运行**等）\n\n## 7.2、**Exception（异常）**\n\n是程序正常运行中，可以预料的意外情况。比如数据库连接中断，空指针，数组下标越界。异常出现可以导致程序非正常终止\n\n（1）编译时异常\n又叫可检查异常，Java语言强制要求捕获和处理所有非运行时异常。通过行为规范，强化程序的健壮性和安全性\n\n（2）运行时异常\n又叫不检查异常RuntimeException，这些异常一般是由程序逻辑错误引起的，即语义错\n\n# 8、常用类\n## 8.1、日期类\n### 8.1.1、第一代日期类Date（JDK1.0）\n\n1. Date：精确到毫秒，代表特定瞬间\n2. SimpleDateFormat：格式化（日期-文本）和解析日期（文本-日期）的类\n\n```java\n\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy 年 MM 月 dd 日 hh:mm:ss E\");\n// format：将日期转换成指定格式的字符串\nDate d1 = new Date();\nString format = sdf.format(d1); \n// parse：格式化的String 转成对应的 Date\nString s = \"1996 年 01 月 01 日 10:20:30 星期一\";\nDate parse = sdf.parse(s);\n```\n\n### 8.1.2、第二代日期类Calendar（JDK1.1）\n\nCalendar它是一种抽象类，相比Date它在操作日历的时候提供了一些方法来操作日历字段\n\n```java\n// Calendar 是一个抽象类， 并且构造器是 private,可以通过 getInstance() 来获取实例\n// Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)\n\n//1. 创建日历类对象\nCalendar c = Calendar.getInstance(); \n//2. 获取日历对象的某个日历字段\nSystem.out.println(\"年：\" + c.get(Calendar.YEAR));\n// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号\nSystem.out.println(\"月：\" + (c.get(Calendar.MONTH) + 1));\nSystem.out.println(\"日：\" + c.get(Calendar.DAY_OF_MONTH));\nSystem.out.println(\"小时：\" + c.get(Calendar.HOUR));\nSystem.out.println(\"分钟：\" + c.get(Calendar.MINUTE));\nSystem.out.println(\"秒：\" + c.get(Calendar.SECOND));\n```\n\n### 8.1.3、第三代日期类LocalDate（JDK8）\n\n\n1. **Calendar日期类存在的问题？**\n\n（1）可变性，像日期和时间这样的类应该是不可变的\n（2）格式化，格式化只对Date有用，Calendar只能自己拼装\n（3）不是线程安全的；不能处理闰秒（每隔两天，多出一秒）等\n\n2. **基本概念**\n\nLocalDate：日期（年月日）\nLocalTime：包含时间（时分秒）\nLocalDateTime：包含日期+时间（年月日时分秒）\n\n```java\n//1. 使用 now() 返回表示当前日期时间的 对象\nLocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()\n//2. 使用 DateTimeFormatter 对象来进行格式化\nDateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nString format = dateTimeFormatter.format(ldt);\nSystem.out.println(\"格式化的日期=\" + format);\nSystem.out.println(\"年=\" + ldt.getYear());\nSystem.out.println(\"月=\" + ldt.getMonth());\nSystem.out.println(\"月=\" + ldt.getMonthValue());\nSystem.out.println(\"日=\" + ldt.getDayOfMonth());\nSystem.out.println(\"时=\" + ldt.getHour());\nSystem.out.println(\"分=\" + ldt.getMinute());\nSystem.out.println(\"秒=\" + ldt.getSecond());\nLocalDate now = LocalDate.now(); //可以获取年月日\nLocalTime now2 = LocalTime.now();//获取到时分秒\n// 3. 提供 plus 和 minus 方法可以对当前时间进行加或者减\n//看看 890 天后，是什么时候 把 年月日-时分秒\nLocalDateTime localDateTime = ldt.plusDays(890);\nSystem.out.println(\"890 天后=\" + dateTimeFormatter.format(localDateTime));\n//看看在 3456 分钟前是什么时候，把 年月日-时分秒\nLocalDateTime localDateTime2 = ldt.minusMinutes(3456);\nSystem.out.println(\"3456 分钟前 日期=\" + dateTimeFormatter.format(localDateTime2));\n```\n\n\n## 8.2、容器\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301540735.png)\n\n\n|名称|底层|线程安全性|扩容机制|备注|\n|--|--|--|--|--|\n|ArrayList|数组|线程不安全|首次创建长度为10，扩为1.5倍|查找快，增删慢|\n|Vector|数组|线程安全|首次创建长度为10，扩为1.5倍|查找快，增删慢|\n|LinkedList|双向链表|线程不安全|不主动扩容|增删快，查找慢|\n|HashSet|HashMap|线程不安全||可以存null|\n|LinkedHashSet|LinkedHashMap|线程不安全||可以存null|\n|TreeSet|TreeMap|线程不安全||不允许存null|\n|HashMap|数组+链表（jdk7） 数组+链表+红黑树 （jdk8）|线程不安全|首次创建长度16，扩容2倍,负载因子0.75|可以存nul|\n|LinkedHashMap|同hashmap|线程不安全|不主动扩容|可以存null|\n|HashTable|数组+链表|线程安全|首次创建时长度为11，扩容为2n+1|不能为null|\n|TreeMap|红黑树|线程不安全|TreeMap由红黑树实现，容量方面没有限制|不能为null 可以实现自然排序和定制排序 |\n\n### 8.2.1、hashmap原理\n\nhashmap数据结构是数组+链表+红黑树，HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对\n两个重要的方法put() get()\n（1）.put方法：调用key的hash方法得hash值，再与（数组长度-1）做与（&）运算，到这个元素在数组中的位置（即下标）如果该位置已经存在其它元素，那么在同一个位子上的元素将以链表的形式存放，通过equals方法依次比较链表中的key，相同则替换。不同则添加到表尾（1.8之前添加到表头）。\n（2）.get方法：调用key的hash方法得到这个元素在数组中的位置（即下标），然后通过key的equals方法在对应位置的链表中找到需要的元素。\n\n> （需要注意Jdk 1.8中对HashMap的实现做了优化,当链表长度大于8且数组长度超过64并之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)）\n> 如果数组长度不足64，优先会进行扩容\n\n### 8.2.2、自然排序和定制排序\n\n自然排序：实现Comparable接口，实现compareTo方法\n\n> 典型实现：String，Integer，Date等\n\n定制排序：当元素对象没有实现comparable接口，又不方便修改，可以考虑使用定制排序，直接在调用方排序\n\n\n```java\nCollections.sort(arrayList, new Comparator<Integer>() {\n        @Override\n        public int compare(Integer o1, Integer o2) {\n            return o1.compareTo(o2);\n        }\n});\n```\n\n\n## 8.3、String\n\n不可变性的理解：\n\n```java\nString s = \"abc\";    //(1)\nSystem.out.println(\"s = \" + s);\n \ns = \"123\";    //(2)\nSystem.out.println(\"s = \" + s);\n```\n\n![b6f0e64b3015ee2ebe2bd49b02c2a68.jpg|275](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270955924.jpg)\n\ns只是一个String对象的引用，并不是String对象本身。\n当执行(1)处这行代码之后，会先在方法区的运行时常量池创建一个String对象\"abc\"，然后在Java栈中创建一个String对象的引用s，并让s指向\"abc\"\n当执行完(2)处这行代码之后，会在方法区的运行时常量池创建一个新的String对象\"123\"，然后让引用s重新指向这个新的对象，而原来的对象\"abc\"还在内存中，并没有改变\n\n为什么这样设计？\n(1)、字符串常量池中的对象可能被很多对象引用，如果一个修改会导致所有对象的内容都变\n(2)、hashmap中key的hash方法只会调用一次然后缓存起来，如果key可变会导致缓存的结果和真实的计算结果不一致\n\n# 9、泛型\n## 9.1、基本概念\n\n（1）泛型：Java在jdk5引入了泛型，在没有泛型之前，每次从集合中读取的对象都必须进行类型转换，如果在插入对象时，类型出错，那么在运行时转换处理的阶段就会报错。在提出泛型之后就可以明确的指定集合接受哪些对象类型，编译器就能知晓并且自动为插入的代码进行泛化，在编译阶段告知是否插入类型错误的对象，程序会变得更加安全清晰。 \n（2）泛型擦除：Java泛型是伪泛型，因为Java代码在编译阶段，所有的泛型信息会被擦除，Java的泛型基本上都是在编辑器这个层次上实现的，在生成的字节码文件中是不包含泛型信息的，使用泛型的时候加上的类型，在编译阶段会被擦除掉，这个过程称为泛型擦除。\n\n为什么使用泛型？\n（1）保证类型安全：可以确保在编译时期检测到类型不匹配的错误，避免在运行时出现类型转换错误\n（2）消除强制转换：消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会\n\n## 9.2、泛型使用方式\n\n泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。\n\n> T是泛型中的类型参数声明，它表示一个占位符,通常用大写字母表示（例如 T、E、K、V 等），但实际上它只是一个占位符，可以根据需要自定义\n>\n>T：任意类型 type\n E：集合中元素的类型 element\n K：key-value形式 key\n V：key-value形式 value\n\n\n```java\n// 泛型类\npublic class Box<T> {\n    private T item;\n\n    public void setItem(T item) {\n        this.item = item;\n    }\n\n    public T getItem() {\n        return item;\n    }\n}\n// 泛型接口\npublic interface List<T> {\n    void add(T element);\n    T get(int index);\n    // ...\n}\n// 泛型方法\npublic class Utils {\n    public static <T> T getFirstElement(List<T> list) {\n        if (list != null && !list.isEmpty()) {\n            return list.get(0);\n        }\n        return null;\n    }\n}\n```\n\n\n## 9.3、泛型通配符\n\n泛型通配符是一种特殊的类型参数，用于在使用泛型时表示未知类型或限制类型范围\n\n```java\n// 1：表示类型参数可以是任何类型\npublic class Apple<?>{} \n// 2：表示类型参数必须是A或者是A的子类\npublic class Apple<T extends A>{} \n// 3: 表示类型参数必须是A或者是A的超类型\npublic class Apple<T supers A>{}\n```\n\n\n## 9.4、实现原理\n\n原码：\n\n```java\npublic class Caculate<T> {\n    private T num;\n}\n```\n\n编译后的代码：\n\n```java\npublic class Caculate{\n    public Caculate(){}\n    private Object num;\n}\n```\n\njava的泛型称为伪泛型，因为Java的泛型只是编译期的泛型，一旦编译成字节码，泛型就被擦除了，即在Java中使用泛型，我们无法在运行期知道泛型的类型，一旦编译成字节码，泛型将被取代为Object。\n在不使用泛型时，我们需要将Object手动转型成特定类型，而在使用泛型后，我们不需要自己转型，但实际上我们get到的对象仍然是Object类型的，只不过编译器会自动帮我们加入这个转型动作\n\n\n# 10、IO\n\n## 10.1、概述\n\n### 10.1.1、简介\n\nI（Input）O（Output）：中文翻译为输入输出，我们知道计算机的数据不管是软件、视频、音乐、游戏等最终都是存储在硬盘中的，当我们打开后，由CPU将硬盘中的数据读取到内存中来运行。这样一个过程就产生了I/O（输入/输出）\n>输入：硬盘 -> 内存\n>输出：内存 -> 硬盘\n### 10.1.2、IO流的分类\n\n按照操作数据单位不同分为：字节流（8bit）二进制文件，字符流（按字符）文本文件\n按数据流的流向不同分为：输入流，输出流\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1659662289021-93129478-8cc1-4d9c-82c9-932c15153a37.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=114&id=uf89be968&originHeight=167&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=154323&status=done&style=none&taskId=u5d128cf6-4c3f-4321-a117-49823508580&title=&width=567)\n\n> java的IO流共涉及40多个类，都是从如上4个抽象基类派生\n\n\n![IO流体系](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251511757.png)\n\n## 10.2、字节流\n\n### 10.2.1、字节输出流\n\nOutputStream是所有字节输出的顶层父类，该父类提供如下公共方法：\n\n#### 10.2.1.1、FileOutputStream\nFileOutputStream是OutputStream中一个常用的子类，他可以关联一个文件，用于将数据写出到文件\n\n>构造方法：\n>public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。\n public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。\n\n\n```java\npublic class IOTest {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"000.txt\");\n        // 字符串转换为字节数组\n        byte[] b = \"abcde\".getBytes();\n        // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b,2,2);\n        // 关闭资源\n        fos.close();\n    }\n}\n\n```\n\n>需要注意的是，在UTF-8编码下，一个中文占用3个字节，GBK编码下一个中文占用2个字节，因此在使用字节流来精确操作字符数据时将会变得非常麻烦\n\n### 10.2.2、字节输入流\n#### 10.2.2.1、FileInputStream\njava.io.FileInputStream类是文件输入流，从文件中读取字节\n\n>构造方法：\n>FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。\n FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。\n\n```java\npublic class IOTest {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象.\n        FileInputStream fis = new FileInputStream(\"abc.txt\"); // 文件中为abcde\n        // 定义变量，作为有效个数\n        int len;\n        // 定义字节数组，作为装字节数据的容器\n        byte[] b = new byte[2];\n        // 循环读取\n        while ((len = fis.read(b)) != -1) {\n            // 每次读取后,把数组的有效字节部分，变成字符串打印\n            System.out.println(new String(b, 0, len));//  len 每次读取的有效字节个数\n        }\n        // 关闭资源\n        fis.close();\n    }\n}\n```\n\n\n## 10.3、字符流\n\n计算机都是按照字节进行存储的，我们之前学习过编码表，通过编码表可以将字节转换为对应的字符，但是世界上有非常多的编码表，不同的编码表规定的单个字符所占用的字节可能都不一样，例如在GBK编码表中一个中文占2个字节，UTF8编码表则占3个字节；且一个中文字符都是由多个字节组成的，为此我们不能再基于字节的操作单位来操作文本文件了，因为这样太过麻烦，我们希望基于字符来操作文件，一次操作读取一个“字符”而不是一个“字节”，这样在操作文本文件时非常便捷\n\n### 10.3.1、字符输出流\n#### 10.3.1.1、FileWriter类\n\njava.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区\n\n```java\npublic class Demo03_写出字符数组 {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"002.txt\");\n        // 字符串转换为字节数组\n        char[] chars = \"我是中国人\".toCharArray();\n        // 写出字符数组\n        fw.write(chars); // 我是中国人\n        // 写出从索引2开始，2个字节。索引2是'中'，两个字节，也就是'中国'。\n        fw.write(chars,2,2); // 中国\n        // 关闭资源\n        fw.close();\n    }\n}\n```\n\n### 10.3.2、字符输入流\n#### 10.3.2.1、FileReader类\n\njava.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区\n\n> Windows系统的中文编码默认是GBK编码表。idea中默认是UTF-8 \n\n```java\npublic class IoTest {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileReader fr = new FileReader(\"001.txt\");\n        // 定义变量，保存数据\n        int data;\n        // 循环读取\n        while ((data = fr.read()) != -1) {\n            // 以数值的方式输出\n//            System.out.println(b);\n            // 以字符的方式输出\n            System.out.println((char) data);\n        }\n        // 关闭资源\n        fr.close();\n    }\n}\n```\n\n\n# 11、反射\n## 11.1、概述\n\n### 11.1.1、基本概念\nJava反射是指在运行时动态地获取类的信息并操作类或对象的能力。它提供了一组API，使得可以在运行时检查类、接口、字段和方法，并且可以在运行时实例化对象、调用方法、获取和设置字段的值\n\n### 11.1.2、好处\n\n1. 运行时类信息：反射允许在运行时获取类的信息，包括类的名称、字段、方法、注解等。这使得可以动态地了解和操作类的结构，从而实现更加灵活和通用的代码设计。\n2. 动态创建对象：通过反射可以在运行时动态地实例化对象，而不需要在编译时明确知道类的类型。这对于根据配置文件或用户输入来创建对象非常有用，可以实现更大程度的灵活性和可配置性。\n3. 动态调用方法：反射可以在运行时动态地调用类的方法，包括公共方法、私有方法和静态方法。这对于实现插件机制、扩展性和动态逻辑非常有用，可以根据运行时条件来调用不同的方法。\n4. 访问私有成员：反射可以绕过访问权限限制，访问类的私有成员。这对于测试、调试和特定场景下的操作非常有用，但也需要小心使用，以遵循封装原则。\n5. 序列化和反序列化：反射在序列化和反序列化过程中起着重要的作用。通过反射可以分析对象的结构，并将其转换为字节流或从字节流中重建对象\n\n## 11.2、 获取Class对象的方式\n\n1. Class.forName(\"全类名\")：将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类\n2.  类名.class：通过类名的属性class获取，多用于参数的传递 \n3. 对象.getClass()：getClass()方法在Object类中定义着\n\n> 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。\n\n\n## 11.3、Class对象功能\n\n1. 获取成员变量\n\n```java\nField[] getFields() ：获取所有public修饰的成员变量\nField getField(String name)   获取指定名称的 public修饰的成员变量\nField[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符\nField getDeclaredField(String name)  \n```\n\n2. 获取构造方法\n\n```java\nConstructor<?>[] getConstructors()  返回public修饰的构造方法\nConstructor<T> getConstructor(类<?>... parameterTypes)  \nConstructor<T> getDeclaredConstructor(类<?>... parameterTypes)  \nConstructor<?>[] getDeclaredConstructors()  返回所有的构造方法\n```\n\n3. 获取成员方法\n\n```java\nMethod[] getMethods()  \nMethod getMethod(String name, 类<?>... parameterTypes)  \nMethod[] getDeclaredMethods()  \nMethod getDeclaredMethod(String name, 类<?>... parameterTypes)  \n```\n\n4. 获取全类名\n\n```java\nString getName()  \n```\n## 11.4、Field 成员变量\n\n```java\n1. 设置值\n\tvoid set(Object obj, Object value)  \n2. 获取值\n\tget(Object obj) \n3. 忽略访问权限修饰符的安全检查\n\tsetAccessible(true):暴力反射\n```\n## 11.5、Constructor 构造方法\n\n```java\nT newInstance(Object... initargs)  \n如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法\n```\n\n## 11.6、Method 方法对象\n\n```java\n1. 执行方法：\n\tObject invoke(Object obj, Object... args)  \n2. 获取方法名称：\n\tString getName:获取方法名\n```\n\n\n# 12、异常\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301636988.png)\n\n\nError：错误，无法被处理的\n\nException：异常，能够被程序本身处理的，可以通过try…catch语句捕捉异常，或者是throws抛出异常。分为运行时异常和非运行时异常\n- 运行时异常：就是RuntimeException，编译时不会检查出错误的。一般是由于逻辑错误引起的，程序员可以手动去解决的，比如判空等。\n- 非运行时异常：也叫编译异常，就是Exception下除了RuntimeException以外的异常。是必须进行处理的异常，编译器会进行异常提醒的。如果不进行处理，程序编译不通过\n\n\n# 13、日志\n## 13.1、基本概念\n\n![image (26).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270851142.png)\n\n> 常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。\n\n## 13.2、java日志演化历史\n\n（1）最开始出现的是 log4j，也是应用最广泛的日志系统，作者是 Ceki Gülcü，开始时，一切都是美好的。\n（2）但 java 的开发主体 Sun 公司认为自己才是正统，为了干掉 log4j，在 jdk1.4 中增加了 jul（因为在 java.util.logging 包下）日志的实现，造成了目前开发者的混乱，迄今为止仍饱受诟病。\n（3）各个日志系统互相没有关联，替换和统一变的非常麻烦。A 项目用 log4j 作为日志系统，但同时引了 B 项目，而 B 项目用 jul 作为日志系统，那么你的应用就得使用两个日志系统。\n（4）为了搞定这个坑爹的问题，开源社区 apache 提供了一个日志框架作为日志的抽象，叫 commons-logging，也被称为 jcl（java common logging），jcl 对各种日志接口进行抽象，抽象出一个接口层，对每个日志实现都适配或者桥接，这样这些提供给别人的库都直接使用抽象层即可，较好的解决了上述问题。\n（5）当年 Apache 说服 log4j 以及其他的日志来按照 commons-logging 的标准编写，但是由于 commons-logging 的类加载有点问题，实现起来也不友好，作为元老级日志 log4j 的作者再度出山，搞出了一个更加牛逼的新的日志框架 slf4j（这个也是抽象层），同时针对 slf4j 的接口实现了一套日志系统，即传说中的 logback。\n（6）同时这个作者心情一好，又把 log4j 进行了改造，就是所谓的 log4j2，同时支持 jcl 以及 slf4j。","source":"_posts/java core.md","raw":"---\ntitle: java core\ndate: 2023/08/22\ncategories:\n  - coding\ntags:\n  - java core\n  - 编程基础\n---\n#  1、Java概述\n## 1.1、java特点\n\n1. Java 语言是面向对象的(oop) \n2. Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证\n3. Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]\n4. java是一种半编译，半解释型语言。 . Java-->. class是由 Javac 编译，这个过程符合编译型语言的特点。而. class-->对应平台机器码 的这一过程 是由Java解释执行 \n# 2、变量\n## 2.1、java基本数据类型\njava基本数据类型 - 四类八种\n\n1. **整型**\n\nbyte 、short 、int 、long\n\n2. **浮点型**\n\nfloat 、 double\n\n3. **字符型**\n\nchar\n\n4. **布尔型**\n\nboolean\n\n| 数据类型名称 | 占用字节 | 范围 | 封装器类 |\n| --- | --- | --- | --- |\n| byte（字节型） | 1 | -（2^7）~2^7-1（-128~127） | Byte |\n| shot（短整型） | 2 | -（2^15）~2^15-1(-32768~32767) | Short |\n| int（整形） | 4 | -（2^31）~2^31-1（-2147483648~2147483647） | Integer |\n| long（长整型） | 8 | -（2^63）~2^63-1 | Long |\n| float（浮点型） | 4 | -3.403E8~3.403E38 | Float |\n| double（双精度浮点型） | 8 | -1.798E308~1.798E308 | Double |\n| boolean（布尔型） | 1 |  | Boolean |\n| char（字符型） | 2 |  | **Character** |\n\n> 注意：计算机的数值是用二进制补码表示的，二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1\n\n\n## 2.2、基本数据类型转换\n### 2.2.1、自动类型转换\n\n当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换\n精度由小到大排序：\n\nbyte short int long float double\n\n```java\n//自动类型转换细节\npublic class AutoConvertDetail {\n    public static void main(String[] args) {\n    //细节 1： 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算\n    int n1 = 10; //ok\n    float d1 = n1 + 1.1;//错误 n1 + 1.1 => 结果类型是 double\n    double d1 = n1 + 1.1;//对 n1 + 1.1 => 结果类型是 double\n    float d1 = n1 + 1.1F;//对 n1 + 1.1 => 结果类型是 float\n    //细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，就会报错，反之就会进行自动类型转换。\n    int n2 = 1.1;//错误 double -> int\n    //细节 3: (byte, short) 和 char 之间不会相互自动转换\n     byte b1 = 10; //对 , -128-127\n     char c1 = b1; //错误， 原因 byte 不能自动转成 char\n    //细节 4：自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型\n    byte b4 = 1;\n    short s3 = 100;\n    int num200 = 1;\n    float num300 = 1.1F;\n    float num500 = b4 + s3 + num200 + num300; \n}\n```\n\n>floatf=3.4;是否正确？\n不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换floatf=(float)3.4;或者写成floatf=3.4F;\n\n### 2.2.2、强制类型转换\n\n将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符( )，但可能造成精度降低或溢出,格外要注意。\n\n### 2.2.3、基本数据类型和String转换\n\n1. 基本数据类型转String类型\n\n（1）将基本类型的值加 \"\" 即可\n（2）String.valueOf(基本数据类型)\n\n2. String转基本数据类型\n\n（1）基本类型包装类调用parseXX方法即可\n\n# 3、运算符\n## 4.1、算数运算符\n算数运算符是对数值变量进行运算的，在java程序种使用非常多\n\n![java算数运算符](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231601761.png)\n\n\n```java\n// 题目1\nint i = 1;\ni = i++; // 规则会使用临时变量(1)temp=i(2)i=i+1(3)i=temp\nSystem.out.println(i); // 1\n\n// 题目2\nint i = 1;\ni = ++i; // 规则会使用临时变量(1)i=i+1(2)temp=i(3)i=temp\nSystem.out.println(i); // 2\n\n```\n## 4.2、关系运算符\n\n关系运算符的结果都是boolean型，也就是要么是true，要么是false\n\n![java关系运算符](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231605071.png)\n\n\n## 4.3、逻辑运算符\n\n用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值\n\n![逻辑运算符](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231608353.png)\n\n\n>   a^b: 叫逻辑异或  ：当 a 和 b 不同时，则结果为 true, 否则为 false  \n>   &&短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高\n>   & 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低  \n\n## 4.4、赋值运算符\n\n基本赋值运算符 = （ int a = 10;） \n复合赋值运算符 += ，-= ，*= ， /= ，%= 等\n\n## 4.5、三元运算符\n条件表达式 ? 表达式 1: 表达式 2; \n\n1. 如果条件表达式为 true，运算后的结果是表达式 1；\n2. 如果条件表达式为 false，运算后的结果是表达式 2；\n\n## 4.6、进制转换（为位运算准备）\n\n对于整数，有四种表示方式：\n二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。\n十进制：0-9 ，满 10 进 1。\n八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。\n十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写\n\n![进制转换](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231612057.png)\n\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1659315826387-ed7e7bab-8366-4fd2-8353-b82acde62fa2.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=243&id=uc4b6c469&originHeight=470&originWidth=664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126331&status=done&style=none&taskId=u69461551-0d4d-415e-bdd3-fb02621b29f&title=&width=343)\n\n### 4.6.1、其它进制转十进制\n\n1. 二进制转十进制\n\n规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和\n\n> 案例：将ob1011转成十进制数\n> 1+2+8=11\n\n\n2. 八进制转十进制\n\n规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和\n\n> 案例：0234转成十进制\n> 4\\*1+3\\*8+2\\*64=156\n\n\n3. 十六进制转十进制\n\n规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和\n\n> 案例：0x23A\n> 10\\*1+3\\*16+2\\*512=570\n\n\n### 4.6.2、十进制转其他进制\n\n1. 十进制转二进制\n\n规则：将该数不断除以2.直到商为0为止，然后将每步余数倒过来，就是对应二进制\n\n> 案例：34转为对应二进制 = 0B00100010\n\n![十进制转二进制](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231618617.png)\n\n\n2. 十进制转八进制\n\n规则：将该数不断除以8.直到商为0为止，然后将每步余数倒过来，就是对应二进制\n\n> 案例：131转为8进制\n\n![十进制转八进制](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231620590.png)\n\n\n\n### 4.6.3、二进制转其它进制\n\n1. 二进制转八进制\n\n规则：从低位开始，将二进制数每三位一组，转成对应的八进制\n\n> 案例：0b11010101转成八进制\n> 0325\n\n\n2. 二进制转十六进制\n\n规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可\n\n> 案例：0b11010101转成十六进制\n> D5\n\n### 4.6.4、其它进制转二进制\n\n1. 八进制转二进制\n\n规则：将八进制数每1位。转成对应的一个3位的二进制数即可\n\n> 案例：将0237转成二进制\n> 0b10011111\n\n2. 十六进制转二进制\n\n规则：将十六进制数每1位。转成对应的一个4位的二进制数即可\n\n> 案例：请将0x23B转成二进制\n> 0b001000111011\n\n## 4.7、位运算符\n### 4.6.1、原码反码补码\n\n1. 进制的最高位是符号位: 0表示正数1表示负数\n2. 正数的原码，反码，补码都一样\n3. 负数的反码=它的原码符号位不变，其它位取反.负数的补码=它的反码+1\n4. 0的反码，补码都是0\n5. 在计算机运算的时候，都是以补码的方式来运算的\n6. 补码的补码就是原码\n\n> 为什么计算机通过补码进行运算？\n> 通过使用补码，无需单独的符号位判断来执行加法和减法运算。计算机可以直接对补码进行位运算，而不需要额外的逻辑电路来处理符号位\n\n### 4.6.2、位运算\n\njava种有7个位运算 &（按位与）,|（按位或）,^（按位异或）,~（按位取反），<<（左移），>>（带符号右移），>>>（无符号右移）\n\n#### 4.6.2.1、& （按位与）\n\n两位全为1，结果为1，否则为0\n\n```asciidoc\n  10  (2)\n& 11  (3)\n------\n  10  (2)\n```\n\n#### 4.6.2.2、|（按位或）\n\n两位一个为1，结果为1，否则为0\n\n```asciidoc\n  10  (2)\n| 11  (3)\n------\n  11  (3)\n```\n\n#### 4.6.2.3、 ^（按位异或）\n\n两位一个为0，结果为1，否则为0\n\n```asciidoc\n  10  (2)\n^ 11  (3)\n------\n  01  (1)\n```\n\n\n#### 4.6.2.4、~（按位取反）\n\n0->1, 1->0\n\n```asciidoc\n~2 \n原码：00000010\n按位取反：11111101\n补码表示：10000011 = 3\n```\n\n#### 4.6.2.5、>>（算数右移）\n\n低位溢出，符号位不变，并用符号位补溢出的高位\n\n```asciidoc\n1 >> 2\n1的补码：00000001\n右移两位，并用符号位填充：00000000\n原码结果为：0\n\n-1 >> 2\n-1的补码：11111111\n右移两位，并用符号位填充：11111111\n原码结果为：100000001 = -1\n```\n\n#### 4.6.2.6、>> （算数左移）\n\n符号位不变，低位补0\n\n```asciidoc\n1 << 2\n0001 << 2 = 0100 = 4\n\n-1 << 3\n11111111 << 3 = 11111000\n原码结果为：10001000 = -8\n```\n\n#### 4.6.2.7、>>> （逻辑右移 或叫 无符号右移）\n\n低位溢出，高位补0\n\n```asciidoc\n8 >>> 2\n1000 >>> 2 = 0010 = 2\n```\n\n# 4、面向对象\n## 4.1、面向对象三大特征\n### 4.1.1、封装\n\n**封装**：尽量避免向外部暴露实现细节，只提供个别接口让使用方调用，降低耦合性。这样做的话，当自身的逻辑发生变化时，不会破坏使用方的逻辑，或是强制使用方修改自身的逻辑，而是只需要修改自身的代码就可以了\n### 4.1.2、继承\n\n**继承**：子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法。以降低代码编写的冗余度\n### 4.1.3、多态\n\n**多态**：父类的引用指向子类的对象。它的意义是可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，而这些方法通过一个抽象类或者接口来实现，多态就是提供父类调用子类代码的一个手段而已\n\n## 4.2、内部类\n\n如果定义类在局部位置(方法中/代码块) :(1) 局部内部类 (2) 匿名内部类 \n如果定义在成员位置 (1) 成员内部类 (2) 静态内部类  \n### 4.2.1、局部内部类\n\n局部内部类是定义在外部类的局部位置，比如方法中，并且有类名数据\n\n> 说明：\n> 1. 可以直接访问外部类的所有成员，包括私有\n> 2. 不能添加访问修饰符，因为他就是一个局部变量，局部变量不能使用修饰符\n> 3. 作用域：仅在定义它的方法或代码块中\n> 4. 局部内部类访问外部类的成员：直接访问。外部类访问局部内部类的成员，创建对象再访问\n\n```java\npublic class OuterClass {\n    private int outerData = 10;\n\n    public void outerMethod() {\n        int localVar = 5;\n        class LocalInnerClass {\n            public void innerMethod() {\n                System.out.println(\"访问外部类数据：\" + outerData);\n                System.out.println(\"访问局部变量：\" + localVar);\n            }\n        }\n        LocalInnerClass innerObj = new LocalInnerClass();\n        innerObj.innerMethod();\n    }\n\n    public static void main(String[] args) {\n        OuterClass outerObj = new OuterClass();\n        outerObj.outerMethod();\n    }\n}\n```\n### 4.2.2、匿名内部类\n\n匿名内部类是一种没有显式定义类名的内部类，定义在外部类的局部位置，比如方法中，它通常用于创建实现某个接口或继承某个类的匿名对象\n\n> 说明：\n> 1. 匿名内部类运行类型：外部类名称$1\n\n\n1. 基于接口的匿名内部类\n\n```java\ninterface IA{\n    void cry();\n}\n\nclass Outer {\n\tpublic void sayHello() {\n\t\t// 编译类型为IA，运行类型为匿名内部类Outer$1\n       // jdk 底层在创建匿名内部类 Outer$1,立即马上就创建了 Outer$1 实例，并且把地址返回给 tiger\n\t    IA tiger = new IA() {\n\t        @Override public void cry() { \n\t            System.out.println(\"老虎叫...\"); \n\t        } \n\t    };\n\t}\n}\n```\n\n2. 基于类的匿名内部类\n\n```java\nclass Father {\n    public void test(){}\n}\n\nclass Outer{\n\tpublic void sayHello() {\n\t\t// father 编译类型 Father, father 运行类型 Outer$1\n\t    Father father = new Father(\"jack\"){\n\t        @Override\n\t        public void test() {\n\t            System.out.println(\"匿名内部类重写了 test 方法\");\n\t        }\n\t    };\n\t}\n    \n}\n```\n\n\n### 4.2.3、成员内部类\n\n成员内部类是定义在外部类的成员位置，并且没有static修饰\n\n> 说明：\n> 1. 可以直接访问外部类的所有成员，包括私有的\n> 2. 可以添加任何修饰符，因为它的地位就是一个成员\n\n```java\npublic static void main(String[] args) {\n    Outer08.Inner08 inner08Instance = outer08.getInner08Instance();\n    inner08Instance.say();\n}\n\nclass Outer08 { //外部类\n    public class Inner08 {//成员内部类\n        public void say() {\n            //可以直接访问外部类的所有成员，包含私有的\n            //如果成员内部类的成员和外部类的成员重名，会遵守就近原则. \n            //可以通过 外部类名.this.属性 来访问外部类的成员\n            System.out.println(\"n1 = \" + n1 + \" name = \" + name + \" 外部类的 n1=\" + Outer08.this.n1);\n            hi();\n        }\n    }    \n}\n```\n### 4.2.4、静态内部类\n\n成员内部类是定义再外部类的成员位置，有static修饰\n\n```java\npublic static void main(String[] args) {\n    Outer10.Inner10 inner10 = new Outer10.Inner10();\n    inner10.say();\n}\nclass Outer10 { //外部类\n    static class Inner10 {\n        private static String name = \"卡卡\";\n        public void say() {\n            cry();\n        }\n    }\n}\n```\n\n## 4.3、重载和重写\n\n**重载**发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载\n**重写**，子类重写父类方法，返回值（JDK7以后，被重写的方法返回值类型可以不同，但是必须是父类返回值的派生类）和形参都不能改变\n\n> 不能根据返回类型来区分重载\n> float max(int a, int b);\n> int max(int a, int b);\n> 上面两个方法名称和参数都一致，如果在同一个类中，别的地方调用的时候都是max（1，2），不能区分出想调用哪个方法\n\n## 4.4、抽象类和接口\n\n1、接口的设计目的，是对类的行为进行约束。也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制\n2、而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为。可以在抽象类中实现这种行为。这样它所有的子类就无需重复实现。达到代码复用的目的\n\n## 4.5、Object类常用方法\n\n1. hashcode（）：将对象的16进制地址值，经过hash算法换算成整值\n2. toString（）：返回该对象的字符串对象\n3. equals（）：比较两个对象的地址值是否相同\n4. clone（）：实现对象的浅拷贝\n5. getclass（）：获取该对象的字节码文件（该对象运行时的类）Class\n6. wait（）notify（）notifyAll（）：wait（）让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法\n\n> void notify()：唤醒一个正在等待该对象的线程。\n  void notifyAll()：唤醒所有正在等待该对象的线程\n\n> 1. equals()没有被重写的情况下等同于 ==\n  Object的equals()方法源码：\n    public boolean equals(Object obj) {\n        return (this == obj);\n    }\n  这用情况= =和equals（）都是引用比较 \n  2. string重写了Object的equals（）方法这种情况equals（）是值比较\n\n## 4.6、深拷贝和浅拷贝\n**浅拷贝**：基本数据类型复制值，引用数据类型复制地址，即拷贝出来的对象与被拷贝出来的对象中的引用的对象是同一个（java默认）：clone方法\n**深拷贝**：基本数据类型复制值，引用数据类型，创建一个新的对象，并复制其内容\n\n```java\n// 使用对象序列化来实现克隆\npublic class Room implements Serializable {\n    Desk desk;\n \n    public Room deepClone() throws Exception{\n        //序列化\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        ObjectOutputStream objectOutputStream = new ObjectOutputStream(outputStream);\n        objectOutputStream.writeObject(this);\n        //反序列化\n        ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());\n        ObjectInputStream objectInputStream = new ObjectInputStream(inputStream);\n        Room roomClone = (Room)objectInputStream.readObject();\n        return roomClone;\n        \n    }\n}\n```\n\n\n## 4.7、面向对象和面向过程的理解\n\n是两种不同的处理问题的角度。面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做什么\n\n> 比如：洗衣机洗衣服\n  **面向过程**：会将任务拆解成一系列的步骤（函数），1、打开洗衣机 2、放衣服3、放洗衣粉4、清洗 5、烘干\n  **面向对象**：会拆出人和洗衣机两个对象：人：打开洗衣机，放衣服，放洗衣粉 洗衣机：清洗，烘干\n\n从以上例子能看出，面向过程比较简单直接，而面向对象更易于复用、扩展和维护\n\n## 4.8、sleep（）和wait（）区别\n\n1. 所属的类型不同 \n- wait()是Object类的实例方法,调用该方法的线程将进入WTING状态。 \n- sleep()是Thread类的静态方法,调用该方法的线程将进入TIMED_WTING状态\n\n1. 对锁的依赖不同 \n- wait()依赖于synchronized锁,通过监视器进行调用,调用后线程会释放锁。\n- sleep()不依赖于任何锁,所以在调用后它也不会释放锁。\n\n1. 返回的条件不同 \n- 调用wait()进入等待状态的线程,需要由notify()/notifyAll()唤醒,从而返回。 \n- 调用sleep()进入超时等待的线程,需要在超时时间到达后自动返回。\n\n\n# 5、枚举\n## 5.1、实现方式\n 枚举是一组常量的集合。 可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象  \n### 5.1.1、 自定义类实现枚举  \n\n1. 不需提供set方法，因为枚举对象值通常为只读\n2. 对枚举对象/属性使用final+static共同修饰，实现底层优化\n3. 枚举 对象名通常使用全部大写，常量的命名规范\n\n```java\nclass Season {//类\n    private String name;\n    private String desc;//描述\n\n    public static final Season SPRING = new Season(\"春天\", \"温暖\");\n    public static final Season WINTER = new Season(\"冬天\", \"寒冷\");\n    public static final Season AUTUMN = new Season(\"秋天\", \"凉爽\");\n    public static final Season SUMMER = new Season(\"夏天\", \"炎热\");\n}\n\npublic class Enumeration02 {\n    public static void main(String[] args) {\n        System.out.println(Season.AUTUMN);\n        System.out.println(Season.SPRING);\n    }\n}\n\n```\n### 5.1.2、enum关键字实现枚举\n\n1. 当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类,  这样我们就可以使用 Enum 类相关的方法  \n2. 如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略\n3. 当有多个枚举对象时，使用,间隔，最后有一个分号结尾\n4. 枚举对象必须放在枚举类的行首  \n\n```java\npublic class Enumeration03 {\n    public static void main(String[] args) {\n        System.out.println(Season2.AUTUMN);\n        System.out.println(Season2.SUMMER);\n    }\n}\n\n//演示使用 enum 关键字来实现枚举类\nenum Season2 {//类\n\n    //3. 如果有多个常量(对象)， 使用 ,号间隔即可\n    //4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面\n    //5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()\n    SPRING(\"春天\", \"温暖\"), \n    WINTER(\"冬天\", \"寒冷\"), \n    AUTUMN(\"秋天\", \"凉爽\"), \n    SUMMER(\"夏天\", \"炎热\");\n    \n    private String name;\n    private String desc;//描述\n    \n    private Season2() {//无参构造器\n    }\n    private Season2(String name, String desc) {//有参构造器\n        this.name = name;\n        this.desc = desc;\n    }\n}\n```\n# 6、注解\n\n \t注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息 。和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息  \n## 6.1、基本注解介绍\n\n 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 \n \n 三个基本的 Annotation:  \n \n1) @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法 \n2) @Deprecated: 用于表示某个程序元素(类, 方法等)已过时 \n3) @SuppressWarnings: 抑制编译器警告（当不希望看到某些警告使用该注解，都不想看到使用all）\n\n\n## 6.2、自定义注解\n\n修饰符：访问修饰符必须为public,不写默认为pubic；\n关键字：关键字为@interface；\n注解名称： 注解名称为自定义注解的名称，使用时还会用到；\n注解类型元素：注解属性 ( 接口方法 ) 返回值类型要求 ,可以使用default来进行赋默认值；\n```java\npublic @interface Info { \n    String value() default \"tracy\"; \n    boolean isDelete(); \n}\n```\n\n## 6.3、元注解\n\n所谓元注解，其主要作用就是负责注解其他注解，为其他注解提供了相关的解释说明。\nJava中存在五个元注解，分别是 @Target、@Retention、@Documented、@Inherited、@Repeatable\n\n1. **Target**：描述了注解修饰的对象范围，取值在java.lang.annotation.ElementType定义，常用包括：\n\n> METHOD：用于描述方法\n> PACKAGE：用于描述包\n> PARAMETER：用于描述方法变量\n> TYPE：用于描述类、接口或enum类型\n\n2. **Retention**：表述注解保留时间的长短，取值在java.lang.annotation.RetentionPolicy中，取值：\n\n> SOURCE：在源文件中有效，编译过程中会被忽略\n> CLASS：随源文件一起编译在class文件中，运行时忽略\n> RUNTIME：在运行时有效(只有定义为RetentionPolicy.RUNTIME时，我们才能通过注解反射获取注解)\n\n3. **Document**：表明这个注解应该被 javadoc文档注释工具记录，正常情况下javadoc中不包含注解的，@Documented属于标志注解\n\n4. **Inherited**:被该注解注解的元注解注解某个类时，子类继承该注解\n\n5. @Repeatable 是 Java 8 引入的一个注解，用于在同一个元素上多次使用相同的注解。通过使用 @Repeatable 注解，可以使得某个注解可以重复应用于同一目标上，而无需使用容器注解或数组\n\n```java\n    @Color(\"Red\")\n    @Color(\"Blue\")\n    public void printColors() {\n        // ...\n    }\n```\n\n## 6.4、案例-自定义注解实现日志功能\n\n1. 定义一个注解\n\n```java\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.METHOD)\npublic @interface Loggable {\n}\n```\n\n2. 创建切面类，使用 @Before 注解和 @AfterReturning 注解分别标记了在方法执行前和方法执行后执行的通知方法\n\n```java\n@Aspect\npublic class LoggingAspect {\n    @Before(\"@annotation(Loggable)\")\n    public void beforeMethodExecution(JoinPoint joinPoint) {\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(\"Entering method: \" + methodName);\n    }\n\n    @AfterReturning(\"@annotation(Loggable)\")\n    public void afterMethodExecution(JoinPoint joinPoint) {\n        String methodName = joinPoint.getSignature().getName();\n        System.out.println(\"Exiting method: \" + methodName);\n    }\n}\n```\n\n3. 在需要进行日志记录的方法上添加 @Loggable 注解即可\n\n```java\npublic class MyClass {\n    @Loggable\n    public void doSomething() {\n        // ...\n    }\n\n    public void doAnotherThing() {\n        // ...\n    }\n}\n```\n# 7、异常\n\n![异常分类](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251414029.png)\n\n\n## 7.1、**Error（错误）**\n\n程序本身不能处理的异常，只能靠外接干预 （常见的如**内存溢出**，j**vm虚拟机自身的非正常运行**等）\n\n## 7.2、**Exception（异常）**\n\n是程序正常运行中，可以预料的意外情况。比如数据库连接中断，空指针，数组下标越界。异常出现可以导致程序非正常终止\n\n（1）编译时异常\n又叫可检查异常，Java语言强制要求捕获和处理所有非运行时异常。通过行为规范，强化程序的健壮性和安全性\n\n（2）运行时异常\n又叫不检查异常RuntimeException，这些异常一般是由程序逻辑错误引起的，即语义错\n\n# 8、常用类\n## 8.1、日期类\n### 8.1.1、第一代日期类Date（JDK1.0）\n\n1. Date：精确到毫秒，代表特定瞬间\n2. SimpleDateFormat：格式化（日期-文本）和解析日期（文本-日期）的类\n\n```java\n\nSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy 年 MM 月 dd 日 hh:mm:ss E\");\n// format：将日期转换成指定格式的字符串\nDate d1 = new Date();\nString format = sdf.format(d1); \n// parse：格式化的String 转成对应的 Date\nString s = \"1996 年 01 月 01 日 10:20:30 星期一\";\nDate parse = sdf.parse(s);\n```\n\n### 8.1.2、第二代日期类Calendar（JDK1.1）\n\nCalendar它是一种抽象类，相比Date它在操作日历的时候提供了一些方法来操作日历字段\n\n```java\n// Calendar 是一个抽象类， 并且构造器是 private,可以通过 getInstance() 来获取实例\n// Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)\n\n//1. 创建日历类对象\nCalendar c = Calendar.getInstance(); \n//2. 获取日历对象的某个日历字段\nSystem.out.println(\"年：\" + c.get(Calendar.YEAR));\n// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号\nSystem.out.println(\"月：\" + (c.get(Calendar.MONTH) + 1));\nSystem.out.println(\"日：\" + c.get(Calendar.DAY_OF_MONTH));\nSystem.out.println(\"小时：\" + c.get(Calendar.HOUR));\nSystem.out.println(\"分钟：\" + c.get(Calendar.MINUTE));\nSystem.out.println(\"秒：\" + c.get(Calendar.SECOND));\n```\n\n### 8.1.3、第三代日期类LocalDate（JDK8）\n\n\n1. **Calendar日期类存在的问题？**\n\n（1）可变性，像日期和时间这样的类应该是不可变的\n（2）格式化，格式化只对Date有用，Calendar只能自己拼装\n（3）不是线程安全的；不能处理闰秒（每隔两天，多出一秒）等\n\n2. **基本概念**\n\nLocalDate：日期（年月日）\nLocalTime：包含时间（时分秒）\nLocalDateTime：包含日期+时间（年月日时分秒）\n\n```java\n//1. 使用 now() 返回表示当前日期时间的 对象\nLocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()\n//2. 使用 DateTimeFormatter 对象来进行格式化\nDateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nString format = dateTimeFormatter.format(ldt);\nSystem.out.println(\"格式化的日期=\" + format);\nSystem.out.println(\"年=\" + ldt.getYear());\nSystem.out.println(\"月=\" + ldt.getMonth());\nSystem.out.println(\"月=\" + ldt.getMonthValue());\nSystem.out.println(\"日=\" + ldt.getDayOfMonth());\nSystem.out.println(\"时=\" + ldt.getHour());\nSystem.out.println(\"分=\" + ldt.getMinute());\nSystem.out.println(\"秒=\" + ldt.getSecond());\nLocalDate now = LocalDate.now(); //可以获取年月日\nLocalTime now2 = LocalTime.now();//获取到时分秒\n// 3. 提供 plus 和 minus 方法可以对当前时间进行加或者减\n//看看 890 天后，是什么时候 把 年月日-时分秒\nLocalDateTime localDateTime = ldt.plusDays(890);\nSystem.out.println(\"890 天后=\" + dateTimeFormatter.format(localDateTime));\n//看看在 3456 分钟前是什么时候，把 年月日-时分秒\nLocalDateTime localDateTime2 = ldt.minusMinutes(3456);\nSystem.out.println(\"3456 分钟前 日期=\" + dateTimeFormatter.format(localDateTime2));\n```\n\n\n## 8.2、容器\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301540735.png)\n\n\n|名称|底层|线程安全性|扩容机制|备注|\n|--|--|--|--|--|\n|ArrayList|数组|线程不安全|首次创建长度为10，扩为1.5倍|查找快，增删慢|\n|Vector|数组|线程安全|首次创建长度为10，扩为1.5倍|查找快，增删慢|\n|LinkedList|双向链表|线程不安全|不主动扩容|增删快，查找慢|\n|HashSet|HashMap|线程不安全||可以存null|\n|LinkedHashSet|LinkedHashMap|线程不安全||可以存null|\n|TreeSet|TreeMap|线程不安全||不允许存null|\n|HashMap|数组+链表（jdk7） 数组+链表+红黑树 （jdk8）|线程不安全|首次创建长度16，扩容2倍,负载因子0.75|可以存nul|\n|LinkedHashMap|同hashmap|线程不安全|不主动扩容|可以存null|\n|HashTable|数组+链表|线程安全|首次创建时长度为11，扩容为2n+1|不能为null|\n|TreeMap|红黑树|线程不安全|TreeMap由红黑树实现，容量方面没有限制|不能为null 可以实现自然排序和定制排序 |\n\n### 8.2.1、hashmap原理\n\nhashmap数据结构是数组+链表+红黑树，HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对\n两个重要的方法put() get()\n（1）.put方法：调用key的hash方法得hash值，再与（数组长度-1）做与（&）运算，到这个元素在数组中的位置（即下标）如果该位置已经存在其它元素，那么在同一个位子上的元素将以链表的形式存放，通过equals方法依次比较链表中的key，相同则替换。不同则添加到表尾（1.8之前添加到表头）。\n（2）.get方法：调用key的hash方法得到这个元素在数组中的位置（即下标），然后通过key的equals方法在对应位置的链表中找到需要的元素。\n\n> （需要注意Jdk 1.8中对HashMap的实现做了优化,当链表长度大于8且数组长度超过64并之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)）\n> 如果数组长度不足64，优先会进行扩容\n\n### 8.2.2、自然排序和定制排序\n\n自然排序：实现Comparable接口，实现compareTo方法\n\n> 典型实现：String，Integer，Date等\n\n定制排序：当元素对象没有实现comparable接口，又不方便修改，可以考虑使用定制排序，直接在调用方排序\n\n\n```java\nCollections.sort(arrayList, new Comparator<Integer>() {\n        @Override\n        public int compare(Integer o1, Integer o2) {\n            return o1.compareTo(o2);\n        }\n});\n```\n\n\n## 8.3、String\n\n不可变性的理解：\n\n```java\nString s = \"abc\";    //(1)\nSystem.out.println(\"s = \" + s);\n \ns = \"123\";    //(2)\nSystem.out.println(\"s = \" + s);\n```\n\n![b6f0e64b3015ee2ebe2bd49b02c2a68.jpg|275](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270955924.jpg)\n\ns只是一个String对象的引用，并不是String对象本身。\n当执行(1)处这行代码之后，会先在方法区的运行时常量池创建一个String对象\"abc\"，然后在Java栈中创建一个String对象的引用s，并让s指向\"abc\"\n当执行完(2)处这行代码之后，会在方法区的运行时常量池创建一个新的String对象\"123\"，然后让引用s重新指向这个新的对象，而原来的对象\"abc\"还在内存中，并没有改变\n\n为什么这样设计？\n(1)、字符串常量池中的对象可能被很多对象引用，如果一个修改会导致所有对象的内容都变\n(2)、hashmap中key的hash方法只会调用一次然后缓存起来，如果key可变会导致缓存的结果和真实的计算结果不一致\n\n# 9、泛型\n## 9.1、基本概念\n\n（1）泛型：Java在jdk5引入了泛型，在没有泛型之前，每次从集合中读取的对象都必须进行类型转换，如果在插入对象时，类型出错，那么在运行时转换处理的阶段就会报错。在提出泛型之后就可以明确的指定集合接受哪些对象类型，编译器就能知晓并且自动为插入的代码进行泛化，在编译阶段告知是否插入类型错误的对象，程序会变得更加安全清晰。 \n（2）泛型擦除：Java泛型是伪泛型，因为Java代码在编译阶段，所有的泛型信息会被擦除，Java的泛型基本上都是在编辑器这个层次上实现的，在生成的字节码文件中是不包含泛型信息的，使用泛型的时候加上的类型，在编译阶段会被擦除掉，这个过程称为泛型擦除。\n\n为什么使用泛型？\n（1）保证类型安全：可以确保在编译时期检测到类型不匹配的错误，避免在运行时出现类型转换错误\n（2）消除强制转换：消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会\n\n## 9.2、泛型使用方式\n\n泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。\n\n> T是泛型中的类型参数声明，它表示一个占位符,通常用大写字母表示（例如 T、E、K、V 等），但实际上它只是一个占位符，可以根据需要自定义\n>\n>T：任意类型 type\n E：集合中元素的类型 element\n K：key-value形式 key\n V：key-value形式 value\n\n\n```java\n// 泛型类\npublic class Box<T> {\n    private T item;\n\n    public void setItem(T item) {\n        this.item = item;\n    }\n\n    public T getItem() {\n        return item;\n    }\n}\n// 泛型接口\npublic interface List<T> {\n    void add(T element);\n    T get(int index);\n    // ...\n}\n// 泛型方法\npublic class Utils {\n    public static <T> T getFirstElement(List<T> list) {\n        if (list != null && !list.isEmpty()) {\n            return list.get(0);\n        }\n        return null;\n    }\n}\n```\n\n\n## 9.3、泛型通配符\n\n泛型通配符是一种特殊的类型参数，用于在使用泛型时表示未知类型或限制类型范围\n\n```java\n// 1：表示类型参数可以是任何类型\npublic class Apple<?>{} \n// 2：表示类型参数必须是A或者是A的子类\npublic class Apple<T extends A>{} \n// 3: 表示类型参数必须是A或者是A的超类型\npublic class Apple<T supers A>{}\n```\n\n\n## 9.4、实现原理\n\n原码：\n\n```java\npublic class Caculate<T> {\n    private T num;\n}\n```\n\n编译后的代码：\n\n```java\npublic class Caculate{\n    public Caculate(){}\n    private Object num;\n}\n```\n\njava的泛型称为伪泛型，因为Java的泛型只是编译期的泛型，一旦编译成字节码，泛型就被擦除了，即在Java中使用泛型，我们无法在运行期知道泛型的类型，一旦编译成字节码，泛型将被取代为Object。\n在不使用泛型时，我们需要将Object手动转型成特定类型，而在使用泛型后，我们不需要自己转型，但实际上我们get到的对象仍然是Object类型的，只不过编译器会自动帮我们加入这个转型动作\n\n\n# 10、IO\n\n## 10.1、概述\n\n### 10.1.1、简介\n\nI（Input）O（Output）：中文翻译为输入输出，我们知道计算机的数据不管是软件、视频、音乐、游戏等最终都是存储在硬盘中的，当我们打开后，由CPU将硬盘中的数据读取到内存中来运行。这样一个过程就产生了I/O（输入/输出）\n>输入：硬盘 -> 内存\n>输出：内存 -> 硬盘\n### 10.1.2、IO流的分类\n\n按照操作数据单位不同分为：字节流（8bit）二进制文件，字符流（按字符）文本文件\n按数据流的流向不同分为：输入流，输出流\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1659662289021-93129478-8cc1-4d9c-82c9-932c15153a37.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=114&id=uf89be968&originHeight=167&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=154323&status=done&style=none&taskId=u5d128cf6-4c3f-4321-a117-49823508580&title=&width=567)\n\n> java的IO流共涉及40多个类，都是从如上4个抽象基类派生\n\n\n![IO流体系](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251511757.png)\n\n## 10.2、字节流\n\n### 10.2.1、字节输出流\n\nOutputStream是所有字节输出的顶层父类，该父类提供如下公共方法：\n\n#### 10.2.1.1、FileOutputStream\nFileOutputStream是OutputStream中一个常用的子类，他可以关联一个文件，用于将数据写出到文件\n\n>构造方法：\n>public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。\n public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。\n\n\n```java\npublic class IOTest {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"000.txt\");\n        // 字符串转换为字节数组\n        byte[] b = \"abcde\".getBytes();\n        // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b,2,2);\n        // 关闭资源\n        fos.close();\n    }\n}\n\n```\n\n>需要注意的是，在UTF-8编码下，一个中文占用3个字节，GBK编码下一个中文占用2个字节，因此在使用字节流来精确操作字符数据时将会变得非常麻烦\n\n### 10.2.2、字节输入流\n#### 10.2.2.1、FileInputStream\njava.io.FileInputStream类是文件输入流，从文件中读取字节\n\n>构造方法：\n>FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。\n FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。\n\n```java\npublic class IOTest {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象.\n        FileInputStream fis = new FileInputStream(\"abc.txt\"); // 文件中为abcde\n        // 定义变量，作为有效个数\n        int len;\n        // 定义字节数组，作为装字节数据的容器\n        byte[] b = new byte[2];\n        // 循环读取\n        while ((len = fis.read(b)) != -1) {\n            // 每次读取后,把数组的有效字节部分，变成字符串打印\n            System.out.println(new String(b, 0, len));//  len 每次读取的有效字节个数\n        }\n        // 关闭资源\n        fis.close();\n    }\n}\n```\n\n\n## 10.3、字符流\n\n计算机都是按照字节进行存储的，我们之前学习过编码表，通过编码表可以将字节转换为对应的字符，但是世界上有非常多的编码表，不同的编码表规定的单个字符所占用的字节可能都不一样，例如在GBK编码表中一个中文占2个字节，UTF8编码表则占3个字节；且一个中文字符都是由多个字节组成的，为此我们不能再基于字节的操作单位来操作文本文件了，因为这样太过麻烦，我们希望基于字符来操作文件，一次操作读取一个“字符”而不是一个“字节”，这样在操作文本文件时非常便捷\n\n### 10.3.1、字符输出流\n#### 10.3.1.1、FileWriter类\n\njava.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区\n\n```java\npublic class Demo03_写出字符数组 {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"002.txt\");\n        // 字符串转换为字节数组\n        char[] chars = \"我是中国人\".toCharArray();\n        // 写出字符数组\n        fw.write(chars); // 我是中国人\n        // 写出从索引2开始，2个字节。索引2是'中'，两个字节，也就是'中国'。\n        fw.write(chars,2,2); // 中国\n        // 关闭资源\n        fw.close();\n    }\n}\n```\n\n### 10.3.2、字符输入流\n#### 10.3.2.1、FileReader类\n\njava.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区\n\n> Windows系统的中文编码默认是GBK编码表。idea中默认是UTF-8 \n\n```java\npublic class IoTest {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileReader fr = new FileReader(\"001.txt\");\n        // 定义变量，保存数据\n        int data;\n        // 循环读取\n        while ((data = fr.read()) != -1) {\n            // 以数值的方式输出\n//            System.out.println(b);\n            // 以字符的方式输出\n            System.out.println((char) data);\n        }\n        // 关闭资源\n        fr.close();\n    }\n}\n```\n\n\n# 11、反射\n## 11.1、概述\n\n### 11.1.1、基本概念\nJava反射是指在运行时动态地获取类的信息并操作类或对象的能力。它提供了一组API，使得可以在运行时检查类、接口、字段和方法，并且可以在运行时实例化对象、调用方法、获取和设置字段的值\n\n### 11.1.2、好处\n\n1. 运行时类信息：反射允许在运行时获取类的信息，包括类的名称、字段、方法、注解等。这使得可以动态地了解和操作类的结构，从而实现更加灵活和通用的代码设计。\n2. 动态创建对象：通过反射可以在运行时动态地实例化对象，而不需要在编译时明确知道类的类型。这对于根据配置文件或用户输入来创建对象非常有用，可以实现更大程度的灵活性和可配置性。\n3. 动态调用方法：反射可以在运行时动态地调用类的方法，包括公共方法、私有方法和静态方法。这对于实现插件机制、扩展性和动态逻辑非常有用，可以根据运行时条件来调用不同的方法。\n4. 访问私有成员：反射可以绕过访问权限限制，访问类的私有成员。这对于测试、调试和特定场景下的操作非常有用，但也需要小心使用，以遵循封装原则。\n5. 序列化和反序列化：反射在序列化和反序列化过程中起着重要的作用。通过反射可以分析对象的结构，并将其转换为字节流或从字节流中重建对象\n\n## 11.2、 获取Class对象的方式\n\n1. Class.forName(\"全类名\")：将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类\n2.  类名.class：通过类名的属性class获取，多用于参数的传递 \n3. 对象.getClass()：getClass()方法在Object类中定义着\n\n> 同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。\n\n\n## 11.3、Class对象功能\n\n1. 获取成员变量\n\n```java\nField[] getFields() ：获取所有public修饰的成员变量\nField getField(String name)   获取指定名称的 public修饰的成员变量\nField[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符\nField getDeclaredField(String name)  \n```\n\n2. 获取构造方法\n\n```java\nConstructor<?>[] getConstructors()  返回public修饰的构造方法\nConstructor<T> getConstructor(类<?>... parameterTypes)  \nConstructor<T> getDeclaredConstructor(类<?>... parameterTypes)  \nConstructor<?>[] getDeclaredConstructors()  返回所有的构造方法\n```\n\n3. 获取成员方法\n\n```java\nMethod[] getMethods()  \nMethod getMethod(String name, 类<?>... parameterTypes)  \nMethod[] getDeclaredMethods()  \nMethod getDeclaredMethod(String name, 类<?>... parameterTypes)  \n```\n\n4. 获取全类名\n\n```java\nString getName()  \n```\n## 11.4、Field 成员变量\n\n```java\n1. 设置值\n\tvoid set(Object obj, Object value)  \n2. 获取值\n\tget(Object obj) \n3. 忽略访问权限修饰符的安全检查\n\tsetAccessible(true):暴力反射\n```\n## 11.5、Constructor 构造方法\n\n```java\nT newInstance(Object... initargs)  \n如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法\n```\n\n## 11.6、Method 方法对象\n\n```java\n1. 执行方法：\n\tObject invoke(Object obj, Object... args)  \n2. 获取方法名称：\n\tString getName:获取方法名\n```\n\n\n# 12、异常\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301636988.png)\n\n\nError：错误，无法被处理的\n\nException：异常，能够被程序本身处理的，可以通过try…catch语句捕捉异常，或者是throws抛出异常。分为运行时异常和非运行时异常\n- 运行时异常：就是RuntimeException，编译时不会检查出错误的。一般是由于逻辑错误引起的，程序员可以手动去解决的，比如判空等。\n- 非运行时异常：也叫编译异常，就是Exception下除了RuntimeException以外的异常。是必须进行处理的异常，编译器会进行异常提醒的。如果不进行处理，程序编译不通过\n\n\n# 13、日志\n## 13.1、基本概念\n\n![image (26).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270851142.png)\n\n> 常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。\n\n## 13.2、java日志演化历史\n\n（1）最开始出现的是 log4j，也是应用最广泛的日志系统，作者是 Ceki Gülcü，开始时，一切都是美好的。\n（2）但 java 的开发主体 Sun 公司认为自己才是正统，为了干掉 log4j，在 jdk1.4 中增加了 jul（因为在 java.util.logging 包下）日志的实现，造成了目前开发者的混乱，迄今为止仍饱受诟病。\n（3）各个日志系统互相没有关联，替换和统一变的非常麻烦。A 项目用 log4j 作为日志系统，但同时引了 B 项目，而 B 项目用 jul 作为日志系统，那么你的应用就得使用两个日志系统。\n（4）为了搞定这个坑爹的问题，开源社区 apache 提供了一个日志框架作为日志的抽象，叫 commons-logging，也被称为 jcl（java common logging），jcl 对各种日志接口进行抽象，抽象出一个接口层，对每个日志实现都适配或者桥接，这样这些提供给别人的库都直接使用抽象层即可，较好的解决了上述问题。\n（5）当年 Apache 说服 log4j 以及其他的日志来按照 commons-logging 的标准编写，但是由于 commons-logging 的类加载有点问题，实现起来也不友好，作为元老级日志 log4j 的作者再度出山，搞出了一个更加牛逼的新的日志框架 slf4j（这个也是抽象层），同时针对 slf4j 的接口实现了一套日志系统，即传说中的 logback。\n（6）同时这个作者心情一好，又把 log4j 进行了改造，就是所谓的 log4j2，同时支持 jcl 以及 slf4j。","slug":"java core","published":1,"updated":"2023-10-31T15:26:55.107Z","_id":"cloe5sr9i000700ujhjckbl9w","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1、Java概述\"><a href=\"#1、Java概述\" class=\"headerlink\" title=\"1、Java概述\"></a>1、Java概述</h1><h2 id=\"1-1、java特点\"><a href=\"#1-1、java特点\" class=\"headerlink\" title=\"1.1、java特点\"></a>1.1、java特点</h2><ol>\n<li>Java 语言是面向对象的(oop) </li>\n<li>Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证</li>\n<li>Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]</li>\n<li>java是一种半编译，半解释型语言。 . Java–&gt;. class是由 Javac 编译，这个过程符合编译型语言的特点。而. class–&gt;对应平台机器码 的这一过程 是由Java解释执行</li>\n</ol>\n<p> </p>\n<h1 id=\"2、变量\"><a href=\"#2、变量\" class=\"headerlink\" title=\"2、变量\"></a>2、变量</h1><h2 id=\"2-1、java基本数据类型\"><a href=\"#2-1、java基本数据类型\" class=\"headerlink\" title=\"2.1、java基本数据类型\"></a>2.1、java基本数据类型</h2><p>java基本数据类型 - 四类八种</p>\n<ol>\n<li><strong>整型</strong></li>\n</ol>\n<p>byte 、short 、int 、long</p>\n<ol start=\"2\">\n<li><strong>浮点型</strong></li>\n</ol>\n<p>float 、 double</p>\n<ol start=\"3\">\n<li><strong>字符型</strong></li>\n</ol>\n<p>char</p>\n<ol start=\"4\">\n<li><strong>布尔型</strong></li>\n</ol>\n<p>boolean</p>\n<table>\n<thead>\n<tr>\n<th>数据类型名称</th>\n<th>占用字节</th>\n<th>范围</th>\n<th>封装器类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte（字节型）</td>\n<td>1</td>\n<td>-（2^7）<del>2^7-1（-128</del>127）</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>shot（短整型）</td>\n<td>2</td>\n<td>-（2^15）<del>2^15-1(-32768</del>32767)</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>int（整形）</td>\n<td>4</td>\n<td>-（2^31）<del>2^31-1（-2147483648</del>2147483647）</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long（长整型）</td>\n<td>8</td>\n<td>-（2^63）~2^63-1</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float（浮点型）</td>\n<td>4</td>\n<td>-3.403E8~3.403E38</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double（双精度浮点型）</td>\n<td>8</td>\n<td>-1.798E308~1.798E308</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>boolean（布尔型）</td>\n<td>1</td>\n<td></td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>char（字符型）</td>\n<td>2</td>\n<td></td>\n<td><strong>Character</strong></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：计算机的数值是用二进制补码表示的，二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1</p>\n</blockquote>\n<h2 id=\"2-2、基本数据类型转换\"><a href=\"#2-2、基本数据类型转换\" class=\"headerlink\" title=\"2.2、基本数据类型转换\"></a>2.2、基本数据类型转换</h2><h3 id=\"2-2-1、自动类型转换\"><a href=\"#2-2-1、自动类型转换\" class=\"headerlink\" title=\"2.2.1、自动类型转换\"></a>2.2.1、自动类型转换</h3><p>当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换<br>精度由小到大排序：</p>\n<p>byte short int long float double</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//自动类型转换细节</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AutoConvertDetail</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//细节 1： 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>; <span class=\"comment\">//ok</span></span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1 + <span class=\"number\">1.1</span>;<span class=\"comment\">//错误 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1 + <span class=\"number\">1.1</span>;<span class=\"comment\">//对 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1 + <span class=\"number\">1.1F</span>;<span class=\"comment\">//对 n1 + 1.1 =&gt; 结果类型是 float</span></span><br><span class=\"line\">    <span class=\"comment\">//细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，就会报错，反之就会进行自动类型转换。</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> <span class=\"number\">1.1</span>;<span class=\"comment\">//错误 double -&gt; int</span></span><br><span class=\"line\">    <span class=\"comment\">//细节 3: (byte, short) 和 char 之间不会相互自动转换</span></span><br><span class=\"line\">     <span class=\"type\">byte</span> <span class=\"variable\">b1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>; <span class=\"comment\">//对 , -128-127</span></span><br><span class=\"line\">     <span class=\"type\">char</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> b1; <span class=\"comment\">//错误， 原因 byte 不能自动转成 char</span></span><br><span class=\"line\">    <span class=\"comment\">//细节 4：自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型</span></span><br><span class=\"line\">    <span class=\"type\">byte</span> <span class=\"variable\">b4</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">short</span> <span class=\"variable\">s3</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num200</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"variable\">num300</span> <span class=\"operator\">=</span> <span class=\"number\">1.1F</span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"variable\">num500</span> <span class=\"operator\">=</span> b4 + s3 + num200 + num300; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>floatf&#x3D;3.4;是否正确？<br>不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换floatf&#x3D;(float)3.4;或者写成floatf&#x3D;3.4F;</p>\n</blockquote>\n<h3 id=\"2-2-2、强制类型转换\"><a href=\"#2-2-2、强制类型转换\" class=\"headerlink\" title=\"2.2.2、强制类型转换\"></a>2.2.2、强制类型转换</h3><p>将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符( )，但可能造成精度降低或溢出,格外要注意。</p>\n<h3 id=\"2-2-3、基本数据类型和String转换\"><a href=\"#2-2-3、基本数据类型和String转换\" class=\"headerlink\" title=\"2.2.3、基本数据类型和String转换\"></a>2.2.3、基本数据类型和String转换</h3><ol>\n<li>基本数据类型转String类型</li>\n</ol>\n<p>（1）将基本类型的值加 “” 即可<br>（2）String.valueOf(基本数据类型)</p>\n<ol start=\"2\">\n<li>String转基本数据类型</li>\n</ol>\n<p>（1）基本类型包装类调用parseXX方法即可</p>\n<h1 id=\"3、运算符\"><a href=\"#3、运算符\" class=\"headerlink\" title=\"3、运算符\"></a>3、运算符</h1><h2 id=\"4-1、算数运算符\"><a href=\"#4-1、算数运算符\" class=\"headerlink\" title=\"4.1、算数运算符\"></a>4.1、算数运算符</h2><p>算数运算符是对数值变量进行运算的，在java程序种使用非常多</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231601761.png\" alt=\"java算数运算符\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 题目1</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">i = i++; <span class=\"comment\">// 规则会使用临时变量(1)temp=i(2)i=i+1(3)i=temp</span></span><br><span class=\"line\">System.out.println(i); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 题目2</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">i = ++i; <span class=\"comment\">// 规则会使用临时变量(1)i=i+1(2)temp=i(3)i=temp</span></span><br><span class=\"line\">System.out.println(i); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2、关系运算符\"><a href=\"#4-2、关系运算符\" class=\"headerlink\" title=\"4.2、关系运算符\"></a>4.2、关系运算符</h2><p>关系运算符的结果都是boolean型，也就是要么是true，要么是false</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231605071.png\" alt=\"java关系运算符\"></p>\n<h2 id=\"4-3、逻辑运算符\"><a href=\"#4-3、逻辑运算符\" class=\"headerlink\" title=\"4.3、逻辑运算符\"></a>4.3、逻辑运算符</h2><p>用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231608353.png\" alt=\"逻辑运算符\"></p>\n<blockquote>\n<p>  a^b: 叫逻辑异或  ：当 a 和 b 不同时，则结果为 true, 否则为 false<br>  &amp;&amp;短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高<br>  &amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低  </p>\n</blockquote>\n<h2 id=\"4-4、赋值运算符\"><a href=\"#4-4、赋值运算符\" class=\"headerlink\" title=\"4.4、赋值运算符\"></a>4.4、赋值运算符</h2><p>基本赋值运算符 &#x3D; （ int a &#x3D; 10;）<br>复合赋值运算符 +&#x3D; ，-&#x3D; ，*&#x3D; ， &#x2F;&#x3D; ，%&#x3D; 等</p>\n<h2 id=\"4-5、三元运算符\"><a href=\"#4-5、三元运算符\" class=\"headerlink\" title=\"4.5、三元运算符\"></a>4.5、三元运算符</h2><p>条件表达式 ? 表达式 1: 表达式 2; </p>\n<ol>\n<li>如果条件表达式为 true，运算后的结果是表达式 1；</li>\n<li>如果条件表达式为 false，运算后的结果是表达式 2；</li>\n</ol>\n<h2 id=\"4-6、进制转换（为位运算准备）\"><a href=\"#4-6、进制转换（为位运算准备）\" class=\"headerlink\" title=\"4.6、进制转换（为位运算准备）\"></a>4.6、进制转换（为位运算准备）</h2><p>对于整数，有四种表示方式：<br>二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。<br>十进制：0-9 ，满 10 进 1。<br>八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。<br>十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231612057.png\" alt=\"进制转换\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1659315826387-ed7e7bab-8366-4fd2-8353-b82acde62fa2.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=243&id=uc4b6c469&originHeight=470&originWidth=664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126331&status=done&style=none&taskId=u69461551-0d4d-415e-bdd3-fb02621b29f&title=&width=343\" alt=\"image.png\"></p>\n<h3 id=\"4-6-1、其它进制转十进制\"><a href=\"#4-6-1、其它进制转十进制\" class=\"headerlink\" title=\"4.6.1、其它进制转十进制\"></a>4.6.1、其它进制转十进制</h3><ol>\n<li>二进制转十进制</li>\n</ol>\n<p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和</p>\n<blockquote>\n<p>案例：将ob1011转成十进制数<br>1+2+8&#x3D;11</p>\n</blockquote>\n<ol start=\"2\">\n<li>八进制转十进制</li>\n</ol>\n<p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和</p>\n<blockquote>\n<p>案例：0234转成十进制<br>4*1+3*8+2*64&#x3D;156</p>\n</blockquote>\n<ol start=\"3\">\n<li>十六进制转十进制</li>\n</ol>\n<p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和</p>\n<blockquote>\n<p>案例：0x23A<br>10*1+3*16+2*512&#x3D;570</p>\n</blockquote>\n<h3 id=\"4-6-2、十进制转其他进制\"><a href=\"#4-6-2、十进制转其他进制\" class=\"headerlink\" title=\"4.6.2、十进制转其他进制\"></a>4.6.2、十进制转其他进制</h3><ol>\n<li>十进制转二进制</li>\n</ol>\n<p>规则：将该数不断除以2.直到商为0为止，然后将每步余数倒过来，就是对应二进制</p>\n<blockquote>\n<p>案例：34转为对应二进制 &#x3D; 0B00100010</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231618617.png\" alt=\"十进制转二进制\"></p>\n<ol start=\"2\">\n<li>十进制转八进制</li>\n</ol>\n<p>规则：将该数不断除以8.直到商为0为止，然后将每步余数倒过来，就是对应二进制</p>\n<blockquote>\n<p>案例：131转为8进制</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231620590.png\" alt=\"十进制转八进制\"></p>\n<h3 id=\"4-6-3、二进制转其它进制\"><a href=\"#4-6-3、二进制转其它进制\" class=\"headerlink\" title=\"4.6.3、二进制转其它进制\"></a>4.6.3、二进制转其它进制</h3><ol>\n<li>二进制转八进制</li>\n</ol>\n<p>规则：从低位开始，将二进制数每三位一组，转成对应的八进制</p>\n<blockquote>\n<p>案例：0b11010101转成八进制<br>0325</p>\n</blockquote>\n<ol start=\"2\">\n<li>二进制转十六进制</li>\n</ol>\n<p>规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可</p>\n<blockquote>\n<p>案例：0b11010101转成十六进制<br>D5</p>\n</blockquote>\n<h3 id=\"4-6-4、其它进制转二进制\"><a href=\"#4-6-4、其它进制转二进制\" class=\"headerlink\" title=\"4.6.4、其它进制转二进制\"></a>4.6.4、其它进制转二进制</h3><ol>\n<li>八进制转二进制</li>\n</ol>\n<p>规则：将八进制数每1位。转成对应的一个3位的二进制数即可</p>\n<blockquote>\n<p>案例：将0237转成二进制<br>0b10011111</p>\n</blockquote>\n<ol start=\"2\">\n<li>十六进制转二进制</li>\n</ol>\n<p>规则：将十六进制数每1位。转成对应的一个4位的二进制数即可</p>\n<blockquote>\n<p>案例：请将0x23B转成二进制<br>0b001000111011</p>\n</blockquote>\n<h2 id=\"4-7、位运算符\"><a href=\"#4-7、位运算符\" class=\"headerlink\" title=\"4.7、位运算符\"></a>4.7、位运算符</h2><h3 id=\"4-6-1、原码反码补码\"><a href=\"#4-6-1、原码反码补码\" class=\"headerlink\" title=\"4.6.1、原码反码补码\"></a>4.6.1、原码反码补码</h3><ol>\n<li>进制的最高位是符号位: 0表示正数1表示负数</li>\n<li>正数的原码，反码，补码都一样</li>\n<li>负数的反码&#x3D;它的原码符号位不变，其它位取反.负数的补码&#x3D;它的反码+1</li>\n<li>0的反码，补码都是0</li>\n<li>在计算机运算的时候，都是以补码的方式来运算的</li>\n<li>补码的补码就是原码</li>\n</ol>\n<blockquote>\n<p>为什么计算机通过补码进行运算？<br>通过使用补码，无需单独的符号位判断来执行加法和减法运算。计算机可以直接对补码进行位运算，而不需要额外的逻辑电路来处理符号位</p>\n</blockquote>\n<h3 id=\"4-6-2、位运算\"><a href=\"#4-6-2、位运算\" class=\"headerlink\" title=\"4.6.2、位运算\"></a>4.6.2、位运算</h3><p>java种有7个位运算 &amp;（按位与）,|（按位或）,^（按位异或）,~（按位取反），&lt;&lt;（左移），&gt;&gt;（带符号右移），&gt;&gt;&gt;（无符号右移）</p>\n<h4 id=\"4-6-2-1、-（按位与）\"><a href=\"#4-6-2-1、-（按位与）\" class=\"headerlink\" title=\"4.6.2.1、&amp; （按位与）\"></a>4.6.2.1、&amp; （按位与）</h4><p>两位全为1，结果为1，否则为0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  10  (2)</span></span><br><span class=\"line\"><span class=\"section\">&amp; 11  (3)</span></span><br><span class=\"line\"><span class=\"section\">------</span></span><br><span class=\"line\"><span class=\"code\">  10  (2)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-2、-（按位或）\"><a href=\"#4-6-2-2、-（按位或）\" class=\"headerlink\" title=\"4.6.2.2、|（按位或）\"></a>4.6.2.2、|（按位或）</h4><p>两位一个为1，结果为1，否则为0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  10  (2)</span></span><br><span class=\"line\"><span class=\"section\">| 11  (3)</span></span><br><span class=\"line\"><span class=\"section\">------</span></span><br><span class=\"line\"><span class=\"code\">  11  (3)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-3、-（按位异或）\"><a href=\"#4-6-2-3、-（按位异或）\" class=\"headerlink\" title=\"4.6.2.3、 ^（按位异或）\"></a>4.6.2.3、 ^（按位异或）</h4><p>两位一个为0，结果为1，否则为0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  10  (2)</span></span><br><span class=\"line\"><span class=\"section\">^ 11  (3)</span></span><br><span class=\"line\"><span class=\"section\">------</span></span><br><span class=\"line\"><span class=\"code\">  01  (1)</span></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"4-6-2-4、-（按位取反）\"><a href=\"#4-6-2-4、-（按位取反）\" class=\"headerlink\" title=\"4.6.2.4、~（按位取反）\"></a>4.6.2.4、~（按位取反）</h4><p>0-&gt;1, 1-&gt;0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~2 </span><br><span class=\"line\">原码：00000010</span><br><span class=\"line\">按位取反：11111101</span><br><span class=\"line\">补码表示：10000011 = 3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-5、-（算数右移）\"><a href=\"#4-6-2-5、-（算数右移）\" class=\"headerlink\" title=\"4.6.2.5、&gt;&gt;（算数右移）\"></a>4.6.2.5、&gt;&gt;（算数右移）</h4><p>低位溢出，符号位不变，并用符号位补溢出的高位</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &gt;&gt; 2</span><br><span class=\"line\">1的补码：00000001</span><br><span class=\"line\">右移两位，并用符号位填充：00000000</span><br><span class=\"line\">原码结果为：0</span><br><span class=\"line\"></span><br><span class=\"line\">-1 &gt;&gt; 2</span><br><span class=\"line\">-1的补码：11111111</span><br><span class=\"line\">右移两位，并用符号位填充：11111111</span><br><span class=\"line\">原码结果为：100000001 = -1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-6、-（算数左移）\"><a href=\"#4-6-2-6、-（算数左移）\" class=\"headerlink\" title=\"4.6.2.6、&gt;&gt; （算数左移）\"></a>4.6.2.6、&gt;&gt; （算数左移）</h4><p>符号位不变，低位补0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;&lt; 2</span><br><span class=\"line\">0001 &lt;&lt; 2 = 0100 = 4</span><br><span class=\"line\"></span><br><span class=\"line\">-1 &lt;&lt; 3</span><br><span class=\"line\">11111111 &lt;&lt; 3 = 11111000</span><br><span class=\"line\">原码结果为：10001000 = -8</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-7、-（逻辑右移-或叫-无符号右移）\"><a href=\"#4-6-2-7、-（逻辑右移-或叫-无符号右移）\" class=\"headerlink\" title=\"4.6.2.7、&gt;&gt;&gt; （逻辑右移 或叫 无符号右移）\"></a>4.6.2.7、&gt;&gt;&gt; （逻辑右移 或叫 无符号右移）</h4><p>低位溢出，高位补0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8 &gt;&gt;&gt; 2</span><br><span class=\"line\">1000 &gt;&gt;&gt; 2 = 0010 = 2</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、面向对象\"><a href=\"#4、面向对象\" class=\"headerlink\" title=\"4、面向对象\"></a>4、面向对象</h1><h2 id=\"4-1、面向对象三大特征\"><a href=\"#4-1、面向对象三大特征\" class=\"headerlink\" title=\"4.1、面向对象三大特征\"></a>4.1、面向对象三大特征</h2><h3 id=\"4-1-1、封装\"><a href=\"#4-1-1、封装\" class=\"headerlink\" title=\"4.1.1、封装\"></a>4.1.1、封装</h3><p><strong>封装</strong>：尽量避免向外部暴露实现细节，只提供个别接口让使用方调用，降低耦合性。这样做的话，当自身的逻辑发生变化时，不会破坏使用方的逻辑，或是强制使用方修改自身的逻辑，而是只需要修改自身的代码就可以了</p>\n<h3 id=\"4-1-2、继承\"><a href=\"#4-1-2、继承\" class=\"headerlink\" title=\"4.1.2、继承\"></a>4.1.2、继承</h3><p><strong>继承</strong>：子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法。以降低代码编写的冗余度</p>\n<h3 id=\"4-1-3、多态\"><a href=\"#4-1-3、多态\" class=\"headerlink\" title=\"4.1.3、多态\"></a>4.1.3、多态</h3><p><strong>多态</strong>：父类的引用指向子类的对象。它的意义是可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，而这些方法通过一个抽象类或者接口来实现，多态就是提供父类调用子类代码的一个手段而已</p>\n<h2 id=\"4-2、内部类\"><a href=\"#4-2、内部类\" class=\"headerlink\" title=\"4.2、内部类\"></a>4.2、内部类</h2><p>如果定义类在局部位置(方法中&#x2F;代码块) :(1) 局部内部类 (2) 匿名内部类<br>如果定义在成员位置 (1) 成员内部类 (2) 静态内部类  </p>\n<h3 id=\"4-2-1、局部内部类\"><a href=\"#4-2-1、局部内部类\" class=\"headerlink\" title=\"4.2.1、局部内部类\"></a>4.2.1、局部内部类</h3><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名数据</p>\n<blockquote>\n<p>说明：</p>\n<ol>\n<li>可以直接访问外部类的所有成员，包括私有</li>\n<li>不能添加访问修饰符，因为他就是一个局部变量，局部变量不能使用修饰符</li>\n<li>作用域：仅在定义它的方法或代码块中</li>\n<li>局部内部类访问外部类的成员：直接访问。外部类访问局部内部类的成员，创建对象再访问</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">outerData</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">localVar</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">LocalInnerClass</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;访问外部类数据：&quot;</span> + outerData);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;访问局部变量：&quot;</span> + localVar);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">LocalInnerClass</span> <span class=\"variable\">innerObj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LocalInnerClass</span>();</span><br><span class=\"line\">        innerObj.innerMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">OuterClass</span> <span class=\"variable\">outerObj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OuterClass</span>();</span><br><span class=\"line\">        outerObj.outerMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-2、匿名内部类\"><a href=\"#4-2-2、匿名内部类\" class=\"headerlink\" title=\"4.2.2、匿名内部类\"></a>4.2.2、匿名内部类</h3><p>匿名内部类是一种没有显式定义类名的内部类，定义在外部类的局部位置，比如方法中，它通常用于创建实现某个接口或继承某个类的匿名对象</p>\n<blockquote>\n<p>说明：</p>\n<ol>\n<li>匿名内部类运行类型：外部类名称$1</li>\n</ol>\n</blockquote>\n<ol>\n<li>基于接口的匿名内部类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 编译类型为IA，运行类型为匿名内部类Outer$1</span></span><br><span class=\"line\">       <span class=\"comment\">// jdk 底层在创建匿名内部类 Outer$1,立即马上就创建了 Outer$1 实例，并且把地址返回给 tiger</span></span><br><span class=\"line\">\t    <span class=\"type\">IA</span> <span class=\"variable\">tiger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IA</span>() &#123;</span><br><span class=\"line\">\t        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">\t            System.out.println(<span class=\"string\">&quot;老虎叫...&quot;</span>); </span><br><span class=\"line\">\t        &#125; </span><br><span class=\"line\">\t    &#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>基于类的匿名内部类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// father 编译类型 Father, father 运行类型 Outer$1</span></span><br><span class=\"line\">\t    <span class=\"type\">Father</span> <span class=\"variable\">father</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Father</span>(<span class=\"string\">&quot;jack&quot;</span>)&#123;</span><br><span class=\"line\">\t        <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t            System.out.println(<span class=\"string\">&quot;匿名内部类重写了 test 方法&quot;</span>);</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-2-3、成员内部类\"><a href=\"#4-2-3、成员内部类\" class=\"headerlink\" title=\"4.2.3、成员内部类\"></a>4.2.3、成员内部类</h3><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p>\n<blockquote>\n<p>说明：</p>\n<ol>\n<li>可以直接访问外部类的所有成员，包括私有的</li>\n<li>可以添加任何修饰符，因为它的地位就是一个成员</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    Outer08.<span class=\"type\">Inner08</span> <span class=\"variable\">inner08Instance</span> <span class=\"operator\">=</span> outer08.getInner08Instance();</span><br><span class=\"line\">    inner08Instance.say();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer08</span> &#123; <span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Inner08</span> &#123;<span class=\"comment\">//成员内部类</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//可以直接访问外部类的所有成员，包含私有的</span></span><br><span class=\"line\">            <span class=\"comment\">//如果成员内部类的成员和外部类的成员重名，会遵守就近原则. </span></span><br><span class=\"line\">            <span class=\"comment\">//可以通过 外部类名.this.属性 来访问外部类的成员</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n1 = &quot;</span> + n1 + <span class=\"string\">&quot; name = &quot;</span> + name + <span class=\"string\">&quot; 外部类的 n1=&quot;</span> + Outer08.<span class=\"built_in\">this</span>.n1);</span><br><span class=\"line\">            hi();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-4、静态内部类\"><a href=\"#4-2-4、静态内部类\" class=\"headerlink\" title=\"4.2.4、静态内部类\"></a>4.2.4、静态内部类</h3><p>成员内部类是定义再外部类的成员位置，有static修饰</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    Outer10.<span class=\"type\">Inner10</span> <span class=\"variable\">inner10</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer10</span>.Inner10();</span><br><span class=\"line\">    inner10.say();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer10</span> &#123; <span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Inner10</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;卡卡&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            cry();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3、重载和重写\"><a href=\"#4-3、重载和重写\" class=\"headerlink\" title=\"4.3、重载和重写\"></a>4.3、重载和重写</h2><p><strong>重载</strong>发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载<br><strong>重写</strong>，子类重写父类方法，返回值（JDK7以后，被重写的方法返回值类型可以不同，但是必须是父类返回值的派生类）和形参都不能改变</p>\n<blockquote>\n<p>不能根据返回类型来区分重载<br>float max(int a, int b);<br>int max(int a, int b);<br>上面两个方法名称和参数都一致，如果在同一个类中，别的地方调用的时候都是max（1，2），不能区分出想调用哪个方法</p>\n</blockquote>\n<h2 id=\"4-4、抽象类和接口\"><a href=\"#4-4、抽象类和接口\" class=\"headerlink\" title=\"4.4、抽象类和接口\"></a>4.4、抽象类和接口</h2><p>1、接口的设计目的，是对类的行为进行约束。也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制<br>2、而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为。可以在抽象类中实现这种行为。这样它所有的子类就无需重复实现。达到代码复用的目的</p>\n<h2 id=\"4-5、Object类常用方法\"><a href=\"#4-5、Object类常用方法\" class=\"headerlink\" title=\"4.5、Object类常用方法\"></a>4.5、Object类常用方法</h2><ol>\n<li>hashcode（）：将对象的16进制地址值，经过hash算法换算成整值</li>\n<li>toString（）：返回该对象的字符串对象</li>\n<li>equals（）：比较两个对象的地址值是否相同</li>\n<li>clone（）：实现对象的浅拷贝</li>\n<li>getclass（）：获取该对象的字节码文件（该对象运行时的类）Class</li>\n<li>wait（）notify（）notifyAll（）：wait（）让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法</li>\n</ol>\n<blockquote>\n<p>void notify()：唤醒一个正在等待该对象的线程。<br>  void notifyAll()：唤醒所有正在等待该对象的线程</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>equals()没有被重写的情况下等同于 &#x3D;&#x3D;<br>  Object的equals()方法源码：<br> public boolean equals(Object obj) {<br> return (this &#x3D;&#x3D; obj);<br> }<br>  这用情况&#x3D; &#x3D;和equals（）都是引用比较 </li>\n<li>string重写了Object的equals（）方法这种情况equals（）是值比较</li>\n</ol>\n</blockquote>\n<h2 id=\"4-6、深拷贝和浅拷贝\"><a href=\"#4-6、深拷贝和浅拷贝\" class=\"headerlink\" title=\"4.6、深拷贝和浅拷贝\"></a>4.6、深拷贝和浅拷贝</h2><p><strong>浅拷贝</strong>：基本数据类型复制值，引用数据类型复制地址，即拷贝出来的对象与被拷贝出来的对象中的引用的对象是同一个（java默认）：clone方法<br><strong>深拷贝</strong>：基本数据类型复制值，引用数据类型，创建一个新的对象，并复制其内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用对象序列化来实现克隆</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Room</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">    Desk desk;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Room <span class=\"title function_\">deepClone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        <span class=\"comment\">//序列化</span></span><br><span class=\"line\">        <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">outputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">objectOutputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(outputStream);</span><br><span class=\"line\">        objectOutputStream.writeObject(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//反序列化</span></span><br><span class=\"line\">        <span class=\"type\">ByteArrayInputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(outputStream.toByteArray());</span><br><span class=\"line\">        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">objectInputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(inputStream);</span><br><span class=\"line\">        <span class=\"type\">Room</span> <span class=\"variable\">roomClone</span> <span class=\"operator\">=</span> (Room)objectInputStream.readObject();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roomClone;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-7、面向对象和面向过程的理解\"><a href=\"#4-7、面向对象和面向过程的理解\" class=\"headerlink\" title=\"4.7、面向对象和面向过程的理解\"></a>4.7、面向对象和面向过程的理解</h2><p>是两种不同的处理问题的角度。面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做什么</p>\n<blockquote>\n<p>比如：洗衣机洗衣服<br>  <strong>面向过程</strong>：会将任务拆解成一系列的步骤（函数），1、打开洗衣机 2、放衣服3、放洗衣粉4、清洗 5、烘干<br>  <strong>面向对象</strong>：会拆出人和洗衣机两个对象：人：打开洗衣机，放衣服，放洗衣粉 洗衣机：清洗，烘干</p>\n</blockquote>\n<p>从以上例子能看出，面向过程比较简单直接，而面向对象更易于复用、扩展和维护</p>\n<h2 id=\"4-8、sleep（）和wait（）区别\"><a href=\"#4-8、sleep（）和wait（）区别\" class=\"headerlink\" title=\"4.8、sleep（）和wait（）区别\"></a>4.8、sleep（）和wait（）区别</h2><ol>\n<li>所属的类型不同</li>\n</ol>\n<ul>\n<li>wait()是Object类的实例方法,调用该方法的线程将进入WTING状态。 </li>\n<li>sleep()是Thread类的静态方法,调用该方法的线程将进入TIMED_WTING状态</li>\n</ul>\n<ol>\n<li>对锁的依赖不同</li>\n</ol>\n<ul>\n<li>wait()依赖于synchronized锁,通过监视器进行调用,调用后线程会释放锁。</li>\n<li>sleep()不依赖于任何锁,所以在调用后它也不会释放锁。</li>\n</ul>\n<ol>\n<li>返回的条件不同</li>\n</ol>\n<ul>\n<li>调用wait()进入等待状态的线程,需要由notify()&#x2F;notifyAll()唤醒,从而返回。 </li>\n<li>调用sleep()进入超时等待的线程,需要在超时时间到达后自动返回。</li>\n</ul>\n<h1 id=\"5、枚举\"><a href=\"#5、枚举\" class=\"headerlink\" title=\"5、枚举\"></a>5、枚举</h1><h2 id=\"5-1、实现方式\"><a href=\"#5-1、实现方式\" class=\"headerlink\" title=\"5.1、实现方式\"></a>5.1、实现方式</h2><p> 枚举是一组常量的集合。 可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象  </p>\n<h3 id=\"5-1-1、-自定义类实现枚举\"><a href=\"#5-1-1、-自定义类实现枚举\" class=\"headerlink\" title=\"5.1.1、 自定义类实现枚举\"></a>5.1.1、 自定义类实现枚举</h3><ol>\n<li>不需提供set方法，因为枚举对象值通常为只读</li>\n<li>对枚举对象&#x2F;属性使用final+static共同修饰，实现底层优化</li>\n<li>枚举 对象名通常使用全部大写，常量的命名规范</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Season</span> &#123;<span class=\"comment\">//类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String desc;<span class=\"comment\">//描述</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Season</span> <span class=\"variable\">SPRING</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Season</span>(<span class=\"string\">&quot;春天&quot;</span>, <span class=\"string\">&quot;温暖&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Season</span> <span class=\"variable\">WINTER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Season</span>(<span class=\"string\">&quot;冬天&quot;</span>, <span class=\"string\">&quot;寒冷&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Season</span> <span class=\"variable\">AUTUMN</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Season</span>(<span class=\"string\">&quot;秋天&quot;</span>, <span class=\"string\">&quot;凉爽&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Season</span> <span class=\"variable\">SUMMER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Season</span>(<span class=\"string\">&quot;夏天&quot;</span>, <span class=\"string\">&quot;炎热&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Enumeration02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(Season.AUTUMN);</span><br><span class=\"line\">        System.out.println(Season.SPRING);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-1-2、enum关键字实现枚举\"><a href=\"#5-1-2、enum关键字实现枚举\" class=\"headerlink\" title=\"5.1.2、enum关键字实现枚举\"></a>5.1.2、enum关键字实现枚举</h3><ol>\n<li>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类,  这样我们就可以使用 Enum 类相关的方法  </li>\n<li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li>\n<li>当有多个枚举对象时，使用,间隔，最后有一个分号结尾</li>\n<li>枚举对象必须放在枚举类的行首</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Enumeration03</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(Season2.AUTUMN);</span><br><span class=\"line\">        System.out.println(Season2.SUMMER);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//演示使用 enum 关键字来实现枚举类</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Season2</span> &#123;<span class=\"comment\">//类</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3. 如果有多个常量(对象)， 使用 ,号间隔即可</span></span><br><span class=\"line\">    <span class=\"comment\">//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面</span></span><br><span class=\"line\">    <span class=\"comment\">//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()</span></span><br><span class=\"line\">    SPRING(<span class=\"string\">&quot;春天&quot;</span>, <span class=\"string\">&quot;温暖&quot;</span>), </span><br><span class=\"line\">    WINTER(<span class=\"string\">&quot;冬天&quot;</span>, <span class=\"string\">&quot;寒冷&quot;</span>), </span><br><span class=\"line\">    AUTUMN(<span class=\"string\">&quot;秋天&quot;</span>, <span class=\"string\">&quot;凉爽&quot;</span>), </span><br><span class=\"line\">    SUMMER(<span class=\"string\">&quot;夏天&quot;</span>, <span class=\"string\">&quot;炎热&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String desc;<span class=\"comment\">//描述</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Season2</span><span class=\"params\">()</span> &#123;<span class=\"comment\">//无参构造器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Season2</span><span class=\"params\">(String name, String desc)</span> &#123;<span class=\"comment\">//有参构造器</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6、注解\"><a href=\"#6、注解\" class=\"headerlink\" title=\"6、注解\"></a>6、注解</h1><pre><code> 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息 。和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息  \n</code></pre>\n<h2 id=\"6-1、基本注解介绍\"><a href=\"#6-1、基本注解介绍\" class=\"headerlink\" title=\"6.1、基本注解介绍\"></a>6.1、基本注解介绍</h2><p> 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 </p>\n<p> 三个基本的 Annotation:  </p>\n<ol>\n<li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法 </li>\n<li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时 </li>\n<li>@SuppressWarnings: 抑制编译器警告（当不希望看到某些警告使用该注解，都不想看到使用all）</li>\n</ol>\n<h2 id=\"6-2、自定义注解\"><a href=\"#6-2、自定义注解\" class=\"headerlink\" title=\"6.2、自定义注解\"></a>6.2、自定义注解</h2><p>修饰符：访问修饰符必须为public,不写默认为pubic；<br>关键字：关键字为@interface；<br>注解名称： 注解名称为自定义注解的名称，使用时还会用到；<br>注解类型元素：注解属性 ( 接口方法 ) 返回值类型要求 ,可以使用default来进行赋默认值；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Info &#123; </span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;tracy&quot;</span>; </span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isDelete</span><span class=\"params\">()</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-3、元注解\"><a href=\"#6-3、元注解\" class=\"headerlink\" title=\"6.3、元注解\"></a>6.3、元注解</h2><p>所谓元注解，其主要作用就是负责注解其他注解，为其他注解提供了相关的解释说明。<br>Java中存在五个元注解，分别是 @Target、@Retention、@Documented、@Inherited、@Repeatable</p>\n<ol>\n<li><strong>Target</strong>：描述了注解修饰的对象范围，取值在java.lang.annotation.ElementType定义，常用包括：</li>\n</ol>\n<blockquote>\n<p>METHOD：用于描述方法<br>PACKAGE：用于描述包<br>PARAMETER：用于描述方法变量<br>TYPE：用于描述类、接口或enum类型</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>Retention</strong>：表述注解保留时间的长短，取值在java.lang.annotation.RetentionPolicy中，取值：</li>\n</ol>\n<blockquote>\n<p>SOURCE：在源文件中有效，编译过程中会被忽略<br>CLASS：随源文件一起编译在class文件中，运行时忽略<br>RUNTIME：在运行时有效(只有定义为RetentionPolicy.RUNTIME时，我们才能通过注解反射获取注解)</p>\n</blockquote>\n<ol start=\"3\">\n<li><p><strong>Document</strong>：表明这个注解应该被 javadoc文档注释工具记录，正常情况下javadoc中不包含注解的，@Documented属于标志注解</p>\n</li>\n<li><p><strong>Inherited</strong>:被该注解注解的元注解注解某个类时，子类继承该注解</p>\n</li>\n<li><p>@Repeatable 是 Java 8 引入的一个注解，用于在同一个元素上多次使用相同的注解。通过使用 @Repeatable 注解，可以使得某个注解可以重复应用于同一目标上，而无需使用容器注解或数组</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Color(&quot;Red&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Color(&quot;Blue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printColors</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-4、案例-自定义注解实现日志功能\"><a href=\"#6-4、案例-自定义注解实现日志功能\" class=\"headerlink\" title=\"6.4、案例-自定义注解实现日志功能\"></a>6.4、案例-自定义注解实现日志功能</h2><ol>\n<li>定义一个注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Loggable &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建切面类，使用 @Before 注解和 @AfterReturning 注解分别标记了在方法执行前和方法执行后执行的通知方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;@annotation(Loggable)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">beforeMethodExecution</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> joinPoint.getSignature().getName();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Entering method: &quot;</span> + methodName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(&quot;@annotation(Loggable)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterMethodExecution</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> joinPoint.getSignature().getName();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Exiting method: &quot;</span> + methodName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在需要进行日志记录的方法上添加 @Loggable 注解即可</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Loggable</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doAnotherThing</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、异常\"><a href=\"#7、异常\" class=\"headerlink\" title=\"7、异常\"></a>7、异常</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251414029.png\" alt=\"异常分类\"></p>\n<h2 id=\"7-1、Error（错误）\"><a href=\"#7-1、Error（错误）\" class=\"headerlink\" title=\"7.1、Error（错误）\"></a>7.1、<strong>Error（错误）</strong></h2><p>程序本身不能处理的异常，只能靠外接干预 （常见的如<strong>内存溢出</strong>，j<strong>vm虚拟机自身的非正常运行</strong>等）</p>\n<h2 id=\"7-2、Exception（异常）\"><a href=\"#7-2、Exception（异常）\" class=\"headerlink\" title=\"7.2、Exception（异常）\"></a>7.2、<strong>Exception（异常）</strong></h2><p>是程序正常运行中，可以预料的意外情况。比如数据库连接中断，空指针，数组下标越界。异常出现可以导致程序非正常终止</p>\n<p>（1）编译时异常<br>又叫可检查异常，Java语言强制要求捕获和处理所有非运行时异常。通过行为规范，强化程序的健壮性和安全性</p>\n<p>（2）运行时异常<br>又叫不检查异常RuntimeException，这些异常一般是由程序逻辑错误引起的，即语义错</p>\n<h1 id=\"8、常用类\"><a href=\"#8、常用类\" class=\"headerlink\" title=\"8、常用类\"></a>8、常用类</h1><h2 id=\"8-1、日期类\"><a href=\"#8-1、日期类\" class=\"headerlink\" title=\"8.1、日期类\"></a>8.1、日期类</h2><h3 id=\"8-1-1、第一代日期类Date（JDK1-0）\"><a href=\"#8-1-1、第一代日期类Date（JDK1-0）\" class=\"headerlink\" title=\"8.1.1、第一代日期类Date（JDK1.0）\"></a>8.1.1、第一代日期类Date（JDK1.0）</h3><ol>\n<li>Date：精确到毫秒，代表特定瞬间</li>\n<li>SimpleDateFormat：格式化（日期-文本）和解析日期（文本-日期）的类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">sdf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// format：将日期转换成指定格式的字符串</span></span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">format</span> <span class=\"operator\">=</span> sdf.format(d1); </span><br><span class=\"line\"><span class=\"comment\">// parse：格式化的String 转成对应的 Date</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;1996 年 01 月 01 日 10:20:30 星期一&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">parse</span> <span class=\"operator\">=</span> sdf.parse(s);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-2、第二代日期类Calendar（JDK1-1）\"><a href=\"#8-1-2、第二代日期类Calendar（JDK1-1）\" class=\"headerlink\" title=\"8.1.2、第二代日期类Calendar（JDK1.1）\"></a>8.1.2、第二代日期类Calendar（JDK1.1）</h3><p>Calendar它是一种抽象类，相比Date它在操作日历的时候提供了一些方法来操作日历字段</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Calendar 是一个抽象类， 并且构造器是 private,可以通过 getInstance() 来获取实例</span></span><br><span class=\"line\"><span class=\"comment\">// Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. 创建日历类对象</span></span><br><span class=\"line\"><span class=\"type\">Calendar</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Calendar.getInstance(); </span><br><span class=\"line\"><span class=\"comment\">//2. 获取日历对象的某个日历字段</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;年：&quot;</span> + c.get(Calendar.YEAR));</span><br><span class=\"line\"><span class=\"comment\">// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;月：&quot;</span> + (c.get(Calendar.MONTH) + <span class=\"number\">1</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;日：&quot;</span> + c.get(Calendar.DAY_OF_MONTH));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;小时：&quot;</span> + c.get(Calendar.HOUR));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;分钟：&quot;</span> + c.get(Calendar.MINUTE));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;秒：&quot;</span> + c.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-3、第三代日期类LocalDate（JDK8）\"><a href=\"#8-1-3、第三代日期类LocalDate（JDK8）\" class=\"headerlink\" title=\"8.1.3、第三代日期类LocalDate（JDK8）\"></a>8.1.3、第三代日期类LocalDate（JDK8）</h3><ol>\n<li><strong>Calendar日期类存在的问题？</strong></li>\n</ol>\n<p>（1）可变性，像日期和时间这样的类应该是不可变的<br>（2）格式化，格式化只对Date有用，Calendar只能自己拼装<br>（3）不是线程安全的；不能处理闰秒（每隔两天，多出一秒）等</p>\n<ol start=\"2\">\n<li><strong>基本概念</strong></li>\n</ol>\n<p>LocalDate：日期（年月日）<br>LocalTime：包含时间（时分秒）<br>LocalDateTime：包含日期+时间（年月日时分秒）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 使用 now() 返回表示当前日期时间的 对象</span></span><br><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">ldt</span> <span class=\"operator\">=</span> LocalDateTime.now(); <span class=\"comment\">//LocalDate.now();//LocalTime.now()</span></span><br><span class=\"line\"><span class=\"comment\">//2. 使用 DateTimeFormatter 对象来进行格式化</span></span><br><span class=\"line\"><span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">dateTimeFormatter</span> <span class=\"operator\">=</span> DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">format</span> <span class=\"operator\">=</span> dateTimeFormatter.format(ldt);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;格式化的日期=&quot;</span> + format);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;年=&quot;</span> + ldt.getYear());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;月=&quot;</span> + ldt.getMonth());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;月=&quot;</span> + ldt.getMonthValue());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;日=&quot;</span> + ldt.getDayOfMonth());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;时=&quot;</span> + ldt.getHour());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;分=&quot;</span> + ldt.getMinute());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;秒=&quot;</span> + ldt.getSecond());</span><br><span class=\"line\"><span class=\"type\">LocalDate</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> LocalDate.now(); <span class=\"comment\">//可以获取年月日</span></span><br><span class=\"line\"><span class=\"type\">LocalTime</span> <span class=\"variable\">now2</span> <span class=\"operator\">=</span> LocalTime.now();<span class=\"comment\">//获取到时分秒</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 提供 plus 和 minus 方法可以对当前时间进行加或者减</span></span><br><span class=\"line\"><span class=\"comment\">//看看 890 天后，是什么时候 把 年月日-时分秒</span></span><br><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">localDateTime</span> <span class=\"operator\">=</span> ldt.plusDays(<span class=\"number\">890</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;890 天后=&quot;</span> + dateTimeFormatter.format(localDateTime));</span><br><span class=\"line\"><span class=\"comment\">//看看在 3456 分钟前是什么时候，把 年月日-时分秒</span></span><br><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">localDateTime2</span> <span class=\"operator\">=</span> ldt.minusMinutes(<span class=\"number\">3456</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;3456 分钟前 日期=&quot;</span> + dateTimeFormatter.format(localDateTime2));</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"8-2、容器\"><a href=\"#8-2、容器\" class=\"headerlink\" title=\"8.2、容器\"></a>8.2、容器</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301540735.png\" alt=\"image.png\"></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>底层</th>\n<th>线程安全性</th>\n<th>扩容机制</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td>数组</td>\n<td>线程不安全</td>\n<td>首次创建长度为10，扩为1.5倍</td>\n<td>查找快，增删慢</td>\n</tr>\n<tr>\n<td>Vector</td>\n<td>数组</td>\n<td>线程安全</td>\n<td>首次创建长度为10，扩为1.5倍</td>\n<td>查找快，增删慢</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td>双向链表</td>\n<td>线程不安全</td>\n<td>不主动扩容</td>\n<td>增删快，查找慢</td>\n</tr>\n<tr>\n<td>HashSet</td>\n<td>HashMap</td>\n<td>线程不安全</td>\n<td></td>\n<td>可以存null</td>\n</tr>\n<tr>\n<td>LinkedHashSet</td>\n<td>LinkedHashMap</td>\n<td>线程不安全</td>\n<td></td>\n<td>可以存null</td>\n</tr>\n<tr>\n<td>TreeSet</td>\n<td>TreeMap</td>\n<td>线程不安全</td>\n<td></td>\n<td>不允许存null</td>\n</tr>\n<tr>\n<td>HashMap</td>\n<td>数组+链表（jdk7） 数组+链表+红黑树 （jdk8）</td>\n<td>线程不安全</td>\n<td>首次创建长度16，扩容2倍,负载因子0.75</td>\n<td>可以存nul</td>\n</tr>\n<tr>\n<td>LinkedHashMap</td>\n<td>同hashmap</td>\n<td>线程不安全</td>\n<td>不主动扩容</td>\n<td>可以存null</td>\n</tr>\n<tr>\n<td>HashTable</td>\n<td>数组+链表</td>\n<td>线程安全</td>\n<td>首次创建时长度为11，扩容为2n+1</td>\n<td>不能为null</td>\n</tr>\n<tr>\n<td>TreeMap</td>\n<td>红黑树</td>\n<td>线程不安全</td>\n<td>TreeMap由红黑树实现，容量方面没有限制</td>\n<td>不能为null 可以实现自然排序和定制排序</td>\n</tr>\n</tbody></table>\n<h3 id=\"8-2-1、hashmap原理\"><a href=\"#8-2-1、hashmap原理\" class=\"headerlink\" title=\"8.2.1、hashmap原理\"></a>8.2.1、hashmap原理</h3><p>hashmap数据结构是数组+链表+红黑树，HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对<br>两个重要的方法put() get()<br>（1）.put方法：调用key的hash方法得hash值，再与（数组长度-1）做与（&amp;）运算，到这个元素在数组中的位置（即下标）如果该位置已经存在其它元素，那么在同一个位子上的元素将以链表的形式存放，通过equals方法依次比较链表中的key，相同则替换。不同则添加到表尾（1.8之前添加到表头）。<br>（2）.get方法：调用key的hash方法得到这个元素在数组中的位置（即下标），然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>\n<blockquote>\n<p>（需要注意Jdk 1.8中对HashMap的实现做了优化,当链表长度大于8且数组长度超过64并之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)）<br>如果数组长度不足64，优先会进行扩容</p>\n</blockquote>\n<h3 id=\"8-2-2、自然排序和定制排序\"><a href=\"#8-2-2、自然排序和定制排序\" class=\"headerlink\" title=\"8.2.2、自然排序和定制排序\"></a>8.2.2、自然排序和定制排序</h3><p>自然排序：实现Comparable接口，实现compareTo方法</p>\n<blockquote>\n<p>典型实现：String，Integer，Date等</p>\n</blockquote>\n<p>定制排序：当元素对象没有实现comparable接口，又不方便修改，可以考虑使用定制排序，直接在调用方排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(arrayList, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"8-3、String\"><a href=\"#8-3、String\" class=\"headerlink\" title=\"8.3、String\"></a>8.3、String</h2><p>不可变性的理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;    <span class=\"comment\">//(1)</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s = &quot;</span> + s);</span><br><span class=\"line\"> </span><br><span class=\"line\">s = <span class=\"string\">&quot;123&quot;</span>;    <span class=\"comment\">//(2)</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s = &quot;</span> + s);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270955924.jpg\" alt=\"b6f0e64b3015ee2ebe2bd49b02c2a68.jpg|275\"></p>\n<p>s只是一个String对象的引用，并不是String对象本身。<br>当执行(1)处这行代码之后，会先在方法区的运行时常量池创建一个String对象”abc”，然后在Java栈中创建一个String对象的引用s，并让s指向”abc”<br>当执行完(2)处这行代码之后，会在方法区的运行时常量池创建一个新的String对象”123”，然后让引用s重新指向这个新的对象，而原来的对象”abc”还在内存中，并没有改变</p>\n<p>为什么这样设计？<br>(1)、字符串常量池中的对象可能被很多对象引用，如果一个修改会导致所有对象的内容都变<br>(2)、hashmap中key的hash方法只会调用一次然后缓存起来，如果key可变会导致缓存的结果和真实的计算结果不一致</p>\n<h1 id=\"9、泛型\"><a href=\"#9、泛型\" class=\"headerlink\" title=\"9、泛型\"></a>9、泛型</h1><h2 id=\"9-1、基本概念\"><a href=\"#9-1、基本概念\" class=\"headerlink\" title=\"9.1、基本概念\"></a>9.1、基本概念</h2><p>（1）泛型：Java在jdk5引入了泛型，在没有泛型之前，每次从集合中读取的对象都必须进行类型转换，如果在插入对象时，类型出错，那么在运行时转换处理的阶段就会报错。在提出泛型之后就可以明确的指定集合接受哪些对象类型，编译器就能知晓并且自动为插入的代码进行泛化，在编译阶段告知是否插入类型错误的对象，程序会变得更加安全清晰。<br>（2）泛型擦除：Java泛型是伪泛型，因为Java代码在编译阶段，所有的泛型信息会被擦除，Java的泛型基本上都是在编辑器这个层次上实现的，在生成的字节码文件中是不包含泛型信息的，使用泛型的时候加上的类型，在编译阶段会被擦除掉，这个过程称为泛型擦除。</p>\n<p>为什么使用泛型？<br>（1）保证类型安全：可以确保在编译时期检测到类型不匹配的错误，避免在运行时出现类型转换错误<br>（2）消除强制转换：消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会</p>\n<h2 id=\"9-2、泛型使用方式\"><a href=\"#9-2、泛型使用方式\" class=\"headerlink\" title=\"9.2、泛型使用方式\"></a>9.2、泛型使用方式</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。</p>\n<blockquote>\n<p>T是泛型中的类型参数声明，它表示一个占位符,通常用大写字母表示（例如 T、E、K、V 等），但实际上它只是一个占位符，可以根据需要自定义</p>\n<p>T：任意类型 type<br> E：集合中元素的类型 element<br> K：key-value形式 key<br> V：key-value形式 value</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 泛型类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T item;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setItem</span><span class=\"params\">(T item)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.item = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">getItem</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 泛型接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">List</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(T element)</span>;</span><br><span class=\"line\">    T <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 泛型方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Utils</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getFirstElement</span><span class=\"params\">(List&lt;T&gt; list)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (list != <span class=\"literal\">null</span> &amp;&amp; !list.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"9-3、泛型通配符\"><a href=\"#9-3、泛型通配符\" class=\"headerlink\" title=\"9.3、泛型通配符\"></a>9.3、泛型通配符</h2><p>泛型通配符是一种特殊的类型参数，用于在使用泛型时表示未知类型或限制类型范围</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1：表示类型参数可以是任何类型</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span>&lt;?&gt;&#123;&#125; </span><br><span class=\"line\"><span class=\"comment\">// 2：表示类型参数必须是A或者是A的子类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span>&gt;&#123;&#125; </span><br><span class=\"line\"><span class=\"comment\">// 3: 表示类型参数必须是A或者是A的超类型</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span>&lt;T supers A&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"9-4、实现原理\"><a href=\"#9-4、实现原理\" class=\"headerlink\" title=\"9.4、实现原理\"></a>9.4、实现原理</h2><p>原码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Caculate</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译后的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Caculate</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Caculate</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>java的泛型称为伪泛型，因为Java的泛型只是编译期的泛型，一旦编译成字节码，泛型就被擦除了，即在Java中使用泛型，我们无法在运行期知道泛型的类型，一旦编译成字节码，泛型将被取代为Object。<br>在不使用泛型时，我们需要将Object手动转型成特定类型，而在使用泛型后，我们不需要自己转型，但实际上我们get到的对象仍然是Object类型的，只不过编译器会自动帮我们加入这个转型动作</p>\n<h1 id=\"10、IO\"><a href=\"#10、IO\" class=\"headerlink\" title=\"10、IO\"></a>10、IO</h1><h2 id=\"10-1、概述\"><a href=\"#10-1、概述\" class=\"headerlink\" title=\"10.1、概述\"></a>10.1、概述</h2><h3 id=\"10-1-1、简介\"><a href=\"#10-1-1、简介\" class=\"headerlink\" title=\"10.1.1、简介\"></a>10.1.1、简介</h3><p>I（Input）O（Output）：中文翻译为输入输出，我们知道计算机的数据不管是软件、视频、音乐、游戏等最终都是存储在硬盘中的，当我们打开后，由CPU将硬盘中的数据读取到内存中来运行。这样一个过程就产生了I&#x2F;O（输入&#x2F;输出）</p>\n<blockquote>\n<p>输入：硬盘 -&gt; 内存<br>输出：内存 -&gt; 硬盘</p>\n</blockquote>\n<h3 id=\"10-1-2、IO流的分类\"><a href=\"#10-1-2、IO流的分类\" class=\"headerlink\" title=\"10.1.2、IO流的分类\"></a>10.1.2、IO流的分类</h3><p>按照操作数据单位不同分为：字节流（8bit）二进制文件，字符流（按字符）文本文件<br>按数据流的流向不同分为：输入流，输出流</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1659662289021-93129478-8cc1-4d9c-82c9-932c15153a37.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=114&id=uf89be968&originHeight=167&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=154323&status=done&style=none&taskId=u5d128cf6-4c3f-4321-a117-49823508580&title=&width=567\" alt=\"image.png\"></p>\n<blockquote>\n<p>java的IO流共涉及40多个类，都是从如上4个抽象基类派生</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251511757.png\" alt=\"IO流体系\"></p>\n<h2 id=\"10-2、字节流\"><a href=\"#10-2、字节流\" class=\"headerlink\" title=\"10.2、字节流\"></a>10.2、字节流</h2><h3 id=\"10-2-1、字节输出流\"><a href=\"#10-2-1、字节输出流\" class=\"headerlink\" title=\"10.2.1、字节输出流\"></a>10.2.1、字节输出流</h3><p>OutputStream是所有字节输出的顶层父类，该父类提供如下公共方法：</p>\n<h4 id=\"10-2-1-1、FileOutputStream\"><a href=\"#10-2-1-1、FileOutputStream\" class=\"headerlink\" title=\"10.2.1.1、FileOutputStream\"></a>10.2.1.1、FileOutputStream</h4><p>FileOutputStream是OutputStream中一个常用的子类，他可以关联一个文件，用于将数据写出到文件</p>\n<blockquote>\n<p>构造方法：<br>public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。<br> public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IOTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用文件名称创建流对象</span></span><br><span class=\"line\">        <span class=\"type\">FileOutputStream</span> <span class=\"variable\">fos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;000.txt&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 字符串转换为字节数组</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] b = <span class=\"string\">&quot;abcde&quot;</span>.getBytes();</span><br><span class=\"line\">        <span class=\"comment\">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class=\"line\">        fos.write(b,<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        fos.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是，在UTF-8编码下，一个中文占用3个字节，GBK编码下一个中文占用2个字节，因此在使用字节流来精确操作字符数据时将会变得非常麻烦</p>\n</blockquote>\n<h3 id=\"10-2-2、字节输入流\"><a href=\"#10-2-2、字节输入流\" class=\"headerlink\" title=\"10.2.2、字节输入流\"></a>10.2.2、字节输入流</h3><h4 id=\"10-2-2-1、FileInputStream\"><a href=\"#10-2-2-1、FileInputStream\" class=\"headerlink\" title=\"10.2.2.1、FileInputStream\"></a>10.2.2.1、FileInputStream</h4><p>java.io.FileInputStream类是文件输入流，从文件中读取字节</p>\n<blockquote>\n<p>构造方法：<br>FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。<br> FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IOTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用文件名称创建流对象.</span></span><br><span class=\"line\">        <span class=\"type\">FileInputStream</span> <span class=\"variable\">fis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;abc.txt&quot;</span>); <span class=\"comment\">// 文件中为abcde</span></span><br><span class=\"line\">        <span class=\"comment\">// 定义变量，作为有效个数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> len;</span><br><span class=\"line\">        <span class=\"comment\">// 定义字节数组，作为装字节数据的容器</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 循环读取</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((len = fis.read(b)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(b, <span class=\"number\">0</span>, len));<span class=\"comment\">//  len 每次读取的有效字节个数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        fis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"10-3、字符流\"><a href=\"#10-3、字符流\" class=\"headerlink\" title=\"10.3、字符流\"></a>10.3、字符流</h2><p>计算机都是按照字节进行存储的，我们之前学习过编码表，通过编码表可以将字节转换为对应的字符，但是世界上有非常多的编码表，不同的编码表规定的单个字符所占用的字节可能都不一样，例如在GBK编码表中一个中文占2个字节，UTF8编码表则占3个字节；且一个中文字符都是由多个字节组成的，为此我们不能再基于字节的操作单位来操作文本文件了，因为这样太过麻烦，我们希望基于字符来操作文件，一次操作读取一个“字符”而不是一个“字节”，这样在操作文本文件时非常便捷</p>\n<h3 id=\"10-3-1、字符输出流\"><a href=\"#10-3-1、字符输出流\" class=\"headerlink\" title=\"10.3.1、字符输出流\"></a>10.3.1、字符输出流</h3><h4 id=\"10-3-1-1、FileWriter类\"><a href=\"#10-3-1-1、FileWriter类\" class=\"headerlink\" title=\"10.3.1.1、FileWriter类\"></a>10.3.1.1、FileWriter类</h4><p>java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo03_</span>写出字符数组 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用文件名称创建流对象</span></span><br><span class=\"line\">        <span class=\"type\">FileWriter</span> <span class=\"variable\">fw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(<span class=\"string\">&quot;002.txt&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 字符串转换为字节数组</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] chars = <span class=\"string\">&quot;我是中国人&quot;</span>.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 写出字符数组</span></span><br><span class=\"line\">        fw.write(chars); <span class=\"comment\">// 我是中国人</span></span><br><span class=\"line\">        <span class=\"comment\">// 写出从索引2开始，2个字节。索引2是&#x27;中&#x27;，两个字节，也就是&#x27;中国&#x27;。</span></span><br><span class=\"line\">        fw.write(chars,<span class=\"number\">2</span>,<span class=\"number\">2</span>); <span class=\"comment\">// 中国</span></span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        fw.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-3-2、字符输入流\"><a href=\"#10-3-2、字符输入流\" class=\"headerlink\" title=\"10.3.2、字符输入流\"></a>10.3.2、字符输入流</h3><h4 id=\"10-3-2-1、FileReader类\"><a href=\"#10-3-2-1、FileReader类\" class=\"headerlink\" title=\"10.3.2.1、FileReader类\"></a>10.3.2.1、FileReader类</h4><p>java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区</p>\n<blockquote>\n<p>Windows系统的中文编码默认是GBK编码表。idea中默认是UTF-8 </p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IoTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用文件名称创建流对象</span></span><br><span class=\"line\">        <span class=\"type\">FileReader</span> <span class=\"variable\">fr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(<span class=\"string\">&quot;001.txt&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 定义变量，保存数据</span></span><br><span class=\"line\">        <span class=\"type\">int</span> data;</span><br><span class=\"line\">        <span class=\"comment\">// 循环读取</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((data = fr.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 以数值的方式输出</span></span><br><span class=\"line\"><span class=\"comment\">//            System.out.println(b);</span></span><br><span class=\"line\">            <span class=\"comment\">// 以字符的方式输出</span></span><br><span class=\"line\">            System.out.println((<span class=\"type\">char</span>) data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        fr.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"11、反射\"><a href=\"#11、反射\" class=\"headerlink\" title=\"11、反射\"></a>11、反射</h1><h2 id=\"11-1、概述\"><a href=\"#11-1、概述\" class=\"headerlink\" title=\"11.1、概述\"></a>11.1、概述</h2><h3 id=\"11-1-1、基本概念\"><a href=\"#11-1-1、基本概念\" class=\"headerlink\" title=\"11.1.1、基本概念\"></a>11.1.1、基本概念</h3><p>Java反射是指在运行时动态地获取类的信息并操作类或对象的能力。它提供了一组API，使得可以在运行时检查类、接口、字段和方法，并且可以在运行时实例化对象、调用方法、获取和设置字段的值</p>\n<h3 id=\"11-1-2、好处\"><a href=\"#11-1-2、好处\" class=\"headerlink\" title=\"11.1.2、好处\"></a>11.1.2、好处</h3><ol>\n<li>运行时类信息：反射允许在运行时获取类的信息，包括类的名称、字段、方法、注解等。这使得可以动态地了解和操作类的结构，从而实现更加灵活和通用的代码设计。</li>\n<li>动态创建对象：通过反射可以在运行时动态地实例化对象，而不需要在编译时明确知道类的类型。这对于根据配置文件或用户输入来创建对象非常有用，可以实现更大程度的灵活性和可配置性。</li>\n<li>动态调用方法：反射可以在运行时动态地调用类的方法，包括公共方法、私有方法和静态方法。这对于实现插件机制、扩展性和动态逻辑非常有用，可以根据运行时条件来调用不同的方法。</li>\n<li>访问私有成员：反射可以绕过访问权限限制，访问类的私有成员。这对于测试、调试和特定场景下的操作非常有用，但也需要小心使用，以遵循封装原则。</li>\n<li>序列化和反序列化：反射在序列化和反序列化过程中起着重要的作用。通过反射可以分析对象的结构，并将其转换为字节流或从字节流中重建对象</li>\n</ol>\n<h2 id=\"11-2、-获取Class对象的方式\"><a href=\"#11-2、-获取Class对象的方式\" class=\"headerlink\" title=\"11.2、 获取Class对象的方式\"></a>11.2、 获取Class对象的方式</h2><ol>\n<li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li>\n<li>类名.class：通过类名的属性class获取，多用于参数的传递 </li>\n<li>对象.getClass()：getClass()方法在Object类中定义着</li>\n</ol>\n<blockquote>\n<p>同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</p>\n</blockquote>\n<h2 id=\"11-3、Class对象功能\"><a href=\"#11-3、Class对象功能\" class=\"headerlink\" title=\"11.3、Class对象功能\"></a>11.3、Class对象功能</h2><ol>\n<li>获取成员变量</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] getFields() ：获取所有<span class=\"keyword\">public</span>修饰的成员变量</span><br><span class=\"line\">Field <span class=\"title function_\">getField</span><span class=\"params\">(String name)</span>   获取指定名称的 <span class=\"keyword\">public</span>修饰的成员变量</span><br><span class=\"line\">Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</span><br><span class=\"line\">Field <span class=\"title function_\">getDeclaredField</span><span class=\"params\">(String name)</span>  </span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>获取构造方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constructor&lt;?&gt;[] getConstructors()  返回<span class=\"keyword\">public</span>修饰的构造方法</span><br><span class=\"line\">Constructor&lt;T&gt; <span class=\"title function_\">getConstructor</span><span class=\"params\">(类&lt;?&gt;... parameterTypes)</span>  </span><br><span class=\"line\">Constructor&lt;T&gt; <span class=\"title function_\">getDeclaredConstructor</span><span class=\"params\">(类&lt;?&gt;... parameterTypes)</span>  </span><br><span class=\"line\">Constructor&lt;?&gt;[] getDeclaredConstructors()  返回所有的构造方法</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>获取成员方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] getMethods()  </span><br><span class=\"line\">Method <span class=\"title function_\">getMethod</span><span class=\"params\">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span><br><span class=\"line\">Method[] getDeclaredMethods()  </span><br><span class=\"line\">Method <span class=\"title function_\">getDeclaredMethod</span><span class=\"params\">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>获取全类名</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String <span class=\"title function_\">getName</span><span class=\"params\">()</span>  </span><br></pre></td></tr></table></figure>\n<h2 id=\"11-4、Field-成员变量\"><a href=\"#11-4、Field-成员变量\" class=\"headerlink\" title=\"11.4、Field 成员变量\"></a>11.4、Field 成员变量</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 设置值</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(Object obj, Object value)</span>  </span><br><span class=\"line\"><span class=\"number\">2.</span> 获取值</span><br><span class=\"line\">\tget(Object obj) </span><br><span class=\"line\"><span class=\"number\">3.</span> 忽略访问权限修饰符的安全检查</span><br><span class=\"line\">\tsetAccessible(<span class=\"literal\">true</span>):暴力反射</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-5、Constructor-构造方法\"><a href=\"#11-5、Constructor-构造方法\" class=\"headerlink\" title=\"11.5、Constructor 构造方法\"></a>11.5、Constructor 构造方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T <span class=\"title function_\">newInstance</span><span class=\"params\">(Object... initargs)</span>  </span><br><span class=\"line\">如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-6、Method-方法对象\"><a href=\"#11-6、Method-方法对象\" class=\"headerlink\" title=\"11.6、Method 方法对象\"></a>11.6、Method 方法对象</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 执行方法：</span><br><span class=\"line\">\tObject <span class=\"title function_\">invoke</span><span class=\"params\">(Object obj, Object... args)</span>  </span><br><span class=\"line\"><span class=\"number\">2.</span> 获取方法名称：</span><br><span class=\"line\">\tString getName:获取方法名</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"12、异常\"><a href=\"#12、异常\" class=\"headerlink\" title=\"12、异常\"></a>12、异常</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301636988.png\" alt=\"image.png\"></p>\n<p>Error：错误，无法被处理的</p>\n<p>Exception：异常，能够被程序本身处理的，可以通过try…catch语句捕捉异常，或者是throws抛出异常。分为运行时异常和非运行时异常</p>\n<ul>\n<li>运行时异常：就是RuntimeException，编译时不会检查出错误的。一般是由于逻辑错误引起的，程序员可以手动去解决的，比如判空等。</li>\n<li>非运行时异常：也叫编译异常，就是Exception下除了RuntimeException以外的异常。是必须进行处理的异常，编译器会进行异常提醒的。如果不进行处理，程序编译不通过</li>\n</ul>\n<h1 id=\"13、日志\"><a href=\"#13、日志\" class=\"headerlink\" title=\"13、日志\"></a>13、日志</h1><h2 id=\"13-1、基本概念\"><a href=\"#13-1、基本概念\" class=\"headerlink\" title=\"13.1、基本概念\"></a>13.1、基本概念</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270851142.png\" alt=\"image (26).png\"></p>\n<blockquote>\n<p>常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。</p>\n</blockquote>\n<h2 id=\"13-2、java日志演化历史\"><a href=\"#13-2、java日志演化历史\" class=\"headerlink\" title=\"13.2、java日志演化历史\"></a>13.2、java日志演化历史</h2><p>（1）最开始出现的是 log4j，也是应用最广泛的日志系统，作者是 Ceki Gülcü，开始时，一切都是美好的。<br>（2）但 java 的开发主体 Sun 公司认为自己才是正统，为了干掉 log4j，在 jdk1.4 中增加了 jul（因为在 java.util.logging 包下）日志的实现，造成了目前开发者的混乱，迄今为止仍饱受诟病。<br>（3）各个日志系统互相没有关联，替换和统一变的非常麻烦。A 项目用 log4j 作为日志系统，但同时引了 B 项目，而 B 项目用 jul 作为日志系统，那么你的应用就得使用两个日志系统。<br>（4）为了搞定这个坑爹的问题，开源社区 apache 提供了一个日志框架作为日志的抽象，叫 commons-logging，也被称为 jcl（java common logging），jcl 对各种日志接口进行抽象，抽象出一个接口层，对每个日志实现都适配或者桥接，这样这些提供给别人的库都直接使用抽象层即可，较好的解决了上述问题。<br>（5）当年 Apache 说服 log4j 以及其他的日志来按照 commons-logging 的标准编写，但是由于 commons-logging 的类加载有点问题，实现起来也不友好，作为元老级日志 log4j 的作者再度出山，搞出了一个更加牛逼的新的日志框架 slf4j（这个也是抽象层），同时针对 slf4j 的接口实现了一套日志系统，即传说中的 logback。<br>（6）同时这个作者心情一好，又把 log4j 进行了改造，就是所谓的 log4j2，同时支持 jcl 以及 slf4j。</p>\n","site":{"data":{}},"cover":false,"abbrlink":58693,"excerpt":"","more":"<h1 id=\"1、Java概述\"><a href=\"#1、Java概述\" class=\"headerlink\" title=\"1、Java概述\"></a>1、Java概述</h1><h2 id=\"1-1、java特点\"><a href=\"#1-1、java特点\" class=\"headerlink\" title=\"1.1、java特点\"></a>1.1、java特点</h2><ol>\n<li>Java 语言是面向对象的(oop) </li>\n<li>Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证</li>\n<li>Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]</li>\n<li>java是一种半编译，半解释型语言。 . Java–&gt;. class是由 Javac 编译，这个过程符合编译型语言的特点。而. class–&gt;对应平台机器码 的这一过程 是由Java解释执行</li>\n</ol>\n<p> </p>\n<h1 id=\"2、变量\"><a href=\"#2、变量\" class=\"headerlink\" title=\"2、变量\"></a>2、变量</h1><h2 id=\"2-1、java基本数据类型\"><a href=\"#2-1、java基本数据类型\" class=\"headerlink\" title=\"2.1、java基本数据类型\"></a>2.1、java基本数据类型</h2><p>java基本数据类型 - 四类八种</p>\n<ol>\n<li><strong>整型</strong></li>\n</ol>\n<p>byte 、short 、int 、long</p>\n<ol start=\"2\">\n<li><strong>浮点型</strong></li>\n</ol>\n<p>float 、 double</p>\n<ol start=\"3\">\n<li><strong>字符型</strong></li>\n</ol>\n<p>char</p>\n<ol start=\"4\">\n<li><strong>布尔型</strong></li>\n</ol>\n<p>boolean</p>\n<table>\n<thead>\n<tr>\n<th>数据类型名称</th>\n<th>占用字节</th>\n<th>范围</th>\n<th>封装器类</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>byte（字节型）</td>\n<td>1</td>\n<td>-（2^7）<del>2^7-1（-128</del>127）</td>\n<td>Byte</td>\n</tr>\n<tr>\n<td>shot（短整型）</td>\n<td>2</td>\n<td>-（2^15）<del>2^15-1(-32768</del>32767)</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>int（整形）</td>\n<td>4</td>\n<td>-（2^31）<del>2^31-1（-2147483648</del>2147483647）</td>\n<td>Integer</td>\n</tr>\n<tr>\n<td>long（长整型）</td>\n<td>8</td>\n<td>-（2^63）~2^63-1</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>float（浮点型）</td>\n<td>4</td>\n<td>-3.403E8~3.403E38</td>\n<td>Float</td>\n</tr>\n<tr>\n<td>double（双精度浮点型）</td>\n<td>8</td>\n<td>-1.798E308~1.798E308</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>boolean（布尔型）</td>\n<td>1</td>\n<td></td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>char（字符型）</td>\n<td>2</td>\n<td></td>\n<td><strong>Character</strong></td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>注意：计算机的数值是用二进制补码表示的，二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1</p>\n</blockquote>\n<h2 id=\"2-2、基本数据类型转换\"><a href=\"#2-2、基本数据类型转换\" class=\"headerlink\" title=\"2.2、基本数据类型转换\"></a>2.2、基本数据类型转换</h2><h3 id=\"2-2-1、自动类型转换\"><a href=\"#2-2-1、自动类型转换\" class=\"headerlink\" title=\"2.2.1、自动类型转换\"></a>2.2.1、自动类型转换</h3><p>当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换<br>精度由小到大排序：</p>\n<p>byte short int long float double</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//自动类型转换细节</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AutoConvertDetail</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//细节 1： 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>; <span class=\"comment\">//ok</span></span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1 + <span class=\"number\">1.1</span>;<span class=\"comment\">//错误 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1 + <span class=\"number\">1.1</span>;<span class=\"comment\">//对 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> n1 + <span class=\"number\">1.1F</span>;<span class=\"comment\">//对 n1 + 1.1 =&gt; 结果类型是 float</span></span><br><span class=\"line\">    <span class=\"comment\">//细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，就会报错，反之就会进行自动类型转换。</span></span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> <span class=\"number\">1.1</span>;<span class=\"comment\">//错误 double -&gt; int</span></span><br><span class=\"line\">    <span class=\"comment\">//细节 3: (byte, short) 和 char 之间不会相互自动转换</span></span><br><span class=\"line\">     <span class=\"type\">byte</span> <span class=\"variable\">b1</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>; <span class=\"comment\">//对 , -128-127</span></span><br><span class=\"line\">     <span class=\"type\">char</span> <span class=\"variable\">c1</span> <span class=\"operator\">=</span> b1; <span class=\"comment\">//错误， 原因 byte 不能自动转成 char</span></span><br><span class=\"line\">    <span class=\"comment\">//细节 4：自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型</span></span><br><span class=\"line\">    <span class=\"type\">byte</span> <span class=\"variable\">b4</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">short</span> <span class=\"variable\">s3</span> <span class=\"operator\">=</span> <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"variable\">num200</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"variable\">num300</span> <span class=\"operator\">=</span> <span class=\"number\">1.1F</span>;</span><br><span class=\"line\">    <span class=\"type\">float</span> <span class=\"variable\">num500</span> <span class=\"operator\">=</span> b4 + s3 + num200 + num300; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>floatf&#x3D;3.4;是否正确？<br>不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换floatf&#x3D;(float)3.4;或者写成floatf&#x3D;3.4F;</p>\n</blockquote>\n<h3 id=\"2-2-2、强制类型转换\"><a href=\"#2-2-2、强制类型转换\" class=\"headerlink\" title=\"2.2.2、强制类型转换\"></a>2.2.2、强制类型转换</h3><p>将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符( )，但可能造成精度降低或溢出,格外要注意。</p>\n<h3 id=\"2-2-3、基本数据类型和String转换\"><a href=\"#2-2-3、基本数据类型和String转换\" class=\"headerlink\" title=\"2.2.3、基本数据类型和String转换\"></a>2.2.3、基本数据类型和String转换</h3><ol>\n<li>基本数据类型转String类型</li>\n</ol>\n<p>（1）将基本类型的值加 “” 即可<br>（2）String.valueOf(基本数据类型)</p>\n<ol start=\"2\">\n<li>String转基本数据类型</li>\n</ol>\n<p>（1）基本类型包装类调用parseXX方法即可</p>\n<h1 id=\"3、运算符\"><a href=\"#3、运算符\" class=\"headerlink\" title=\"3、运算符\"></a>3、运算符</h1><h2 id=\"4-1、算数运算符\"><a href=\"#4-1、算数运算符\" class=\"headerlink\" title=\"4.1、算数运算符\"></a>4.1、算数运算符</h2><p>算数运算符是对数值变量进行运算的，在java程序种使用非常多</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231601761.png\" alt=\"java算数运算符\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 题目1</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">i = i++; <span class=\"comment\">// 规则会使用临时变量(1)temp=i(2)i=i+1(3)i=temp</span></span><br><span class=\"line\">System.out.println(i); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 题目2</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">i = ++i; <span class=\"comment\">// 规则会使用临时变量(1)i=i+1(2)temp=i(3)i=temp</span></span><br><span class=\"line\">System.out.println(i); <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2、关系运算符\"><a href=\"#4-2、关系运算符\" class=\"headerlink\" title=\"4.2、关系运算符\"></a>4.2、关系运算符</h2><p>关系运算符的结果都是boolean型，也就是要么是true，要么是false</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231605071.png\" alt=\"java关系运算符\"></p>\n<h2 id=\"4-3、逻辑运算符\"><a href=\"#4-3、逻辑运算符\" class=\"headerlink\" title=\"4.3、逻辑运算符\"></a>4.3、逻辑运算符</h2><p>用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231608353.png\" alt=\"逻辑运算符\"></p>\n<blockquote>\n<p>  a^b: 叫逻辑异或  ：当 a 和 b 不同时，则结果为 true, 否则为 false<br>  &amp;&amp;短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高<br>  &amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低  </p>\n</blockquote>\n<h2 id=\"4-4、赋值运算符\"><a href=\"#4-4、赋值运算符\" class=\"headerlink\" title=\"4.4、赋值运算符\"></a>4.4、赋值运算符</h2><p>基本赋值运算符 &#x3D; （ int a &#x3D; 10;）<br>复合赋值运算符 +&#x3D; ，-&#x3D; ，*&#x3D; ， &#x2F;&#x3D; ，%&#x3D; 等</p>\n<h2 id=\"4-5、三元运算符\"><a href=\"#4-5、三元运算符\" class=\"headerlink\" title=\"4.5、三元运算符\"></a>4.5、三元运算符</h2><p>条件表达式 ? 表达式 1: 表达式 2; </p>\n<ol>\n<li>如果条件表达式为 true，运算后的结果是表达式 1；</li>\n<li>如果条件表达式为 false，运算后的结果是表达式 2；</li>\n</ol>\n<h2 id=\"4-6、进制转换（为位运算准备）\"><a href=\"#4-6、进制转换（为位运算准备）\" class=\"headerlink\" title=\"4.6、进制转换（为位运算准备）\"></a>4.6、进制转换（为位运算准备）</h2><p>对于整数，有四种表示方式：<br>二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。<br>十进制：0-9 ，满 10 进 1。<br>八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。<br>十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231612057.png\" alt=\"进制转换\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1659315826387-ed7e7bab-8366-4fd2-8353-b82acde62fa2.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=243&id=uc4b6c469&originHeight=470&originWidth=664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126331&status=done&style=none&taskId=u69461551-0d4d-415e-bdd3-fb02621b29f&title=&width=343\" alt=\"image.png\"></p>\n<h3 id=\"4-6-1、其它进制转十进制\"><a href=\"#4-6-1、其它进制转十进制\" class=\"headerlink\" title=\"4.6.1、其它进制转十进制\"></a>4.6.1、其它进制转十进制</h3><ol>\n<li>二进制转十进制</li>\n</ol>\n<p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和</p>\n<blockquote>\n<p>案例：将ob1011转成十进制数<br>1+2+8&#x3D;11</p>\n</blockquote>\n<ol start=\"2\">\n<li>八进制转十进制</li>\n</ol>\n<p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和</p>\n<blockquote>\n<p>案例：0234转成十进制<br>4*1+3*8+2*64&#x3D;156</p>\n</blockquote>\n<ol start=\"3\">\n<li>十六进制转十进制</li>\n</ol>\n<p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和</p>\n<blockquote>\n<p>案例：0x23A<br>10*1+3*16+2*512&#x3D;570</p>\n</blockquote>\n<h3 id=\"4-6-2、十进制转其他进制\"><a href=\"#4-6-2、十进制转其他进制\" class=\"headerlink\" title=\"4.6.2、十进制转其他进制\"></a>4.6.2、十进制转其他进制</h3><ol>\n<li>十进制转二进制</li>\n</ol>\n<p>规则：将该数不断除以2.直到商为0为止，然后将每步余数倒过来，就是对应二进制</p>\n<blockquote>\n<p>案例：34转为对应二进制 &#x3D; 0B00100010</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231618617.png\" alt=\"十进制转二进制\"></p>\n<ol start=\"2\">\n<li>十进制转八进制</li>\n</ol>\n<p>规则：将该数不断除以8.直到商为0为止，然后将每步余数倒过来，就是对应二进制</p>\n<blockquote>\n<p>案例：131转为8进制</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231620590.png\" alt=\"十进制转八进制\"></p>\n<h3 id=\"4-6-3、二进制转其它进制\"><a href=\"#4-6-3、二进制转其它进制\" class=\"headerlink\" title=\"4.6.3、二进制转其它进制\"></a>4.6.3、二进制转其它进制</h3><ol>\n<li>二进制转八进制</li>\n</ol>\n<p>规则：从低位开始，将二进制数每三位一组，转成对应的八进制</p>\n<blockquote>\n<p>案例：0b11010101转成八进制<br>0325</p>\n</blockquote>\n<ol start=\"2\">\n<li>二进制转十六进制</li>\n</ol>\n<p>规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可</p>\n<blockquote>\n<p>案例：0b11010101转成十六进制<br>D5</p>\n</blockquote>\n<h3 id=\"4-6-4、其它进制转二进制\"><a href=\"#4-6-4、其它进制转二进制\" class=\"headerlink\" title=\"4.6.4、其它进制转二进制\"></a>4.6.4、其它进制转二进制</h3><ol>\n<li>八进制转二进制</li>\n</ol>\n<p>规则：将八进制数每1位。转成对应的一个3位的二进制数即可</p>\n<blockquote>\n<p>案例：将0237转成二进制<br>0b10011111</p>\n</blockquote>\n<ol start=\"2\">\n<li>十六进制转二进制</li>\n</ol>\n<p>规则：将十六进制数每1位。转成对应的一个4位的二进制数即可</p>\n<blockquote>\n<p>案例：请将0x23B转成二进制<br>0b001000111011</p>\n</blockquote>\n<h2 id=\"4-7、位运算符\"><a href=\"#4-7、位运算符\" class=\"headerlink\" title=\"4.7、位运算符\"></a>4.7、位运算符</h2><h3 id=\"4-6-1、原码反码补码\"><a href=\"#4-6-1、原码反码补码\" class=\"headerlink\" title=\"4.6.1、原码反码补码\"></a>4.6.1、原码反码补码</h3><ol>\n<li>进制的最高位是符号位: 0表示正数1表示负数</li>\n<li>正数的原码，反码，补码都一样</li>\n<li>负数的反码&#x3D;它的原码符号位不变，其它位取反.负数的补码&#x3D;它的反码+1</li>\n<li>0的反码，补码都是0</li>\n<li>在计算机运算的时候，都是以补码的方式来运算的</li>\n<li>补码的补码就是原码</li>\n</ol>\n<blockquote>\n<p>为什么计算机通过补码进行运算？<br>通过使用补码，无需单独的符号位判断来执行加法和减法运算。计算机可以直接对补码进行位运算，而不需要额外的逻辑电路来处理符号位</p>\n</blockquote>\n<h3 id=\"4-6-2、位运算\"><a href=\"#4-6-2、位运算\" class=\"headerlink\" title=\"4.6.2、位运算\"></a>4.6.2、位运算</h3><p>java种有7个位运算 &amp;（按位与）,|（按位或）,^（按位异或）,~（按位取反），&lt;&lt;（左移），&gt;&gt;（带符号右移），&gt;&gt;&gt;（无符号右移）</p>\n<h4 id=\"4-6-2-1、-（按位与）\"><a href=\"#4-6-2-1、-（按位与）\" class=\"headerlink\" title=\"4.6.2.1、&amp; （按位与）\"></a>4.6.2.1、&amp; （按位与）</h4><p>两位全为1，结果为1，否则为0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  10  (2)</span></span><br><span class=\"line\"><span class=\"section\">&amp; 11  (3)</span></span><br><span class=\"line\"><span class=\"section\">------</span></span><br><span class=\"line\"><span class=\"code\">  10  (2)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-2、-（按位或）\"><a href=\"#4-6-2-2、-（按位或）\" class=\"headerlink\" title=\"4.6.2.2、|（按位或）\"></a>4.6.2.2、|（按位或）</h4><p>两位一个为1，结果为1，否则为0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  10  (2)</span></span><br><span class=\"line\"><span class=\"section\">| 11  (3)</span></span><br><span class=\"line\"><span class=\"section\">------</span></span><br><span class=\"line\"><span class=\"code\">  11  (3)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-3、-（按位异或）\"><a href=\"#4-6-2-3、-（按位异或）\" class=\"headerlink\" title=\"4.6.2.3、 ^（按位异或）\"></a>4.6.2.3、 ^（按位异或）</h4><p>两位一个为0，结果为1，否则为0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"code\">  10  (2)</span></span><br><span class=\"line\"><span class=\"section\">^ 11  (3)</span></span><br><span class=\"line\"><span class=\"section\">------</span></span><br><span class=\"line\"><span class=\"code\">  01  (1)</span></span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"4-6-2-4、-（按位取反）\"><a href=\"#4-6-2-4、-（按位取反）\" class=\"headerlink\" title=\"4.6.2.4、~（按位取反）\"></a>4.6.2.4、~（按位取反）</h4><p>0-&gt;1, 1-&gt;0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~2 </span><br><span class=\"line\">原码：00000010</span><br><span class=\"line\">按位取反：11111101</span><br><span class=\"line\">补码表示：10000011 = 3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-5、-（算数右移）\"><a href=\"#4-6-2-5、-（算数右移）\" class=\"headerlink\" title=\"4.6.2.5、&gt;&gt;（算数右移）\"></a>4.6.2.5、&gt;&gt;（算数右移）</h4><p>低位溢出，符号位不变，并用符号位补溢出的高位</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &gt;&gt; 2</span><br><span class=\"line\">1的补码：00000001</span><br><span class=\"line\">右移两位，并用符号位填充：00000000</span><br><span class=\"line\">原码结果为：0</span><br><span class=\"line\"></span><br><span class=\"line\">-1 &gt;&gt; 2</span><br><span class=\"line\">-1的补码：11111111</span><br><span class=\"line\">右移两位，并用符号位填充：11111111</span><br><span class=\"line\">原码结果为：100000001 = -1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-6、-（算数左移）\"><a href=\"#4-6-2-6、-（算数左移）\" class=\"headerlink\" title=\"4.6.2.6、&gt;&gt; （算数左移）\"></a>4.6.2.6、&gt;&gt; （算数左移）</h4><p>符号位不变，低位补0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 &lt;&lt; 2</span><br><span class=\"line\">0001 &lt;&lt; 2 = 0100 = 4</span><br><span class=\"line\"></span><br><span class=\"line\">-1 &lt;&lt; 3</span><br><span class=\"line\">11111111 &lt;&lt; 3 = 11111000</span><br><span class=\"line\">原码结果为：10001000 = -8</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-6-2-7、-（逻辑右移-或叫-无符号右移）\"><a href=\"#4-6-2-7、-（逻辑右移-或叫-无符号右移）\" class=\"headerlink\" title=\"4.6.2.7、&gt;&gt;&gt; （逻辑右移 或叫 无符号右移）\"></a>4.6.2.7、&gt;&gt;&gt; （逻辑右移 或叫 无符号右移）</h4><p>低位溢出，高位补0</p>\n<figure class=\"highlight asciidoc\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">8 &gt;&gt;&gt; 2</span><br><span class=\"line\">1000 &gt;&gt;&gt; 2 = 0010 = 2</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、面向对象\"><a href=\"#4、面向对象\" class=\"headerlink\" title=\"4、面向对象\"></a>4、面向对象</h1><h2 id=\"4-1、面向对象三大特征\"><a href=\"#4-1、面向对象三大特征\" class=\"headerlink\" title=\"4.1、面向对象三大特征\"></a>4.1、面向对象三大特征</h2><h3 id=\"4-1-1、封装\"><a href=\"#4-1-1、封装\" class=\"headerlink\" title=\"4.1.1、封装\"></a>4.1.1、封装</h3><p><strong>封装</strong>：尽量避免向外部暴露实现细节，只提供个别接口让使用方调用，降低耦合性。这样做的话，当自身的逻辑发生变化时，不会破坏使用方的逻辑，或是强制使用方修改自身的逻辑，而是只需要修改自身的代码就可以了</p>\n<h3 id=\"4-1-2、继承\"><a href=\"#4-1-2、继承\" class=\"headerlink\" title=\"4.1.2、继承\"></a>4.1.2、继承</h3><p><strong>继承</strong>：子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法。以降低代码编写的冗余度</p>\n<h3 id=\"4-1-3、多态\"><a href=\"#4-1-3、多态\" class=\"headerlink\" title=\"4.1.3、多态\"></a>4.1.3、多态</h3><p><strong>多态</strong>：父类的引用指向子类的对象。它的意义是可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，而这些方法通过一个抽象类或者接口来实现，多态就是提供父类调用子类代码的一个手段而已</p>\n<h2 id=\"4-2、内部类\"><a href=\"#4-2、内部类\" class=\"headerlink\" title=\"4.2、内部类\"></a>4.2、内部类</h2><p>如果定义类在局部位置(方法中&#x2F;代码块) :(1) 局部内部类 (2) 匿名内部类<br>如果定义在成员位置 (1) 成员内部类 (2) 静态内部类  </p>\n<h3 id=\"4-2-1、局部内部类\"><a href=\"#4-2-1、局部内部类\" class=\"headerlink\" title=\"4.2.1、局部内部类\"></a>4.2.1、局部内部类</h3><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名数据</p>\n<blockquote>\n<p>说明：</p>\n<ol>\n<li>可以直接访问外部类的所有成员，包括私有</li>\n<li>不能添加访问修饰符，因为他就是一个局部变量，局部变量不能使用修饰符</li>\n<li>作用域：仅在定义它的方法或代码块中</li>\n<li>局部内部类访问外部类的成员：直接访问。外部类访问局部内部类的成员，创建对象再访问</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">OuterClass</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"type\">int</span> <span class=\"variable\">outerData</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">outerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">localVar</span> <span class=\"operator\">=</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">        <span class=\"keyword\">class</span> <span class=\"title class_\">LocalInnerClass</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">innerMethod</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;访问外部类数据：&quot;</span> + outerData);</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;访问局部变量：&quot;</span> + localVar);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">LocalInnerClass</span> <span class=\"variable\">innerObj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">LocalInnerClass</span>();</span><br><span class=\"line\">        innerObj.innerMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">OuterClass</span> <span class=\"variable\">outerObj</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">OuterClass</span>();</span><br><span class=\"line\">        outerObj.outerMethod();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-2、匿名内部类\"><a href=\"#4-2-2、匿名内部类\" class=\"headerlink\" title=\"4.2.2、匿名内部类\"></a>4.2.2、匿名内部类</h3><p>匿名内部类是一种没有显式定义类名的内部类，定义在外部类的局部位置，比如方法中，它通常用于创建实现某个接口或继承某个类的匿名对象</p>\n<blockquote>\n<p>说明：</p>\n<ol>\n<li>匿名内部类运行类型：外部类名称$1</li>\n</ol>\n</blockquote>\n<ol>\n<li>基于接口的匿名内部类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">IA</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// 编译类型为IA，运行类型为匿名内部类Outer$1</span></span><br><span class=\"line\">       <span class=\"comment\">// jdk 底层在创建匿名内部类 Outer$1,立即马上就创建了 Outer$1 实例，并且把地址返回给 tiger</span></span><br><span class=\"line\">\t    <span class=\"type\">IA</span> <span class=\"variable\">tiger</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">IA</span>() &#123;</span><br><span class=\"line\">\t        <span class=\"meta\">@Override</span> <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">cry</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">\t            System.out.println(<span class=\"string\">&quot;老虎叫...&quot;</span>); </span><br><span class=\"line\">\t        &#125; </span><br><span class=\"line\">\t    &#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>基于类的匿名内部类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Father</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">sayHello</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">// father 编译类型 Father, father 运行类型 Outer$1</span></span><br><span class=\"line\">\t    <span class=\"type\">Father</span> <span class=\"variable\">father</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Father</span>(<span class=\"string\">&quot;jack&quot;</span>)&#123;</span><br><span class=\"line\">\t        <span class=\"meta\">@Override</span></span><br><span class=\"line\">\t        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t            System.out.println(<span class=\"string\">&quot;匿名内部类重写了 test 方法&quot;</span>);</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t    &#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"4-2-3、成员内部类\"><a href=\"#4-2-3、成员内部类\" class=\"headerlink\" title=\"4.2.3、成员内部类\"></a>4.2.3、成员内部类</h3><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p>\n<blockquote>\n<p>说明：</p>\n<ol>\n<li>可以直接访问外部类的所有成员，包括私有的</li>\n<li>可以添加任何修饰符，因为它的地位就是一个成员</li>\n</ol>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    Outer08.<span class=\"type\">Inner08</span> <span class=\"variable\">inner08Instance</span> <span class=\"operator\">=</span> outer08.getInner08Instance();</span><br><span class=\"line\">    inner08Instance.say();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer08</span> &#123; <span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Inner08</span> &#123;<span class=\"comment\">//成员内部类</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//可以直接访问外部类的所有成员，包含私有的</span></span><br><span class=\"line\">            <span class=\"comment\">//如果成员内部类的成员和外部类的成员重名，会遵守就近原则. </span></span><br><span class=\"line\">            <span class=\"comment\">//可以通过 外部类名.this.属性 来访问外部类的成员</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;n1 = &quot;</span> + n1 + <span class=\"string\">&quot; name = &quot;</span> + name + <span class=\"string\">&quot; 外部类的 n1=&quot;</span> + Outer08.<span class=\"built_in\">this</span>.n1);</span><br><span class=\"line\">            hi();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-2-4、静态内部类\"><a href=\"#4-2-4、静态内部类\" class=\"headerlink\" title=\"4.2.4、静态内部类\"></a>4.2.4、静态内部类</h3><p>成员内部类是定义再外部类的成员位置，有static修饰</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    Outer10.<span class=\"type\">Inner10</span> <span class=\"variable\">inner10</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Outer10</span>.Inner10();</span><br><span class=\"line\">    inner10.say();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Outer10</span> &#123; <span class=\"comment\">//外部类</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Inner10</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">String</span> <span class=\"variable\">name</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;卡卡&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">say</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">            cry();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-3、重载和重写\"><a href=\"#4-3、重载和重写\" class=\"headerlink\" title=\"4.3、重载和重写\"></a>4.3、重载和重写</h2><p><strong>重载</strong>发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载<br><strong>重写</strong>，子类重写父类方法，返回值（JDK7以后，被重写的方法返回值类型可以不同，但是必须是父类返回值的派生类）和形参都不能改变</p>\n<blockquote>\n<p>不能根据返回类型来区分重载<br>float max(int a, int b);<br>int max(int a, int b);<br>上面两个方法名称和参数都一致，如果在同一个类中，别的地方调用的时候都是max（1，2），不能区分出想调用哪个方法</p>\n</blockquote>\n<h2 id=\"4-4、抽象类和接口\"><a href=\"#4-4、抽象类和接口\" class=\"headerlink\" title=\"4.4、抽象类和接口\"></a>4.4、抽象类和接口</h2><p>1、接口的设计目的，是对类的行为进行约束。也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制<br>2、而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为。可以在抽象类中实现这种行为。这样它所有的子类就无需重复实现。达到代码复用的目的</p>\n<h2 id=\"4-5、Object类常用方法\"><a href=\"#4-5、Object类常用方法\" class=\"headerlink\" title=\"4.5、Object类常用方法\"></a>4.5、Object类常用方法</h2><ol>\n<li>hashcode（）：将对象的16进制地址值，经过hash算法换算成整值</li>\n<li>toString（）：返回该对象的字符串对象</li>\n<li>equals（）：比较两个对象的地址值是否相同</li>\n<li>clone（）：实现对象的浅拷贝</li>\n<li>getclass（）：获取该对象的字节码文件（该对象运行时的类）Class</li>\n<li>wait（）notify（）notifyAll（）：wait（）让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法</li>\n</ol>\n<blockquote>\n<p>void notify()：唤醒一个正在等待该对象的线程。<br>  void notifyAll()：唤醒所有正在等待该对象的线程</p>\n</blockquote>\n<blockquote>\n<ol>\n<li>equals()没有被重写的情况下等同于 &#x3D;&#x3D;<br>  Object的equals()方法源码：<br> public boolean equals(Object obj) {<br> return (this &#x3D;&#x3D; obj);<br> }<br>  这用情况&#x3D; &#x3D;和equals（）都是引用比较 </li>\n<li>string重写了Object的equals（）方法这种情况equals（）是值比较</li>\n</ol>\n</blockquote>\n<h2 id=\"4-6、深拷贝和浅拷贝\"><a href=\"#4-6、深拷贝和浅拷贝\" class=\"headerlink\" title=\"4.6、深拷贝和浅拷贝\"></a>4.6、深拷贝和浅拷贝</h2><p><strong>浅拷贝</strong>：基本数据类型复制值，引用数据类型复制地址，即拷贝出来的对象与被拷贝出来的对象中的引用的对象是同一个（java默认）：clone方法<br><strong>深拷贝</strong>：基本数据类型复制值，引用数据类型，创建一个新的对象，并复制其内容</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用对象序列化来实现克隆</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Room</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Serializable</span> &#123;</span><br><span class=\"line\">    Desk desk;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Room <span class=\"title function_\">deepClone</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        <span class=\"comment\">//序列化</span></span><br><span class=\"line\">        <span class=\"type\">ByteArrayOutputStream</span> <span class=\"variable\">outputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayOutputStream</span>();</span><br><span class=\"line\">        <span class=\"type\">ObjectOutputStream</span> <span class=\"variable\">objectOutputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectOutputStream</span>(outputStream);</span><br><span class=\"line\">        objectOutputStream.writeObject(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">        <span class=\"comment\">//反序列化</span></span><br><span class=\"line\">        <span class=\"type\">ByteArrayInputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ByteArrayInputStream</span>(outputStream.toByteArray());</span><br><span class=\"line\">        <span class=\"type\">ObjectInputStream</span> <span class=\"variable\">objectInputStream</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectInputStream</span>(inputStream);</span><br><span class=\"line\">        <span class=\"type\">Room</span> <span class=\"variable\">roomClone</span> <span class=\"operator\">=</span> (Room)objectInputStream.readObject();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roomClone;</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-7、面向对象和面向过程的理解\"><a href=\"#4-7、面向对象和面向过程的理解\" class=\"headerlink\" title=\"4.7、面向对象和面向过程的理解\"></a>4.7、面向对象和面向过程的理解</h2><p>是两种不同的处理问题的角度。面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做什么</p>\n<blockquote>\n<p>比如：洗衣机洗衣服<br>  <strong>面向过程</strong>：会将任务拆解成一系列的步骤（函数），1、打开洗衣机 2、放衣服3、放洗衣粉4、清洗 5、烘干<br>  <strong>面向对象</strong>：会拆出人和洗衣机两个对象：人：打开洗衣机，放衣服，放洗衣粉 洗衣机：清洗，烘干</p>\n</blockquote>\n<p>从以上例子能看出，面向过程比较简单直接，而面向对象更易于复用、扩展和维护</p>\n<h2 id=\"4-8、sleep（）和wait（）区别\"><a href=\"#4-8、sleep（）和wait（）区别\" class=\"headerlink\" title=\"4.8、sleep（）和wait（）区别\"></a>4.8、sleep（）和wait（）区别</h2><ol>\n<li>所属的类型不同</li>\n</ol>\n<ul>\n<li>wait()是Object类的实例方法,调用该方法的线程将进入WTING状态。 </li>\n<li>sleep()是Thread类的静态方法,调用该方法的线程将进入TIMED_WTING状态</li>\n</ul>\n<ol>\n<li>对锁的依赖不同</li>\n</ol>\n<ul>\n<li>wait()依赖于synchronized锁,通过监视器进行调用,调用后线程会释放锁。</li>\n<li>sleep()不依赖于任何锁,所以在调用后它也不会释放锁。</li>\n</ul>\n<ol>\n<li>返回的条件不同</li>\n</ol>\n<ul>\n<li>调用wait()进入等待状态的线程,需要由notify()&#x2F;notifyAll()唤醒,从而返回。 </li>\n<li>调用sleep()进入超时等待的线程,需要在超时时间到达后自动返回。</li>\n</ul>\n<h1 id=\"5、枚举\"><a href=\"#5、枚举\" class=\"headerlink\" title=\"5、枚举\"></a>5、枚举</h1><h2 id=\"5-1、实现方式\"><a href=\"#5-1、实现方式\" class=\"headerlink\" title=\"5.1、实现方式\"></a>5.1、实现方式</h2><p> 枚举是一组常量的集合。 可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象  </p>\n<h3 id=\"5-1-1、-自定义类实现枚举\"><a href=\"#5-1-1、-自定义类实现枚举\" class=\"headerlink\" title=\"5.1.1、 自定义类实现枚举\"></a>5.1.1、 自定义类实现枚举</h3><ol>\n<li>不需提供set方法，因为枚举对象值通常为只读</li>\n<li>对枚举对象&#x2F;属性使用final+static共同修饰，实现底层优化</li>\n<li>枚举 对象名通常使用全部大写，常量的命名规范</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Season</span> &#123;<span class=\"comment\">//类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String desc;<span class=\"comment\">//描述</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Season</span> <span class=\"variable\">SPRING</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Season</span>(<span class=\"string\">&quot;春天&quot;</span>, <span class=\"string\">&quot;温暖&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Season</span> <span class=\"variable\">WINTER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Season</span>(<span class=\"string\">&quot;冬天&quot;</span>, <span class=\"string\">&quot;寒冷&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Season</span> <span class=\"variable\">AUTUMN</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Season</span>(<span class=\"string\">&quot;秋天&quot;</span>, <span class=\"string\">&quot;凉爽&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">Season</span> <span class=\"variable\">SUMMER</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Season</span>(<span class=\"string\">&quot;夏天&quot;</span>, <span class=\"string\">&quot;炎热&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Enumeration02</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(Season.AUTUMN);</span><br><span class=\"line\">        System.out.println(Season.SPRING);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"5-1-2、enum关键字实现枚举\"><a href=\"#5-1-2、enum关键字实现枚举\" class=\"headerlink\" title=\"5.1.2、enum关键字实现枚举\"></a>5.1.2、enum关键字实现枚举</h3><ol>\n<li>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类,  这样我们就可以使用 Enum 类相关的方法  </li>\n<li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li>\n<li>当有多个枚举对象时，使用,间隔，最后有一个分号结尾</li>\n<li>枚举对象必须放在枚举类的行首</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Enumeration03</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        System.out.println(Season2.AUTUMN);</span><br><span class=\"line\">        System.out.println(Season2.SUMMER);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//演示使用 enum 关键字来实现枚举类</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Season2</span> &#123;<span class=\"comment\">//类</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//3. 如果有多个常量(对象)， 使用 ,号间隔即可</span></span><br><span class=\"line\">    <span class=\"comment\">//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面</span></span><br><span class=\"line\">    <span class=\"comment\">//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()</span></span><br><span class=\"line\">    SPRING(<span class=\"string\">&quot;春天&quot;</span>, <span class=\"string\">&quot;温暖&quot;</span>), </span><br><span class=\"line\">    WINTER(<span class=\"string\">&quot;冬天&quot;</span>, <span class=\"string\">&quot;寒冷&quot;</span>), </span><br><span class=\"line\">    AUTUMN(<span class=\"string\">&quot;秋天&quot;</span>, <span class=\"string\">&quot;凉爽&quot;</span>), </span><br><span class=\"line\">    SUMMER(<span class=\"string\">&quot;夏天&quot;</span>, <span class=\"string\">&quot;炎热&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String desc;<span class=\"comment\">//描述</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Season2</span><span class=\"params\">()</span> &#123;<span class=\"comment\">//无参构造器</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"title function_\">Season2</span><span class=\"params\">(String name, String desc)</span> &#123;<span class=\"comment\">//有参构造器</span></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.desc = desc;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6、注解\"><a href=\"#6、注解\" class=\"headerlink\" title=\"6、注解\"></a>6、注解</h1><pre><code> 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息 。和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息  \n</code></pre>\n<h2 id=\"6-1、基本注解介绍\"><a href=\"#6-1、基本注解介绍\" class=\"headerlink\" title=\"6.1、基本注解介绍\"></a>6.1、基本注解介绍</h2><p> 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 </p>\n<p> 三个基本的 Annotation:  </p>\n<ol>\n<li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法 </li>\n<li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时 </li>\n<li>@SuppressWarnings: 抑制编译器警告（当不希望看到某些警告使用该注解，都不想看到使用all）</li>\n</ol>\n<h2 id=\"6-2、自定义注解\"><a href=\"#6-2、自定义注解\" class=\"headerlink\" title=\"6.2、自定义注解\"></a>6.2、自定义注解</h2><p>修饰符：访问修饰符必须为public,不写默认为pubic；<br>关键字：关键字为@interface；<br>注解名称： 注解名称为自定义注解的名称，使用时还会用到；<br>注解类型元素：注解属性 ( 接口方法 ) 返回值类型要求 ,可以使用default来进行赋默认值；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Info &#123; </span><br><span class=\"line\">    String <span class=\"title function_\">value</span><span class=\"params\">()</span> <span class=\"keyword\">default</span> <span class=\"string\">&quot;tracy&quot;</span>; </span><br><span class=\"line\">    <span class=\"type\">boolean</span> <span class=\"title function_\">isDelete</span><span class=\"params\">()</span>; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-3、元注解\"><a href=\"#6-3、元注解\" class=\"headerlink\" title=\"6.3、元注解\"></a>6.3、元注解</h2><p>所谓元注解，其主要作用就是负责注解其他注解，为其他注解提供了相关的解释说明。<br>Java中存在五个元注解，分别是 @Target、@Retention、@Documented、@Inherited、@Repeatable</p>\n<ol>\n<li><strong>Target</strong>：描述了注解修饰的对象范围，取值在java.lang.annotation.ElementType定义，常用包括：</li>\n</ol>\n<blockquote>\n<p>METHOD：用于描述方法<br>PACKAGE：用于描述包<br>PARAMETER：用于描述方法变量<br>TYPE：用于描述类、接口或enum类型</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>Retention</strong>：表述注解保留时间的长短，取值在java.lang.annotation.RetentionPolicy中，取值：</li>\n</ol>\n<blockquote>\n<p>SOURCE：在源文件中有效，编译过程中会被忽略<br>CLASS：随源文件一起编译在class文件中，运行时忽略<br>RUNTIME：在运行时有效(只有定义为RetentionPolicy.RUNTIME时，我们才能通过注解反射获取注解)</p>\n</blockquote>\n<ol start=\"3\">\n<li><p><strong>Document</strong>：表明这个注解应该被 javadoc文档注释工具记录，正常情况下javadoc中不包含注解的，@Documented属于标志注解</p>\n</li>\n<li><p><strong>Inherited</strong>:被该注解注解的元注解注解某个类时，子类继承该注解</p>\n</li>\n<li><p>@Repeatable 是 Java 8 引入的一个注解，用于在同一个元素上多次使用相同的注解。通过使用 @Repeatable 注解，可以使得某个注解可以重复应用于同一目标上，而无需使用容器注解或数组</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Color(&quot;Red&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@Color(&quot;Blue&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">printColors</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-4、案例-自定义注解实现日志功能\"><a href=\"#6-4、案例-自定义注解实现日志功能\" class=\"headerlink\" title=\"6.4、案例-自定义注解实现日志功能\"></a>6.4、案例-自定义注解实现日志功能</h2><ol>\n<li>定义一个注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Loggable &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建切面类，使用 @Before 注解和 @AfterReturning 注解分别标记了在方法执行前和方法执行后执行的通知方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoggingAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Before(&quot;@annotation(Loggable)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">beforeMethodExecution</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> joinPoint.getSignature().getName();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Entering method: &quot;</span> + methodName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterReturning(&quot;@annotation(Loggable)&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">afterMethodExecution</span><span class=\"params\">(JoinPoint joinPoint)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">methodName</span> <span class=\"operator\">=</span> joinPoint.getSignature().getName();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Exiting method: &quot;</span> + methodName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>在需要进行日志记录的方法上添加 @Loggable 注解即可</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Loggable</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doSomething</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">doAnotherThing</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、异常\"><a href=\"#7、异常\" class=\"headerlink\" title=\"7、异常\"></a>7、异常</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251414029.png\" alt=\"异常分类\"></p>\n<h2 id=\"7-1、Error（错误）\"><a href=\"#7-1、Error（错误）\" class=\"headerlink\" title=\"7.1、Error（错误）\"></a>7.1、<strong>Error（错误）</strong></h2><p>程序本身不能处理的异常，只能靠外接干预 （常见的如<strong>内存溢出</strong>，j<strong>vm虚拟机自身的非正常运行</strong>等）</p>\n<h2 id=\"7-2、Exception（异常）\"><a href=\"#7-2、Exception（异常）\" class=\"headerlink\" title=\"7.2、Exception（异常）\"></a>7.2、<strong>Exception（异常）</strong></h2><p>是程序正常运行中，可以预料的意外情况。比如数据库连接中断，空指针，数组下标越界。异常出现可以导致程序非正常终止</p>\n<p>（1）编译时异常<br>又叫可检查异常，Java语言强制要求捕获和处理所有非运行时异常。通过行为规范，强化程序的健壮性和安全性</p>\n<p>（2）运行时异常<br>又叫不检查异常RuntimeException，这些异常一般是由程序逻辑错误引起的，即语义错</p>\n<h1 id=\"8、常用类\"><a href=\"#8、常用类\" class=\"headerlink\" title=\"8、常用类\"></a>8、常用类</h1><h2 id=\"8-1、日期类\"><a href=\"#8-1、日期类\" class=\"headerlink\" title=\"8.1、日期类\"></a>8.1、日期类</h2><h3 id=\"8-1-1、第一代日期类Date（JDK1-0）\"><a href=\"#8-1-1、第一代日期类Date（JDK1-0）\" class=\"headerlink\" title=\"8.1.1、第一代日期类Date（JDK1.0）\"></a>8.1.1、第一代日期类Date（JDK1.0）</h3><ol>\n<li>Date：精确到毫秒，代表特定瞬间</li>\n<li>SimpleDateFormat：格式化（日期-文本）和解析日期（文本-日期）的类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">sdf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// format：将日期转换成指定格式的字符串</span></span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">d1</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">format</span> <span class=\"operator\">=</span> sdf.format(d1); </span><br><span class=\"line\"><span class=\"comment\">// parse：格式化的String 转成对应的 Date</span></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;1996 年 01 月 01 日 10:20:30 星期一&quot;</span>;</span><br><span class=\"line\"><span class=\"type\">Date</span> <span class=\"variable\">parse</span> <span class=\"operator\">=</span> sdf.parse(s);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-2、第二代日期类Calendar（JDK1-1）\"><a href=\"#8-1-2、第二代日期类Calendar（JDK1-1）\" class=\"headerlink\" title=\"8.1.2、第二代日期类Calendar（JDK1.1）\"></a>8.1.2、第二代日期类Calendar（JDK1.1）</h3><p>Calendar它是一种抽象类，相比Date它在操作日历的时候提供了一些方法来操作日历字段</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Calendar 是一个抽象类， 并且构造器是 private,可以通过 getInstance() 来获取实例</span></span><br><span class=\"line\"><span class=\"comment\">// Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//1. 创建日历类对象</span></span><br><span class=\"line\"><span class=\"type\">Calendar</span> <span class=\"variable\">c</span> <span class=\"operator\">=</span> Calendar.getInstance(); </span><br><span class=\"line\"><span class=\"comment\">//2. 获取日历对象的某个日历字段</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;年：&quot;</span> + c.get(Calendar.YEAR));</span><br><span class=\"line\"><span class=\"comment\">// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;月：&quot;</span> + (c.get(Calendar.MONTH) + <span class=\"number\">1</span>));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;日：&quot;</span> + c.get(Calendar.DAY_OF_MONTH));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;小时：&quot;</span> + c.get(Calendar.HOUR));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;分钟：&quot;</span> + c.get(Calendar.MINUTE));</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;秒：&quot;</span> + c.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"8-1-3、第三代日期类LocalDate（JDK8）\"><a href=\"#8-1-3、第三代日期类LocalDate（JDK8）\" class=\"headerlink\" title=\"8.1.3、第三代日期类LocalDate（JDK8）\"></a>8.1.3、第三代日期类LocalDate（JDK8）</h3><ol>\n<li><strong>Calendar日期类存在的问题？</strong></li>\n</ol>\n<p>（1）可变性，像日期和时间这样的类应该是不可变的<br>（2）格式化，格式化只对Date有用，Calendar只能自己拼装<br>（3）不是线程安全的；不能处理闰秒（每隔两天，多出一秒）等</p>\n<ol start=\"2\">\n<li><strong>基本概念</strong></li>\n</ol>\n<p>LocalDate：日期（年月日）<br>LocalTime：包含时间（时分秒）<br>LocalDateTime：包含日期+时间（年月日时分秒）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//1. 使用 now() 返回表示当前日期时间的 对象</span></span><br><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">ldt</span> <span class=\"operator\">=</span> LocalDateTime.now(); <span class=\"comment\">//LocalDate.now();//LocalTime.now()</span></span><br><span class=\"line\"><span class=\"comment\">//2. 使用 DateTimeFormatter 对象来进行格式化</span></span><br><span class=\"line\"><span class=\"type\">DateTimeFormatter</span> <span class=\"variable\">dateTimeFormatter</span> <span class=\"operator\">=</span> DateTimeFormatter.ofPattern(<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">format</span> <span class=\"operator\">=</span> dateTimeFormatter.format(ldt);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;格式化的日期=&quot;</span> + format);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;年=&quot;</span> + ldt.getYear());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;月=&quot;</span> + ldt.getMonth());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;月=&quot;</span> + ldt.getMonthValue());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;日=&quot;</span> + ldt.getDayOfMonth());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;时=&quot;</span> + ldt.getHour());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;分=&quot;</span> + ldt.getMinute());</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;秒=&quot;</span> + ldt.getSecond());</span><br><span class=\"line\"><span class=\"type\">LocalDate</span> <span class=\"variable\">now</span> <span class=\"operator\">=</span> LocalDate.now(); <span class=\"comment\">//可以获取年月日</span></span><br><span class=\"line\"><span class=\"type\">LocalTime</span> <span class=\"variable\">now2</span> <span class=\"operator\">=</span> LocalTime.now();<span class=\"comment\">//获取到时分秒</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 提供 plus 和 minus 方法可以对当前时间进行加或者减</span></span><br><span class=\"line\"><span class=\"comment\">//看看 890 天后，是什么时候 把 年月日-时分秒</span></span><br><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">localDateTime</span> <span class=\"operator\">=</span> ldt.plusDays(<span class=\"number\">890</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;890 天后=&quot;</span> + dateTimeFormatter.format(localDateTime));</span><br><span class=\"line\"><span class=\"comment\">//看看在 3456 分钟前是什么时候，把 年月日-时分秒</span></span><br><span class=\"line\"><span class=\"type\">LocalDateTime</span> <span class=\"variable\">localDateTime2</span> <span class=\"operator\">=</span> ldt.minusMinutes(<span class=\"number\">3456</span>);</span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;3456 分钟前 日期=&quot;</span> + dateTimeFormatter.format(localDateTime2));</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"8-2、容器\"><a href=\"#8-2、容器\" class=\"headerlink\" title=\"8.2、容器\"></a>8.2、容器</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301540735.png\" alt=\"image.png\"></p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>底层</th>\n<th>线程安全性</th>\n<th>扩容机制</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ArrayList</td>\n<td>数组</td>\n<td>线程不安全</td>\n<td>首次创建长度为10，扩为1.5倍</td>\n<td>查找快，增删慢</td>\n</tr>\n<tr>\n<td>Vector</td>\n<td>数组</td>\n<td>线程安全</td>\n<td>首次创建长度为10，扩为1.5倍</td>\n<td>查找快，增删慢</td>\n</tr>\n<tr>\n<td>LinkedList</td>\n<td>双向链表</td>\n<td>线程不安全</td>\n<td>不主动扩容</td>\n<td>增删快，查找慢</td>\n</tr>\n<tr>\n<td>HashSet</td>\n<td>HashMap</td>\n<td>线程不安全</td>\n<td></td>\n<td>可以存null</td>\n</tr>\n<tr>\n<td>LinkedHashSet</td>\n<td>LinkedHashMap</td>\n<td>线程不安全</td>\n<td></td>\n<td>可以存null</td>\n</tr>\n<tr>\n<td>TreeSet</td>\n<td>TreeMap</td>\n<td>线程不安全</td>\n<td></td>\n<td>不允许存null</td>\n</tr>\n<tr>\n<td>HashMap</td>\n<td>数组+链表（jdk7） 数组+链表+红黑树 （jdk8）</td>\n<td>线程不安全</td>\n<td>首次创建长度16，扩容2倍,负载因子0.75</td>\n<td>可以存nul</td>\n</tr>\n<tr>\n<td>LinkedHashMap</td>\n<td>同hashmap</td>\n<td>线程不安全</td>\n<td>不主动扩容</td>\n<td>可以存null</td>\n</tr>\n<tr>\n<td>HashTable</td>\n<td>数组+链表</td>\n<td>线程安全</td>\n<td>首次创建时长度为11，扩容为2n+1</td>\n<td>不能为null</td>\n</tr>\n<tr>\n<td>TreeMap</td>\n<td>红黑树</td>\n<td>线程不安全</td>\n<td>TreeMap由红黑树实现，容量方面没有限制</td>\n<td>不能为null 可以实现自然排序和定制排序</td>\n</tr>\n</tbody></table>\n<h3 id=\"8-2-1、hashmap原理\"><a href=\"#8-2-1、hashmap原理\" class=\"headerlink\" title=\"8.2.1、hashmap原理\"></a>8.2.1、hashmap原理</h3><p>hashmap数据结构是数组+链表+红黑树，HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对<br>两个重要的方法put() get()<br>（1）.put方法：调用key的hash方法得hash值，再与（数组长度-1）做与（&amp;）运算，到这个元素在数组中的位置（即下标）如果该位置已经存在其它元素，那么在同一个位子上的元素将以链表的形式存放，通过equals方法依次比较链表中的key，相同则替换。不同则添加到表尾（1.8之前添加到表头）。<br>（2）.get方法：调用key的hash方法得到这个元素在数组中的位置（即下标），然后通过key的equals方法在对应位置的链表中找到需要的元素。</p>\n<blockquote>\n<p>（需要注意Jdk 1.8中对HashMap的实现做了优化,当链表长度大于8且数组长度超过64并之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)）<br>如果数组长度不足64，优先会进行扩容</p>\n</blockquote>\n<h3 id=\"8-2-2、自然排序和定制排序\"><a href=\"#8-2-2、自然排序和定制排序\" class=\"headerlink\" title=\"8.2.2、自然排序和定制排序\"></a>8.2.2、自然排序和定制排序</h3><p>自然排序：实现Comparable接口，实现compareTo方法</p>\n<blockquote>\n<p>典型实现：String，Integer，Date等</p>\n</blockquote>\n<p>定制排序：当元素对象没有实现comparable接口，又不方便修改，可以考虑使用定制排序，直接在调用方排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(arrayList, <span class=\"keyword\">new</span> <span class=\"title class_\">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">compare</span><span class=\"params\">(Integer o1, Integer o2)</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> o1.compareTo(o2);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"8-3、String\"><a href=\"#8-3、String\" class=\"headerlink\" title=\"8.3、String\"></a>8.3、String</h2><p>不可变性的理解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">s</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;abc&quot;</span>;    <span class=\"comment\">//(1)</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s = &quot;</span> + s);</span><br><span class=\"line\"> </span><br><span class=\"line\">s = <span class=\"string\">&quot;123&quot;</span>;    <span class=\"comment\">//(2)</span></span><br><span class=\"line\">System.out.println(<span class=\"string\">&quot;s = &quot;</span> + s);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270955924.jpg\" alt=\"b6f0e64b3015ee2ebe2bd49b02c2a68.jpg|275\"></p>\n<p>s只是一个String对象的引用，并不是String对象本身。<br>当执行(1)处这行代码之后，会先在方法区的运行时常量池创建一个String对象”abc”，然后在Java栈中创建一个String对象的引用s，并让s指向”abc”<br>当执行完(2)处这行代码之后，会在方法区的运行时常量池创建一个新的String对象”123”，然后让引用s重新指向这个新的对象，而原来的对象”abc”还在内存中，并没有改变</p>\n<p>为什么这样设计？<br>(1)、字符串常量池中的对象可能被很多对象引用，如果一个修改会导致所有对象的内容都变<br>(2)、hashmap中key的hash方法只会调用一次然后缓存起来，如果key可变会导致缓存的结果和真实的计算结果不一致</p>\n<h1 id=\"9、泛型\"><a href=\"#9、泛型\" class=\"headerlink\" title=\"9、泛型\"></a>9、泛型</h1><h2 id=\"9-1、基本概念\"><a href=\"#9-1、基本概念\" class=\"headerlink\" title=\"9.1、基本概念\"></a>9.1、基本概念</h2><p>（1）泛型：Java在jdk5引入了泛型，在没有泛型之前，每次从集合中读取的对象都必须进行类型转换，如果在插入对象时，类型出错，那么在运行时转换处理的阶段就会报错。在提出泛型之后就可以明确的指定集合接受哪些对象类型，编译器就能知晓并且自动为插入的代码进行泛化，在编译阶段告知是否插入类型错误的对象，程序会变得更加安全清晰。<br>（2）泛型擦除：Java泛型是伪泛型，因为Java代码在编译阶段，所有的泛型信息会被擦除，Java的泛型基本上都是在编辑器这个层次上实现的，在生成的字节码文件中是不包含泛型信息的，使用泛型的时候加上的类型，在编译阶段会被擦除掉，这个过程称为泛型擦除。</p>\n<p>为什么使用泛型？<br>（1）保证类型安全：可以确保在编译时期检测到类型不匹配的错误，避免在运行时出现类型转换错误<br>（2）消除强制转换：消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会</p>\n<h2 id=\"9-2、泛型使用方式\"><a href=\"#9-2、泛型使用方式\" class=\"headerlink\" title=\"9.2、泛型使用方式\"></a>9.2、泛型使用方式</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。</p>\n<blockquote>\n<p>T是泛型中的类型参数声明，它表示一个占位符,通常用大写字母表示（例如 T、E、K、V 等），但实际上它只是一个占位符，可以根据需要自定义</p>\n<p>T：任意类型 type<br> E：集合中元素的类型 element<br> K：key-value形式 key<br> V：key-value形式 value</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 泛型类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Box</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T item;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setItem</span><span class=\"params\">(T item)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.item = item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> T <span class=\"title function_\">getItem</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 泛型接口</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">List</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> <span class=\"title function_\">add</span><span class=\"params\">(T element)</span>;</span><br><span class=\"line\">    T <span class=\"title function_\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span>;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 泛型方法</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Utils</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; T <span class=\"title function_\">getFirstElement</span><span class=\"params\">(List&lt;T&gt; list)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (list != <span class=\"literal\">null</span> &amp;&amp; !list.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> list.get(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"9-3、泛型通配符\"><a href=\"#9-3、泛型通配符\" class=\"headerlink\" title=\"9.3、泛型通配符\"></a>9.3、泛型通配符</h2><p>泛型通配符是一种特殊的类型参数，用于在使用泛型时表示未知类型或限制类型范围</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1：表示类型参数可以是任何类型</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span>&lt;?&gt;&#123;&#125; </span><br><span class=\"line\"><span class=\"comment\">// 2：表示类型参数必须是A或者是A的子类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span>&lt;T <span class=\"keyword\">extends</span> <span class=\"title class_\">A</span>&gt;&#123;&#125; </span><br><span class=\"line\"><span class=\"comment\">// 3: 表示类型参数必须是A或者是A的超类型</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Apple</span>&lt;T supers A&gt;&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"9-4、实现原理\"><a href=\"#9-4、实现原理\" class=\"headerlink\" title=\"9.4、实现原理\"></a>9.4、实现原理</h2><p>原码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Caculate</span>&lt;T&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> T num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>编译后的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Caculate</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Caculate</span><span class=\"params\">()</span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object num;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>java的泛型称为伪泛型，因为Java的泛型只是编译期的泛型，一旦编译成字节码，泛型就被擦除了，即在Java中使用泛型，我们无法在运行期知道泛型的类型，一旦编译成字节码，泛型将被取代为Object。<br>在不使用泛型时，我们需要将Object手动转型成特定类型，而在使用泛型后，我们不需要自己转型，但实际上我们get到的对象仍然是Object类型的，只不过编译器会自动帮我们加入这个转型动作</p>\n<h1 id=\"10、IO\"><a href=\"#10、IO\" class=\"headerlink\" title=\"10、IO\"></a>10、IO</h1><h2 id=\"10-1、概述\"><a href=\"#10-1、概述\" class=\"headerlink\" title=\"10.1、概述\"></a>10.1、概述</h2><h3 id=\"10-1-1、简介\"><a href=\"#10-1-1、简介\" class=\"headerlink\" title=\"10.1.1、简介\"></a>10.1.1、简介</h3><p>I（Input）O（Output）：中文翻译为输入输出，我们知道计算机的数据不管是软件、视频、音乐、游戏等最终都是存储在硬盘中的，当我们打开后，由CPU将硬盘中的数据读取到内存中来运行。这样一个过程就产生了I&#x2F;O（输入&#x2F;输出）</p>\n<blockquote>\n<p>输入：硬盘 -&gt; 内存<br>输出：内存 -&gt; 硬盘</p>\n</blockquote>\n<h3 id=\"10-1-2、IO流的分类\"><a href=\"#10-1-2、IO流的分类\" class=\"headerlink\" title=\"10.1.2、IO流的分类\"></a>10.1.2、IO流的分类</h3><p>按照操作数据单位不同分为：字节流（8bit）二进制文件，字符流（按字符）文本文件<br>按数据流的流向不同分为：输入流，输出流</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1659662289021-93129478-8cc1-4d9c-82c9-932c15153a37.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=114&id=uf89be968&originHeight=167&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=154323&status=done&style=none&taskId=u5d128cf6-4c3f-4321-a117-49823508580&title=&width=567\" alt=\"image.png\"></p>\n<blockquote>\n<p>java的IO流共涉及40多个类，都是从如上4个抽象基类派生</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251511757.png\" alt=\"IO流体系\"></p>\n<h2 id=\"10-2、字节流\"><a href=\"#10-2、字节流\" class=\"headerlink\" title=\"10.2、字节流\"></a>10.2、字节流</h2><h3 id=\"10-2-1、字节输出流\"><a href=\"#10-2-1、字节输出流\" class=\"headerlink\" title=\"10.2.1、字节输出流\"></a>10.2.1、字节输出流</h3><p>OutputStream是所有字节输出的顶层父类，该父类提供如下公共方法：</p>\n<h4 id=\"10-2-1-1、FileOutputStream\"><a href=\"#10-2-1-1、FileOutputStream\" class=\"headerlink\" title=\"10.2.1.1、FileOutputStream\"></a>10.2.1.1、FileOutputStream</h4><p>FileOutputStream是OutputStream中一个常用的子类，他可以关联一个文件，用于将数据写出到文件</p>\n<blockquote>\n<p>构造方法：<br>public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。<br> public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IOTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用文件名称创建流对象</span></span><br><span class=\"line\">        <span class=\"type\">FileOutputStream</span> <span class=\"variable\">fos</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileOutputStream</span>(<span class=\"string\">&quot;000.txt&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 字符串转换为字节数组</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] b = <span class=\"string\">&quot;abcde&quot;</span>.getBytes();</span><br><span class=\"line\">        <span class=\"comment\">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class=\"line\">        fos.write(b,<span class=\"number\">2</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        fos.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是，在UTF-8编码下，一个中文占用3个字节，GBK编码下一个中文占用2个字节，因此在使用字节流来精确操作字符数据时将会变得非常麻烦</p>\n</blockquote>\n<h3 id=\"10-2-2、字节输入流\"><a href=\"#10-2-2、字节输入流\" class=\"headerlink\" title=\"10.2.2、字节输入流\"></a>10.2.2、字节输入流</h3><h4 id=\"10-2-2-1、FileInputStream\"><a href=\"#10-2-2-1、FileInputStream\" class=\"headerlink\" title=\"10.2.2.1、FileInputStream\"></a>10.2.2.1、FileInputStream</h4><p>java.io.FileInputStream类是文件输入流，从文件中读取字节</p>\n<blockquote>\n<p>构造方法：<br>FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。<br> FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IOTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用文件名称创建流对象.</span></span><br><span class=\"line\">        <span class=\"type\">FileInputStream</span> <span class=\"variable\">fis</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileInputStream</span>(<span class=\"string\">&quot;abc.txt&quot;</span>); <span class=\"comment\">// 文件中为abcde</span></span><br><span class=\"line\">        <span class=\"comment\">// 定义变量，作为有效个数</span></span><br><span class=\"line\">        <span class=\"type\">int</span> len;</span><br><span class=\"line\">        <span class=\"comment\">// 定义字节数组，作为装字节数据的容器</span></span><br><span class=\"line\">        <span class=\"type\">byte</span>[] b = <span class=\"keyword\">new</span> <span class=\"title class_\">byte</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"comment\">// 循环读取</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((len = fis.read(b)) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(b, <span class=\"number\">0</span>, len));<span class=\"comment\">//  len 每次读取的有效字节个数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        fis.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"10-3、字符流\"><a href=\"#10-3、字符流\" class=\"headerlink\" title=\"10.3、字符流\"></a>10.3、字符流</h2><p>计算机都是按照字节进行存储的，我们之前学习过编码表，通过编码表可以将字节转换为对应的字符，但是世界上有非常多的编码表，不同的编码表规定的单个字符所占用的字节可能都不一样，例如在GBK编码表中一个中文占2个字节，UTF8编码表则占3个字节；且一个中文字符都是由多个字节组成的，为此我们不能再基于字节的操作单位来操作文本文件了，因为这样太过麻烦，我们希望基于字符来操作文件，一次操作读取一个“字符”而不是一个“字节”，这样在操作文本文件时非常便捷</p>\n<h3 id=\"10-3-1、字符输出流\"><a href=\"#10-3-1、字符输出流\" class=\"headerlink\" title=\"10.3.1、字符输出流\"></a>10.3.1、字符输出流</h3><h4 id=\"10-3-1-1、FileWriter类\"><a href=\"#10-3-1-1、FileWriter类\" class=\"headerlink\" title=\"10.3.1.1、FileWriter类\"></a>10.3.1.1、FileWriter类</h4><p>java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo03_</span>写出字符数组 &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用文件名称创建流对象</span></span><br><span class=\"line\">        <span class=\"type\">FileWriter</span> <span class=\"variable\">fw</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileWriter</span>(<span class=\"string\">&quot;002.txt&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 字符串转换为字节数组</span></span><br><span class=\"line\">        <span class=\"type\">char</span>[] chars = <span class=\"string\">&quot;我是中国人&quot;</span>.toCharArray();</span><br><span class=\"line\">        <span class=\"comment\">// 写出字符数组</span></span><br><span class=\"line\">        fw.write(chars); <span class=\"comment\">// 我是中国人</span></span><br><span class=\"line\">        <span class=\"comment\">// 写出从索引2开始，2个字节。索引2是&#x27;中&#x27;，两个字节，也就是&#x27;中国&#x27;。</span></span><br><span class=\"line\">        fw.write(chars,<span class=\"number\">2</span>,<span class=\"number\">2</span>); <span class=\"comment\">// 中国</span></span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        fw.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-3-2、字符输入流\"><a href=\"#10-3-2、字符输入流\" class=\"headerlink\" title=\"10.3.2、字符输入流\"></a>10.3.2、字符输入流</h3><h4 id=\"10-3-2-1、FileReader类\"><a href=\"#10-3-2-1、FileReader类\" class=\"headerlink\" title=\"10.3.2.1、FileReader类\"></a>10.3.2.1、FileReader类</h4><p>java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区</p>\n<blockquote>\n<p>Windows系统的中文编码默认是GBK编码表。idea中默认是UTF-8 </p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">IoTest</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用文件名称创建流对象</span></span><br><span class=\"line\">        <span class=\"type\">FileReader</span> <span class=\"variable\">fr</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FileReader</span>(<span class=\"string\">&quot;001.txt&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 定义变量，保存数据</span></span><br><span class=\"line\">        <span class=\"type\">int</span> data;</span><br><span class=\"line\">        <span class=\"comment\">// 循环读取</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((data = fr.read()) != -<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 以数值的方式输出</span></span><br><span class=\"line\"><span class=\"comment\">//            System.out.println(b);</span></span><br><span class=\"line\">            <span class=\"comment\">// 以字符的方式输出</span></span><br><span class=\"line\">            System.out.println((<span class=\"type\">char</span>) data);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 关闭资源</span></span><br><span class=\"line\">        fr.close();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"11、反射\"><a href=\"#11、反射\" class=\"headerlink\" title=\"11、反射\"></a>11、反射</h1><h2 id=\"11-1、概述\"><a href=\"#11-1、概述\" class=\"headerlink\" title=\"11.1、概述\"></a>11.1、概述</h2><h3 id=\"11-1-1、基本概念\"><a href=\"#11-1-1、基本概念\" class=\"headerlink\" title=\"11.1.1、基本概念\"></a>11.1.1、基本概念</h3><p>Java反射是指在运行时动态地获取类的信息并操作类或对象的能力。它提供了一组API，使得可以在运行时检查类、接口、字段和方法，并且可以在运行时实例化对象、调用方法、获取和设置字段的值</p>\n<h3 id=\"11-1-2、好处\"><a href=\"#11-1-2、好处\" class=\"headerlink\" title=\"11.1.2、好处\"></a>11.1.2、好处</h3><ol>\n<li>运行时类信息：反射允许在运行时获取类的信息，包括类的名称、字段、方法、注解等。这使得可以动态地了解和操作类的结构，从而实现更加灵活和通用的代码设计。</li>\n<li>动态创建对象：通过反射可以在运行时动态地实例化对象，而不需要在编译时明确知道类的类型。这对于根据配置文件或用户输入来创建对象非常有用，可以实现更大程度的灵活性和可配置性。</li>\n<li>动态调用方法：反射可以在运行时动态地调用类的方法，包括公共方法、私有方法和静态方法。这对于实现插件机制、扩展性和动态逻辑非常有用，可以根据运行时条件来调用不同的方法。</li>\n<li>访问私有成员：反射可以绕过访问权限限制，访问类的私有成员。这对于测试、调试和特定场景下的操作非常有用，但也需要小心使用，以遵循封装原则。</li>\n<li>序列化和反序列化：反射在序列化和反序列化过程中起着重要的作用。通过反射可以分析对象的结构，并将其转换为字节流或从字节流中重建对象</li>\n</ol>\n<h2 id=\"11-2、-获取Class对象的方式\"><a href=\"#11-2、-获取Class对象的方式\" class=\"headerlink\" title=\"11.2、 获取Class对象的方式\"></a>11.2、 获取Class对象的方式</h2><ol>\n<li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li>\n<li>类名.class：通过类名的属性class获取，多用于参数的传递 </li>\n<li>对象.getClass()：getClass()方法在Object类中定义着</li>\n</ol>\n<blockquote>\n<p>同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</p>\n</blockquote>\n<h2 id=\"11-3、Class对象功能\"><a href=\"#11-3、Class对象功能\" class=\"headerlink\" title=\"11.3、Class对象功能\"></a>11.3、Class对象功能</h2><ol>\n<li>获取成员变量</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Field[] getFields() ：获取所有<span class=\"keyword\">public</span>修饰的成员变量</span><br><span class=\"line\">Field <span class=\"title function_\">getField</span><span class=\"params\">(String name)</span>   获取指定名称的 <span class=\"keyword\">public</span>修饰的成员变量</span><br><span class=\"line\">Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</span><br><span class=\"line\">Field <span class=\"title function_\">getDeclaredField</span><span class=\"params\">(String name)</span>  </span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>获取构造方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Constructor&lt;?&gt;[] getConstructors()  返回<span class=\"keyword\">public</span>修饰的构造方法</span><br><span class=\"line\">Constructor&lt;T&gt; <span class=\"title function_\">getConstructor</span><span class=\"params\">(类&lt;?&gt;... parameterTypes)</span>  </span><br><span class=\"line\">Constructor&lt;T&gt; <span class=\"title function_\">getDeclaredConstructor</span><span class=\"params\">(类&lt;?&gt;... parameterTypes)</span>  </span><br><span class=\"line\">Constructor&lt;?&gt;[] getDeclaredConstructors()  返回所有的构造方法</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>获取成员方法</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Method[] getMethods()  </span><br><span class=\"line\">Method <span class=\"title function_\">getMethod</span><span class=\"params\">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span><br><span class=\"line\">Method[] getDeclaredMethods()  </span><br><span class=\"line\">Method <span class=\"title function_\">getDeclaredMethod</span><span class=\"params\">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>获取全类名</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String <span class=\"title function_\">getName</span><span class=\"params\">()</span>  </span><br></pre></td></tr></table></figure>\n<h2 id=\"11-4、Field-成员变量\"><a href=\"#11-4、Field-成员变量\" class=\"headerlink\" title=\"11.4、Field 成员变量\"></a>11.4、Field 成员变量</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 设置值</span><br><span class=\"line\">\t<span class=\"keyword\">void</span> <span class=\"title function_\">set</span><span class=\"params\">(Object obj, Object value)</span>  </span><br><span class=\"line\"><span class=\"number\">2.</span> 获取值</span><br><span class=\"line\">\tget(Object obj) </span><br><span class=\"line\"><span class=\"number\">3.</span> 忽略访问权限修饰符的安全检查</span><br><span class=\"line\">\tsetAccessible(<span class=\"literal\">true</span>):暴力反射</span><br></pre></td></tr></table></figure>\n<h2 id=\"11-5、Constructor-构造方法\"><a href=\"#11-5、Constructor-构造方法\" class=\"headerlink\" title=\"11.5、Constructor 构造方法\"></a>11.5、Constructor 构造方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">T <span class=\"title function_\">newInstance</span><span class=\"params\">(Object... initargs)</span>  </span><br><span class=\"line\">如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"11-6、Method-方法对象\"><a href=\"#11-6、Method-方法对象\" class=\"headerlink\" title=\"11.6、Method 方法对象\"></a>11.6、Method 方法对象</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 执行方法：</span><br><span class=\"line\">\tObject <span class=\"title function_\">invoke</span><span class=\"params\">(Object obj, Object... args)</span>  </span><br><span class=\"line\"><span class=\"number\">2.</span> 获取方法名称：</span><br><span class=\"line\">\tString getName:获取方法名</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"12、异常\"><a href=\"#12、异常\" class=\"headerlink\" title=\"12、异常\"></a>12、异常</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301636988.png\" alt=\"image.png\"></p>\n<p>Error：错误，无法被处理的</p>\n<p>Exception：异常，能够被程序本身处理的，可以通过try…catch语句捕捉异常，或者是throws抛出异常。分为运行时异常和非运行时异常</p>\n<ul>\n<li>运行时异常：就是RuntimeException，编译时不会检查出错误的。一般是由于逻辑错误引起的，程序员可以手动去解决的，比如判空等。</li>\n<li>非运行时异常：也叫编译异常，就是Exception下除了RuntimeException以外的异常。是必须进行处理的异常，编译器会进行异常提醒的。如果不进行处理，程序编译不通过</li>\n</ul>\n<h1 id=\"13、日志\"><a href=\"#13、日志\" class=\"headerlink\" title=\"13、日志\"></a>13、日志</h1><h2 id=\"13-1、基本概念\"><a href=\"#13-1、基本概念\" class=\"headerlink\" title=\"13.1、基本概念\"></a>13.1、基本概念</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270851142.png\" alt=\"image (26).png\"></p>\n<blockquote>\n<p>常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。</p>\n</blockquote>\n<h2 id=\"13-2、java日志演化历史\"><a href=\"#13-2、java日志演化历史\" class=\"headerlink\" title=\"13.2、java日志演化历史\"></a>13.2、java日志演化历史</h2><p>（1）最开始出现的是 log4j，也是应用最广泛的日志系统，作者是 Ceki Gülcü，开始时，一切都是美好的。<br>（2）但 java 的开发主体 Sun 公司认为自己才是正统，为了干掉 log4j，在 jdk1.4 中增加了 jul（因为在 java.util.logging 包下）日志的实现，造成了目前开发者的混乱，迄今为止仍饱受诟病。<br>（3）各个日志系统互相没有关联，替换和统一变的非常麻烦。A 项目用 log4j 作为日志系统，但同时引了 B 项目，而 B 项目用 jul 作为日志系统，那么你的应用就得使用两个日志系统。<br>（4）为了搞定这个坑爹的问题，开源社区 apache 提供了一个日志框架作为日志的抽象，叫 commons-logging，也被称为 jcl（java common logging），jcl 对各种日志接口进行抽象，抽象出一个接口层，对每个日志实现都适配或者桥接，这样这些提供给别人的库都直接使用抽象层即可，较好的解决了上述问题。<br>（5）当年 Apache 说服 log4j 以及其他的日志来按照 commons-logging 的标准编写，但是由于 commons-logging 的类加载有点问题，实现起来也不友好，作为元老级日志 log4j 的作者再度出山，搞出了一个更加牛逼的新的日志框架 slf4j（这个也是抽象层），同时针对 slf4j 的接口实现了一套日志系统，即传说中的 logback。<br>（6）同时这个作者心情一好，又把 log4j 进行了改造，就是所谓的 log4j2，同时支持 jcl 以及 slf4j。</p>\n"},{"title":"RabbitMQ","date":"2023-07-23T16:00:00.000Z","abbrlink":33708,"_content":"# 1、基本基础\n## 1.1、mq概念\nMQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信\n## 1.2、mq优缺点\n**优势：**\n（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单\n（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度\n（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  \n\n**劣势：**\n（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用\n（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？\n（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性\n## 1.3、mq产品选型\n\n|指标 | **ActiveMQ** | **RabbitMQ** | **RocketM Q** | **Kafka** |\n| --- | --- | --- | --- | --- |\n| 数据量级（每秒） | 万级 | 万级 | 十万级 | 十万级 |\n| 可靠性 | 低概率丢失 | 0丢失 | 0丢失 | 0丢失 |\n| 可用性 | 主从架构 | 主从架构 | 分布式 | 分布式 |\n| 时效性 | 毫秒 | 微秒 | 毫秒 | 毫秒 |\n\n> 一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。\n\n## 1.4、AMQP协议\n AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是**应用层协议**的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制 1\n\n## 1.5、rabbitMQ安装\n\n1. 安装Eralng，下面链接已提供otp_win64_20.2.exe\n\n链接： [https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg](https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg)\n提取码：x9m7\n\n2. 安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe\n\n链接： [https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg](https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg)\n提取码：h4r3\n\n3. 配置erlang环境变量\n\n![配置erlang环境变量](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png)\n\n\n\n4. 测试erlang\n\n![测试erlang](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png)\n\n\n5. 启动rabbitmq\n\n![启动rabbitmq](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png)\n\n\n6. 访问 [http://127.0.0.1:15672/](http://127.0.0.1:15672/)      guest guest\n\n\n# 2、组件\n## 2.1、RabbitMQ架构\n![RabbitMQ架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png)\n\n\n（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。\n（2）Connection：连接，应用程序与Server的网络连接，TCP连接。\n（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。\n（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。\n（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。\n（6）Queue：消息队列，用来保存消息，供消费者消费\n（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。\n（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。\n（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”\n\n## 2.2、4种Exchange交换机类型\n### 2.2.1、Direct Exchange（直连交换机）\n\n根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。\n\n![直连交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png)\n\n\n### 2.2.2、Fanout Exchange（广播交换机）\n该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么\n> 如果想让多个消费者消费到数据必须不指定queues，指定交换机\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n\n        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生\n\n        exchange = @Exchange(value = \"business_rrpc_exchange\",type = ExchangeTypes.FANOUT)\n\n))\n\n\n```\n### 2.2.3、Topic Exchange（主题交换机）\n\n将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“\\*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.\\* ” 只会匹配到“abc.def”。\n\n![主题交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png)\n\n\n### 2.2.4、Headers Exchanges（头交换机）\n\n与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()\n\n> 匹配规则x-match有下列两种类型：\nx-match = all ：表示所有的键值对都匹配才能接受到消息\nx-match = any ：表示只要有键值对匹配就能接受到消息\n\n![image (6).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png)\n\n\n## 2.3、工作模式\n### 2.3.1、简单模式\n一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景\n\n![简单模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png)\n\n\n> P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理\n\n\n```java\n// 1. 创建队列\n@Bean\npublic Queue Queue() {\n    return new Queue(\"hello\");\n}\n\n// 2. 生产者\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        amqpTemplate.convertAndSend(\"queue1\", content);\n        return content;\n    }\n}\n\n// 3. 消费者\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(msg);\n    }\n}\n\n```\n\n\n### 2.3.2、工作队列模式\n一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率\n\n> 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度\n\n![工作队列模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png)\n\n\n**实现方式**\n多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息\n```java\n// 增加一个消费者监听同一个队列\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276)\n\n### 2.3.3、发布订阅模式\n一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景\n\n![发布订阅模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png)\n\n\n1. **实现方式**\n\n（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 \n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nFanoutExchange fanoutExchange1() {\n    return new FanoutExchange(\"fanoutExchange1\");\n}\n\n@Bean\nBinding bindingExchangeA(Queue queue1, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue1).to(fanoutExchange1);\n}\n\n@Bean\nBinding bindingExchangeB(Queue queue2, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue2).to(fanoutExchange1);\n}\n```\n\n（2）生产者消费者\n\n```java\n// 生产者：第二个参数是队列名，设置为空\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"\", content);\n        }\n        return content;\n    }\n}\n// 消费者1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer1: \"+msg);\n    }\n}\n// 消费者2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339)\n\n### 2.3.4、路由模式\n一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景\n\n![路由模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png)\n\n**实现方式**\n（1）交换机和队列根据指定路由规则绑定\n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nDirectExchange directExchange1() {\n    return new DirectExchange(\"directExchange1\");\n}\n\n@Bean\nBinding bindingExchangeMessage1(Queue queue1, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue1).to(directExchange1).with(\"routingKey1\");\n}\n\n\n@Bean\nBinding bindingExchangeMessage2(Queue queue2, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue2).to(directExchange1).with(\"routingKey2\");\n}\n```\n\n（2）生产者和消费者\n```java\n// consumer1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue1 consumer1: \"+msg);\n    }\n}\n// consumer2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue2 consumer2: \"+msg);\n    }\n}\n// producer\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"routingKey1\", content);\n        }\n        return content;\n    }\n}\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335)\n\n\n# 3、高级特性\n\n## 3.1、保证消息传递的可靠性\nRabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消费者消息确认\n（1）投递确认：**confirm确认模式**（producer——>exchange），**return退回模式**（exchange——>queue）\n（2）消费者确认：ACK消息签收机制，表示消费者收到消息后的确认方式\n\n### 3.1.1、confirm确认模式\n消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)\n\n\n### 3.1.2、return退回模式\n\n消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）\n\n\n**实现confirm callback和return callback：**\n\n1. 配置文件开启相关配置\n\n```yml\nspring:\n  #配置rabbitMq 服务器\n  rabbitmq:\n    host: 127.0.0.1\n    port: 5672\n    username: yancey\n    password: yancey\n \n    # confirmCallback 确认模式\n    # SIMPLE       禁用发布确认模式，是默认值\n\t# CORRELATED   发布消息成功到交换器或失败后 会触发回调方法\n\t# NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用。rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 返回false则会关闭channel，则接下来无法发送消息到broker;\n    publisher-confirm-type: correlated\n \n    # returnCallback 退回模式\n    publisher-returns: true\n```\n\n2. 编写配置类\n\n```java\n@Configuration\npublic class RabbitConfig {\n \n    @Bean\n    public RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) {\n        RabbitTemplate rabbitTemplate = new RabbitTemplate();\n        rabbitTemplate.setConnectionFactory(connectionFactory);\n \n        //设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。\n        //我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)\n        rabbitTemplate.setMandatory(true);\n \n        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {\n            @Override\n            public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n                log.info(\"相关数据：\" + correlationData);\n                if (ack) {\n                    log.info(\"投递成功,确认情况：\" + ack);\n                } else {\n                    log.info(\"投递失败,确认情况：\" + ack);\n                    log.info(\"原因：\" + cause);\n                }\n            }\n        });\n \n        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {\n            @Override\n            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {\n               log.info(\"ReturnCallback:     \" + \"消息：\" + message);\n               log.info(\"ReturnCallback:     \" + \"回应码：\" + replyCode);\n               log.info(\"ReturnCallback:     \" + \"回应信息：\" + replyText);\n               log.info(\"ReturnCallback:     \" + \"交换机：\" + exchange);\n               log.info(\"ReturnCallback:     \" + \"路由键：\" + routingKey);\n            }\n        });\n \n        return rabbitTemplate;\n    }\n}\n```\n\n\n### 3.1.3、消费者端ack机制\n消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除\n\n1. rabbitmq默认的是自动ack，无需添加其他配置\n\n若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。\n若消费过程中出现异常，则超过ack心跳时间，会触发重试消费\n\n2. 手动ack\n\n开启方式简单，只需要放开此配置即可\n```java\nacknowledge-mode: manual # 设置消费端手动 ack\n```\n\n消费者类\n```java\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        try {\n            int i = 10/0;\n            // 消费成功后ack\n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n        }catch (Exception e){\n            // 消费失败后ack\n            // 三个参数：\n            // （1）delivery_tag：表示消息的唯一标识符\n            // （2）multiple：表示是否将delivery_tag之前的所有未确认消息都拒绝。如果multiple为true，则RabbitMQ将拒绝所有未确认的消息，如果为false，则只拒绝指定的消息\n            // （3）requeue：表示是否将被拒绝的消息重新放回队列中。如果requeue为true，则消息将返回到队列中以便重新处理，如果为false，则消息将被丢弃\n            channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);\n\t\t\n            if (message.getMessageProperties().getRedelivered()) {//判断是否已经重试过\n                log.error(\"消息已重复处理失败,拒绝再次接收...\");\n                channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); // 拒绝消息\n                // 重复消费失败的消息入库...\n            } else {\n                log.error(\"消息即将再次返回队列处理...\");\n                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);\n            }\n\t\t\n        }\n    }\n}\n```\n\n\n>requeue参数设置为true，可以将消息返回到队列中以便重新处理\n>但是这样可能导致无限循环地处理同一个错误消息\n>所以上面代码采用了折中方案：首次失败的消息通知队列重发，重复失败的消息落地进行后面的补偿机制\n\n\n\n## 3.2、消息持久化机制\n持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：\n\n1. Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。\n2. Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。\n3. 消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。\n\n>  注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可\n\n### 3.2.1、交换机持久化\n在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true\n```java\n// autoDelete:当所有绑定队列都不在使用时，是否自动 删除\npublic DirectExchange(String name, boolean durable, boolean autoDelete) {\n        super(name, durable, autoDelete);\n}\n\n```\n\n### 3.2.2、队列持久化\n申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true\n```java\n// durable: 是否做队列持久化\n// exclusive: 是否排外。两个作用：（1）当连接关闭时connection.close()该队列是否会自动删除（2）对当前队列加锁，其他通道channel是不能访问的，用于一个队列只能有一个消费者来消费的场景\n// autoDelete:当所有消费客户端连接断开后，是否自动删除 \npublic Queue(String name, boolean durable, boolean exclusive, boolean autoDelete) {\n        this(name, durable, exclusive, autoDelete, (Map)null);\n}\n```\n\n## 3.3、避免消息重复消费\n### 3.3.1、消息重复发送的场景\n消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息\n\n### 3.3.2、解决方案\n保证消费者的幂等性（调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果）\n\n如何保证幂等性？\n1. 使用代码的逻辑判断，判断消息状态是否已经被消费过了\n\n> 使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。\n\n2. 使用token，要申请，一次有效性。\n\n> 在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）\n\n\n## 3.4、避免消息积压问题\n### 3.4.1、消息积压场景\n消费者宕机/消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压\n### 3.4.2、解决方案\n\n1. 上线更多的消费者（如：库存服务），进行正常消费\n2. 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。\n\n## 3.5、保证消息的顺序性\n### 3.5.1、消息顺序错乱场景\n\n生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。\n\n### 3.5.2、解决方案\n保证队列与消费者一对一\n思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的 \n\n","source":"_posts/RabbitMQ.md","raw":"---\ntitle: RabbitMQ\ndate: 2023/07/24\ncategories:\n  - coding\ntags:\n  - RabbitMQ\n  - 消息队列\n  - 编程基础\nabbrlink: 33708\n---\n# 1、基本基础\n## 1.1、mq概念\nMQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信\n## 1.2、mq优缺点\n**优势：**\n（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单\n（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度\n（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  \n\n**劣势：**\n（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用\n（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？\n（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性\n## 1.3、mq产品选型\n\n|指标 | **ActiveMQ** | **RabbitMQ** | **RocketM Q** | **Kafka** |\n| --- | --- | --- | --- | --- |\n| 数据量级（每秒） | 万级 | 万级 | 十万级 | 十万级 |\n| 可靠性 | 低概率丢失 | 0丢失 | 0丢失 | 0丢失 |\n| 可用性 | 主从架构 | 主从架构 | 分布式 | 分布式 |\n| 时效性 | 毫秒 | 微秒 | 毫秒 | 毫秒 |\n\n> 一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。\n\n## 1.4、AMQP协议\n AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是**应用层协议**的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制 1\n\n## 1.5、rabbitMQ安装\n\n1. 安装Eralng，下面链接已提供otp_win64_20.2.exe\n\n链接： [https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg](https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg)\n提取码：x9m7\n\n2. 安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe\n\n链接： [https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg](https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg)\n提取码：h4r3\n\n3. 配置erlang环境变量\n\n![配置erlang环境变量](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png)\n\n\n\n4. 测试erlang\n\n![测试erlang](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png)\n\n\n5. 启动rabbitmq\n\n![启动rabbitmq](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png)\n\n\n6. 访问 [http://127.0.0.1:15672/](http://127.0.0.1:15672/)      guest guest\n\n\n# 2、组件\n## 2.1、RabbitMQ架构\n![RabbitMQ架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png)\n\n\n（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。\n（2）Connection：连接，应用程序与Server的网络连接，TCP连接。\n（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。\n（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。\n（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。\n（6）Queue：消息队列，用来保存消息，供消费者消费\n（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。\n（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。\n（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”\n\n## 2.2、4种Exchange交换机类型\n### 2.2.1、Direct Exchange（直连交换机）\n\n根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。\n\n![直连交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png)\n\n\n### 2.2.2、Fanout Exchange（广播交换机）\n该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么\n> 如果想让多个消费者消费到数据必须不指定queues，指定交换机\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n\n        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生\n\n        exchange = @Exchange(value = \"business_rrpc_exchange\",type = ExchangeTypes.FANOUT)\n\n))\n\n\n```\n### 2.2.3、Topic Exchange（主题交换机）\n\n将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“\\*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.\\* ” 只会匹配到“abc.def”。\n\n![主题交换机](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png)\n\n\n### 2.2.4、Headers Exchanges（头交换机）\n\n与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()\n\n> 匹配规则x-match有下列两种类型：\nx-match = all ：表示所有的键值对都匹配才能接受到消息\nx-match = any ：表示只要有键值对匹配就能接受到消息\n\n![image (6).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png)\n\n\n## 2.3、工作模式\n### 2.3.1、简单模式\n一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景\n\n![简单模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png)\n\n\n> P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理\n\n\n```java\n// 1. 创建队列\n@Bean\npublic Queue Queue() {\n    return new Queue(\"hello\");\n}\n\n// 2. 生产者\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        amqpTemplate.convertAndSend(\"queue1\", content);\n        return content;\n    }\n}\n\n// 3. 消费者\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(msg);\n    }\n}\n\n```\n\n\n### 2.3.2、工作队列模式\n一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率\n\n> 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度\n\n![工作队列模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png)\n\n\n**实现方式**\n多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息\n```java\n// 增加一个消费者监听同一个队列\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276)\n\n### 2.3.3、发布订阅模式\n一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景\n\n![发布订阅模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png)\n\n\n1. **实现方式**\n\n（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 \n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nFanoutExchange fanoutExchange1() {\n    return new FanoutExchange(\"fanoutExchange1\");\n}\n\n@Bean\nBinding bindingExchangeA(Queue queue1, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue1).to(fanoutExchange1);\n}\n\n@Bean\nBinding bindingExchangeB(Queue queue2, FanoutExchange fanoutExchange1) {\n    return BindingBuilder.bind(queue2).to(fanoutExchange1);\n}\n```\n\n（2）生产者消费者\n\n```java\n// 生产者：第二个参数是队列名，设置为空\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"\", content);\n        }\n        return content;\n    }\n}\n// 消费者1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer1: \"+msg);\n    }\n}\n// 消费者2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"consumer2: \"+msg);\n    }\n}\n```\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339)\n\n### 2.3.4、路由模式\n一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景\n\n![路由模式](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png)\n\n**实现方式**\n（1）交换机和队列根据指定路由规则绑定\n\n```java\n@Bean\npublic Queue queue1() {\n    return new Queue(\"queue1\", true);\n}\n\n@Bean\npublic Queue queue2() {\n    return new Queue(\"queue2\", true);\n}\n\n@Bean\nDirectExchange directExchange1() {\n    return new DirectExchange(\"directExchange1\");\n}\n\n@Bean\nBinding bindingExchangeMessage1(Queue queue1, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue1).to(directExchange1).with(\"routingKey1\");\n}\n\n\n@Bean\nBinding bindingExchangeMessage2(Queue queue2, DirectExchange directExchange1) {\n    return BindingBuilder.bind(queue2).to(directExchange1).with(\"routingKey2\");\n}\n```\n\n（2）生产者和消费者\n```java\n// consumer1\n@Component\npublic class Consumer1 {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue1 consumer1: \"+msg);\n    }\n}\n// consumer2\n@Component\npublic class Consumer2 {\n    @RabbitListener(queues = \"queue2\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        System.out.println(\"queue2 consumer2: \"+msg);\n    }\n}\n// producer\n@RestController\npublic class Producer {\n    @Autowired\n    AmqpTemplate amqpTemplate;\n\n    @RequestMapping(\"/send\")\n    public String send() {\n        String content = \"hello,rabbitmq\";\n        for (int i=0;i<5;i++){\n            amqpTemplate.convertAndSend(\"fanoutExchange1\",\"routingKey1\", content);\n        }\n        return content;\n    }\n}\n```\n\n![image.png](https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335)\n\n\n# 3、高级特性\n\n## 3.1、保证消息传递的可靠性\nRabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消费者消息确认\n（1）投递确认：**confirm确认模式**（producer——>exchange），**return退回模式**（exchange——>queue）\n（2）消费者确认：ACK消息签收机制，表示消费者收到消息后的确认方式\n\n### 3.1.1、confirm确认模式\n消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)\n\n\n### 3.1.2、return退回模式\n\n消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）\n\n\n**实现confirm callback和return callback：**\n\n1. 配置文件开启相关配置\n\n```yml\nspring:\n  #配置rabbitMq 服务器\n  rabbitmq:\n    host: 127.0.0.1\n    port: 5672\n    username: yancey\n    password: yancey\n \n    # confirmCallback 确认模式\n    # SIMPLE       禁用发布确认模式，是默认值\n\t# CORRELATED   发布消息成功到交换器或失败后 会触发回调方法\n\t# NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用。rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 返回false则会关闭channel，则接下来无法发送消息到broker;\n    publisher-confirm-type: correlated\n \n    # returnCallback 退回模式\n    publisher-returns: true\n```\n\n2. 编写配置类\n\n```java\n@Configuration\npublic class RabbitConfig {\n \n    @Bean\n    public RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) {\n        RabbitTemplate rabbitTemplate = new RabbitTemplate();\n        rabbitTemplate.setConnectionFactory(connectionFactory);\n \n        //设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。\n        //我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)\n        rabbitTemplate.setMandatory(true);\n \n        rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() {\n            @Override\n            public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n                log.info(\"相关数据：\" + correlationData);\n                if (ack) {\n                    log.info(\"投递成功,确认情况：\" + ack);\n                } else {\n                    log.info(\"投递失败,确认情况：\" + ack);\n                    log.info(\"原因：\" + cause);\n                }\n            }\n        });\n \n        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {\n            @Override\n            public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {\n               log.info(\"ReturnCallback:     \" + \"消息：\" + message);\n               log.info(\"ReturnCallback:     \" + \"回应码：\" + replyCode);\n               log.info(\"ReturnCallback:     \" + \"回应信息：\" + replyText);\n               log.info(\"ReturnCallback:     \" + \"交换机：\" + exchange);\n               log.info(\"ReturnCallback:     \" + \"路由键：\" + routingKey);\n            }\n        });\n \n        return rabbitTemplate;\n    }\n}\n```\n\n\n### 3.1.3、消费者端ack机制\n消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除\n\n1. rabbitmq默认的是自动ack，无需添加其他配置\n\n若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。\n若消费过程中出现异常，则超过ack心跳时间，会触发重试消费\n\n2. 手动ack\n\n开启方式简单，只需要放开此配置即可\n```java\nacknowledge-mode: manual # 设置消费端手动 ack\n```\n\n消费者类\n```java\n@Component\npublic class Consumer {\n    @RabbitListener(queues = \"queue1\")\n    @RabbitHandler\n    public void getMsg(String msg, Channel channel, Message message) throws IOException {\n        try {\n            int i = 10/0;\n            // 消费成功后ack\n            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);\n        }catch (Exception e){\n            // 消费失败后ack\n            // 三个参数：\n            // （1）delivery_tag：表示消息的唯一标识符\n            // （2）multiple：表示是否将delivery_tag之前的所有未确认消息都拒绝。如果multiple为true，则RabbitMQ将拒绝所有未确认的消息，如果为false，则只拒绝指定的消息\n            // （3）requeue：表示是否将被拒绝的消息重新放回队列中。如果requeue为true，则消息将返回到队列中以便重新处理，如果为false，则消息将被丢弃\n            channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);\n\t\t\n            if (message.getMessageProperties().getRedelivered()) {//判断是否已经重试过\n                log.error(\"消息已重复处理失败,拒绝再次接收...\");\n                channel.basicReject(message.getMessageProperties().getDeliveryTag(), false); // 拒绝消息\n                // 重复消费失败的消息入库...\n            } else {\n                log.error(\"消息即将再次返回队列处理...\");\n                channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, true);\n            }\n\t\t\n        }\n    }\n}\n```\n\n\n>requeue参数设置为true，可以将消息返回到队列中以便重新处理\n>但是这样可能导致无限循环地处理同一个错误消息\n>所以上面代码采用了折中方案：首次失败的消息通知队列重发，重复失败的消息落地进行后面的补偿机制\n\n\n\n## 3.2、消息持久化机制\n持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：\n\n1. Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。\n2. Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。\n3. 消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。\n\n>  注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可\n\n### 3.2.1、交换机持久化\n在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true\n```java\n// autoDelete:当所有绑定队列都不在使用时，是否自动 删除\npublic DirectExchange(String name, boolean durable, boolean autoDelete) {\n        super(name, durable, autoDelete);\n}\n\n```\n\n### 3.2.2、队列持久化\n申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true\n```java\n// durable: 是否做队列持久化\n// exclusive: 是否排外。两个作用：（1）当连接关闭时connection.close()该队列是否会自动删除（2）对当前队列加锁，其他通道channel是不能访问的，用于一个队列只能有一个消费者来消费的场景\n// autoDelete:当所有消费客户端连接断开后，是否自动删除 \npublic Queue(String name, boolean durable, boolean exclusive, boolean autoDelete) {\n        this(name, durable, exclusive, autoDelete, (Map)null);\n}\n```\n\n## 3.3、避免消息重复消费\n### 3.3.1、消息重复发送的场景\n消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息\n\n### 3.3.2、解决方案\n保证消费者的幂等性（调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果）\n\n如何保证幂等性？\n1. 使用代码的逻辑判断，判断消息状态是否已经被消费过了\n\n> 使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。\n\n2. 使用token，要申请，一次有效性。\n\n> 在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）\n\n\n## 3.4、避免消息积压问题\n### 3.4.1、消息积压场景\n消费者宕机/消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压\n### 3.4.2、解决方案\n\n1. 上线更多的消费者（如：库存服务），进行正常消费\n2. 上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。\n\n## 3.5、保证消息的顺序性\n### 3.5.1、消息顺序错乱场景\n\n生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。\n\n### 3.5.2、解决方案\n保证队列与消费者一对一\n思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的 \n\n","slug":"RabbitMQ","published":1,"updated":"2023-07-31T14:36:17.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9j000900uj9937dau1","content":"<h1 id=\"1、基本基础\"><a href=\"#1、基本基础\" class=\"headerlink\" title=\"1、基本基础\"></a>1、基本基础</h1><h2 id=\"1-1、mq概念\"><a href=\"#1-1、mq概念\" class=\"headerlink\" title=\"1.1、mq概念\"></a>1.1、mq概念</h2><p>MQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信</p>\n<h2 id=\"1-2、mq优缺点\"><a href=\"#1-2、mq优缺点\" class=\"headerlink\" title=\"1.2、mq优缺点\"></a>1.2、mq优缺点</h2><p><strong>优势：</strong><br>（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单<br>（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度<br>（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  </p>\n<p><strong>劣势：</strong><br>（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用<br>（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？<br>（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性</p>\n<h2 id=\"1-3、mq产品选型\"><a href=\"#1-3、mq产品选型\" class=\"headerlink\" title=\"1.3、mq产品选型\"></a>1.3、mq产品选型</h2><table>\n<thead>\n<tr>\n<th>指标</th>\n<th><strong>ActiveMQ</strong></th>\n<th><strong>RabbitMQ</strong></th>\n<th><strong>RocketM Q</strong></th>\n<th><strong>Kafka</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据量级（每秒）</td>\n<td>万级</td>\n<td>万级</td>\n<td>十万级</td>\n<td>十万级</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>低概率丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>主从架构</td>\n<td>主从架构</td>\n<td>分布式</td>\n<td>分布式</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>毫秒</td>\n<td>微秒</td>\n<td>毫秒</td>\n<td>毫秒</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。</p>\n</blockquote>\n<h2 id=\"1-4、AMQP协议\"><a href=\"#1-4、AMQP协议\" class=\"headerlink\" title=\"1.4、AMQP协议\"></a>1.4、AMQP协议</h2><p> AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是<strong>应用层协议</strong>的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制 1</p>\n<h2 id=\"1-5、rabbitMQ安装\"><a href=\"#1-5、rabbitMQ安装\" class=\"headerlink\" title=\"1.5、rabbitMQ安装\"></a>1.5、rabbitMQ安装</h2><ol>\n<li>安装Eralng，下面链接已提供otp_win64_20.2.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg\">https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg</a><br>提取码：x9m7</p>\n<ol start=\"2\">\n<li>安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg\">https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg</a><br>提取码：h4r3</p>\n<ol start=\"3\">\n<li>配置erlang环境变量</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png\" alt=\"配置erlang环境变量\"></p>\n<ol start=\"4\">\n<li>测试erlang</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png\" alt=\"测试erlang\"></p>\n<ol start=\"5\">\n<li>启动rabbitmq</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png\" alt=\"启动rabbitmq\"></p>\n<ol start=\"6\">\n<li>访问 <a href=\"http://127.0.0.1:15672/\">http://127.0.0.1:15672/</a>      guest guest</li>\n</ol>\n<h1 id=\"2、组件\"><a href=\"#2、组件\" class=\"headerlink\" title=\"2、组件\"></a>2、组件</h1><h2 id=\"2-1、RabbitMQ架构\"><a href=\"#2-1、RabbitMQ架构\" class=\"headerlink\" title=\"2.1、RabbitMQ架构\"></a>2.1、RabbitMQ架构</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png\" alt=\"RabbitMQ架构\"></p>\n<p>（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。<br>（2）Connection：连接，应用程序与Server的网络连接，TCP连接。<br>（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。<br>（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。<br>（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。<br>（6）Queue：消息队列，用来保存消息，供消费者消费<br>（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。<br>（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。<br>（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”</p>\n<h2 id=\"2-2、4种Exchange交换机类型\"><a href=\"#2-2、4种Exchange交换机类型\" class=\"headerlink\" title=\"2.2、4种Exchange交换机类型\"></a>2.2、4种Exchange交换机类型</h2><h3 id=\"2-2-1、Direct-Exchange（直连交换机）\"><a href=\"#2-2-1、Direct-Exchange（直连交换机）\" class=\"headerlink\" title=\"2.2.1、Direct Exchange（直连交换机）\"></a>2.2.1、Direct Exchange（直连交换机）</h3><p>根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png\" alt=\"直连交换机\"></p>\n<h3 id=\"2-2-2、Fanout-Exchange（广播交换机）\"><a href=\"#2-2-2、Fanout-Exchange（广播交换机）\" class=\"headerlink\" title=\"2.2.2、Fanout Exchange（广播交换机）\"></a>2.2.2、Fanout Exchange（广播交换机）</h3><p>该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么</p>\n<blockquote>\n<p>如果想让多个消费者消费到数据必须不指定queues，指定交换机</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(value = &quot;business_rrpc_exchange&quot;,type = ExchangeTypes.FANOUT)</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-3、Topic-Exchange（主题交换机）\"><a href=\"#2-2-3、Topic-Exchange（主题交换机）\" class=\"headerlink\" title=\"2.2.3、Topic Exchange（主题交换机）\"></a>2.2.3、Topic Exchange（主题交换机）</h3><p>将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.* ” 只会匹配到“abc.def”。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png\" alt=\"主题交换机\"></p>\n<h3 id=\"2-2-4、Headers-Exchanges（头交换机）\"><a href=\"#2-2-4、Headers-Exchanges（头交换机）\" class=\"headerlink\" title=\"2.2.4、Headers Exchanges（头交换机）\"></a>2.2.4、Headers Exchanges（头交换机）</h3><p>与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()</p>\n<blockquote>\n<p>匹配规则x-match有下列两种类型：<br>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息<br>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png\" alt=\"image (6).png\"></p>\n<h2 id=\"2-3、工作模式\"><a href=\"#2-3、工作模式\" class=\"headerlink\" title=\"2.3、工作模式\"></a>2.3、工作模式</h2><h3 id=\"2-3-1、简单模式\"><a href=\"#2-3-1、简单模式\" class=\"headerlink\" title=\"2.3.1、简单模式\"></a>2.3.1、简单模式</h3><p>一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png\" alt=\"简单模式\"></p>\n<blockquote>\n<p>P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建队列</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">Queue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 生产者</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;queue1&quot;</span>, content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 消费者</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-3-2、工作队列模式\"><a href=\"#2-3-2、工作队列模式\" class=\"headerlink\" title=\"2.3.2、工作队列模式\"></a>2.3.2、工作队列模式</h3><p>一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率</p>\n<blockquote>\n<p>对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png\" alt=\"工作队列模式\"></p>\n<p><strong>实现方式</strong><br>多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 增加一个消费者监听同一个队列</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276\" alt=\"image.png\"></p>\n<h3 id=\"2-3-3、发布订阅模式\"><a href=\"#2-3-3、发布订阅模式\" class=\"headerlink\" title=\"2.3.3、发布订阅模式\"></a>2.3.3、发布订阅模式</h3><p>一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png\" alt=\"发布订阅模式\"></p>\n<ol>\n<li><strong>实现方式</strong></li>\n</ol>\n<p>（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">FanoutExchange <span class=\"title function_\">fanoutExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FanoutExchange</span>(<span class=\"string\">&quot;fanoutExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeA</span><span class=\"params\">(Queue queue1, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeB</span><span class=\"params\">(Queue queue2, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者：第二个参数是队列名，设置为空</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339\" alt=\"image.png\"></p>\n<h3 id=\"2-3-4、路由模式\"><a href=\"#2-3-4、路由模式\" class=\"headerlink\" title=\"2.3.4、路由模式\"></a>2.3.4、路由模式</h3><p>一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png\" alt=\"路由模式\"></p>\n<p><strong>实现方式</strong><br>（1）交换机和队列根据指定路由规则绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">DirectExchange <span class=\"title function_\">directExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;directExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage1</span><span class=\"params\">(Queue queue1, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(directExchange1).with(<span class=\"string\">&quot;routingKey1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage2</span><span class=\"params\">(Queue queue2, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(directExchange1).with(<span class=\"string\">&quot;routingKey2&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者和消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue1 consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue2 consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// producer</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;routingKey1&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335\" alt=\"image.png\"></p>\n<h1 id=\"3、高级特性\"><a href=\"#3、高级特性\" class=\"headerlink\" title=\"3、高级特性\"></a>3、高级特性</h1><h2 id=\"3-1、保证消息传递的可靠性\"><a href=\"#3-1、保证消息传递的可靠性\" class=\"headerlink\" title=\"3.1、保证消息传递的可靠性\"></a>3.1、保证消息传递的可靠性</h2><p>RabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消费者消息确认<br>（1）投递确认：<strong>confirm确认模式</strong>（producer——&gt;exchange），<strong>return退回模式</strong>（exchange——&gt;queue）<br>（2）消费者确认：ACK消息签收机制，表示消费者收到消息后的确认方式</p>\n<h3 id=\"3-1-1、confirm确认模式\"><a href=\"#3-1-1、confirm确认模式\" class=\"headerlink\" title=\"3.1.1、confirm确认模式\"></a>3.1.1、confirm确认模式</h3><p>消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)</p>\n<h3 id=\"3-1-2、return退回模式\"><a href=\"#3-1-2、return退回模式\" class=\"headerlink\" title=\"3.1.2、return退回模式\"></a>3.1.2、return退回模式</h3><p>消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）</p>\n<p><strong>实现confirm callback和return callback：</strong></p>\n<ol>\n<li>配置文件开启相关配置</li>\n</ol>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"comment\">#配置rabbitMq 服务器</span></span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">5672</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">yancey</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">yancey</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># confirmCallback 确认模式</span></span><br><span class=\"line\">    <span class=\"comment\"># SIMPLE       禁用发布确认模式，是默认值</span></span><br><span class=\"line\">\t<span class=\"comment\"># CORRELATED   发布消息成功到交换器或失败后 会触发回调方法</span></span><br><span class=\"line\">\t<span class=\"comment\"># NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用。rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 返回false则会关闭channel，则接下来无法发送消息到broker;</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-confirm-type:</span> <span class=\"string\">correlated</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># returnCallback 退回模式</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-returns:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写配置类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RabbitTemplate <span class=\"title function_\">createRabbitTemplate</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RabbitTemplate</span> <span class=\"variable\">rabbitTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>();</span><br><span class=\"line\">        rabbitTemplate.setConnectionFactory(connectionFactory);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。</span></span><br><span class=\"line\">        <span class=\"comment\">//我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)</span></span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"literal\">true</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"type\">boolean</span> ack, String cause)</span> &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;相关数据：&quot;</span> + correlationData);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;投递成功,确认情况：&quot;</span> + ack);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;投递失败,确认情况：&quot;</span> + ack);</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;原因：&quot;</span> + cause);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ReturnCallback() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"type\">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;消息：&quot;</span> + message);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;回应码：&quot;</span> + replyCode);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;回应信息：&quot;</span> + replyText);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;交换机：&quot;</span> + exchange);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;路由键：&quot;</span> + routingKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rabbitTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-1-3、消费者端ack机制\"><a href=\"#3-1-3、消费者端ack机制\" class=\"headerlink\" title=\"3.1.3、消费者端ack机制\"></a>3.1.3、消费者端ack机制</h3><p>消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除</p>\n<ol>\n<li>rabbitmq默认的是自动ack，无需添加其他配置</li>\n</ol>\n<p>若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。<br>若消费过程中出现异常，则超过ack心跳时间，会触发重试消费</p>\n<ol start=\"2\">\n<li>手动ack</li>\n</ol>\n<p>开启方式简单，只需要放开此配置即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acknowledge-mode: manual # 设置消费端手动 ack</span><br></pre></td></tr></table></figure>\n\n<p>消费者类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>/<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 消费成功后ack</span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 消费失败后ack</span></span><br><span class=\"line\">            <span class=\"comment\">// 三个参数：</span></span><br><span class=\"line\">            <span class=\"comment\">// （1）delivery_tag：表示消息的唯一标识符</span></span><br><span class=\"line\">            <span class=\"comment\">// （2）multiple：表示是否将delivery_tag之前的所有未确认消息都拒绝。如果multiple为true，则RabbitMQ将拒绝所有未确认的消息，如果为false，则只拒绝指定的消息</span></span><br><span class=\"line\">            <span class=\"comment\">// （3）requeue：表示是否将被拒绝的消息重新放回队列中。如果requeue为true，则消息将返回到队列中以便重新处理，如果为false，则消息将被丢弃</span></span><br><span class=\"line\">            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class=\"literal\">false</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.getMessageProperties().getRedelivered()) &#123;<span class=\"comment\">//判断是否已经重试过</span></span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;消息已重复处理失败,拒绝再次接收...&quot;</span>);</span><br><span class=\"line\">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>); <span class=\"comment\">// 拒绝消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 重复消费失败的消息入库...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;消息即将再次返回队列处理...&quot;</span>);</span><br><span class=\"line\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>requeue参数设置为true，可以将消息返回到队列中以便重新处理<br>但是这样可能导致无限循环地处理同一个错误消息<br>所以上面代码采用了折中方案：首次失败的消息通知队列重发，重复失败的消息落地进行后面的补偿机制</p>\n</blockquote>\n<h2 id=\"3-2、消息持久化机制\"><a href=\"#3-2、消息持久化机制\" class=\"headerlink\" title=\"3.2、消息持久化机制\"></a>3.2、消息持久化机制</h2><p>持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：</p>\n<ol>\n<li>Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。</li>\n<li>Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。</li>\n<li>消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。</li>\n</ol>\n<blockquote>\n<p> 注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可</p>\n</blockquote>\n<h3 id=\"3-2-1、交换机持久化\"><a href=\"#3-2-1、交换机持久化\" class=\"headerlink\" title=\"3.2.1、交换机持久化\"></a>3.2.1、交换机持久化</h3><p>在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// autoDelete:当所有绑定队列都不在使用时，是否自动 删除</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DirectExchange</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, durable, autoDelete);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2、队列持久化\"><a href=\"#3-2-2、队列持久化\" class=\"headerlink\" title=\"3.2.2、队列持久化\"></a>3.2.2、队列持久化</h3><p>申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// durable: 是否做队列持久化</span></span><br><span class=\"line\"><span class=\"comment\">// exclusive: 是否排外。两个作用：（1）当连接关闭时connection.close()该队列是否会自动删除（2）对当前队列加锁，其他通道channel是不能访问的，用于一个队列只能有一个消费者来消费的场景</span></span><br><span class=\"line\"><span class=\"comment\">// autoDelete:当所有消费客户端连接断开后，是否自动删除 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Queue</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> exclusive, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(name, durable, exclusive, autoDelete, (Map)<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3、避免消息重复消费\"><a href=\"#3-3、避免消息重复消费\" class=\"headerlink\" title=\"3.3、避免消息重复消费\"></a>3.3、避免消息重复消费</h2><h3 id=\"3-3-1、消息重复发送的场景\"><a href=\"#3-3-1、消息重复发送的场景\" class=\"headerlink\" title=\"3.3.1、消息重复发送的场景\"></a>3.3.1、消息重复发送的场景</h3><p>消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息</p>\n<h3 id=\"3-3-2、解决方案\"><a href=\"#3-3-2、解决方案\" class=\"headerlink\" title=\"3.3.2、解决方案\"></a>3.3.2、解决方案</h3><p>保证消费者的幂等性（调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果）</p>\n<p>如何保证幂等性？</p>\n<ol>\n<li>使用代码的逻辑判断，判断消息状态是否已经被消费过了</li>\n</ol>\n<blockquote>\n<p>使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。</p>\n</blockquote>\n<ol start=\"2\">\n<li>使用token，要申请，一次有效性。</li>\n</ol>\n<blockquote>\n<p>在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）</p>\n</blockquote>\n<h2 id=\"3-4、避免消息积压问题\"><a href=\"#3-4、避免消息积压问题\" class=\"headerlink\" title=\"3.4、避免消息积压问题\"></a>3.4、避免消息积压问题</h2><h3 id=\"3-4-1、消息积压场景\"><a href=\"#3-4-1、消息积压场景\" class=\"headerlink\" title=\"3.4.1、消息积压场景\"></a>3.4.1、消息积压场景</h3><p>消费者宕机&#x2F;消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压</p>\n<h3 id=\"3-4-2、解决方案\"><a href=\"#3-4-2、解决方案\" class=\"headerlink\" title=\"3.4.2、解决方案\"></a>3.4.2、解决方案</h3><ol>\n<li>上线更多的消费者（如：库存服务），进行正常消费</li>\n<li>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。</li>\n</ol>\n<h2 id=\"3-5、保证消息的顺序性\"><a href=\"#3-5、保证消息的顺序性\" class=\"headerlink\" title=\"3.5、保证消息的顺序性\"></a>3.5、保证消息的顺序性</h2><h3 id=\"3-5-1、消息顺序错乱场景\"><a href=\"#3-5-1、消息顺序错乱场景\" class=\"headerlink\" title=\"3.5.1、消息顺序错乱场景\"></a>3.5.1、消息顺序错乱场景</h3><p>生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。</p>\n<h3 id=\"3-5-2、解决方案\"><a href=\"#3-5-2、解决方案\" class=\"headerlink\" title=\"3.5.2、解决方案\"></a>3.5.2、解决方案</h3><p>保证队列与消费者一对一<br>思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的 </p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、基本基础\"><a href=\"#1、基本基础\" class=\"headerlink\" title=\"1、基本基础\"></a>1、基本基础</h1><h2 id=\"1-1、mq概念\"><a href=\"#1-1、mq概念\" class=\"headerlink\" title=\"1.1、mq概念\"></a>1.1、mq概念</h2><p>MQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信</p>\n<h2 id=\"1-2、mq优缺点\"><a href=\"#1-2、mq优缺点\" class=\"headerlink\" title=\"1.2、mq优缺点\"></a>1.2、mq优缺点</h2><p><strong>优势：</strong><br>（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单<br>（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度<br>（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  </p>\n<p><strong>劣势：</strong><br>（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用<br>（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？<br>（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性</p>\n<h2 id=\"1-3、mq产品选型\"><a href=\"#1-3、mq产品选型\" class=\"headerlink\" title=\"1.3、mq产品选型\"></a>1.3、mq产品选型</h2><table>\n<thead>\n<tr>\n<th>指标</th>\n<th><strong>ActiveMQ</strong></th>\n<th><strong>RabbitMQ</strong></th>\n<th><strong>RocketM Q</strong></th>\n<th><strong>Kafka</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据量级（每秒）</td>\n<td>万级</td>\n<td>万级</td>\n<td>十万级</td>\n<td>十万级</td>\n</tr>\n<tr>\n<td>可靠性</td>\n<td>低概率丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n<td>0丢失</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>主从架构</td>\n<td>主从架构</td>\n<td>分布式</td>\n<td>分布式</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>毫秒</td>\n<td>微秒</td>\n<td>毫秒</td>\n<td>毫秒</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。</p>\n</blockquote>\n<h2 id=\"1-4、AMQP协议\"><a href=\"#1-4、AMQP协议\" class=\"headerlink\" title=\"1.4、AMQP协议\"></a>1.4、AMQP协议</h2><p> AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是<strong>应用层协议</strong>的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制 1</p>\n<h2 id=\"1-5、rabbitMQ安装\"><a href=\"#1-5、rabbitMQ安装\" class=\"headerlink\" title=\"1.5、rabbitMQ安装\"></a>1.5、rabbitMQ安装</h2><ol>\n<li>安装Eralng，下面链接已提供otp_win64_20.2.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg\">https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg</a><br>提取码：x9m7</p>\n<ol start=\"2\">\n<li>安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe</li>\n</ol>\n<p>链接： <a href=\"https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg\">https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg</a><br>提取码：h4r3</p>\n<ol start=\"3\">\n<li>配置erlang环境变量</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png\" alt=\"配置erlang环境变量\"></p>\n<ol start=\"4\">\n<li>测试erlang</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png\" alt=\"测试erlang\"></p>\n<ol start=\"5\">\n<li>启动rabbitmq</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png\" alt=\"启动rabbitmq\"></p>\n<ol start=\"6\">\n<li>访问 <a href=\"http://127.0.0.1:15672/\">http://127.0.0.1:15672/</a>      guest guest</li>\n</ol>\n<h1 id=\"2、组件\"><a href=\"#2、组件\" class=\"headerlink\" title=\"2、组件\"></a>2、组件</h1><h2 id=\"2-1、RabbitMQ架构\"><a href=\"#2-1、RabbitMQ架构\" class=\"headerlink\" title=\"2.1、RabbitMQ架构\"></a>2.1、RabbitMQ架构</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png\" alt=\"RabbitMQ架构\"></p>\n<p>（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。<br>（2）Connection：连接，应用程序与Server的网络连接，TCP连接。<br>（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。<br>（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。<br>（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。<br>（6）Queue：消息队列，用来保存消息，供消费者消费<br>（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。<br>（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。<br>（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”</p>\n<h2 id=\"2-2、4种Exchange交换机类型\"><a href=\"#2-2、4种Exchange交换机类型\" class=\"headerlink\" title=\"2.2、4种Exchange交换机类型\"></a>2.2、4种Exchange交换机类型</h2><h3 id=\"2-2-1、Direct-Exchange（直连交换机）\"><a href=\"#2-2-1、Direct-Exchange（直连交换机）\" class=\"headerlink\" title=\"2.2.1、Direct Exchange（直连交换机）\"></a>2.2.1、Direct Exchange（直连交换机）</h3><p>根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png\" alt=\"直连交换机\"></p>\n<h3 id=\"2-2-2、Fanout-Exchange（广播交换机）\"><a href=\"#2-2-2、Fanout-Exchange（广播交换机）\" class=\"headerlink\" title=\"2.2.2、Fanout Exchange（广播交换机）\"></a>2.2.2、Fanout Exchange（广播交换机）</h3><p>该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么</p>\n<blockquote>\n<p>如果想让多个消费者消费到数据必须不指定queues，指定交换机</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">        exchange = @Exchange(value = &quot;business_rrpc_exchange&quot;,type = ExchangeTypes.FANOUT)</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">))</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-3、Topic-Exchange（主题交换机）\"><a href=\"#2-2-3、Topic-Exchange（主题交换机）\" class=\"headerlink\" title=\"2.2.3、Topic Exchange（主题交换机）\"></a>2.2.3、Topic Exchange（主题交换机）</h3><p>将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.* ” 只会匹配到“abc.def”。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png\" alt=\"主题交换机\"></p>\n<h3 id=\"2-2-4、Headers-Exchanges（头交换机）\"><a href=\"#2-2-4、Headers-Exchanges（头交换机）\" class=\"headerlink\" title=\"2.2.4、Headers Exchanges（头交换机）\"></a>2.2.4、Headers Exchanges（头交换机）</h3><p>与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()</p>\n<blockquote>\n<p>匹配规则x-match有下列两种类型：<br>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息<br>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png\" alt=\"image (6).png\"></p>\n<h2 id=\"2-3、工作模式\"><a href=\"#2-3、工作模式\" class=\"headerlink\" title=\"2.3、工作模式\"></a>2.3、工作模式</h2><h3 id=\"2-3-1、简单模式\"><a href=\"#2-3-1、简单模式\" class=\"headerlink\" title=\"2.3.1、简单模式\"></a>2.3.1、简单模式</h3><p>一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png\" alt=\"简单模式\"></p>\n<blockquote>\n<p>P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 创建队列</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">Queue</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 生产者</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        amqpTemplate.convertAndSend(<span class=\"string\">&quot;queue1&quot;</span>, content);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 消费者</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-3-2、工作队列模式\"><a href=\"#2-3-2、工作队列模式\" class=\"headerlink\" title=\"2.3.2、工作队列模式\"></a>2.3.2、工作队列模式</h3><p>一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率</p>\n<blockquote>\n<p>对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png\" alt=\"工作队列模式\"></p>\n<p><strong>实现方式</strong><br>多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 增加一个消费者监听同一个队列</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276\" alt=\"image.png\"></p>\n<h3 id=\"2-3-3、发布订阅模式\"><a href=\"#2-3-3、发布订阅模式\" class=\"headerlink\" title=\"2.3.3、发布订阅模式\"></a>2.3.3、发布订阅模式</h3><p>一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png\" alt=\"发布订阅模式\"></p>\n<ol>\n<li><strong>实现方式</strong></li>\n</ol>\n<p>（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">FanoutExchange <span class=\"title function_\">fanoutExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">FanoutExchange</span>(<span class=\"string\">&quot;fanoutExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeA</span><span class=\"params\">(Queue queue1, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeB</span><span class=\"params\">(Queue queue2, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(fanoutExchange1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生产者：第二个参数是队列名，设置为空</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 消费者2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339\" alt=\"image.png\"></p>\n<h3 id=\"2-3-4、路由模式\"><a href=\"#2-3-4、路由模式\" class=\"headerlink\" title=\"2.3.4、路由模式\"></a>2.3.4、路由模式</h3><p>一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png\" alt=\"路由模式\"></p>\n<p><strong>实现方式</strong><br>（1）交换机和队列根据指定路由规则绑定</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue1&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Queue <span class=\"title function_\">queue2</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Queue</span>(<span class=\"string\">&quot;queue2&quot;</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">DirectExchange <span class=\"title function_\">directExchange1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DirectExchange</span>(<span class=\"string\">&quot;directExchange1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage1</span><span class=\"params\">(Queue queue1, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue1).to(directExchange1).with(<span class=\"string\">&quot;routingKey1&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\">Binding <span class=\"title function_\">bindingExchangeMessage2</span><span class=\"params\">(Queue queue2, DirectExchange directExchange1)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> BindingBuilder.bind(queue2).to(directExchange1).with(<span class=\"string\">&quot;routingKey2&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）生产者和消费者</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// consumer1</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue1 consumer1: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// consumer2</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;queue2 consumer2: &quot;</span>+msg);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// producer</span></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Producer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    AmqpTemplate amqpTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/send&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">send</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">content</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;hello,rabbitmq&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">5</span>;i++)&#123;</span><br><span class=\"line\">            amqpTemplate.convertAndSend(<span class=\"string\">&quot;fanoutExchange1&quot;</span>,<span class=\"string\">&quot;routingKey1&quot;</span>, content);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> content;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335\" alt=\"image.png\"></p>\n<h1 id=\"3、高级特性\"><a href=\"#3、高级特性\" class=\"headerlink\" title=\"3、高级特性\"></a>3、高级特性</h1><h2 id=\"3-1、保证消息传递的可靠性\"><a href=\"#3-1、保证消息传递的可靠性\" class=\"headerlink\" title=\"3.1、保证消息传递的可靠性\"></a>3.1、保证消息传递的可靠性</h2><p>RabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消费者消息确认<br>（1）投递确认：<strong>confirm确认模式</strong>（producer——&gt;exchange），<strong>return退回模式</strong>（exchange——&gt;queue）<br>（2）消费者确认：ACK消息签收机制，表示消费者收到消息后的确认方式</p>\n<h3 id=\"3-1-1、confirm确认模式\"><a href=\"#3-1-1、confirm确认模式\" class=\"headerlink\" title=\"3.1.1、confirm确认模式\"></a>3.1.1、confirm确认模式</h3><p>消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)</p>\n<h3 id=\"3-1-2、return退回模式\"><a href=\"#3-1-2、return退回模式\" class=\"headerlink\" title=\"3.1.2、return退回模式\"></a>3.1.2、return退回模式</h3><p>消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）</p>\n<p><strong>实现confirm callback和return callback：</strong></p>\n<ol>\n<li>配置文件开启相关配置</li>\n</ol>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\">  <span class=\"comment\">#配置rabbitMq 服务器</span></span><br><span class=\"line\">  <span class=\"attr\">rabbitmq:</span></span><br><span class=\"line\">    <span class=\"attr\">host:</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    <span class=\"attr\">port:</span> <span class=\"number\">5672</span></span><br><span class=\"line\">    <span class=\"attr\">username:</span> <span class=\"string\">yancey</span></span><br><span class=\"line\">    <span class=\"attr\">password:</span> <span class=\"string\">yancey</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># confirmCallback 确认模式</span></span><br><span class=\"line\">    <span class=\"comment\"># SIMPLE       禁用发布确认模式，是默认值</span></span><br><span class=\"line\">\t<span class=\"comment\"># CORRELATED   发布消息成功到交换器或失败后 会触发回调方法</span></span><br><span class=\"line\">\t<span class=\"comment\"># NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用。rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 返回false则会关闭channel，则接下来无法发送消息到broker;</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-confirm-type:</span> <span class=\"string\">correlated</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"comment\"># returnCallback 退回模式</span></span><br><span class=\"line\">    <span class=\"attr\">publisher-returns:</span> <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写配置类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RabbitConfig</span> &#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RabbitTemplate <span class=\"title function_\">createRabbitTemplate</span><span class=\"params\">(ConnectionFactory connectionFactory)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">RabbitTemplate</span> <span class=\"variable\">rabbitTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>();</span><br><span class=\"line\">        rabbitTemplate.setConnectionFactory(connectionFactory);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"comment\">//设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。</span></span><br><span class=\"line\">        <span class=\"comment\">//我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)</span></span><br><span class=\"line\">        rabbitTemplate.setMandatory(<span class=\"literal\">true</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">        rabbitTemplate.setConfirmCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">confirm</span><span class=\"params\">(CorrelationData correlationData, <span class=\"type\">boolean</span> ack, String cause)</span> &#123;</span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;相关数据：&quot;</span> + correlationData);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (ack) &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;投递成功,确认情况：&quot;</span> + ack);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;投递失败,确认情况：&quot;</span> + ack);</span><br><span class=\"line\">                    log.info(<span class=\"string\">&quot;原因：&quot;</span> + cause);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        rabbitTemplate.setReturnCallback(<span class=\"keyword\">new</span> <span class=\"title class_\">RabbitTemplate</span>.ReturnCallback() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">returnedMessage</span><span class=\"params\">(Message message, <span class=\"type\">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;消息：&quot;</span> + message);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;回应码：&quot;</span> + replyCode);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;回应信息：&quot;</span> + replyText);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;交换机：&quot;</span> + exchange);</span><br><span class=\"line\">               log.info(<span class=\"string\">&quot;ReturnCallback:     &quot;</span> + <span class=\"string\">&quot;路由键：&quot;</span> + routingKey);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> rabbitTemplate;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"3-1-3、消费者端ack机制\"><a href=\"#3-1-3、消费者端ack机制\" class=\"headerlink\" title=\"3.1.3、消费者端ack机制\"></a>3.1.3、消费者端ack机制</h3><p>消费者端消息接收确认采用的是ack模式。ACK机制是消费者从RabbitMQ收到消息并处理完成后，反馈给RabbitMQ，RabbitMQ收到反馈后才将此消息从队列中删除</p>\n<ol>\n<li>rabbitmq默认的是自动ack，无需添加其他配置</li>\n</ol>\n<p>若正常消费成功了，则会自动返回确认ack给队列，队列收到后即可将消息移除。<br>若消费过程中出现异常，则超过ack心跳时间，会触发重试消费</p>\n<ol start=\"2\">\n<li>手动ack</li>\n</ol>\n<p>开启方式简单，只需要放开此配置即可</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">acknowledge-mode: manual # 设置消费端手动 ack</span><br></pre></td></tr></table></figure>\n\n<p>消费者类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@RabbitHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">getMsg</span><span class=\"params\">(String msg, Channel channel, Message message)</span> <span class=\"keyword\">throws</span> IOException &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">10</span>/<span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"comment\">// 消费成功后ack</span></span><br><span class=\"line\">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 消费失败后ack</span></span><br><span class=\"line\">            <span class=\"comment\">// 三个参数：</span></span><br><span class=\"line\">            <span class=\"comment\">// （1）delivery_tag：表示消息的唯一标识符</span></span><br><span class=\"line\">            <span class=\"comment\">// （2）multiple：表示是否将delivery_tag之前的所有未确认消息都拒绝。如果multiple为true，则RabbitMQ将拒绝所有未确认的消息，如果为false，则只拒绝指定的消息</span></span><br><span class=\"line\">            <span class=\"comment\">// （3）requeue：表示是否将被拒绝的消息重新放回队列中。如果requeue为true，则消息将返回到队列中以便重新处理，如果为false，则消息将被丢弃</span></span><br><span class=\"line\">            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class=\"literal\">false</span>,<span class=\"literal\">false</span>);</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (message.getMessageProperties().getRedelivered()) &#123;<span class=\"comment\">//判断是否已经重试过</span></span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;消息已重复处理失败,拒绝再次接收...&quot;</span>);</span><br><span class=\"line\">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>); <span class=\"comment\">// 拒绝消息</span></span><br><span class=\"line\">                <span class=\"comment\">// 重复消费失败的消息入库...</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                log.error(<span class=\"string\">&quot;消息即将再次返回队列处理...&quot;</span>);</span><br><span class=\"line\">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class=\"literal\">false</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>requeue参数设置为true，可以将消息返回到队列中以便重新处理<br>但是这样可能导致无限循环地处理同一个错误消息<br>所以上面代码采用了折中方案：首次失败的消息通知队列重发，重复失败的消息落地进行后面的补偿机制</p>\n</blockquote>\n<h2 id=\"3-2、消息持久化机制\"><a href=\"#3-2、消息持久化机制\" class=\"headerlink\" title=\"3.2、消息持久化机制\"></a>3.2、消息持久化机制</h2><p>持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：</p>\n<ol>\n<li>Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。</li>\n<li>Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。</li>\n<li>消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。</li>\n</ol>\n<blockquote>\n<p> 注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可</p>\n</blockquote>\n<h3 id=\"3-2-1、交换机持久化\"><a href=\"#3-2-1、交换机持久化\" class=\"headerlink\" title=\"3.2.1、交换机持久化\"></a>3.2.1、交换机持久化</h3><p>在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// autoDelete:当所有绑定队列都不在使用时，是否自动 删除</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">DirectExchange</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(name, durable, autoDelete);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2、队列持久化\"><a href=\"#3-2-2、队列持久化\" class=\"headerlink\" title=\"3.2.2、队列持久化\"></a>3.2.2、队列持久化</h3><p>申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// durable: 是否做队列持久化</span></span><br><span class=\"line\"><span class=\"comment\">// exclusive: 是否排外。两个作用：（1）当连接关闭时connection.close()该队列是否会自动删除（2）对当前队列加锁，其他通道channel是不能访问的，用于一个队列只能有一个消费者来消费的场景</span></span><br><span class=\"line\"><span class=\"comment\">// autoDelete:当所有消费客户端连接断开后，是否自动删除 </span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">Queue</span><span class=\"params\">(String name, <span class=\"type\">boolean</span> durable, <span class=\"type\">boolean</span> exclusive, <span class=\"type\">boolean</span> autoDelete)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>(name, durable, exclusive, autoDelete, (Map)<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3、避免消息重复消费\"><a href=\"#3-3、避免消息重复消费\" class=\"headerlink\" title=\"3.3、避免消息重复消费\"></a>3.3、避免消息重复消费</h2><h3 id=\"3-3-1、消息重复发送的场景\"><a href=\"#3-3-1、消息重复发送的场景\" class=\"headerlink\" title=\"3.3.1、消息重复发送的场景\"></a>3.3.1、消息重复发送的场景</h3><p>消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息</p>\n<h3 id=\"3-3-2、解决方案\"><a href=\"#3-3-2、解决方案\" class=\"headerlink\" title=\"3.3.2、解决方案\"></a>3.3.2、解决方案</h3><p>保证消费者的幂等性（调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果）</p>\n<p>如何保证幂等性？</p>\n<ol>\n<li>使用代码的逻辑判断，判断消息状态是否已经被消费过了</li>\n</ol>\n<blockquote>\n<p>使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。</p>\n</blockquote>\n<ol start=\"2\">\n<li>使用token，要申请，一次有效性。</li>\n</ol>\n<blockquote>\n<p>在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）</p>\n</blockquote>\n<h2 id=\"3-4、避免消息积压问题\"><a href=\"#3-4、避免消息积压问题\" class=\"headerlink\" title=\"3.4、避免消息积压问题\"></a>3.4、避免消息积压问题</h2><h3 id=\"3-4-1、消息积压场景\"><a href=\"#3-4-1、消息积压场景\" class=\"headerlink\" title=\"3.4.1、消息积压场景\"></a>3.4.1、消息积压场景</h3><p>消费者宕机&#x2F;消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压</p>\n<h3 id=\"3-4-2、解决方案\"><a href=\"#3-4-2、解决方案\" class=\"headerlink\" title=\"3.4.2、解决方案\"></a>3.4.2、解决方案</h3><ol>\n<li>上线更多的消费者（如：库存服务），进行正常消费</li>\n<li>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。</li>\n</ol>\n<h2 id=\"3-5、保证消息的顺序性\"><a href=\"#3-5、保证消息的顺序性\" class=\"headerlink\" title=\"3.5、保证消息的顺序性\"></a>3.5、保证消息的顺序性</h2><h3 id=\"3-5-1、消息顺序错乱场景\"><a href=\"#3-5-1、消息顺序错乱场景\" class=\"headerlink\" title=\"3.5.1、消息顺序错乱场景\"></a>3.5.1、消息顺序错乱场景</h3><p>生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。</p>\n<h3 id=\"3-5-2、解决方案\"><a href=\"#3-5-2、解决方案\" class=\"headerlink\" title=\"3.5.2、解决方案\"></a>3.5.2、解决方案</h3><p>保证队列与消费者一对一<br>思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的 </p>\n"},{"title":"PBRTQC","date":"2023-10-07T16:00:00.000Z","abbrlink":22105,"_content":"# 1、基本概念\n\n## 1.1、PBRTQC\n\n基于患者样本的实时质量控制（patient-based real-time quality control，PBRTQC）系统是一种基于统计学以及数学模型的质量控制方法，是根据患者样本检测结果，利用统计学模型建立的一套以实时监测实验室检测质量的模型或者规则，是医学检验实验室提高质量控制体系的重要发展方向，最早由Hoffmann和Waid于1965年提出\n\n## 1.2、PBRTQC模型\n\n1. 五个关键参数：上截断值（UTL）、下截断值（LTL）、浮动窗口大小（N）、上控制限（UCL）、下控制限（LCL）\n2. 排除规则：对于偏态分布以及存在极端值的分布数据，应选择一个适宜的截断值区间，将在截断值区间外的数据进行缩尾或者去除\n3. SPC算法：浮动均值（MA）、浮动分位数（MQ）、指数加权移动平均值（EWMA）用于监测定值误差（CE）和百分比误差（PE）；浮动标准差（MovSD）、浮动非正常值患者数（MovSO）用于监测随机误差（RE）\n4. 控制限：1. 分布法：通过分析历史数据生成的PBRTQC计算值，得出计算值的均值与标准差，根据正态分布或其它分布特征计算出对应的控制限\n           2. 百分位点法：根据目标假阳性报警率（DFAR），如0.1%，考虑双边的情况下，那么控制限则为历史数据PBRTQC计算值的0.05%和99.95%百分位数点\n\n## 1.3、模型评估指标\n1. 假阳性报警率（FAR）：指误报次数与样本数的比值，文献中通常要求该值≤0.1%，即每进行1000例患者样本的实时质控，最多允许1次误报，表征模型的特异性，FAR越小，模型特异性越好\n2. 误差检出前平均患者样本数（ANPed）：误差出现时至模型检测出误差所经历的患者样本例数，表征模型的灵敏度，例数越少，模型灵敏度越高\n3. 二者关系：二者之间存在矛盾关系，FAR越低，ANPed越大，实际应用中应综合考虑，能满足当前项目的需求即可\n\n# 2、实现简要流程\n\n1. 数据类型位信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换\n2. 根据条件查询数据集合(仪器+批号+项目+时间)\n3. 定量定性项目过滤，定量项目过滤掉单位为S/CO，定性项目液体类型为C（校准）或单位为S/CO\n4. cut-off过滤（不包括校准点数据）\n5. 根据washStatus判断是否需要排除修改前后信号值不一致的数据\n6. 得到两份数据。allDataList：经过上述步骤剩余的数据。list：经过上述步骤再过滤掉校准点（液体类型C）数据\n7. list为空、list大于20000，list大小小于训练数据集样本容量n。直接返回\n8. 寻找定标线。液体类型为c（校准）,连续12个点确定一个定标线（不连续的舍弃）\n9. 暂存list\n10. 遍历函数模型集合，一个模型出一个图\n11. 暂存全量数据list\n12. 计算控制线\n13. 每次移动训练数据集个数个数据。计算截断限LTL和UTL（通过移动分位数mq计算）\n14. 根据LTL和UTL截断sublist数据。数据被截断并且是定标点，将前一个点设置为定标点\n15. 数据转换sublist，使数据更符合正态性(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)\n16. 记录最优lambda，加权失控报警0.5N和2N最优lambda用N计算出的lambda\n17. 计算本次控制线（LCL,UCL）\n18. 判断控制线的合理性：根据控制线偏差和Moving-Slope斜率最大值，最小值判断（斜率判断最新版本已废除）\n19. 满足合理性判断时，暂存N转换后的数据,用作失控报警中的加权失控计算（0.5N，2N）\n20. 未找到合适控制线时，直接返回并提示用户\n21. 使用计算控制线得到的LTL和UTL截断全量数据，得到list\n22. list数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)\n23. 暂存转换后的数据,用作失控报警中的加权失控计算\n24. list统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)\n25. Moving-Slope计算系统误差点（最新版本废弃）\n26. 失控报警：失控点计算(0-单点失控,1-连续X点失控,2-加权失控，3-加权连续失控)\n27. 找到所有定标线\n28. 响应封装\n\n# 3、代码实现\n\n## 3.1、基本流程框架\n\n```java\npublic AjaxResult pbrtqcLineData(PbrtqcDTO dto) {  \n    PBRTQCResultVO response = new PBRTQCResultVO();  \n    // 请求转换  \n    if (dto.getDataType() == 1) {  \n        // 数据类型位信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换  \n        dto.setFuncModel(1);  \n        dto.setMqQuantile(50.0);  \n        dto.setTransType(null);  \n    }  \n    // 根据条件查询数据集合(仪器+批号+项目+时间)  \n    List<PbrtqcWashed> allDataList = iPbrtqcWashedService.selectLineData(dto);  \n    // 定量项目&定性项目过滤  \n    if (dto.getProjectType() == 0){  \n        allDataList = allDataList.stream().filter(item -> !\"S/CO\".equals(item.getUnit())).collect(Collectors.toList());  \n    }else {  \n        allDataList = allDataList.stream().filter(item -> \"C\".equals(item.getLiquidType()) || \"S/CO\".equals(item.getUnit())).collect(Collectors.toList());  \n    }  \n    // cut-off过滤(不包括校准点数据)  \n    if (1 == dto.getCutOffCondition()){  \n        allDataList = allDataList.stream().filter(item -> \"C\".equals(item.getLiquidType()) ||  item.getValue() < dto.getCutOffValue()).collect(Collectors.toList());  \n    }else if (2 == dto.getCutOffCondition()){  \n        allDataList = allDataList.stream().filter(item -> \"C\".equals(item.getLiquidType()) ||  BigDecimal.valueOf(item.getValue()).compareTo(BigDecimal.valueOf(dto.getCutOffValue())) >= 0).collect(Collectors.toList());  \n    }  \n    // 不包含液体类型为C的数据 根据washStatus判断是否需要排除修改前后信号值不一致的数据，排除时不对C（校准点）排除  \n    if (dto.getWashStatus() == 0){  \n        allDataList = allDataList.stream().filter(item -> \"C\".equals(item.getLiquidType()) || item.getModifiedSignal().equals(item.getOriginalSignal())).collect(Collectors.toList());  \n    }  \n    List<PbrtqcWashed> list = allDataList.stream().filter(item -> !\"C\".equals(item.getLiquidType())).collect(Collectors.toList());  \n    // 数据为空  \n    if (CollectionUtils.isEmpty(list)) {  \n        return AjaxResult.error(\"查询数据为空\");  \n    }  \n    // 数据量过大不进行计算  \n    if (list.size() > 20000) {  \n        return AjaxResult.error(\"数据量过大（超过20000条），请调整查询条件\");  \n    }  \n    // 训练数据集样本大于集合数量，调整数量  \n    if (dto.getN() > list.size()) {  \n        return AjaxResult.error(\"总数据量为：\" + list.size() + \",小于训练数据集样本N，请调整N大小!\");  \n    }  \n    // 寻找定标线  \n    List<CalibrationPoint> calibrationDetailList = findCalibrationLine(allDataList); // 定标点集合  \n    // 暂存全量数据list  \n    List<PbrtqcWashed> tempList = saveDataList(list);  \n    // 单位记录  \n    String unit = list.get(0).getUnit();  \n    List<PBRTQCData> pbrtqcDataList = new ArrayList<>();  \n    List<Integer> funcModels = Arrays.stream(dto.getFuncModels().split(\",\")).map(Integer::parseInt).collect(Collectors.toList());  \n    // 把movsd放到集合最后一个元素  \n    for (int i=0; i< funcModels.size(); i++){  \n        if (funcModels.get(i) == 3){  \n            funcModels.remove(i);  \n            funcModels.add(3);  \n        }  \n    }  \n    // 序号  \n    dto.setIndex(0);  \n    for (Integer funcModel : funcModels) {  \n        List<PbrtqcWashed> modelDataList = saveDataList(list);  \n        // 函数模型  \n        dto.setFuncModel(funcModel);  \n        // 控制限偏差设置  \n        if (funcModel == 3) {  \n            dto.setLimitQuantile(dto.getSdLimitQuantile());  \n        } else {  \n            dto.setLimitQuantile(dto.getMqLimitQuantile());  \n        }  \n        // 计算N控制限  \n        ControlLineData controlLine = calculateControlLine(dto, tempList, 1, 0, dto.getIndex());  \n        // 控制限判断  \n        if ((dto.getIndex() ==  0 && controlLine.getUcl() == null) || (dto.getIndex() > 0 && dto.getFindControlLine() == null)){  \n            return AjaxResult.error(\"未找到合适的控制线,请设置合理的控制限偏差\");  \n        }  \n        List<PbrtqcWashed> cutDataList = modelDataList;  \n        if (dto.getCutType() != 0) {  \n            // LTL（下截断限值）和UTL（上截断限值）  \n            QuantileData quantileData = new QuantileData(dto.getLtl(),dto.getUtl());  \n            // 根据截断方式截断数据  \n            cutDataList = cutData(dto, quantileData, modelDataList);  \n        }  \n        // 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  \n        dataTrans(dto, cutDataList, 0);  \n        // 暂存转换后的数据,用作失控报警中的加权失控计算  \n        List<PbrtqcWashed> transData = new ArrayList<>();  \n        if (dto.getAlarmMode() == 2 || dto.getAlarmMode() == 3){  \n            transData = saveDataList(cutDataList);  \n        }  \n        // 统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)  \n        List<PBRTQCLineVO> dataList = funcModelCalculate(dto, cutDataList,1);  \n        // Moving-Slope计算系统误差失控点  \n        List<PBRTQCLineVO> systemErrorDataList = systemErrorPoint(dto, dataList);  \n        // 失控报警  \n        List<PBRTQCLineVO> alarmDataList = outOfControlAlarm(dto, tempList, dataList, controlLine, transData);  \n        // 批号计算  \n        List<String> lots = dataList.stream().map(PBRTQCLineVO::getName).distinct().collect(Collectors.toList());  \n        lots.add(0, \"失控点\");  \n        lots.add(1, \"系统误差点\");  \n        // 设置失控点  \n        alarmDataList.forEach(item -> dataList.get(item.getId()).setName(\"失控点\"));  \n        // 找到所有的定标线  \n        List<PBRTQCLineVO> calibrationPointList = dataList.stream().filter(item ->  \n                item.getIsCalibration() != null && item.getIsCalibration().equals(1)).collect(Collectors.toList());  \n        List<Integer> calibrationList = calibrationPointList.stream().map(PBRTQCLineVO::getId).collect(Collectors.toList());  \n        // 寻找失控点中的所有系统误差点  \n        List<PBRTQCLineVO> systemErrorData = alarmDataList.stream().filter(item -> systemErrorDataList.stream().anyMatch(obj -> obj.getId().equals(item.getId()))).collect(Collectors.toList());  \n        systemErrorData.forEach(item -> dataList.get(item.getId()).setName(\"系统误差点\"));  \n        // 响应封装  \n        PBRTQCData data = new PBRTQCData();  \n        data.setList(dataList);  \n        data.setLots(lots);  \n        data.setUnit(unit);  \n        data.setMethodName(DictUtils.getDictLabel(\"ims_pbrtqc_func_model\", dto.getFuncModel().toString()));  \n        data.setAlarmList(alarmDataList);  \n        data.setSystemErrorList(systemErrorData);  \n        data.setLcl(controlLine.getLcl());  \n        data.setUcl(controlLine.getUcl());  \n        data.setOriginLcl(controlLine.getOriginLcl());  \n        data.setOriginUcl(controlLine.getOriginUcl());  \n        data.setCalibrationList(calibrationList);  \n        pbrtqcDataList.add(data);  \n        dto.setIndex(dto.getIndex() + 1);  \n    }  \n    response.setList(pbrtqcDataList);  \n    response.setLtl(dto.getLtl());  \n    response.setUtl(dto.getUtl());  \n    response.setCalibrationPointList(calibrationDetailList);  \n    return AjaxResult.success(response);  \n}\n```\n\n\n## 3.2、控制线计算流程\n\n```java\nprivate ControlLineData calculateControlLine(PbrtqcDTO dto, List<PbrtqcWashed> list, Integer transFlag, Integer alarmFlag, Integer index) {  \n//        List<PbrtqcWashed> list = saveDataList(originlist);  \n        int size = list.size();  \n        Integer offset = dto.getLimitOffset();  \n        Integer n = dto.getN();  \n        Double limitQuantile = dto.getLimitQuantile();  \n        ControlLineData controlLineData = new ControlLineData();  \n        // 第二次计算控制线用第一次的截断转换数据  \n        if(index > 0){  \n            // 计算控制线  \n            ControlLineData controlLine =  calculateCurrentControlLine(dto.getTransDataList(), dto);  \n            Double ucl = controlLine.getUcl();  \n            Double lcl = controlLine.getLcl();  \n            Double originLcl = controlLine.getOriginLcl();  \n            Double originUcl = controlLine.getOriginUcl();  \n            // 新增控制线判断条件Moving-Slope  \n            boolean msFlag = true;  \n            if (dto.getMinSlope() != null && dto.getMaxSlope() != null){  \n                msFlag = movingSlope(dto, dto.getStatisticList2());  \n            }  \n            // 判断合理性  \n            if ((originUcl - originLcl) / (originLcl + originUcl) <= limitQuantile / 100 && msFlag) {  \n                dto.setFindControlLine(1);  \n                controlLineData.setLcl(lcl);  \n                controlLineData.setUcl(ucl);  \n                controlLineData.setOriginUcl(originUcl);  \n                controlLineData.setOriginLcl(originLcl);  \n                dto.setBestMean2(dto.getUseMean2());  \n                dto.setBestSD2(dto.getUseSD2());  \n                return controlLineData;  \n            }  \n        }  \n        for (int i = 0; i < size - offset; i++) {  \n            // 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  \n            if (i > 100) {  \n                break;  \n            }  \n            List<PbrtqcWashed> subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  \n            subList = saveDataList(subList);  \n            if (subList.size() < n) {  \n                return controlLineData;  \n            }  \n            QuantileData quantileData = new QuantileData();  \n            if (dto.getCutType() != 0) {  \n                // 计算LTL（下截断限值）和UTL（上截断限值）  \n                quantileData = calculateQuantile(subList, dto);  \n                // 训练数据集截断后数据  \n                subList = cutData(dto, quantileData, subList);  \n            }  \n            // 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  \n            List<PbrtqcWashed> transDatas = dataTrans(dto, subList, transFlag);  \n            // 暂存N转换后的数据，用来计算加权失控0.5N，2N  \n            List<PbrtqcWashed> tempTransDataList = new ArrayList<>();  \n            if (dto.getAlarmMode() == 2 || dto.getAlarmMode() == 3) {  \n                tempTransDataList = saveDataList(transDatas);  \n            }  \n            // 计算本次控制线  \n            ControlLineData currentControlLine =  calculateCurrentControlLine(transDatas, dto);  \n            // 计算合理性  \n            Double ucl = currentControlLine.getUcl();  \n            Double lcl = currentControlLine.getLcl();  \n            Double originLcl = currentControlLine.getOriginLcl();  \n            Double originUcl = currentControlLine.getOriginUcl();  \n            // 新增控制线判断条件Moving-Slope  \n            boolean msFlag = true;  \n            if (dto.getMinSlope() != null && dto.getMaxSlope() != null){  \n                msFlag = movingSlope(dto, dto.getStatisticList());  \n            }  \n            if ((originUcl - originLcl) / (originLcl + originUcl) <= limitQuantile / 100 && msFlag) {  \n                if (index == 0){  \n                    // 记录截断限，用于第二次全量数据的截断  \n                    dto.setLtl(quantileData.getLtl());  \n                    dto.setUtl(quantileData.getUtl());  \n                    // 记录该次转换后的数据,用于第二次统计量的计算  \n                    dto.setTransDataList(transDatas);  \n                    dto.setBestMean(dto.getUseMean());  \n                    dto.setBestSD(dto.getUseSD());  \n                }  \n                controlLineData.setLcl(lcl);  \n                controlLineData.setUcl(ucl);  \n                controlLineData.setOriginUcl(originUcl);  \n                controlLineData.setOriginLcl(originLcl);  \n                // N转换后的数据，用于加权失控计算  \n                dto.setTransDataN(tempTransDataList);  \n                break;            }  \n        }  \n        return controlLineData;  \n    }\n```\n\n\n## 3.3、数据转换box-cox转换\n\n```java\nprivate ControlLineData calculateControlLine(PbrtqcDTO dto, List<PbrtqcWashed> list, Integer transFlag, Integer alarmFlag, Integer index) {  \n//        List<PbrtqcWashed> list = saveDataList(originlist);  \n        int size = list.size();  \n        Integer offset = dto.getLimitOffset();  \n        Integer n = dto.getN();  \n        Double limitQuantile = dto.getLimitQuantile();  \n        ControlLineData controlLineData = new ControlLineData();  \n        // 第二次计算控制线用第一次的截断转换数据  \n        if(index > 0){  \n            // 计算控制线  \n            ControlLineData controlLine =  calculateCurrentControlLine(dto.getTransDataList(), dto);  \n            Double ucl = controlLine.getUcl();  \n            Double lcl = controlLine.getLcl();  \n            Double originLcl = controlLine.getOriginLcl();  \n            Double originUcl = controlLine.getOriginUcl();  \n            // 新增控制线判断条件Moving-Slope  \n            boolean msFlag = true;  \n            if (dto.getMinSlope() != null && dto.getMaxSlope() != null){  \n                msFlag = movingSlope(dto, dto.getStatisticList2());  \n            }  \n            // 判断合理性  \n            if ((originUcl - originLcl) / (originLcl + originUcl) <= limitQuantile / 100 && msFlag) {  \n                dto.setFindControlLine(1);  \n                controlLineData.setLcl(lcl);  \n                controlLineData.setUcl(ucl);  \n                controlLineData.setOriginUcl(originUcl);  \n                controlLineData.setOriginLcl(originLcl);  \n                dto.setBestMean2(dto.getUseMean2());  \n                dto.setBestSD2(dto.getUseSD2());  \n                return controlLineData;  \n            }  \n        }  \n        for (int i = 0; i < size - offset; i++) {  \n            // 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  \n            if (i > 100) {  \n                break;  \n            }  \n            List<PbrtqcWashed> subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  \n            subList = saveDataList(subList);  \n            if (subList.size() < n) {  \n                return controlLineData;  \n            }  \n            QuantileData quantileData = new QuantileData();  \n            if (dto.getCutType() != 0) {  \n                // 计算LTL（下截断限值）和UTL（上截断限值）  \n                quantileData = calculateQuantile(subList, dto);  \n                // 训练数据集截断后数据  \n                subList = cutData(dto, quantileData, subList);  \n            }  \n            // 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  \n            List<PbrtqcWashed> transDatas = dataTrans(dto, subList, transFlag);  \n            // 暂存N转换后的数据，用来计算加权失控0.5N，2N  \n            List<PbrtqcWashed> tempTransDataList = new ArrayList<>();  \n            if (dto.getAlarmMode() == 2 || dto.getAlarmMode() == 3) {  \n                tempTransDataList = saveDataList(transDatas);  \n            }  \n            // 计算本次控制线  \n            ControlLineData currentControlLine =  calculateCurrentControlLine(transDatas, dto);  \n            // 计算合理性  \n            Double ucl = currentControlLine.getUcl();  \n            Double lcl = currentControlLine.getLcl();  \n            Double originLcl = currentControlLine.getOriginLcl();  \n            Double originUcl = currentControlLine.getOriginUcl();  \n            // 新增控制线判断条件Moving-Slope  \n            boolean msFlag = true;  \n            if (dto.getMinSlope() != null && dto.getMaxSlope() != null){  \n                msFlag = movingSlope(dto, dto.getStatisticList());  \n            }  \n            if ((originUcl - originLcl) / (originLcl + originUcl) <= limitQuantile / 100 && msFlag) {  \n                if (index == 0){  \n                    // 记录截断限，用于第二次全量数据的截断  \n                    dto.setLtl(quantileData.getLtl());  \n                    dto.setUtl(quantileData.getUtl());  \n                    // 记录该次转换后的数据,用于第二次统计量的计算  \n                    dto.setTransDataList(transDatas);  \n                    dto.setBestMean(dto.getUseMean());  \n                    dto.setBestSD(dto.getUseSD());  \n                }  \n                controlLineData.setLcl(lcl);  \n                controlLineData.setUcl(ucl);  \n                controlLineData.setOriginUcl(originUcl);  \n                controlLineData.setOriginLcl(originLcl);  \n                // N转换后的数据，用于加权失控计算  \n                dto.setTransDataN(tempTransDataList);  \n                break;            }  \n        }  \n        return controlLineData;  \n    }\n\n/**  \n * 计算最优的lambda值  \n *  \n * @param data 数据  \n * @return 最优的lambda值  \n */  \npublic static double findBestLambda(double[] data) {  \n    // 定义lambda的范围和步长  \n    double lambdaStart = -5.0;  \n    double lambdaEnd = 5.0;  \n    double lambdaStep = 0.01;  \n  \n    // 计算原始数据的几何均值G  \n    double G = 1.0;  \n    for (double x : data) {  \n        G *= Math.pow(x, 1.0 / data.length);  \n    }  \n  \n    // 计算最优lambda  \n    double minSD = Double.MAX_VALUE;  \n    double minLambda = -5;  \n    for (double lambda = lambdaStart; lambda <= lambdaEnd; lambda += lambdaStep) {  \n        double[] transformedData = boxCoxTransform(data, lambda, G);  \n        double avg = calculateAverage(transformedData);  \n        double sd = calculateStandardDeviation(transformedData, avg);  \n        if (sd < minSD) {  \n            minSD = sd;  \n            minLambda = lambda;  \n        }  \n    }  \n    return minLambda;  \n}\n\n/**  \n * 计算Box-Cox变换后的数据  \n * @param data   数据  \n * @param lambda lambda值  \n * @return Box-Cox变换后的数据  \n */  \npublic static double[] boxCoxTransform(double[] data, double lambda, double G) {  \n    double[] transformedData = new double[data.length];  \n    if (lambda == 0) {  \n        for (int i = 0; i < data.length; i++) {  \n            transformedData[i] = G * Math.log(data[i]);  \n        }  \n    } else {  \n        for (int i = 0; i < data.length; i++) {  \n            transformedData[i] = (Math.pow(data[i], lambda) - 1) / (lambda * Math.pow(G, lambda - 1));  \n        }  \n    }  \n    return transformedData;  \n}\n```\n\n## 3.4、统计值计算之mq\n\n```java\n/**  \n * 移动分位数（MQ）  \n * @param N 窗口大小  \n * @param X mq分位数  \n * @param list  \n * @return  \n */  \npublic static List<PBRTQCLineVO> MQ(Integer N, Double X, List<PbrtqcWashed> list) {  \n    List<PBRTQCLineVO> result = new ArrayList<>();  \n    for (int i = 0; i < list.size() -N + 1; i++) {  \n        double val1 = (N + 1) * X / 100;  \n        // 整数部分  \n        int j = (int) val1;  \n        // 小数部分  \n        double g = val1 - j;  \n        List<Integer> subIndex = new ArrayList<>();  \n        double calValue;  \n        // list从小到大排序  \n        List<PbrtqcWashed> subList = list.stream().skip(i).limit(N).collect(Collectors.toList());  \n        List<PbrtqcWashed> collect = subList.stream().sorted(Comparator.comparing(PbrtqcWashed::getValue)).collect(Collectors.toList());  \n        if (g == 0) {  \n            calValue = collect.get(j - 1).getValue();  \n        } else {  \n            calValue = (1 - g) * collect.get(j - 1).getValue() + g * collect.get(j).getValue();  \n        }  \n        PBRTQCLineVO vo = new PBRTQCLineVO();  \n        vo.setId(i);  \n        vo.setName(list.get(i+N-1).getReagentBatch());  \n        vo.setValue(calValue);  \n        vo.setIsCalibration(list.get(i+N-1).getIsCalibration());  \n        vo.setReadyTime(list.get(i+N-1).getReadyTime());  \n        result.add(vo);  \n    }  \n    return result;  \n}\n```\n\n\n# 4、效果图\n\n![PBRTQC](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310081549987.png)\n","source":"_posts/PBRTQC质控功能实现.md","raw":"---\ntitle: PBRTQC\ndate: 2023/10/08\ncategories:\n  - coding\ntags:\n  - PBRTQC\n  - 技术文章\nabbrlink: 22105\n---\n# 1、基本概念\n\n## 1.1、PBRTQC\n\n基于患者样本的实时质量控制（patient-based real-time quality control，PBRTQC）系统是一种基于统计学以及数学模型的质量控制方法，是根据患者样本检测结果，利用统计学模型建立的一套以实时监测实验室检测质量的模型或者规则，是医学检验实验室提高质量控制体系的重要发展方向，最早由Hoffmann和Waid于1965年提出\n\n## 1.2、PBRTQC模型\n\n1. 五个关键参数：上截断值（UTL）、下截断值（LTL）、浮动窗口大小（N）、上控制限（UCL）、下控制限（LCL）\n2. 排除规则：对于偏态分布以及存在极端值的分布数据，应选择一个适宜的截断值区间，将在截断值区间外的数据进行缩尾或者去除\n3. SPC算法：浮动均值（MA）、浮动分位数（MQ）、指数加权移动平均值（EWMA）用于监测定值误差（CE）和百分比误差（PE）；浮动标准差（MovSD）、浮动非正常值患者数（MovSO）用于监测随机误差（RE）\n4. 控制限：1. 分布法：通过分析历史数据生成的PBRTQC计算值，得出计算值的均值与标准差，根据正态分布或其它分布特征计算出对应的控制限\n           2. 百分位点法：根据目标假阳性报警率（DFAR），如0.1%，考虑双边的情况下，那么控制限则为历史数据PBRTQC计算值的0.05%和99.95%百分位数点\n\n## 1.3、模型评估指标\n1. 假阳性报警率（FAR）：指误报次数与样本数的比值，文献中通常要求该值≤0.1%，即每进行1000例患者样本的实时质控，最多允许1次误报，表征模型的特异性，FAR越小，模型特异性越好\n2. 误差检出前平均患者样本数（ANPed）：误差出现时至模型检测出误差所经历的患者样本例数，表征模型的灵敏度，例数越少，模型灵敏度越高\n3. 二者关系：二者之间存在矛盾关系，FAR越低，ANPed越大，实际应用中应综合考虑，能满足当前项目的需求即可\n\n# 2、实现简要流程\n\n1. 数据类型位信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换\n2. 根据条件查询数据集合(仪器+批号+项目+时间)\n3. 定量定性项目过滤，定量项目过滤掉单位为S/CO，定性项目液体类型为C（校准）或单位为S/CO\n4. cut-off过滤（不包括校准点数据）\n5. 根据washStatus判断是否需要排除修改前后信号值不一致的数据\n6. 得到两份数据。allDataList：经过上述步骤剩余的数据。list：经过上述步骤再过滤掉校准点（液体类型C）数据\n7. list为空、list大于20000，list大小小于训练数据集样本容量n。直接返回\n8. 寻找定标线。液体类型为c（校准）,连续12个点确定一个定标线（不连续的舍弃）\n9. 暂存list\n10. 遍历函数模型集合，一个模型出一个图\n11. 暂存全量数据list\n12. 计算控制线\n13. 每次移动训练数据集个数个数据。计算截断限LTL和UTL（通过移动分位数mq计算）\n14. 根据LTL和UTL截断sublist数据。数据被截断并且是定标点，将前一个点设置为定标点\n15. 数据转换sublist，使数据更符合正态性(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)\n16. 记录最优lambda，加权失控报警0.5N和2N最优lambda用N计算出的lambda\n17. 计算本次控制线（LCL,UCL）\n18. 判断控制线的合理性：根据控制线偏差和Moving-Slope斜率最大值，最小值判断（斜率判断最新版本已废除）\n19. 满足合理性判断时，暂存N转换后的数据,用作失控报警中的加权失控计算（0.5N，2N）\n20. 未找到合适控制线时，直接返回并提示用户\n21. 使用计算控制线得到的LTL和UTL截断全量数据，得到list\n22. list数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)\n23. 暂存转换后的数据,用作失控报警中的加权失控计算\n24. list统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)\n25. Moving-Slope计算系统误差点（最新版本废弃）\n26. 失控报警：失控点计算(0-单点失控,1-连续X点失控,2-加权失控，3-加权连续失控)\n27. 找到所有定标线\n28. 响应封装\n\n# 3、代码实现\n\n## 3.1、基本流程框架\n\n```java\npublic AjaxResult pbrtqcLineData(PbrtqcDTO dto) {  \n    PBRTQCResultVO response = new PBRTQCResultVO();  \n    // 请求转换  \n    if (dto.getDataType() == 1) {  \n        // 数据类型位信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换  \n        dto.setFuncModel(1);  \n        dto.setMqQuantile(50.0);  \n        dto.setTransType(null);  \n    }  \n    // 根据条件查询数据集合(仪器+批号+项目+时间)  \n    List<PbrtqcWashed> allDataList = iPbrtqcWashedService.selectLineData(dto);  \n    // 定量项目&定性项目过滤  \n    if (dto.getProjectType() == 0){  \n        allDataList = allDataList.stream().filter(item -> !\"S/CO\".equals(item.getUnit())).collect(Collectors.toList());  \n    }else {  \n        allDataList = allDataList.stream().filter(item -> \"C\".equals(item.getLiquidType()) || \"S/CO\".equals(item.getUnit())).collect(Collectors.toList());  \n    }  \n    // cut-off过滤(不包括校准点数据)  \n    if (1 == dto.getCutOffCondition()){  \n        allDataList = allDataList.stream().filter(item -> \"C\".equals(item.getLiquidType()) ||  item.getValue() < dto.getCutOffValue()).collect(Collectors.toList());  \n    }else if (2 == dto.getCutOffCondition()){  \n        allDataList = allDataList.stream().filter(item -> \"C\".equals(item.getLiquidType()) ||  BigDecimal.valueOf(item.getValue()).compareTo(BigDecimal.valueOf(dto.getCutOffValue())) >= 0).collect(Collectors.toList());  \n    }  \n    // 不包含液体类型为C的数据 根据washStatus判断是否需要排除修改前后信号值不一致的数据，排除时不对C（校准点）排除  \n    if (dto.getWashStatus() == 0){  \n        allDataList = allDataList.stream().filter(item -> \"C\".equals(item.getLiquidType()) || item.getModifiedSignal().equals(item.getOriginalSignal())).collect(Collectors.toList());  \n    }  \n    List<PbrtqcWashed> list = allDataList.stream().filter(item -> !\"C\".equals(item.getLiquidType())).collect(Collectors.toList());  \n    // 数据为空  \n    if (CollectionUtils.isEmpty(list)) {  \n        return AjaxResult.error(\"查询数据为空\");  \n    }  \n    // 数据量过大不进行计算  \n    if (list.size() > 20000) {  \n        return AjaxResult.error(\"数据量过大（超过20000条），请调整查询条件\");  \n    }  \n    // 训练数据集样本大于集合数量，调整数量  \n    if (dto.getN() > list.size()) {  \n        return AjaxResult.error(\"总数据量为：\" + list.size() + \",小于训练数据集样本N，请调整N大小!\");  \n    }  \n    // 寻找定标线  \n    List<CalibrationPoint> calibrationDetailList = findCalibrationLine(allDataList); // 定标点集合  \n    // 暂存全量数据list  \n    List<PbrtqcWashed> tempList = saveDataList(list);  \n    // 单位记录  \n    String unit = list.get(0).getUnit();  \n    List<PBRTQCData> pbrtqcDataList = new ArrayList<>();  \n    List<Integer> funcModels = Arrays.stream(dto.getFuncModels().split(\",\")).map(Integer::parseInt).collect(Collectors.toList());  \n    // 把movsd放到集合最后一个元素  \n    for (int i=0; i< funcModels.size(); i++){  \n        if (funcModels.get(i) == 3){  \n            funcModels.remove(i);  \n            funcModels.add(3);  \n        }  \n    }  \n    // 序号  \n    dto.setIndex(0);  \n    for (Integer funcModel : funcModels) {  \n        List<PbrtqcWashed> modelDataList = saveDataList(list);  \n        // 函数模型  \n        dto.setFuncModel(funcModel);  \n        // 控制限偏差设置  \n        if (funcModel == 3) {  \n            dto.setLimitQuantile(dto.getSdLimitQuantile());  \n        } else {  \n            dto.setLimitQuantile(dto.getMqLimitQuantile());  \n        }  \n        // 计算N控制限  \n        ControlLineData controlLine = calculateControlLine(dto, tempList, 1, 0, dto.getIndex());  \n        // 控制限判断  \n        if ((dto.getIndex() ==  0 && controlLine.getUcl() == null) || (dto.getIndex() > 0 && dto.getFindControlLine() == null)){  \n            return AjaxResult.error(\"未找到合适的控制线,请设置合理的控制限偏差\");  \n        }  \n        List<PbrtqcWashed> cutDataList = modelDataList;  \n        if (dto.getCutType() != 0) {  \n            // LTL（下截断限值）和UTL（上截断限值）  \n            QuantileData quantileData = new QuantileData(dto.getLtl(),dto.getUtl());  \n            // 根据截断方式截断数据  \n            cutDataList = cutData(dto, quantileData, modelDataList);  \n        }  \n        // 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  \n        dataTrans(dto, cutDataList, 0);  \n        // 暂存转换后的数据,用作失控报警中的加权失控计算  \n        List<PbrtqcWashed> transData = new ArrayList<>();  \n        if (dto.getAlarmMode() == 2 || dto.getAlarmMode() == 3){  \n            transData = saveDataList(cutDataList);  \n        }  \n        // 统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)  \n        List<PBRTQCLineVO> dataList = funcModelCalculate(dto, cutDataList,1);  \n        // Moving-Slope计算系统误差失控点  \n        List<PBRTQCLineVO> systemErrorDataList = systemErrorPoint(dto, dataList);  \n        // 失控报警  \n        List<PBRTQCLineVO> alarmDataList = outOfControlAlarm(dto, tempList, dataList, controlLine, transData);  \n        // 批号计算  \n        List<String> lots = dataList.stream().map(PBRTQCLineVO::getName).distinct().collect(Collectors.toList());  \n        lots.add(0, \"失控点\");  \n        lots.add(1, \"系统误差点\");  \n        // 设置失控点  \n        alarmDataList.forEach(item -> dataList.get(item.getId()).setName(\"失控点\"));  \n        // 找到所有的定标线  \n        List<PBRTQCLineVO> calibrationPointList = dataList.stream().filter(item ->  \n                item.getIsCalibration() != null && item.getIsCalibration().equals(1)).collect(Collectors.toList());  \n        List<Integer> calibrationList = calibrationPointList.stream().map(PBRTQCLineVO::getId).collect(Collectors.toList());  \n        // 寻找失控点中的所有系统误差点  \n        List<PBRTQCLineVO> systemErrorData = alarmDataList.stream().filter(item -> systemErrorDataList.stream().anyMatch(obj -> obj.getId().equals(item.getId()))).collect(Collectors.toList());  \n        systemErrorData.forEach(item -> dataList.get(item.getId()).setName(\"系统误差点\"));  \n        // 响应封装  \n        PBRTQCData data = new PBRTQCData();  \n        data.setList(dataList);  \n        data.setLots(lots);  \n        data.setUnit(unit);  \n        data.setMethodName(DictUtils.getDictLabel(\"ims_pbrtqc_func_model\", dto.getFuncModel().toString()));  \n        data.setAlarmList(alarmDataList);  \n        data.setSystemErrorList(systemErrorData);  \n        data.setLcl(controlLine.getLcl());  \n        data.setUcl(controlLine.getUcl());  \n        data.setOriginLcl(controlLine.getOriginLcl());  \n        data.setOriginUcl(controlLine.getOriginUcl());  \n        data.setCalibrationList(calibrationList);  \n        pbrtqcDataList.add(data);  \n        dto.setIndex(dto.getIndex() + 1);  \n    }  \n    response.setList(pbrtqcDataList);  \n    response.setLtl(dto.getLtl());  \n    response.setUtl(dto.getUtl());  \n    response.setCalibrationPointList(calibrationDetailList);  \n    return AjaxResult.success(response);  \n}\n```\n\n\n## 3.2、控制线计算流程\n\n```java\nprivate ControlLineData calculateControlLine(PbrtqcDTO dto, List<PbrtqcWashed> list, Integer transFlag, Integer alarmFlag, Integer index) {  \n//        List<PbrtqcWashed> list = saveDataList(originlist);  \n        int size = list.size();  \n        Integer offset = dto.getLimitOffset();  \n        Integer n = dto.getN();  \n        Double limitQuantile = dto.getLimitQuantile();  \n        ControlLineData controlLineData = new ControlLineData();  \n        // 第二次计算控制线用第一次的截断转换数据  \n        if(index > 0){  \n            // 计算控制线  \n            ControlLineData controlLine =  calculateCurrentControlLine(dto.getTransDataList(), dto);  \n            Double ucl = controlLine.getUcl();  \n            Double lcl = controlLine.getLcl();  \n            Double originLcl = controlLine.getOriginLcl();  \n            Double originUcl = controlLine.getOriginUcl();  \n            // 新增控制线判断条件Moving-Slope  \n            boolean msFlag = true;  \n            if (dto.getMinSlope() != null && dto.getMaxSlope() != null){  \n                msFlag = movingSlope(dto, dto.getStatisticList2());  \n            }  \n            // 判断合理性  \n            if ((originUcl - originLcl) / (originLcl + originUcl) <= limitQuantile / 100 && msFlag) {  \n                dto.setFindControlLine(1);  \n                controlLineData.setLcl(lcl);  \n                controlLineData.setUcl(ucl);  \n                controlLineData.setOriginUcl(originUcl);  \n                controlLineData.setOriginLcl(originLcl);  \n                dto.setBestMean2(dto.getUseMean2());  \n                dto.setBestSD2(dto.getUseSD2());  \n                return controlLineData;  \n            }  \n        }  \n        for (int i = 0; i < size - offset; i++) {  \n            // 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  \n            if (i > 100) {  \n                break;  \n            }  \n            List<PbrtqcWashed> subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  \n            subList = saveDataList(subList);  \n            if (subList.size() < n) {  \n                return controlLineData;  \n            }  \n            QuantileData quantileData = new QuantileData();  \n            if (dto.getCutType() != 0) {  \n                // 计算LTL（下截断限值）和UTL（上截断限值）  \n                quantileData = calculateQuantile(subList, dto);  \n                // 训练数据集截断后数据  \n                subList = cutData(dto, quantileData, subList);  \n            }  \n            // 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  \n            List<PbrtqcWashed> transDatas = dataTrans(dto, subList, transFlag);  \n            // 暂存N转换后的数据，用来计算加权失控0.5N，2N  \n            List<PbrtqcWashed> tempTransDataList = new ArrayList<>();  \n            if (dto.getAlarmMode() == 2 || dto.getAlarmMode() == 3) {  \n                tempTransDataList = saveDataList(transDatas);  \n            }  \n            // 计算本次控制线  \n            ControlLineData currentControlLine =  calculateCurrentControlLine(transDatas, dto);  \n            // 计算合理性  \n            Double ucl = currentControlLine.getUcl();  \n            Double lcl = currentControlLine.getLcl();  \n            Double originLcl = currentControlLine.getOriginLcl();  \n            Double originUcl = currentControlLine.getOriginUcl();  \n            // 新增控制线判断条件Moving-Slope  \n            boolean msFlag = true;  \n            if (dto.getMinSlope() != null && dto.getMaxSlope() != null){  \n                msFlag = movingSlope(dto, dto.getStatisticList());  \n            }  \n            if ((originUcl - originLcl) / (originLcl + originUcl) <= limitQuantile / 100 && msFlag) {  \n                if (index == 0){  \n                    // 记录截断限，用于第二次全量数据的截断  \n                    dto.setLtl(quantileData.getLtl());  \n                    dto.setUtl(quantileData.getUtl());  \n                    // 记录该次转换后的数据,用于第二次统计量的计算  \n                    dto.setTransDataList(transDatas);  \n                    dto.setBestMean(dto.getUseMean());  \n                    dto.setBestSD(dto.getUseSD());  \n                }  \n                controlLineData.setLcl(lcl);  \n                controlLineData.setUcl(ucl);  \n                controlLineData.setOriginUcl(originUcl);  \n                controlLineData.setOriginLcl(originLcl);  \n                // N转换后的数据，用于加权失控计算  \n                dto.setTransDataN(tempTransDataList);  \n                break;            }  \n        }  \n        return controlLineData;  \n    }\n```\n\n\n## 3.3、数据转换box-cox转换\n\n```java\nprivate ControlLineData calculateControlLine(PbrtqcDTO dto, List<PbrtqcWashed> list, Integer transFlag, Integer alarmFlag, Integer index) {  \n//        List<PbrtqcWashed> list = saveDataList(originlist);  \n        int size = list.size();  \n        Integer offset = dto.getLimitOffset();  \n        Integer n = dto.getN();  \n        Double limitQuantile = dto.getLimitQuantile();  \n        ControlLineData controlLineData = new ControlLineData();  \n        // 第二次计算控制线用第一次的截断转换数据  \n        if(index > 0){  \n            // 计算控制线  \n            ControlLineData controlLine =  calculateCurrentControlLine(dto.getTransDataList(), dto);  \n            Double ucl = controlLine.getUcl();  \n            Double lcl = controlLine.getLcl();  \n            Double originLcl = controlLine.getOriginLcl();  \n            Double originUcl = controlLine.getOriginUcl();  \n            // 新增控制线判断条件Moving-Slope  \n            boolean msFlag = true;  \n            if (dto.getMinSlope() != null && dto.getMaxSlope() != null){  \n                msFlag = movingSlope(dto, dto.getStatisticList2());  \n            }  \n            // 判断合理性  \n            if ((originUcl - originLcl) / (originLcl + originUcl) <= limitQuantile / 100 && msFlag) {  \n                dto.setFindControlLine(1);  \n                controlLineData.setLcl(lcl);  \n                controlLineData.setUcl(ucl);  \n                controlLineData.setOriginUcl(originUcl);  \n                controlLineData.setOriginLcl(originLcl);  \n                dto.setBestMean2(dto.getUseMean2());  \n                dto.setBestSD2(dto.getUseSD2());  \n                return controlLineData;  \n            }  \n        }  \n        for (int i = 0; i < size - offset; i++) {  \n            // 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  \n            if (i > 100) {  \n                break;  \n            }  \n            List<PbrtqcWashed> subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  \n            subList = saveDataList(subList);  \n            if (subList.size() < n) {  \n                return controlLineData;  \n            }  \n            QuantileData quantileData = new QuantileData();  \n            if (dto.getCutType() != 0) {  \n                // 计算LTL（下截断限值）和UTL（上截断限值）  \n                quantileData = calculateQuantile(subList, dto);  \n                // 训练数据集截断后数据  \n                subList = cutData(dto, quantileData, subList);  \n            }  \n            // 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  \n            List<PbrtqcWashed> transDatas = dataTrans(dto, subList, transFlag);  \n            // 暂存N转换后的数据，用来计算加权失控0.5N，2N  \n            List<PbrtqcWashed> tempTransDataList = new ArrayList<>();  \n            if (dto.getAlarmMode() == 2 || dto.getAlarmMode() == 3) {  \n                tempTransDataList = saveDataList(transDatas);  \n            }  \n            // 计算本次控制线  \n            ControlLineData currentControlLine =  calculateCurrentControlLine(transDatas, dto);  \n            // 计算合理性  \n            Double ucl = currentControlLine.getUcl();  \n            Double lcl = currentControlLine.getLcl();  \n            Double originLcl = currentControlLine.getOriginLcl();  \n            Double originUcl = currentControlLine.getOriginUcl();  \n            // 新增控制线判断条件Moving-Slope  \n            boolean msFlag = true;  \n            if (dto.getMinSlope() != null && dto.getMaxSlope() != null){  \n                msFlag = movingSlope(dto, dto.getStatisticList());  \n            }  \n            if ((originUcl - originLcl) / (originLcl + originUcl) <= limitQuantile / 100 && msFlag) {  \n                if (index == 0){  \n                    // 记录截断限，用于第二次全量数据的截断  \n                    dto.setLtl(quantileData.getLtl());  \n                    dto.setUtl(quantileData.getUtl());  \n                    // 记录该次转换后的数据,用于第二次统计量的计算  \n                    dto.setTransDataList(transDatas);  \n                    dto.setBestMean(dto.getUseMean());  \n                    dto.setBestSD(dto.getUseSD());  \n                }  \n                controlLineData.setLcl(lcl);  \n                controlLineData.setUcl(ucl);  \n                controlLineData.setOriginUcl(originUcl);  \n                controlLineData.setOriginLcl(originLcl);  \n                // N转换后的数据，用于加权失控计算  \n                dto.setTransDataN(tempTransDataList);  \n                break;            }  \n        }  \n        return controlLineData;  \n    }\n\n/**  \n * 计算最优的lambda值  \n *  \n * @param data 数据  \n * @return 最优的lambda值  \n */  \npublic static double findBestLambda(double[] data) {  \n    // 定义lambda的范围和步长  \n    double lambdaStart = -5.0;  \n    double lambdaEnd = 5.0;  \n    double lambdaStep = 0.01;  \n  \n    // 计算原始数据的几何均值G  \n    double G = 1.0;  \n    for (double x : data) {  \n        G *= Math.pow(x, 1.0 / data.length);  \n    }  \n  \n    // 计算最优lambda  \n    double minSD = Double.MAX_VALUE;  \n    double minLambda = -5;  \n    for (double lambda = lambdaStart; lambda <= lambdaEnd; lambda += lambdaStep) {  \n        double[] transformedData = boxCoxTransform(data, lambda, G);  \n        double avg = calculateAverage(transformedData);  \n        double sd = calculateStandardDeviation(transformedData, avg);  \n        if (sd < minSD) {  \n            minSD = sd;  \n            minLambda = lambda;  \n        }  \n    }  \n    return minLambda;  \n}\n\n/**  \n * 计算Box-Cox变换后的数据  \n * @param data   数据  \n * @param lambda lambda值  \n * @return Box-Cox变换后的数据  \n */  \npublic static double[] boxCoxTransform(double[] data, double lambda, double G) {  \n    double[] transformedData = new double[data.length];  \n    if (lambda == 0) {  \n        for (int i = 0; i < data.length; i++) {  \n            transformedData[i] = G * Math.log(data[i]);  \n        }  \n    } else {  \n        for (int i = 0; i < data.length; i++) {  \n            transformedData[i] = (Math.pow(data[i], lambda) - 1) / (lambda * Math.pow(G, lambda - 1));  \n        }  \n    }  \n    return transformedData;  \n}\n```\n\n## 3.4、统计值计算之mq\n\n```java\n/**  \n * 移动分位数（MQ）  \n * @param N 窗口大小  \n * @param X mq分位数  \n * @param list  \n * @return  \n */  \npublic static List<PBRTQCLineVO> MQ(Integer N, Double X, List<PbrtqcWashed> list) {  \n    List<PBRTQCLineVO> result = new ArrayList<>();  \n    for (int i = 0; i < list.size() -N + 1; i++) {  \n        double val1 = (N + 1) * X / 100;  \n        // 整数部分  \n        int j = (int) val1;  \n        // 小数部分  \n        double g = val1 - j;  \n        List<Integer> subIndex = new ArrayList<>();  \n        double calValue;  \n        // list从小到大排序  \n        List<PbrtqcWashed> subList = list.stream().skip(i).limit(N).collect(Collectors.toList());  \n        List<PbrtqcWashed> collect = subList.stream().sorted(Comparator.comparing(PbrtqcWashed::getValue)).collect(Collectors.toList());  \n        if (g == 0) {  \n            calValue = collect.get(j - 1).getValue();  \n        } else {  \n            calValue = (1 - g) * collect.get(j - 1).getValue() + g * collect.get(j).getValue();  \n        }  \n        PBRTQCLineVO vo = new PBRTQCLineVO();  \n        vo.setId(i);  \n        vo.setName(list.get(i+N-1).getReagentBatch());  \n        vo.setValue(calValue);  \n        vo.setIsCalibration(list.get(i+N-1).getIsCalibration());  \n        vo.setReadyTime(list.get(i+N-1).getReadyTime());  \n        result.add(vo);  \n    }  \n    return result;  \n}\n```\n\n\n# 4、效果图\n\n![PBRTQC](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310081549987.png)\n","slug":"PBRTQC质控功能实现","published":1,"updated":"2023-10-19T12:57:37.898Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9k000b00uj4lob2sw4","content":"<h1 id=\"1、基本概念\"><a href=\"#1、基本概念\" class=\"headerlink\" title=\"1、基本概念\"></a>1、基本概念</h1><h2 id=\"1-1、PBRTQC\"><a href=\"#1-1、PBRTQC\" class=\"headerlink\" title=\"1.1、PBRTQC\"></a>1.1、PBRTQC</h2><p>基于患者样本的实时质量控制（patient-based real-time quality control，PBRTQC）系统是一种基于统计学以及数学模型的质量控制方法，是根据患者样本检测结果，利用统计学模型建立的一套以实时监测实验室检测质量的模型或者规则，是医学检验实验室提高质量控制体系的重要发展方向，最早由Hoffmann和Waid于1965年提出</p>\n<h2 id=\"1-2、PBRTQC模型\"><a href=\"#1-2、PBRTQC模型\" class=\"headerlink\" title=\"1.2、PBRTQC模型\"></a>1.2、PBRTQC模型</h2><ol>\n<li>五个关键参数：上截断值（UTL）、下截断值（LTL）、浮动窗口大小（N）、上控制限（UCL）、下控制限（LCL）</li>\n<li>排除规则：对于偏态分布以及存在极端值的分布数据，应选择一个适宜的截断值区间，将在截断值区间外的数据进行缩尾或者去除</li>\n<li>SPC算法：浮动均值（MA）、浮动分位数（MQ）、指数加权移动平均值（EWMA）用于监测定值误差（CE）和百分比误差（PE）；浮动标准差（MovSD）、浮动非正常值患者数（MovSO）用于监测随机误差（RE）</li>\n<li>控制限：1. 分布法：通过分析历史数据生成的PBRTQC计算值，得出计算值的均值与标准差，根据正态分布或其它分布特征计算出对应的控制限<br>    2. 百分位点法：根据目标假阳性报警率（DFAR），如0.1%，考虑双边的情况下，那么控制限则为历史数据PBRTQC计算值的0.05%和99.95%百分位数点</li>\n</ol>\n<h2 id=\"1-3、模型评估指标\"><a href=\"#1-3、模型评估指标\" class=\"headerlink\" title=\"1.3、模型评估指标\"></a>1.3、模型评估指标</h2><ol>\n<li>假阳性报警率（FAR）：指误报次数与样本数的比值，文献中通常要求该值≤0.1%，即每进行1000例患者样本的实时质控，最多允许1次误报，表征模型的特异性，FAR越小，模型特异性越好</li>\n<li>误差检出前平均患者样本数（ANPed）：误差出现时至模型检测出误差所经历的患者样本例数，表征模型的灵敏度，例数越少，模型灵敏度越高</li>\n<li>二者关系：二者之间存在矛盾关系，FAR越低，ANPed越大，实际应用中应综合考虑，能满足当前项目的需求即可</li>\n</ol>\n<h1 id=\"2、实现简要流程\"><a href=\"#2、实现简要流程\" class=\"headerlink\" title=\"2、实现简要流程\"></a>2、实现简要流程</h1><ol>\n<li>数据类型位信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换</li>\n<li>根据条件查询数据集合(仪器+批号+项目+时间)</li>\n<li>定量定性项目过滤，定量项目过滤掉单位为S&#x2F;CO，定性项目液体类型为C（校准）或单位为S&#x2F;CO</li>\n<li>cut-off过滤（不包括校准点数据）</li>\n<li>根据washStatus判断是否需要排除修改前后信号值不一致的数据</li>\n<li>得到两份数据。allDataList：经过上述步骤剩余的数据。list：经过上述步骤再过滤掉校准点（液体类型C）数据</li>\n<li>list为空、list大于20000，list大小小于训练数据集样本容量n。直接返回</li>\n<li>寻找定标线。液体类型为c（校准）,连续12个点确定一个定标线（不连续的舍弃）</li>\n<li>暂存list</li>\n<li>遍历函数模型集合，一个模型出一个图</li>\n<li>暂存全量数据list</li>\n<li>计算控制线</li>\n<li>每次移动训练数据集个数个数据。计算截断限LTL和UTL（通过移动分位数mq计算）</li>\n<li>根据LTL和UTL截断sublist数据。数据被截断并且是定标点，将前一个点设置为定标点</li>\n<li>数据转换sublist，使数据更符合正态性(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)</li>\n<li>记录最优lambda，加权失控报警0.5N和2N最优lambda用N计算出的lambda</li>\n<li>计算本次控制线（LCL,UCL）</li>\n<li>判断控制线的合理性：根据控制线偏差和Moving-Slope斜率最大值，最小值判断（斜率判断最新版本已废除）</li>\n<li>满足合理性判断时，暂存N转换后的数据,用作失控报警中的加权失控计算（0.5N，2N）</li>\n<li>未找到合适控制线时，直接返回并提示用户</li>\n<li>使用计算控制线得到的LTL和UTL截断全量数据，得到list</li>\n<li>list数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)</li>\n<li>暂存转换后的数据,用作失控报警中的加权失控计算</li>\n<li>list统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)</li>\n<li>Moving-Slope计算系统误差点（最新版本废弃）</li>\n<li>失控报警：失控点计算(0-单点失控,1-连续X点失控,2-加权失控，3-加权连续失控)</li>\n<li>找到所有定标线</li>\n<li>响应封装</li>\n</ol>\n<h1 id=\"3、代码实现\"><a href=\"#3、代码实现\" class=\"headerlink\" title=\"3、代码实现\"></a>3、代码实现</h1><h2 id=\"3-1、基本流程框架\"><a href=\"#3-1、基本流程框架\" class=\"headerlink\" title=\"3.1、基本流程框架\"></a>3.1、基本流程框架</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> AjaxResult <span class=\"title function_\">pbrtqcLineData</span><span class=\"params\">(PbrtqcDTO dto)</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">PBRTQCResultVO</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PBRTQCResultVO</span>();  </span><br><span class=\"line\">    <span class=\"comment\">// 请求转换  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dto.getDataType() == <span class=\"number\">1</span>) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 数据类型位信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换  </span></span><br><span class=\"line\">        dto.setFuncModel(<span class=\"number\">1</span>);  </span><br><span class=\"line\">        dto.setMqQuantile(<span class=\"number\">50.0</span>);  </span><br><span class=\"line\">        dto.setTransType(<span class=\"literal\">null</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 根据条件查询数据集合(仪器+批号+项目+时间)  </span></span><br><span class=\"line\">    List&lt;PbrtqcWashed&gt; allDataList = iPbrtqcWashedService.selectLineData(dto);  </span><br><span class=\"line\">    <span class=\"comment\">// 定量项目&amp;定性项目过滤  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dto.getProjectType() == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; !<span class=\"string\">&quot;S/CO&quot;</span>.equals(item.getUnit())).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; <span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType()) || <span class=\"string\">&quot;S/CO&quot;</span>.equals(item.getUnit())).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// cut-off过滤(不包括校准点数据)  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> == dto.getCutOffCondition())&#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; <span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType()) ||  item.getValue() &lt; dto.getCutOffValue()).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">2</span> == dto.getCutOffCondition())&#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; <span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType()) ||  BigDecimal.valueOf(item.getValue()).compareTo(BigDecimal.valueOf(dto.getCutOffValue())) &gt;= <span class=\"number\">0</span>).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 不包含液体类型为C的数据 根据washStatus判断是否需要排除修改前后信号值不一致的数据，排除时不对C（校准点）排除  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dto.getWashStatus() == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; <span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType()) || item.getModifiedSignal().equals(item.getOriginalSignal())).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    List&lt;PbrtqcWashed&gt; list = allDataList.stream().filter(item -&gt; !<span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType())).collect(Collectors.toList());  </span><br><span class=\"line\">    <span class=\"comment\">// 数据为空  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(list)) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> AjaxResult.error(<span class=\"string\">&quot;查询数据为空&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 数据量过大不进行计算  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list.size() &gt; <span class=\"number\">20000</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> AjaxResult.error(<span class=\"string\">&quot;数据量过大（超过20000条），请调整查询条件&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 训练数据集样本大于集合数量，调整数量  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dto.getN() &gt; list.size()) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> AjaxResult.error(<span class=\"string\">&quot;总数据量为：&quot;</span> + list.size() + <span class=\"string\">&quot;,小于训练数据集样本N，请调整N大小!&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 寻找定标线  </span></span><br><span class=\"line\">    List&lt;CalibrationPoint&gt; calibrationDetailList = findCalibrationLine(allDataList); <span class=\"comment\">// 定标点集合  </span></span><br><span class=\"line\">    <span class=\"comment\">// 暂存全量数据list  </span></span><br><span class=\"line\">    List&lt;PbrtqcWashed&gt; tempList = saveDataList(list);  </span><br><span class=\"line\">    <span class=\"comment\">// 单位记录  </span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">unit</span> <span class=\"operator\">=</span> list.get(<span class=\"number\">0</span>).getUnit();  </span><br><span class=\"line\">    List&lt;PBRTQCData&gt; pbrtqcDataList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">    List&lt;Integer&gt; funcModels = Arrays.stream(dto.getFuncModels().split(<span class=\"string\">&quot;,&quot;</span>)).map(Integer::parseInt).collect(Collectors.toList());  </span><br><span class=\"line\">    <span class=\"comment\">// 把movsd放到集合最后一个元素  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt; funcModels.size(); i++)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (funcModels.get(i) == <span class=\"number\">3</span>)&#123;  </span><br><span class=\"line\">            funcModels.remove(i);  </span><br><span class=\"line\">            funcModels.add(<span class=\"number\">3</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 序号  </span></span><br><span class=\"line\">    dto.setIndex(<span class=\"number\">0</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer funcModel : funcModels) &#123;  </span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; modelDataList = saveDataList(list);  </span><br><span class=\"line\">        <span class=\"comment\">// 函数模型  </span></span><br><span class=\"line\">        dto.setFuncModel(funcModel);  </span><br><span class=\"line\">        <span class=\"comment\">// 控制限偏差设置  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (funcModel == <span class=\"number\">3</span>) &#123;  </span><br><span class=\"line\">            dto.setLimitQuantile(dto.getSdLimitQuantile());  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            dto.setLimitQuantile(dto.getMqLimitQuantile());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 计算N控制限  </span></span><br><span class=\"line\">        <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLine</span> <span class=\"operator\">=</span> calculateControlLine(dto, tempList, <span class=\"number\">1</span>, <span class=\"number\">0</span>, dto.getIndex());  </span><br><span class=\"line\">        <span class=\"comment\">// 控制限判断  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((dto.getIndex() ==  <span class=\"number\">0</span> &amp;&amp; controlLine.getUcl() == <span class=\"literal\">null</span>) || (dto.getIndex() &gt; <span class=\"number\">0</span> &amp;&amp; dto.getFindControlLine() == <span class=\"literal\">null</span>))&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> AjaxResult.error(<span class=\"string\">&quot;未找到合适的控制线,请设置合理的控制限偏差&quot;</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; cutDataList = modelDataList;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dto.getCutType() != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// LTL（下截断限值）和UTL（上截断限值）  </span></span><br><span class=\"line\">            <span class=\"type\">QuantileData</span> <span class=\"variable\">quantileData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QuantileData</span>(dto.getLtl(),dto.getUtl());  </span><br><span class=\"line\">            <span class=\"comment\">// 根据截断方式截断数据  </span></span><br><span class=\"line\">            cutDataList = cutData(dto, quantileData, modelDataList);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  </span></span><br><span class=\"line\">        dataTrans(dto, cutDataList, <span class=\"number\">0</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// 暂存转换后的数据,用作失控报警中的加权失控计算  </span></span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; transData = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dto.getAlarmMode() == <span class=\"number\">2</span> || dto.getAlarmMode() == <span class=\"number\">3</span>)&#123;  </span><br><span class=\"line\">            transData = saveDataList(cutDataList);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; dataList = funcModelCalculate(dto, cutDataList,<span class=\"number\">1</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// Moving-Slope计算系统误差失控点  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; systemErrorDataList = systemErrorPoint(dto, dataList);  </span><br><span class=\"line\">        <span class=\"comment\">// 失控报警  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; alarmDataList = outOfControlAlarm(dto, tempList, dataList, controlLine, transData);  </span><br><span class=\"line\">        <span class=\"comment\">// 批号计算  </span></span><br><span class=\"line\">        List&lt;String&gt; lots = dataList.stream().map(PBRTQCLineVO::getName).distinct().collect(Collectors.toList());  </span><br><span class=\"line\">        lots.add(<span class=\"number\">0</span>, <span class=\"string\">&quot;失控点&quot;</span>);  </span><br><span class=\"line\">        lots.add(<span class=\"number\">1</span>, <span class=\"string\">&quot;系统误差点&quot;</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// 设置失控点  </span></span><br><span class=\"line\">        alarmDataList.forEach(item -&gt; dataList.get(item.getId()).setName(<span class=\"string\">&quot;失控点&quot;</span>));  </span><br><span class=\"line\">        <span class=\"comment\">// 找到所有的定标线  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; calibrationPointList = dataList.stream().filter(item -&gt;  </span><br><span class=\"line\">                item.getIsCalibration() != <span class=\"literal\">null</span> &amp;&amp; item.getIsCalibration().equals(<span class=\"number\">1</span>)).collect(Collectors.toList());  </span><br><span class=\"line\">        List&lt;Integer&gt; calibrationList = calibrationPointList.stream().map(PBRTQCLineVO::getId).collect(Collectors.toList());  </span><br><span class=\"line\">        <span class=\"comment\">// 寻找失控点中的所有系统误差点  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; systemErrorData = alarmDataList.stream().filter(item -&gt; systemErrorDataList.stream().anyMatch(obj -&gt; obj.getId().equals(item.getId()))).collect(Collectors.toList());  </span><br><span class=\"line\">        systemErrorData.forEach(item -&gt; dataList.get(item.getId()).setName(<span class=\"string\">&quot;系统误差点&quot;</span>));  </span><br><span class=\"line\">        <span class=\"comment\">// 响应封装  </span></span><br><span class=\"line\">        <span class=\"type\">PBRTQCData</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PBRTQCData</span>();  </span><br><span class=\"line\">        data.setList(dataList);  </span><br><span class=\"line\">        data.setLots(lots);  </span><br><span class=\"line\">        data.setUnit(unit);  </span><br><span class=\"line\">        data.setMethodName(DictUtils.getDictLabel(<span class=\"string\">&quot;ims_pbrtqc_func_model&quot;</span>, dto.getFuncModel().toString()));  </span><br><span class=\"line\">        data.setAlarmList(alarmDataList);  </span><br><span class=\"line\">        data.setSystemErrorList(systemErrorData);  </span><br><span class=\"line\">        data.setLcl(controlLine.getLcl());  </span><br><span class=\"line\">        data.setUcl(controlLine.getUcl());  </span><br><span class=\"line\">        data.setOriginLcl(controlLine.getOriginLcl());  </span><br><span class=\"line\">        data.setOriginUcl(controlLine.getOriginUcl());  </span><br><span class=\"line\">        data.setCalibrationList(calibrationList);  </span><br><span class=\"line\">        pbrtqcDataList.add(data);  </span><br><span class=\"line\">        dto.setIndex(dto.getIndex() + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    response.setList(pbrtqcDataList);  </span><br><span class=\"line\">    response.setLtl(dto.getLtl());  </span><br><span class=\"line\">    response.setUtl(dto.getUtl());  </span><br><span class=\"line\">    response.setCalibrationPointList(calibrationDetailList);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> AjaxResult.success(response);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-2、控制线计算流程\"><a href=\"#3-2、控制线计算流程\" class=\"headerlink\" title=\"3.2、控制线计算流程\"></a>3.2、控制线计算流程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ControlLineData <span class=\"title function_\">calculateControlLine</span><span class=\"params\">(PbrtqcDTO dto, List&lt;PbrtqcWashed&gt; list, Integer transFlag, Integer alarmFlag, Integer index)</span> &#123;  </span><br><span class=\"line\"><span class=\"comment\">//        List&lt;PbrtqcWashed&gt; list = saveDataList(originlist);  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> list.size();  </span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">offset</span> <span class=\"operator\">=</span> dto.getLimitOffset();  </span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> dto.getN();  </span><br><span class=\"line\">        <span class=\"type\">Double</span> <span class=\"variable\">limitQuantile</span> <span class=\"operator\">=</span> dto.getLimitQuantile();  </span><br><span class=\"line\">        <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLineData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ControlLineData</span>();  </span><br><span class=\"line\">        <span class=\"comment\">// 第二次计算控制线用第一次的截断转换数据  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index &gt; <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 计算控制线  </span></span><br><span class=\"line\">            <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLine</span> <span class=\"operator\">=</span>  calculateCurrentControlLine(dto.getTransDataList(), dto);  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">ucl</span> <span class=\"operator\">=</span> controlLine.getUcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">lcl</span> <span class=\"operator\">=</span> controlLine.getLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originLcl</span> <span class=\"operator\">=</span> controlLine.getOriginLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originUcl</span> <span class=\"operator\">=</span> controlLine.getOriginUcl();  </span><br><span class=\"line\">            <span class=\"comment\">// 新增控制线判断条件Moving-Slope  </span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">msFlag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getMinSlope() != <span class=\"literal\">null</span> &amp;&amp; dto.getMaxSlope() != <span class=\"literal\">null</span>)&#123;  </span><br><span class=\"line\">                msFlag = movingSlope(dto, dto.getStatisticList2());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 判断合理性  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class=\"number\">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class=\"line\">                dto.setFindControlLine(<span class=\"number\">1</span>);  </span><br><span class=\"line\">                controlLineData.setLcl(lcl);  </span><br><span class=\"line\">                controlLineData.setUcl(ucl);  </span><br><span class=\"line\">                controlLineData.setOriginUcl(originUcl);  </span><br><span class=\"line\">                controlLineData.setOriginLcl(originLcl);  </span><br><span class=\"line\">                dto.setBestMean2(dto.getUseMean2());  </span><br><span class=\"line\">                dto.setBestSD2(dto.getUseSD2());  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size - offset; i++) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">100</span>) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  </span><br><span class=\"line\">            subList = saveDataList(subList);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subList.size() &lt; n) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"type\">QuantileData</span> <span class=\"variable\">quantileData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QuantileData</span>();  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getCutType() != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// 计算LTL（下截断限值）和UTL（上截断限值）  </span></span><br><span class=\"line\">                quantileData = calculateQuantile(subList, dto);  </span><br><span class=\"line\">                <span class=\"comment\">// 训练数据集截断后数据  </span></span><br><span class=\"line\">                subList = cutData(dto, quantileData, subList);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  </span></span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; transDatas = dataTrans(dto, subList, transFlag);  </span><br><span class=\"line\">            <span class=\"comment\">// 暂存N转换后的数据，用来计算加权失控0.5N，2N  </span></span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; tempTransDataList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getAlarmMode() == <span class=\"number\">2</span> || dto.getAlarmMode() == <span class=\"number\">3</span>) &#123;  </span><br><span class=\"line\">                tempTransDataList = saveDataList(transDatas);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 计算本次控制线  </span></span><br><span class=\"line\">            <span class=\"type\">ControlLineData</span> <span class=\"variable\">currentControlLine</span> <span class=\"operator\">=</span>  calculateCurrentControlLine(transDatas, dto);  </span><br><span class=\"line\">            <span class=\"comment\">// 计算合理性  </span></span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">ucl</span> <span class=\"operator\">=</span> currentControlLine.getUcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">lcl</span> <span class=\"operator\">=</span> currentControlLine.getLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originLcl</span> <span class=\"operator\">=</span> currentControlLine.getOriginLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originUcl</span> <span class=\"operator\">=</span> currentControlLine.getOriginUcl();  </span><br><span class=\"line\">            <span class=\"comment\">// 新增控制线判断条件Moving-Slope  </span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">msFlag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getMinSlope() != <span class=\"literal\">null</span> &amp;&amp; dto.getMaxSlope() != <span class=\"literal\">null</span>)&#123;  </span><br><span class=\"line\">                msFlag = movingSlope(dto, dto.getStatisticList());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class=\"number\">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">                    <span class=\"comment\">// 记录截断限，用于第二次全量数据的截断  </span></span><br><span class=\"line\">                    dto.setLtl(quantileData.getLtl());  </span><br><span class=\"line\">                    dto.setUtl(quantileData.getUtl());  </span><br><span class=\"line\">                    <span class=\"comment\">// 记录该次转换后的数据,用于第二次统计量的计算  </span></span><br><span class=\"line\">                    dto.setTransDataList(transDatas);  </span><br><span class=\"line\">                    dto.setBestMean(dto.getUseMean());  </span><br><span class=\"line\">                    dto.setBestSD(dto.getUseSD());  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                controlLineData.setLcl(lcl);  </span><br><span class=\"line\">                controlLineData.setUcl(ucl);  </span><br><span class=\"line\">                controlLineData.setOriginUcl(originUcl);  </span><br><span class=\"line\">                controlLineData.setOriginLcl(originLcl);  </span><br><span class=\"line\">                <span class=\"comment\">// N转换后的数据，用于加权失控计算  </span></span><br><span class=\"line\">                dto.setTransDataN(tempTransDataList);  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-3、数据转换box-cox转换\"><a href=\"#3-3、数据转换box-cox转换\" class=\"headerlink\" title=\"3.3、数据转换box-cox转换\"></a>3.3、数据转换box-cox转换</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ControlLineData <span class=\"title function_\">calculateControlLine</span><span class=\"params\">(PbrtqcDTO dto, List&lt;PbrtqcWashed&gt; list, Integer transFlag, Integer alarmFlag, Integer index)</span> &#123;  </span><br><span class=\"line\"><span class=\"comment\">//        List&lt;PbrtqcWashed&gt; list = saveDataList(originlist);  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> list.size();  </span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">offset</span> <span class=\"operator\">=</span> dto.getLimitOffset();  </span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> dto.getN();  </span><br><span class=\"line\">        <span class=\"type\">Double</span> <span class=\"variable\">limitQuantile</span> <span class=\"operator\">=</span> dto.getLimitQuantile();  </span><br><span class=\"line\">        <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLineData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ControlLineData</span>();  </span><br><span class=\"line\">        <span class=\"comment\">// 第二次计算控制线用第一次的截断转换数据  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index &gt; <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 计算控制线  </span></span><br><span class=\"line\">            <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLine</span> <span class=\"operator\">=</span>  calculateCurrentControlLine(dto.getTransDataList(), dto);  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">ucl</span> <span class=\"operator\">=</span> controlLine.getUcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">lcl</span> <span class=\"operator\">=</span> controlLine.getLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originLcl</span> <span class=\"operator\">=</span> controlLine.getOriginLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originUcl</span> <span class=\"operator\">=</span> controlLine.getOriginUcl();  </span><br><span class=\"line\">            <span class=\"comment\">// 新增控制线判断条件Moving-Slope  </span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">msFlag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getMinSlope() != <span class=\"literal\">null</span> &amp;&amp; dto.getMaxSlope() != <span class=\"literal\">null</span>)&#123;  </span><br><span class=\"line\">                msFlag = movingSlope(dto, dto.getStatisticList2());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 判断合理性  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class=\"number\">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class=\"line\">                dto.setFindControlLine(<span class=\"number\">1</span>);  </span><br><span class=\"line\">                controlLineData.setLcl(lcl);  </span><br><span class=\"line\">                controlLineData.setUcl(ucl);  </span><br><span class=\"line\">                controlLineData.setOriginUcl(originUcl);  </span><br><span class=\"line\">                controlLineData.setOriginLcl(originLcl);  </span><br><span class=\"line\">                dto.setBestMean2(dto.getUseMean2());  </span><br><span class=\"line\">                dto.setBestSD2(dto.getUseSD2());  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size - offset; i++) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">100</span>) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  </span><br><span class=\"line\">            subList = saveDataList(subList);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subList.size() &lt; n) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"type\">QuantileData</span> <span class=\"variable\">quantileData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QuantileData</span>();  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getCutType() != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// 计算LTL（下截断限值）和UTL（上截断限值）  </span></span><br><span class=\"line\">                quantileData = calculateQuantile(subList, dto);  </span><br><span class=\"line\">                <span class=\"comment\">// 训练数据集截断后数据  </span></span><br><span class=\"line\">                subList = cutData(dto, quantileData, subList);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  </span></span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; transDatas = dataTrans(dto, subList, transFlag);  </span><br><span class=\"line\">            <span class=\"comment\">// 暂存N转换后的数据，用来计算加权失控0.5N，2N  </span></span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; tempTransDataList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getAlarmMode() == <span class=\"number\">2</span> || dto.getAlarmMode() == <span class=\"number\">3</span>) &#123;  </span><br><span class=\"line\">                tempTransDataList = saveDataList(transDatas);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 计算本次控制线  </span></span><br><span class=\"line\">            <span class=\"type\">ControlLineData</span> <span class=\"variable\">currentControlLine</span> <span class=\"operator\">=</span>  calculateCurrentControlLine(transDatas, dto);  </span><br><span class=\"line\">            <span class=\"comment\">// 计算合理性  </span></span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">ucl</span> <span class=\"operator\">=</span> currentControlLine.getUcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">lcl</span> <span class=\"operator\">=</span> currentControlLine.getLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originLcl</span> <span class=\"operator\">=</span> currentControlLine.getOriginLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originUcl</span> <span class=\"operator\">=</span> currentControlLine.getOriginUcl();  </span><br><span class=\"line\">            <span class=\"comment\">// 新增控制线判断条件Moving-Slope  </span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">msFlag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getMinSlope() != <span class=\"literal\">null</span> &amp;&amp; dto.getMaxSlope() != <span class=\"literal\">null</span>)&#123;  </span><br><span class=\"line\">                msFlag = movingSlope(dto, dto.getStatisticList());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class=\"number\">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">                    <span class=\"comment\">// 记录截断限，用于第二次全量数据的截断  </span></span><br><span class=\"line\">                    dto.setLtl(quantileData.getLtl());  </span><br><span class=\"line\">                    dto.setUtl(quantileData.getUtl());  </span><br><span class=\"line\">                    <span class=\"comment\">// 记录该次转换后的数据,用于第二次统计量的计算  </span></span><br><span class=\"line\">                    dto.setTransDataList(transDatas);  </span><br><span class=\"line\">                    dto.setBestMean(dto.getUseMean());  </span><br><span class=\"line\">                    dto.setBestSD(dto.getUseSD());  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                controlLineData.setLcl(lcl);  </span><br><span class=\"line\">                controlLineData.setUcl(ucl);  </span><br><span class=\"line\">                controlLineData.setOriginUcl(originUcl);  </span><br><span class=\"line\">                controlLineData.setOriginLcl(originLcl);  </span><br><span class=\"line\">                <span class=\"comment\">// N转换后的数据，用于加权失控计算  </span></span><br><span class=\"line\">                dto.setTransDataN(tempTransDataList);  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 计算最优的lambda值  </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> data 数据  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 最优的lambda值  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">double</span> <span class=\"title function_\">findBestLambda</span><span class=\"params\">(<span class=\"type\">double</span>[] data)</span> &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 定义lambda的范围和步长  </span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">lambdaStart</span> <span class=\"operator\">=</span> -<span class=\"number\">5.0</span>;  </span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">lambdaEnd</span> <span class=\"operator\">=</span> <span class=\"number\">5.0</span>;  </span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">lambdaStep</span> <span class=\"operator\">=</span> <span class=\"number\">0.01</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 计算原始数据的几何均值G  </span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">G</span> <span class=\"operator\">=</span> <span class=\"number\">1.0</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">double</span> x : data) &#123;  </span><br><span class=\"line\">        G *= Math.pow(x, <span class=\"number\">1.0</span> / data.length);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 计算最优lambda  </span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">minSD</span> <span class=\"operator\">=</span> Double.MAX_VALUE;  </span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">minLambda</span> <span class=\"operator\">=</span> -<span class=\"number\">5</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">double</span> <span class=\"variable\">lambda</span> <span class=\"operator\">=</span> lambdaStart; lambda &lt;= lambdaEnd; lambda += lambdaStep) &#123;  </span><br><span class=\"line\">        <span class=\"type\">double</span>[] transformedData = boxCoxTransform(data, lambda, G);  </span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">avg</span> <span class=\"operator\">=</span> calculateAverage(transformedData);  </span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">sd</span> <span class=\"operator\">=</span> calculateStandardDeviation(transformedData, avg);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sd &lt; minSD) &#123;  </span><br><span class=\"line\">            minSD = sd;  </span><br><span class=\"line\">            minLambda = lambda;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> minLambda;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 计算Box-Cox变换后的数据  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> data   数据  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> lambda lambda值  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> Box-Cox变换后的数据  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">double</span>[] boxCoxTransform(<span class=\"type\">double</span>[] data, <span class=\"type\">double</span> lambda, <span class=\"type\">double</span> G) &#123;  </span><br><span class=\"line\">    <span class=\"type\">double</span>[] transformedData = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[data.length];  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lambda == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;  </span><br><span class=\"line\">            transformedData[i] = G * Math.log(data[i]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;  </span><br><span class=\"line\">            transformedData[i] = (Math.pow(data[i], lambda) - <span class=\"number\">1</span>) / (lambda * Math.pow(G, lambda - <span class=\"number\">1</span>));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformedData;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4、统计值计算之mq\"><a href=\"#3-4、统计值计算之mq\" class=\"headerlink\" title=\"3.4、统计值计算之mq\"></a>3.4、统计值计算之mq</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 移动分位数（MQ）  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> N 窗口大小  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> X mq分位数  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> list  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;PBRTQCLineVO&gt; <span class=\"title function_\">MQ</span><span class=\"params\">(Integer N, Double X, List&lt;PbrtqcWashed&gt; list)</span> &#123;  </span><br><span class=\"line\">    List&lt;PBRTQCLineVO&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; list.size() -N + <span class=\"number\">1</span>; i++) &#123;  </span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">val1</span> <span class=\"operator\">=</span> (N + <span class=\"number\">1</span>) * X / <span class=\"number\">100</span>;  </span><br><span class=\"line\">        <span class=\"comment\">// 整数部分  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) val1;  </span><br><span class=\"line\">        <span class=\"comment\">// 小数部分  </span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">g</span> <span class=\"operator\">=</span> val1 - j;  </span><br><span class=\"line\">        List&lt;Integer&gt; subIndex = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">        <span class=\"type\">double</span> calValue;  </span><br><span class=\"line\">        <span class=\"comment\">// list从小到大排序  </span></span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; subList = list.stream().skip(i).limit(N).collect(Collectors.toList());  </span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; collect = subList.stream().sorted(Comparator.comparing(PbrtqcWashed::getValue)).collect(Collectors.toList());  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">            calValue = collect.get(j - <span class=\"number\">1</span>).getValue();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            calValue = (<span class=\"number\">1</span> - g) * collect.get(j - <span class=\"number\">1</span>).getValue() + g * collect.get(j).getValue();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"type\">PBRTQCLineVO</span> <span class=\"variable\">vo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PBRTQCLineVO</span>();  </span><br><span class=\"line\">        vo.setId(i);  </span><br><span class=\"line\">        vo.setName(list.get(i+N-<span class=\"number\">1</span>).getReagentBatch());  </span><br><span class=\"line\">        vo.setValue(calValue);  </span><br><span class=\"line\">        vo.setIsCalibration(list.get(i+N-<span class=\"number\">1</span>).getIsCalibration());  </span><br><span class=\"line\">        vo.setReadyTime(list.get(i+N-<span class=\"number\">1</span>).getReadyTime());  </span><br><span class=\"line\">        result.add(vo);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"4、效果图\"><a href=\"#4、效果图\" class=\"headerlink\" title=\"4、效果图\"></a>4、效果图</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310081549987.png\" alt=\"PBRTQC\"></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、基本概念\"><a href=\"#1、基本概念\" class=\"headerlink\" title=\"1、基本概念\"></a>1、基本概念</h1><h2 id=\"1-1、PBRTQC\"><a href=\"#1-1、PBRTQC\" class=\"headerlink\" title=\"1.1、PBRTQC\"></a>1.1、PBRTQC</h2><p>基于患者样本的实时质量控制（patient-based real-time quality control，PBRTQC）系统是一种基于统计学以及数学模型的质量控制方法，是根据患者样本检测结果，利用统计学模型建立的一套以实时监测实验室检测质量的模型或者规则，是医学检验实验室提高质量控制体系的重要发展方向，最早由Hoffmann和Waid于1965年提出</p>\n<h2 id=\"1-2、PBRTQC模型\"><a href=\"#1-2、PBRTQC模型\" class=\"headerlink\" title=\"1.2、PBRTQC模型\"></a>1.2、PBRTQC模型</h2><ol>\n<li>五个关键参数：上截断值（UTL）、下截断值（LTL）、浮动窗口大小（N）、上控制限（UCL）、下控制限（LCL）</li>\n<li>排除规则：对于偏态分布以及存在极端值的分布数据，应选择一个适宜的截断值区间，将在截断值区间外的数据进行缩尾或者去除</li>\n<li>SPC算法：浮动均值（MA）、浮动分位数（MQ）、指数加权移动平均值（EWMA）用于监测定值误差（CE）和百分比误差（PE）；浮动标准差（MovSD）、浮动非正常值患者数（MovSO）用于监测随机误差（RE）</li>\n<li>控制限：1. 分布法：通过分析历史数据生成的PBRTQC计算值，得出计算值的均值与标准差，根据正态分布或其它分布特征计算出对应的控制限<br>    2. 百分位点法：根据目标假阳性报警率（DFAR），如0.1%，考虑双边的情况下，那么控制限则为历史数据PBRTQC计算值的0.05%和99.95%百分位数点</li>\n</ol>\n<h2 id=\"1-3、模型评估指标\"><a href=\"#1-3、模型评估指标\" class=\"headerlink\" title=\"1.3、模型评估指标\"></a>1.3、模型评估指标</h2><ol>\n<li>假阳性报警率（FAR）：指误报次数与样本数的比值，文献中通常要求该值≤0.1%，即每进行1000例患者样本的实时质控，最多允许1次误报，表征模型的特异性，FAR越小，模型特异性越好</li>\n<li>误差检出前平均患者样本数（ANPed）：误差出现时至模型检测出误差所经历的患者样本例数，表征模型的灵敏度，例数越少，模型灵敏度越高</li>\n<li>二者关系：二者之间存在矛盾关系，FAR越低，ANPed越大，实际应用中应综合考虑，能满足当前项目的需求即可</li>\n</ol>\n<h1 id=\"2、实现简要流程\"><a href=\"#2、实现简要流程\" class=\"headerlink\" title=\"2、实现简要流程\"></a>2、实现简要流程</h1><ol>\n<li>数据类型位信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换</li>\n<li>根据条件查询数据集合(仪器+批号+项目+时间)</li>\n<li>定量定性项目过滤，定量项目过滤掉单位为S&#x2F;CO，定性项目液体类型为C（校准）或单位为S&#x2F;CO</li>\n<li>cut-off过滤（不包括校准点数据）</li>\n<li>根据washStatus判断是否需要排除修改前后信号值不一致的数据</li>\n<li>得到两份数据。allDataList：经过上述步骤剩余的数据。list：经过上述步骤再过滤掉校准点（液体类型C）数据</li>\n<li>list为空、list大于20000，list大小小于训练数据集样本容量n。直接返回</li>\n<li>寻找定标线。液体类型为c（校准）,连续12个点确定一个定标线（不连续的舍弃）</li>\n<li>暂存list</li>\n<li>遍历函数模型集合，一个模型出一个图</li>\n<li>暂存全量数据list</li>\n<li>计算控制线</li>\n<li>每次移动训练数据集个数个数据。计算截断限LTL和UTL（通过移动分位数mq计算）</li>\n<li>根据LTL和UTL截断sublist数据。数据被截断并且是定标点，将前一个点设置为定标点</li>\n<li>数据转换sublist，使数据更符合正态性(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)</li>\n<li>记录最优lambda，加权失控报警0.5N和2N最优lambda用N计算出的lambda</li>\n<li>计算本次控制线（LCL,UCL）</li>\n<li>判断控制线的合理性：根据控制线偏差和Moving-Slope斜率最大值，最小值判断（斜率判断最新版本已废除）</li>\n<li>满足合理性判断时，暂存N转换后的数据,用作失控报警中的加权失控计算（0.5N，2N）</li>\n<li>未找到合适控制线时，直接返回并提示用户</li>\n<li>使用计算控制线得到的LTL和UTL截断全量数据，得到list</li>\n<li>list数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)</li>\n<li>暂存转换后的数据,用作失控报警中的加权失控计算</li>\n<li>list统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)</li>\n<li>Moving-Slope计算系统误差点（最新版本废弃）</li>\n<li>失控报警：失控点计算(0-单点失控,1-连续X点失控,2-加权失控，3-加权连续失控)</li>\n<li>找到所有定标线</li>\n<li>响应封装</li>\n</ol>\n<h1 id=\"3、代码实现\"><a href=\"#3、代码实现\" class=\"headerlink\" title=\"3、代码实现\"></a>3、代码实现</h1><h2 id=\"3-1、基本流程框架\"><a href=\"#3-1、基本流程框架\" class=\"headerlink\" title=\"3.1、基本流程框架\"></a>3.1、基本流程框架</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> AjaxResult <span class=\"title function_\">pbrtqcLineData</span><span class=\"params\">(PbrtqcDTO dto)</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">PBRTQCResultVO</span> <span class=\"variable\">response</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PBRTQCResultVO</span>();  </span><br><span class=\"line\">    <span class=\"comment\">// 请求转换  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dto.getDataType() == <span class=\"number\">1</span>) &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 数据类型位信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换  </span></span><br><span class=\"line\">        dto.setFuncModel(<span class=\"number\">1</span>);  </span><br><span class=\"line\">        dto.setMqQuantile(<span class=\"number\">50.0</span>);  </span><br><span class=\"line\">        dto.setTransType(<span class=\"literal\">null</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 根据条件查询数据集合(仪器+批号+项目+时间)  </span></span><br><span class=\"line\">    List&lt;PbrtqcWashed&gt; allDataList = iPbrtqcWashedService.selectLineData(dto);  </span><br><span class=\"line\">    <span class=\"comment\">// 定量项目&amp;定性项目过滤  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dto.getProjectType() == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; !<span class=\"string\">&quot;S/CO&quot;</span>.equals(item.getUnit())).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; <span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType()) || <span class=\"string\">&quot;S/CO&quot;</span>.equals(item.getUnit())).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// cut-off过滤(不包括校准点数据)  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"number\">1</span> == dto.getCutOffCondition())&#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; <span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType()) ||  item.getValue() &lt; dto.getCutOffValue()).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"number\">2</span> == dto.getCutOffCondition())&#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; <span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType()) ||  BigDecimal.valueOf(item.getValue()).compareTo(BigDecimal.valueOf(dto.getCutOffValue())) &gt;= <span class=\"number\">0</span>).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 不包含液体类型为C的数据 根据washStatus判断是否需要排除修改前后信号值不一致的数据，排除时不对C（校准点）排除  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dto.getWashStatus() == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">        allDataList = allDataList.stream().filter(item -&gt; <span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType()) || item.getModifiedSignal().equals(item.getOriginalSignal())).collect(Collectors.toList());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    List&lt;PbrtqcWashed&gt; list = allDataList.stream().filter(item -&gt; !<span class=\"string\">&quot;C&quot;</span>.equals(item.getLiquidType())).collect(Collectors.toList());  </span><br><span class=\"line\">    <span class=\"comment\">// 数据为空  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (CollectionUtils.isEmpty(list)) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> AjaxResult.error(<span class=\"string\">&quot;查询数据为空&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 数据量过大不进行计算  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (list.size() &gt; <span class=\"number\">20000</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> AjaxResult.error(<span class=\"string\">&quot;数据量过大（超过20000条），请调整查询条件&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 训练数据集样本大于集合数量，调整数量  </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dto.getN() &gt; list.size()) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> AjaxResult.error(<span class=\"string\">&quot;总数据量为：&quot;</span> + list.size() + <span class=\"string\">&quot;,小于训练数据集样本N，请调整N大小!&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 寻找定标线  </span></span><br><span class=\"line\">    List&lt;CalibrationPoint&gt; calibrationDetailList = findCalibrationLine(allDataList); <span class=\"comment\">// 定标点集合  </span></span><br><span class=\"line\">    <span class=\"comment\">// 暂存全量数据list  </span></span><br><span class=\"line\">    List&lt;PbrtqcWashed&gt; tempList = saveDataList(list);  </span><br><span class=\"line\">    <span class=\"comment\">// 单位记录  </span></span><br><span class=\"line\">    <span class=\"type\">String</span> <span class=\"variable\">unit</span> <span class=\"operator\">=</span> list.get(<span class=\"number\">0</span>).getUnit();  </span><br><span class=\"line\">    List&lt;PBRTQCData&gt; pbrtqcDataList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">    List&lt;Integer&gt; funcModels = Arrays.stream(dto.getFuncModels().split(<span class=\"string\">&quot;,&quot;</span>)).map(Integer::parseInt).collect(Collectors.toList());  </span><br><span class=\"line\">    <span class=\"comment\">// 把movsd放到集合最后一个元素  </span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt; funcModels.size(); i++)&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (funcModels.get(i) == <span class=\"number\">3</span>)&#123;  </span><br><span class=\"line\">            funcModels.remove(i);  </span><br><span class=\"line\">            funcModels.add(<span class=\"number\">3</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"comment\">// 序号  </span></span><br><span class=\"line\">    dto.setIndex(<span class=\"number\">0</span>);  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Integer funcModel : funcModels) &#123;  </span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; modelDataList = saveDataList(list);  </span><br><span class=\"line\">        <span class=\"comment\">// 函数模型  </span></span><br><span class=\"line\">        dto.setFuncModel(funcModel);  </span><br><span class=\"line\">        <span class=\"comment\">// 控制限偏差设置  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (funcModel == <span class=\"number\">3</span>) &#123;  </span><br><span class=\"line\">            dto.setLimitQuantile(dto.getSdLimitQuantile());  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            dto.setLimitQuantile(dto.getMqLimitQuantile());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 计算N控制限  </span></span><br><span class=\"line\">        <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLine</span> <span class=\"operator\">=</span> calculateControlLine(dto, tempList, <span class=\"number\">1</span>, <span class=\"number\">0</span>, dto.getIndex());  </span><br><span class=\"line\">        <span class=\"comment\">// 控制限判断  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((dto.getIndex() ==  <span class=\"number\">0</span> &amp;&amp; controlLine.getUcl() == <span class=\"literal\">null</span>) || (dto.getIndex() &gt; <span class=\"number\">0</span> &amp;&amp; dto.getFindControlLine() == <span class=\"literal\">null</span>))&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> AjaxResult.error(<span class=\"string\">&quot;未找到合适的控制线,请设置合理的控制限偏差&quot;</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; cutDataList = modelDataList;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dto.getCutType() != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// LTL（下截断限值）和UTL（上截断限值）  </span></span><br><span class=\"line\">            <span class=\"type\">QuantileData</span> <span class=\"variable\">quantileData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QuantileData</span>(dto.getLtl(),dto.getUtl());  </span><br><span class=\"line\">            <span class=\"comment\">// 根据截断方式截断数据  </span></span><br><span class=\"line\">            cutDataList = cutData(dto, quantileData, modelDataList);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  </span></span><br><span class=\"line\">        dataTrans(dto, cutDataList, <span class=\"number\">0</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// 暂存转换后的数据,用作失控报警中的加权失控计算  </span></span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; transData = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dto.getAlarmMode() == <span class=\"number\">2</span> || dto.getAlarmMode() == <span class=\"number\">3</span>)&#123;  </span><br><span class=\"line\">            transData = saveDataList(cutDataList);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; dataList = funcModelCalculate(dto, cutDataList,<span class=\"number\">1</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// Moving-Slope计算系统误差失控点  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; systemErrorDataList = systemErrorPoint(dto, dataList);  </span><br><span class=\"line\">        <span class=\"comment\">// 失控报警  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; alarmDataList = outOfControlAlarm(dto, tempList, dataList, controlLine, transData);  </span><br><span class=\"line\">        <span class=\"comment\">// 批号计算  </span></span><br><span class=\"line\">        List&lt;String&gt; lots = dataList.stream().map(PBRTQCLineVO::getName).distinct().collect(Collectors.toList());  </span><br><span class=\"line\">        lots.add(<span class=\"number\">0</span>, <span class=\"string\">&quot;失控点&quot;</span>);  </span><br><span class=\"line\">        lots.add(<span class=\"number\">1</span>, <span class=\"string\">&quot;系统误差点&quot;</span>);  </span><br><span class=\"line\">        <span class=\"comment\">// 设置失控点  </span></span><br><span class=\"line\">        alarmDataList.forEach(item -&gt; dataList.get(item.getId()).setName(<span class=\"string\">&quot;失控点&quot;</span>));  </span><br><span class=\"line\">        <span class=\"comment\">// 找到所有的定标线  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; calibrationPointList = dataList.stream().filter(item -&gt;  </span><br><span class=\"line\">                item.getIsCalibration() != <span class=\"literal\">null</span> &amp;&amp; item.getIsCalibration().equals(<span class=\"number\">1</span>)).collect(Collectors.toList());  </span><br><span class=\"line\">        List&lt;Integer&gt; calibrationList = calibrationPointList.stream().map(PBRTQCLineVO::getId).collect(Collectors.toList());  </span><br><span class=\"line\">        <span class=\"comment\">// 寻找失控点中的所有系统误差点  </span></span><br><span class=\"line\">        List&lt;PBRTQCLineVO&gt; systemErrorData = alarmDataList.stream().filter(item -&gt; systemErrorDataList.stream().anyMatch(obj -&gt; obj.getId().equals(item.getId()))).collect(Collectors.toList());  </span><br><span class=\"line\">        systemErrorData.forEach(item -&gt; dataList.get(item.getId()).setName(<span class=\"string\">&quot;系统误差点&quot;</span>));  </span><br><span class=\"line\">        <span class=\"comment\">// 响应封装  </span></span><br><span class=\"line\">        <span class=\"type\">PBRTQCData</span> <span class=\"variable\">data</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PBRTQCData</span>();  </span><br><span class=\"line\">        data.setList(dataList);  </span><br><span class=\"line\">        data.setLots(lots);  </span><br><span class=\"line\">        data.setUnit(unit);  </span><br><span class=\"line\">        data.setMethodName(DictUtils.getDictLabel(<span class=\"string\">&quot;ims_pbrtqc_func_model&quot;</span>, dto.getFuncModel().toString()));  </span><br><span class=\"line\">        data.setAlarmList(alarmDataList);  </span><br><span class=\"line\">        data.setSystemErrorList(systemErrorData);  </span><br><span class=\"line\">        data.setLcl(controlLine.getLcl());  </span><br><span class=\"line\">        data.setUcl(controlLine.getUcl());  </span><br><span class=\"line\">        data.setOriginLcl(controlLine.getOriginLcl());  </span><br><span class=\"line\">        data.setOriginUcl(controlLine.getOriginUcl());  </span><br><span class=\"line\">        data.setCalibrationList(calibrationList);  </span><br><span class=\"line\">        pbrtqcDataList.add(data);  </span><br><span class=\"line\">        dto.setIndex(dto.getIndex() + <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    response.setList(pbrtqcDataList);  </span><br><span class=\"line\">    response.setLtl(dto.getLtl());  </span><br><span class=\"line\">    response.setUtl(dto.getUtl());  </span><br><span class=\"line\">    response.setCalibrationPointList(calibrationDetailList);  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> AjaxResult.success(response);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-2、控制线计算流程\"><a href=\"#3-2、控制线计算流程\" class=\"headerlink\" title=\"3.2、控制线计算流程\"></a>3.2、控制线计算流程</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ControlLineData <span class=\"title function_\">calculateControlLine</span><span class=\"params\">(PbrtqcDTO dto, List&lt;PbrtqcWashed&gt; list, Integer transFlag, Integer alarmFlag, Integer index)</span> &#123;  </span><br><span class=\"line\"><span class=\"comment\">//        List&lt;PbrtqcWashed&gt; list = saveDataList(originlist);  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> list.size();  </span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">offset</span> <span class=\"operator\">=</span> dto.getLimitOffset();  </span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> dto.getN();  </span><br><span class=\"line\">        <span class=\"type\">Double</span> <span class=\"variable\">limitQuantile</span> <span class=\"operator\">=</span> dto.getLimitQuantile();  </span><br><span class=\"line\">        <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLineData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ControlLineData</span>();  </span><br><span class=\"line\">        <span class=\"comment\">// 第二次计算控制线用第一次的截断转换数据  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index &gt; <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 计算控制线  </span></span><br><span class=\"line\">            <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLine</span> <span class=\"operator\">=</span>  calculateCurrentControlLine(dto.getTransDataList(), dto);  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">ucl</span> <span class=\"operator\">=</span> controlLine.getUcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">lcl</span> <span class=\"operator\">=</span> controlLine.getLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originLcl</span> <span class=\"operator\">=</span> controlLine.getOriginLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originUcl</span> <span class=\"operator\">=</span> controlLine.getOriginUcl();  </span><br><span class=\"line\">            <span class=\"comment\">// 新增控制线判断条件Moving-Slope  </span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">msFlag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getMinSlope() != <span class=\"literal\">null</span> &amp;&amp; dto.getMaxSlope() != <span class=\"literal\">null</span>)&#123;  </span><br><span class=\"line\">                msFlag = movingSlope(dto, dto.getStatisticList2());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 判断合理性  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class=\"number\">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class=\"line\">                dto.setFindControlLine(<span class=\"number\">1</span>);  </span><br><span class=\"line\">                controlLineData.setLcl(lcl);  </span><br><span class=\"line\">                controlLineData.setUcl(ucl);  </span><br><span class=\"line\">                controlLineData.setOriginUcl(originUcl);  </span><br><span class=\"line\">                controlLineData.setOriginLcl(originLcl);  </span><br><span class=\"line\">                dto.setBestMean2(dto.getUseMean2());  </span><br><span class=\"line\">                dto.setBestSD2(dto.getUseSD2());  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size - offset; i++) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">100</span>) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  </span><br><span class=\"line\">            subList = saveDataList(subList);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subList.size() &lt; n) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"type\">QuantileData</span> <span class=\"variable\">quantileData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QuantileData</span>();  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getCutType() != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// 计算LTL（下截断限值）和UTL（上截断限值）  </span></span><br><span class=\"line\">                quantileData = calculateQuantile(subList, dto);  </span><br><span class=\"line\">                <span class=\"comment\">// 训练数据集截断后数据  </span></span><br><span class=\"line\">                subList = cutData(dto, quantileData, subList);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  </span></span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; transDatas = dataTrans(dto, subList, transFlag);  </span><br><span class=\"line\">            <span class=\"comment\">// 暂存N转换后的数据，用来计算加权失控0.5N，2N  </span></span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; tempTransDataList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getAlarmMode() == <span class=\"number\">2</span> || dto.getAlarmMode() == <span class=\"number\">3</span>) &#123;  </span><br><span class=\"line\">                tempTransDataList = saveDataList(transDatas);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 计算本次控制线  </span></span><br><span class=\"line\">            <span class=\"type\">ControlLineData</span> <span class=\"variable\">currentControlLine</span> <span class=\"operator\">=</span>  calculateCurrentControlLine(transDatas, dto);  </span><br><span class=\"line\">            <span class=\"comment\">// 计算合理性  </span></span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">ucl</span> <span class=\"operator\">=</span> currentControlLine.getUcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">lcl</span> <span class=\"operator\">=</span> currentControlLine.getLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originLcl</span> <span class=\"operator\">=</span> currentControlLine.getOriginLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originUcl</span> <span class=\"operator\">=</span> currentControlLine.getOriginUcl();  </span><br><span class=\"line\">            <span class=\"comment\">// 新增控制线判断条件Moving-Slope  </span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">msFlag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getMinSlope() != <span class=\"literal\">null</span> &amp;&amp; dto.getMaxSlope() != <span class=\"literal\">null</span>)&#123;  </span><br><span class=\"line\">                msFlag = movingSlope(dto, dto.getStatisticList());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class=\"number\">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">                    <span class=\"comment\">// 记录截断限，用于第二次全量数据的截断  </span></span><br><span class=\"line\">                    dto.setLtl(quantileData.getLtl());  </span><br><span class=\"line\">                    dto.setUtl(quantileData.getUtl());  </span><br><span class=\"line\">                    <span class=\"comment\">// 记录该次转换后的数据,用于第二次统计量的计算  </span></span><br><span class=\"line\">                    dto.setTransDataList(transDatas);  </span><br><span class=\"line\">                    dto.setBestMean(dto.getUseMean());  </span><br><span class=\"line\">                    dto.setBestSD(dto.getUseSD());  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                controlLineData.setLcl(lcl);  </span><br><span class=\"line\">                controlLineData.setUcl(ucl);  </span><br><span class=\"line\">                controlLineData.setOriginUcl(originUcl);  </span><br><span class=\"line\">                controlLineData.setOriginLcl(originLcl);  </span><br><span class=\"line\">                <span class=\"comment\">// N转换后的数据，用于加权失控计算  </span></span><br><span class=\"line\">                dto.setTransDataN(tempTransDataList);  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"3-3、数据转换box-cox转换\"><a href=\"#3-3、数据转换box-cox转换\" class=\"headerlink\" title=\"3.3、数据转换box-cox转换\"></a>3.3、数据转换box-cox转换</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> ControlLineData <span class=\"title function_\">calculateControlLine</span><span class=\"params\">(PbrtqcDTO dto, List&lt;PbrtqcWashed&gt; list, Integer transFlag, Integer alarmFlag, Integer index)</span> &#123;  </span><br><span class=\"line\"><span class=\"comment\">//        List&lt;PbrtqcWashed&gt; list = saveDataList(originlist);  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">size</span> <span class=\"operator\">=</span> list.size();  </span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">offset</span> <span class=\"operator\">=</span> dto.getLimitOffset();  </span><br><span class=\"line\">        <span class=\"type\">Integer</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> dto.getN();  </span><br><span class=\"line\">        <span class=\"type\">Double</span> <span class=\"variable\">limitQuantile</span> <span class=\"operator\">=</span> dto.getLimitQuantile();  </span><br><span class=\"line\">        <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLineData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ControlLineData</span>();  </span><br><span class=\"line\">        <span class=\"comment\">// 第二次计算控制线用第一次的截断转换数据  </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(index &gt; <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 计算控制线  </span></span><br><span class=\"line\">            <span class=\"type\">ControlLineData</span> <span class=\"variable\">controlLine</span> <span class=\"operator\">=</span>  calculateCurrentControlLine(dto.getTransDataList(), dto);  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">ucl</span> <span class=\"operator\">=</span> controlLine.getUcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">lcl</span> <span class=\"operator\">=</span> controlLine.getLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originLcl</span> <span class=\"operator\">=</span> controlLine.getOriginLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originUcl</span> <span class=\"operator\">=</span> controlLine.getOriginUcl();  </span><br><span class=\"line\">            <span class=\"comment\">// 新增控制线判断条件Moving-Slope  </span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">msFlag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getMinSlope() != <span class=\"literal\">null</span> &amp;&amp; dto.getMaxSlope() != <span class=\"literal\">null</span>)&#123;  </span><br><span class=\"line\">                msFlag = movingSlope(dto, dto.getStatisticList2());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 判断合理性  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class=\"number\">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class=\"line\">                dto.setFindControlLine(<span class=\"number\">1</span>);  </span><br><span class=\"line\">                controlLineData.setLcl(lcl);  </span><br><span class=\"line\">                controlLineData.setUcl(ucl);  </span><br><span class=\"line\">                controlLineData.setOriginUcl(originUcl);  </span><br><span class=\"line\">                controlLineData.setOriginLcl(originLcl);  </span><br><span class=\"line\">                dto.setBestMean2(dto.getUseMean2());  </span><br><span class=\"line\">                dto.setBestSD2(dto.getUseSD2());  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; size - offset; i++) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  </span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">100</span>) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  </span><br><span class=\"line\">            subList = saveDataList(subList);  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (subList.size() &lt; n) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"type\">QuantileData</span> <span class=\"variable\">quantileData</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">QuantileData</span>();  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getCutType() != <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">                <span class=\"comment\">// 计算LTL（下截断限值）和UTL（上截断限值）  </span></span><br><span class=\"line\">                quantileData = calculateQuantile(subList, dto);  </span><br><span class=\"line\">                <span class=\"comment\">// 训练数据集截断后数据  </span></span><br><span class=\"line\">                subList = cutData(dto, quantileData, subList);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  </span></span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; transDatas = dataTrans(dto, subList, transFlag);  </span><br><span class=\"line\">            <span class=\"comment\">// 暂存N转换后的数据，用来计算加权失控0.5N，2N  </span></span><br><span class=\"line\">            List&lt;PbrtqcWashed&gt; tempTransDataList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getAlarmMode() == <span class=\"number\">2</span> || dto.getAlarmMode() == <span class=\"number\">3</span>) &#123;  </span><br><span class=\"line\">                tempTransDataList = saveDataList(transDatas);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// 计算本次控制线  </span></span><br><span class=\"line\">            <span class=\"type\">ControlLineData</span> <span class=\"variable\">currentControlLine</span> <span class=\"operator\">=</span>  calculateCurrentControlLine(transDatas, dto);  </span><br><span class=\"line\">            <span class=\"comment\">// 计算合理性  </span></span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">ucl</span> <span class=\"operator\">=</span> currentControlLine.getUcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">lcl</span> <span class=\"operator\">=</span> currentControlLine.getLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originLcl</span> <span class=\"operator\">=</span> currentControlLine.getOriginLcl();  </span><br><span class=\"line\">            <span class=\"type\">Double</span> <span class=\"variable\">originUcl</span> <span class=\"operator\">=</span> currentControlLine.getOriginUcl();  </span><br><span class=\"line\">            <span class=\"comment\">// 新增控制线判断条件Moving-Slope  </span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">msFlag</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dto.getMinSlope() != <span class=\"literal\">null</span> &amp;&amp; dto.getMaxSlope() != <span class=\"literal\">null</span>)&#123;  </span><br><span class=\"line\">                msFlag = movingSlope(dto, dto.getStatisticList());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class=\"number\">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (index == <span class=\"number\">0</span>)&#123;  </span><br><span class=\"line\">                    <span class=\"comment\">// 记录截断限，用于第二次全量数据的截断  </span></span><br><span class=\"line\">                    dto.setLtl(quantileData.getLtl());  </span><br><span class=\"line\">                    dto.setUtl(quantileData.getUtl());  </span><br><span class=\"line\">                    <span class=\"comment\">// 记录该次转换后的数据,用于第二次统计量的计算  </span></span><br><span class=\"line\">                    dto.setTransDataList(transDatas);  </span><br><span class=\"line\">                    dto.setBestMean(dto.getUseMean());  </span><br><span class=\"line\">                    dto.setBestSD(dto.getUseSD());  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">                controlLineData.setLcl(lcl);  </span><br><span class=\"line\">                controlLineData.setUcl(ucl);  </span><br><span class=\"line\">                controlLineData.setOriginUcl(originUcl);  </span><br><span class=\"line\">                controlLineData.setOriginLcl(originLcl);  </span><br><span class=\"line\">                <span class=\"comment\">// N转换后的数据，用于加权失控计算  </span></span><br><span class=\"line\">                dto.setTransDataN(tempTransDataList);  </span><br><span class=\"line\">                <span class=\"keyword\">break</span>;            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> controlLineData;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 计算最优的lambda值  </span></span><br><span class=\"line\"><span class=\"comment\"> *  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> data 数据  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> 最优的lambda值  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">double</span> <span class=\"title function_\">findBestLambda</span><span class=\"params\">(<span class=\"type\">double</span>[] data)</span> &#123;  </span><br><span class=\"line\">    <span class=\"comment\">// 定义lambda的范围和步长  </span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">lambdaStart</span> <span class=\"operator\">=</span> -<span class=\"number\">5.0</span>;  </span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">lambdaEnd</span> <span class=\"operator\">=</span> <span class=\"number\">5.0</span>;  </span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">lambdaStep</span> <span class=\"operator\">=</span> <span class=\"number\">0.01</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 计算原始数据的几何均值G  </span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">G</span> <span class=\"operator\">=</span> <span class=\"number\">1.0</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">double</span> x : data) &#123;  </span><br><span class=\"line\">        G *= Math.pow(x, <span class=\"number\">1.0</span> / data.length);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">// 计算最优lambda  </span></span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">minSD</span> <span class=\"operator\">=</span> Double.MAX_VALUE;  </span><br><span class=\"line\">    <span class=\"type\">double</span> <span class=\"variable\">minLambda</span> <span class=\"operator\">=</span> -<span class=\"number\">5</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">double</span> <span class=\"variable\">lambda</span> <span class=\"operator\">=</span> lambdaStart; lambda &lt;= lambdaEnd; lambda += lambdaStep) &#123;  </span><br><span class=\"line\">        <span class=\"type\">double</span>[] transformedData = boxCoxTransform(data, lambda, G);  </span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">avg</span> <span class=\"operator\">=</span> calculateAverage(transformedData);  </span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">sd</span> <span class=\"operator\">=</span> calculateStandardDeviation(transformedData, avg);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (sd &lt; minSD) &#123;  </span><br><span class=\"line\">            minSD = sd;  </span><br><span class=\"line\">            minLambda = lambda;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> minLambda;  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 计算Box-Cox变换后的数据  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> data   数据  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> lambda lambda值  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> Box-Cox变换后的数据  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"type\">double</span>[] boxCoxTransform(<span class=\"type\">double</span>[] data, <span class=\"type\">double</span> lambda, <span class=\"type\">double</span> G) &#123;  </span><br><span class=\"line\">    <span class=\"type\">double</span>[] transformedData = <span class=\"keyword\">new</span> <span class=\"title class_\">double</span>[data.length];  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lambda == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;  </span><br><span class=\"line\">            transformedData[i] = G * Math.log(data[i]);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; data.length; i++) &#123;  </span><br><span class=\"line\">            transformedData[i] = (Math.pow(data[i], lambda) - <span class=\"number\">1</span>) / (lambda * Math.pow(G, lambda - <span class=\"number\">1</span>));  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> transformedData;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4、统计值计算之mq\"><a href=\"#3-4、统计值计算之mq\" class=\"headerlink\" title=\"3.4、统计值计算之mq\"></a>3.4、统计值计算之mq</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\"> * 移动分位数（MQ）  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> N 窗口大小  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> X mq分位数  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> list  </span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span>  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> List&lt;PBRTQCLineVO&gt; <span class=\"title function_\">MQ</span><span class=\"params\">(Integer N, Double X, List&lt;PbrtqcWashed&gt; list)</span> &#123;  </span><br><span class=\"line\">    List&lt;PBRTQCLineVO&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; list.size() -N + <span class=\"number\">1</span>; i++) &#123;  </span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">val1</span> <span class=\"operator\">=</span> (N + <span class=\"number\">1</span>) * X / <span class=\"number\">100</span>;  </span><br><span class=\"line\">        <span class=\"comment\">// 整数部分  </span></span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">j</span> <span class=\"operator\">=</span> (<span class=\"type\">int</span>) val1;  </span><br><span class=\"line\">        <span class=\"comment\">// 小数部分  </span></span><br><span class=\"line\">        <span class=\"type\">double</span> <span class=\"variable\">g</span> <span class=\"operator\">=</span> val1 - j;  </span><br><span class=\"line\">        List&lt;Integer&gt; subIndex = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">        <span class=\"type\">double</span> calValue;  </span><br><span class=\"line\">        <span class=\"comment\">// list从小到大排序  </span></span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; subList = list.stream().skip(i).limit(N).collect(Collectors.toList());  </span><br><span class=\"line\">        List&lt;PbrtqcWashed&gt; collect = subList.stream().sorted(Comparator.comparing(PbrtqcWashed::getValue)).collect(Collectors.toList());  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (g == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">            calValue = collect.get(j - <span class=\"number\">1</span>).getValue();  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">            calValue = (<span class=\"number\">1</span> - g) * collect.get(j - <span class=\"number\">1</span>).getValue() + g * collect.get(j).getValue();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"type\">PBRTQCLineVO</span> <span class=\"variable\">vo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">PBRTQCLineVO</span>();  </span><br><span class=\"line\">        vo.setId(i);  </span><br><span class=\"line\">        vo.setName(list.get(i+N-<span class=\"number\">1</span>).getReagentBatch());  </span><br><span class=\"line\">        vo.setValue(calValue);  </span><br><span class=\"line\">        vo.setIsCalibration(list.get(i+N-<span class=\"number\">1</span>).getIsCalibration());  </span><br><span class=\"line\">        vo.setReadyTime(list.get(i+N-<span class=\"number\">1</span>).getReadyTime());  </span><br><span class=\"line\">        result.add(vo);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"4、效果图\"><a href=\"#4、效果图\" class=\"headerlink\" title=\"4、效果图\"></a>4、效果图</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310081549987.png\" alt=\"PBRTQC\"></p>\n"},{"title":"jvm","date":"2023-10-21T16:00:00.000Z","abbrlink":37319,"_content":"# 1、jvm概念\n## 1.1、定义\nJava Virtual Machine，JAVA程序的**运行环境**（JAVA二进制字节码的运行环境）\n\n## 1.2、好处\n\n- 跨平台，一次编写，到处运行\n- 自动内存管理，垃圾回收机制\n- 数组下标越界检查\n\n## 1.3、jvm jre jdk的区别\n\n\n# 2、内存结构\n\n![jvm内存结构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222232072.jpg)\n\n\n注意：常量池，运行时常量池，字符串常量池逻辑上属于方法区，只是存储的物理位置在堆（所以他们属于方法区）\n## 2.1、程序计数器\n### 2.1.1、作用\n当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令\n### 2.1.2、特点\n\n1. 为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，独立存储，互不影响。所以，程序计数器是**线程私有**的内存区域\n2. Java虚拟机规范中**唯一一个没有规定任何OutOfMemoryError情况的区域**\n\n\n## 2.2、虚拟机栈\n### 2.2.1、定义\n每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈是线程私有的，它的生命周期与线程相同\n\n> 局部变量表：存放方法参数和方法内部定义的局部变量\n  操作数栈：操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区\n  动态链接：将这些符号引用转换为调用方法的直接引用\n\n### 2.2.2、问题辨析\n\n1. 垃圾回收是否涉及栈内存？\n   - **不需要**。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。\n2. 栈内存的分配越大越好吗？\n   - 不是。因为**物理内存是一定的**，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。\n\n\n### 2.2.4、线程运行诊断（CPU占用过高）\n\n1. 查询占用cpu过高程序pid（top）\n2. 查询该进程下各线程的CPU占用情况  （ ps H -eo pid,tid,%cpu|grep 27598）\n\n![image (17).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235151.png)\n\n\n3. 找到cpu占用最高的线程id，转为16进制\n\n![image (18).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235572.png)\n\n\n4. 打印堆栈 （jstack pid）\n\njstack 27598 | grep -A 100 6bdf\n\n![image (19).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222236269.png)\n\n\n## 2.3、本地方法栈\n\n一些带有**native关键字**的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法\n## 2.4、堆\n### 2.4.1、定义\nJava堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存（特例：栈上分配策略）\n\n> 1. 从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代。新生代又可分为Eden和Suvivor区\n> 2. 新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2  通过参数 –XX:NewRatio 来指定\n> 3. 最大物理内存大小不超过192兆字节（MB）时默认最大堆大小是物理内存的一半，否则占用物理内存的四分之一\n\n![image (20).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222237526.png)\n\n### 2.4.4、堆内存诊断\njps：查看java进程\njmap：查看堆内存占用情况 jmap -heap 进程id\njconsole：图形界面，检测堆栈，CPU占用，类加载情况等（可以连续监测）\njvisualvm：和jconsole功能类似，但功能更强。可以抓取和导入堆dump快照\n\n## 2.6、内存泄漏\n\n1. **什么是内存泄露**\n\n内存泄露：内存空间使用完毕之后未回收\n\n2. **内存泄露的原因？**\n\n（1）static字段引起的内存泄露\n大量使用static字段会潜在的导致内存泄露，在Java中，静态字段通常拥有与整个应用程序相匹配的生命周期。\n解决办法：最大限度的减少静态变量的使用；单例模式时，依赖于延迟加载对象而不是立即加载方式\n\n（2）未关闭的资源导致内存泄露\n每当创建连接或者打开流时，JVM都会为这些资源分配内存。如果没有关闭连接，会导致持续占有内存。在任意情况下，资源留下的开放连接都会消耗内存，如果我们不处理，就会降低性能，甚至OOM。\n解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；jdk1.7后，可以使用try-with-resource块\n\n## 2.5、方法区\n### 2.5.1、结构\n方法区是java虚拟机的一个模型规范，具体实现是永久代和元空间。方法区存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等\n方法区在程序启动时被创建，方法区是一个概念。具体实现有永久代（1.8前）和元空间（1.8）永久代用的是堆内存，元空间用的是本地内存（也就是操作系统的内存）\n\n> 方法区如果内存不足，也会抛出**OutofMemoryError** 的异常\n\n\n### 2.5.2、class常量池\nJava 文件被编译成 Class 文件，Class 文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是 Class 常量池，**Class 常量池是当 Class 文件被 Java 虚拟机加载进来后存放各种字面量和符号引用**\n\n> 类的加载过程中的链接部分的解析步骤就是把符号引用替换为直接引用，即把那些描述符（名字）替换为能直接定位到字段、方法的引用或句柄（地址）\n\n![image (21).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222238635.png)\n\nSystem.out.println(\"hello\")经过反编译后的内容如下：\n```java\njavap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.class\n```\n\n![class常量池](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222239362.png)\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2996398/1658211741107-6e92db9f-e7b1-4fe3-9b54-0f608dad19b6.png#clientId=u2849290d-6927-4&from=paste&id=u0f35b784&originHeight=410&originWidth=1118&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3e3cb8ec-7f59-44f8-b925-f1bce7b280b&title=)\n![](https://cdn.nlark.com/yuque/0/2022/png/2996398/1658211750067-5a5fe357-17ac-4ed5-8463-862b32649804.png#clientId=u2849290d-6927-4&from=paste&id=u52353eda&originHeight=236&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue01b07e2-503e-45f1-b6a7-3479b81cc26&title=)\n\n虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）\n\n### 2.5.3、运行时常量池\n\n运行时常量池是方法区的一部分。运行时常量池是当 Class 文件被加载到内存后，Java虚拟机会将 Class 文件常量池里的内容转移到运行时常量池里，**并且把里面的符号地址变为真实地址**\n\n### 2.5.4、字符串常量池\n\nJVM为了提高性能，减少内存开销，维护的一个存放字符串常量的内存区域，里面的字符串不允许重复，有长度限制，最大为65535字节\n\n1. **两种创建字符串对象不同方式的比较**\n\n（1）采用字面值的方式创建字符串对象\n```java\npublic class Str {\n    public static void main(String[] args) {\n        String str1=\"aaa\";\n        String str2=\"aaa\";\n        System.out.println(str1==str2);   \n    }\n}\n// 运行结果：\n// true\n```\n\n> 采用字面值的方式创建一个字符串时，JVM 首先会去字符串池中查找是否存在 \"aaa\" 这个对象，如果不存在，则在字符串池中创建 \"aaa\" 这个对象，然后将池中 \"aaa\" 这个对象的引用地址返回给字符串常量 str，这样 str 会指向池中\"aaa\"这个字符串对象；如果存在，则不创建任何对象，直接将池中 \"aaa\" 这个对象的地址返回，赋给字符串常量。\n\n> 对于上述的例子：这是因为，创建字符串对象 str2 时，字符串池中已经存在 “aaa” 这个对象，直接把对象 “aaa” 的引用地址返回给 str2，这样 str2 指向了池中 “aaa” 这个对象，也就是说 str1 和 str2 指向了同一个对象，因此语句 System.out.println(str1== str2) 输出：true。\n\n\n2）采用 new 关键字新建一个字符串对象\n```java\npublic class Str {\n    public static void main(String[] args) {\n        String str1=new String(\"aaa\");\n        String str2=new String(\"aaa\");\n        System.out.println(str1==str2);\n    }\n}\n// 运行结果：\n// false\n```\n\n\n> 采用 new 关键字新建一个字符串对象时，JVM 首先在字符串常量池中查找有没有 \"aaa\" 这个字符串对象，如果有，则不在池中再去创建 \"aaa\" 这个对象了，直接在堆中创建一个 \"aaa\" 字符串对象，然后将堆中的这个\"aaa\"对象的地址返回赋给引用 str1，这样，str1 就指向了堆中创建的这个 \"aaa\" 字符串对象；如果没有，则首先在字符串常量池池中创建一个 \"aaa\" 字符串对象，然后再在堆中创建一个 \"aaa\" 字符串对象，然后将堆中这个 \"aaa\" 字符串对象的地址返回赋给 str1 引用，这样，str1 指向了堆中创建的这个 \"aaa\" 字符串对象。\n\n> 对于上述的例子：因为，采用new关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str1和str2指向的是两个不同的对象，因此语句System.out.println(str1 == str2)输出：false\n\n- 使用**拼接字符串常量**的方法来创建新的字符串时，因为**内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab**，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。\n- 使用**拼接字符串变量**的方法来创建新的字符串时，因为内容是变量，只能**在运行期确定它的值，所以需要使用StringBuilder来创建**\n\n\n\n\n2. **字符串拼接问题**\n\n（1）字符串变量拼接\n\n```java\npublic class StringTableStudy {\n\tpublic static void main(String[] args) {\n\t\tString a = \"a\";\n\t\tString b = \"b\";\n\t\tString ab = \"ab\";\n\t\t//拼接字符串对象来创建新的字符串\n\t\tString ab2 = a+b; \n        System.out.println(ab == ab2);  //false\n\t}\n}\n```\n\n\n> 通过变量拼接的方式来创建字符串的**过程**是：StringBuilder().append(“a”).append(“b”).toString()\n> 最后的toString方法的返回值是一个**新的字符串**，但字符串的**值**和拼接的字符串一致，但是两个不同的字符串，**一个存在于串池之中，一个存在于堆内存之中**\n\n（2）字符串拼接\n\n```java\npublic class StringTableStudy {\n\tpublic static void main(String[] args) {\n\t\tString a = \"a\";\n\t\tString b = \"b\";\n\t\tString ab = \"ab\";\n\t\t//拼接字符串对象来创建新的字符串\n\t\tString ab2 = \"a\"+\"b\"; \n        System.out.println(ab == ab2);  //true\n\t}\n}\n```\n\n\n> 使用**拼接字符串常量**的方法来创建新的字符串时，因为**内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab**，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接引用串池中的地址，所以进行的操作和 ab = “ab” 一致。\n\n\n3. i**ntern方法**\n\njdk1.8调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中，如果有则不会放入\n\n> jdk1.6调用字符串对象的intern方法，会将该字符串对象复制一份放入到串池中，如果有则不会放入\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t//\"a\" \"b\" 被放入串池中，str则存在于堆内存之中\n\t\tString str = new String(\"a\") + new String(\"b\");\n\t\t//调用str的intern方法，这时串池中没有\"ab\"，则会将串池引用指向堆，此时堆内存与串池中的\"ab\"是同一个对象\n\t\tString st2 = str.intern();\n\t\t//给str3赋值，因为此时串池中已有\"ab\"，则直接将串池中的内容返回\n\t\tString str3 = \"ab\";\n\t\t//因为堆内存与串池中的\"ab\"是同一个对象，所以以下两条语句打印的都为true\n        // 注意：上面的结果是在1.8下，在1.6下都为false（字符串常量池和堆不是一个对象）\n\t\tSystem.out.println(str == st2);\n\t\tSystem.out.println(str == str3);\n\t}\n}\n```\n\n4. 思考\n\n（1）String str = new String(“abc”);创建了几个对象，常量池有abc字段是1个，常量池没有\"abc\"字段则是2个。\n（2）String str=“abc”;创建了几个对象（如果常量池里面已经有对象了就是0个。如果没有就是1个）;\n（3）new String(“abc”).intern();创建了几个对象（如果常量池里面已经有该字符串对象了就是1个，如果没有就是两个）\n（4）string a = \"a\"+”b“创建几个对象？0个或1个。因为编译器优化，不会创建\"a\"或\"b\".\n# 3、垃圾回收算法\n## 3.1、如何判断一个对象可以被回收\n\n1. 引用计数法\n\n每个对象关联一个引用计数器属性，任何一个对象引用了A，引用计数器的值加1.当引用失效时，引用计数器就减1.当引用计数器的值为0时，表示对象不再被使用，可进行回收\n\n> 缺点：（1）需要单独的字段存储计数器，这样增加了存储空间的开销 （2）每次赋值都要更新计数器值，增加了时间开销 （3）存在循环引用的问题（所以jvm不用）\n\n\n2. 可达性分析法\n\n设立若干根对象（GC Root Object），当任何一个根对象到某一个对象均不可达时，认为这个对象可以被回收\n\n> 哪些对象可以被作为根对象？\n> - 虚拟机栈(栈帧中的本地变量表)中引用的对象。就是在方法中new的对象\n> - 方法区中静态属性引用的对象用static修饰的全局的静态的对象\n> - 方法区中常量引用的对象static final关键字\n> - 本地方法栈中(Native方法)引用的对象引用Native方法的所有对象\n> \n为什么这些对象可以作为根对象？\n> GC Root 需要确保引用所指的对象都是活着的,而当前线程栈帧中的对象，在这一时刻是存活的。\n\n## 3.2、五种引用\n\n![五种引用](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222241216.png)\n\n\n1. **强引用**：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它\n\n> 在java程序中，一般由Object object = new Object();定义的object就是一个强引用\n> 如上图B、C对象都不引用A1对象时，A1对象才会被回收\n\n2. **软引用**：当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象\n\n> 如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收\n> 作用：软引用是用来描述一些有用但并不是必需的对象，JVM 内存空间充足的时候将数据缓存在内存中，如果空间不足了就将其回收掉\n\n```java\n\n    String str = new String(\"456\");\n    SoftReference<String> softReference = new SoftReference<String>(str);\n\n```\n\n3. **弱引用**：有弱引用引用该对象时，在垃圾回收时，**无论内存是否充足**，都会回收弱引用所引用的对象\n\n> 如上图如果B对象不再引用A3对象，则A3对象会被回收\n\n```java\neakReference<String> sr = new WeakReference<String>(new String(\"hello\"));\n```\n\n4. **虚引用**：  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列\n\n当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。你声明虚引用的时候是要传入一个queue的。当你的虚引用所引用的对象已经执行完finalize函数的时候，就会把对象加到queue里面。你可以通过判断queue里面是不是有对象来判断你的对象是不是要被回收了\n\n> 如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存\n\n```java\nPhantomReference<String> abcWeakRef = new PhantomReference<String>(abc, referenceQueue);\n```\n\n5. **引用强度**\n\n强引用>软引用>弱引用>虚引用\n\n## 3.3、垃圾回收算法\n### 3.3.1、标记清除算法\n\n1. 概念：通过根节点，标记所有根节点开始的可达对象，清除未被标记对象\n2. 优点：算法简单\n3. 缺点：（1）产生内存碎片，造成新来的大对象（如数组）可能没有有效的内存空间\n\n### 3.3.2、标记整理算法（老年代默认）\n\n1. 概念：将标记的对象移动到内存的一端，清除边界外的所有空间\n2. 优点：解决了标记清除算法的碎片问题\n3. 缺点：效率低（整理后依赖这个对象的对象更新一下引用地址信息）\n\n### 3.3.3、复制算法（新生代默认）\n\n1. 概念：将内存分为一块较大的Eden和两块较小的survivor，每次使用Eden和其中一块survivo,gc时将Eden存活对象复制到suvivorTo,suvivorFrom存活的对象没有达到分代年龄阈值时复制到suvivorTo，达到分带年龄阈值复制到老年区，之后清除Eden和suvivorFrom的对象,交换两个suvivor的角色,后面以此类推\n2. 优点：（1）不会产生内存碎片（2）在存活对象不多的情况下，效率较高，适合新生代\n3. 缺点：浪费内存空间，始终要有一个空闲的survivor\n\n## 3.4、FULL GC原因\n\n> Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，元空间等。是说在这次GC的全过程中所有用户线程都是处于暂停的状态（stop the world）\n\n\n1. **System.gc()方法的调用**\n\n在代码中调用System.gc()方法会建议JVM进行Full GC，但是注意这只是建议，JVM执行不执行是另外一回事儿，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。\n\n2. **老年代空间不足**\n\n旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space\n\n# 4、垃圾回收器\n## 4.1、新生代垃圾收集器\n### 4.1.1、Serial（串行）收集器\n\n1. **概念**：Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程\n\n> 优点：简单高效，拥有很高的单线程收集效率\n  缺点：收集过程需要暂停所有线程\n  算法：复制算法应用\n\n2. **收集过程**\n\n![image (23).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242409.png)\n\n\n### 4.1.2、ParNew 收集器\n\n1. **概念：**可以把这个收集器理解为Serial收集器的多线程版本\n\n> 优点：在多CPU时，比Serial效率高。\n  缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。\n  算法：复制算法\n\n\n![image (24).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242011.png)\n\n\n### 4.1.3、Parallel Scavenge 收集器\n\n1. **概念**：Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的吞吐量 。\n2. **可设置参数**：-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间， -XX:GC Time Ratio直接设置吞吐量的大小\n\n> 吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间)\n  比如虚拟机总共运行了120秒，垃圾收集时间用了1秒，吞吐量=(120-1)/120=99.167%。\n  若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。\n\n\n## 4.2、老年代收集器\n\n\n### 4.2.1、serial old\nSerial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用\"标记-整理算法\"，运行过程和Serial收集器一样。\n\n### 4.2.2、Parallel old\nParallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和\"标记-整理算法\"进行垃圾回收，吞吐量优先。\n**回收算法**：标记-整理\n**适用场景**：为了替代serial old与Parallel Scanvenge配合使用。\n\n### 4.2.3、CMS\n\n1. **特点：**最短回收停顿时间，\n2. **回收算法：**标记-清除\n3. **回收步骤：**\n   （1）初始标记：标记GC Roots直接关联的对象，速度快\n   （2）并发标记：GC Roots Tracing过程，耗时长，与用户进程并发工作\n   （3）重新标记：修正并发标记期间用户进程运行而产生变化的标记，好事比初始标记长，但是远远小于并发标记\n   （4）并发清除：清除标记的对象\n1. **缺点**：\n\n对CPU资源非常敏感，CPU少于4个时，CMS岁用户程序的影响可能变得很大，由此虚拟机提供了“增量式并发收集器”；无法回收浮动垃圾；采用标记清除算法会产生内存碎片，不过可以通过参数开启内存碎片的合并整理。\n\n![image (25).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222243378.png)\n\n\n## 4.3、整堆收集器\n### 4.3.1、G1\n\n1. **基本概念**\n\nG1将整个JVM堆划分成多个大小相等的独立区域regin，跟踪各个regin里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收最大的regin，当然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离了，他们都是一部分regin集合。内存“化整为零”的思路：在GC根节点的枚举范围汇总加入remembered set 即可保证不对全堆扫面也不会遗漏。\n\n2. **回收步骤**：\n   （1）初始标记：标记GC Roots直接关联的对象\n   （2）并发标记：对堆中对象进行可达性分析，找出存活对象，耗时长，与用户进程并发工作\n   （3）重新标记：修正并发标记期间用户进程继续运行而产生变化的标记\n   （4）筛选回收：对各个regin的回收价值进行排序，然后根据期望的GC停顿时间制定回收计划\n\n![G1垃圾收集器](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222244637.png)\n\n\n \n### 4.3.2、ZGC\n\nZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。\n在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。\n**优点**：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小\n**缺点**：浮动垃圾\n目前使用的非常少，真正普及还是需要写时间的。\n\n## 4.4、垃圾收集器的选择？\n\njdk1.8 前默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）\njdk1.9 默认垃圾收集器G1\n\n1. 如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益\n\n```java\n参数：-XX:+UseSerialGC。\n```\n\n\n2. 如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的\n\n```java\n参数：-XX:+UseParallelGC。\n```\n\n\n3. 如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择G1、ZGC、CMS都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些\n\n```java\n参数：\n-XX:+UseConcMarkSweepGC、\n-XX:+UseG1GC、\n-XX:+UseZGC 等。\n```\n\n# 5、类加载机制\n\n虚拟机把类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的类加载机制\n\n## 5.1、类加载过程\n### 5.1.1、加载阶段\n（1）通过一个类的全限定名来获取定义此类的二进制字节流\n（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n### 5.1.2、链接阶段\n（1）**验证**： 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全\n\n> **文件格式验证**：验证字节流是否符合Class文件格式的规范，如：是否以模数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内等等。\n**元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；如：这个类是否有父类，是否实现了父类的抽象方法，是否重写了父类的final方法，是否继承了被final修饰的类等等。\n**符号引用验证**：确保解析动作能正确执行；如：通过符合引用能找到对应的类和方法，符号引用中类、属性、方法的访问性是否能被当前类访问等等\n（验证阶段是非常重要的，但不是必须的。可以采用-Xverify:none参数来关闭大部分的类验证措施）\n\n\n（2）**准备**：为类的静态变量分配内存，并将其赋默认值\n\n> 为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：\n只对**static**修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。\n对**final**的静态字面值常量直接赋初值（赋初值不是赋默认值，如果不是字面值静态常量，那么会和静态变量一样赋默认值）\n\n\n（3）**解析**：将常量池中的符号引用替换为直接引用（内存地址）的过程\n\n> 符号引用：就是一组符号来描述目标，可以是任何字面量。属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符（eg:java.lang.String）。\n  直接引用：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。如指向方法区某个类的一个指针\n\n\n### 5.1.3、初始化阶段\n为类的静态变量赋初值\n\n> 赋初值两种方式：\n（1）定义静态变量时指定初始值。如 private static String x=\"123\";\n（2）在静态代码块里为静态变量赋值。如 static{ x=\"123\"; }\n 注意：只有对类的主动使用才会导致类的初始化。\n\n\n**初始化顺序：**\n（1）静态初始化 ：父类静态成员和static块-子类静态成员和static块\n（2）父类初始化：父类普通成员和非static块-父类构造函数\n（3）子类初始化：子类普通成员和非static块-子类构造函数\n## 5.2、类加载器分类\n\n1. **启动类加载器**\n\n使用c++实现，加载jre和jre/lib目录下的核心库\n\n2. **扩展类加载器**\n\njava编写，父加载器为启动类加载器，从jre/lib/ext下加载类库\n\n3. **应用类加载器**\n\n负责加载用户类路径（classpath）上的指定类库\n## 5.3、双亲委派机制\n\n当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类\n\n**好处：**\n\n1. 避免重复加载，通过委托去向上面问一问，加载过了，就不用再加载一遍\n2. 保证核心api定义的类型不会被随意篡改，比如自己定义一个java.lang.String，顶级加载器系统类加载器加载时会加载核心包下的String类而不是自定义的。保证了核心类的安全\n\n# 6、逃逸分析\n\n我们都知道，java里面绝大多数对象都是存放在堆里面的，然后当对象没用的时候就会靠垃圾回收器去回收对象。那么什么是栈上分配呢？\n## 6.1、逃逸方式\n\n1. 方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法\n2. 线程逃逸：这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程\n\n![逃逸分析](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222246915.png)\n\n## 6.2、逃逸结果\n\n1. 栈上分配\n\n如果通过**逃逸分析**，能够确认对象不会发生逃逸行为，就会在栈上分配对象。如果在栈上分配对象的话，这个对象占用的空间就会在栈帧出栈的时候被销毁，所以，通过栈上分配可以降低垃圾回收的压力\n\n2. 标量替换　　\n\nJava虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。\n\n","source":"_posts/jvm.md","raw":"---\ntitle: jvm\ncategories:\n  - coding\ndate: 2023/10/22\ntags:\n  - 编程基础\n  - jvm\nabbrlink: 37319\n---\n# 1、jvm概念\n## 1.1、定义\nJava Virtual Machine，JAVA程序的**运行环境**（JAVA二进制字节码的运行环境）\n\n## 1.2、好处\n\n- 跨平台，一次编写，到处运行\n- 自动内存管理，垃圾回收机制\n- 数组下标越界检查\n\n## 1.3、jvm jre jdk的区别\n\n\n# 2、内存结构\n\n![jvm内存结构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222232072.jpg)\n\n\n注意：常量池，运行时常量池，字符串常量池逻辑上属于方法区，只是存储的物理位置在堆（所以他们属于方法区）\n## 2.1、程序计数器\n### 2.1.1、作用\n当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令\n### 2.1.2、特点\n\n1. 为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，独立存储，互不影响。所以，程序计数器是**线程私有**的内存区域\n2. Java虚拟机规范中**唯一一个没有规定任何OutOfMemoryError情况的区域**\n\n\n## 2.2、虚拟机栈\n### 2.2.1、定义\n每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈是线程私有的，它的生命周期与线程相同\n\n> 局部变量表：存放方法参数和方法内部定义的局部变量\n  操作数栈：操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区\n  动态链接：将这些符号引用转换为调用方法的直接引用\n\n### 2.2.2、问题辨析\n\n1. 垃圾回收是否涉及栈内存？\n   - **不需要**。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。\n2. 栈内存的分配越大越好吗？\n   - 不是。因为**物理内存是一定的**，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。\n\n\n### 2.2.4、线程运行诊断（CPU占用过高）\n\n1. 查询占用cpu过高程序pid（top）\n2. 查询该进程下各线程的CPU占用情况  （ ps H -eo pid,tid,%cpu|grep 27598）\n\n![image (17).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235151.png)\n\n\n3. 找到cpu占用最高的线程id，转为16进制\n\n![image (18).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235572.png)\n\n\n4. 打印堆栈 （jstack pid）\n\njstack 27598 | grep -A 100 6bdf\n\n![image (19).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222236269.png)\n\n\n## 2.3、本地方法栈\n\n一些带有**native关键字**的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法\n## 2.4、堆\n### 2.4.1、定义\nJava堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存（特例：栈上分配策略）\n\n> 1. 从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代。新生代又可分为Eden和Suvivor区\n> 2. 新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2  通过参数 –XX:NewRatio 来指定\n> 3. 最大物理内存大小不超过192兆字节（MB）时默认最大堆大小是物理内存的一半，否则占用物理内存的四分之一\n\n![image (20).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222237526.png)\n\n### 2.4.4、堆内存诊断\njps：查看java进程\njmap：查看堆内存占用情况 jmap -heap 进程id\njconsole：图形界面，检测堆栈，CPU占用，类加载情况等（可以连续监测）\njvisualvm：和jconsole功能类似，但功能更强。可以抓取和导入堆dump快照\n\n## 2.6、内存泄漏\n\n1. **什么是内存泄露**\n\n内存泄露：内存空间使用完毕之后未回收\n\n2. **内存泄露的原因？**\n\n（1）static字段引起的内存泄露\n大量使用static字段会潜在的导致内存泄露，在Java中，静态字段通常拥有与整个应用程序相匹配的生命周期。\n解决办法：最大限度的减少静态变量的使用；单例模式时，依赖于延迟加载对象而不是立即加载方式\n\n（2）未关闭的资源导致内存泄露\n每当创建连接或者打开流时，JVM都会为这些资源分配内存。如果没有关闭连接，会导致持续占有内存。在任意情况下，资源留下的开放连接都会消耗内存，如果我们不处理，就会降低性能，甚至OOM。\n解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；jdk1.7后，可以使用try-with-resource块\n\n## 2.5、方法区\n### 2.5.1、结构\n方法区是java虚拟机的一个模型规范，具体实现是永久代和元空间。方法区存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等\n方法区在程序启动时被创建，方法区是一个概念。具体实现有永久代（1.8前）和元空间（1.8）永久代用的是堆内存，元空间用的是本地内存（也就是操作系统的内存）\n\n> 方法区如果内存不足，也会抛出**OutofMemoryError** 的异常\n\n\n### 2.5.2、class常量池\nJava 文件被编译成 Class 文件，Class 文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是 Class 常量池，**Class 常量池是当 Class 文件被 Java 虚拟机加载进来后存放各种字面量和符号引用**\n\n> 类的加载过程中的链接部分的解析步骤就是把符号引用替换为直接引用，即把那些描述符（名字）替换为能直接定位到字段、方法的引用或句柄（地址）\n\n![image (21).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222238635.png)\n\nSystem.out.println(\"hello\")经过反编译后的内容如下：\n```java\njavap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.class\n```\n\n![class常量池](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222239362.png)\n\n![](https://cdn.nlark.com/yuque/0/2022/png/2996398/1658211741107-6e92db9f-e7b1-4fe3-9b54-0f608dad19b6.png#clientId=u2849290d-6927-4&from=paste&id=u0f35b784&originHeight=410&originWidth=1118&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3e3cb8ec-7f59-44f8-b925-f1bce7b280b&title=)\n![](https://cdn.nlark.com/yuque/0/2022/png/2996398/1658211750067-5a5fe357-17ac-4ed5-8463-862b32649804.png#clientId=u2849290d-6927-4&from=paste&id=u52353eda&originHeight=236&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue01b07e2-503e-45f1-b6a7-3479b81cc26&title=)\n\n虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）\n\n### 2.5.3、运行时常量池\n\n运行时常量池是方法区的一部分。运行时常量池是当 Class 文件被加载到内存后，Java虚拟机会将 Class 文件常量池里的内容转移到运行时常量池里，**并且把里面的符号地址变为真实地址**\n\n### 2.5.4、字符串常量池\n\nJVM为了提高性能，减少内存开销，维护的一个存放字符串常量的内存区域，里面的字符串不允许重复，有长度限制，最大为65535字节\n\n1. **两种创建字符串对象不同方式的比较**\n\n（1）采用字面值的方式创建字符串对象\n```java\npublic class Str {\n    public static void main(String[] args) {\n        String str1=\"aaa\";\n        String str2=\"aaa\";\n        System.out.println(str1==str2);   \n    }\n}\n// 运行结果：\n// true\n```\n\n> 采用字面值的方式创建一个字符串时，JVM 首先会去字符串池中查找是否存在 \"aaa\" 这个对象，如果不存在，则在字符串池中创建 \"aaa\" 这个对象，然后将池中 \"aaa\" 这个对象的引用地址返回给字符串常量 str，这样 str 会指向池中\"aaa\"这个字符串对象；如果存在，则不创建任何对象，直接将池中 \"aaa\" 这个对象的地址返回，赋给字符串常量。\n\n> 对于上述的例子：这是因为，创建字符串对象 str2 时，字符串池中已经存在 “aaa” 这个对象，直接把对象 “aaa” 的引用地址返回给 str2，这样 str2 指向了池中 “aaa” 这个对象，也就是说 str1 和 str2 指向了同一个对象，因此语句 System.out.println(str1== str2) 输出：true。\n\n\n2）采用 new 关键字新建一个字符串对象\n```java\npublic class Str {\n    public static void main(String[] args) {\n        String str1=new String(\"aaa\");\n        String str2=new String(\"aaa\");\n        System.out.println(str1==str2);\n    }\n}\n// 运行结果：\n// false\n```\n\n\n> 采用 new 关键字新建一个字符串对象时，JVM 首先在字符串常量池中查找有没有 \"aaa\" 这个字符串对象，如果有，则不在池中再去创建 \"aaa\" 这个对象了，直接在堆中创建一个 \"aaa\" 字符串对象，然后将堆中的这个\"aaa\"对象的地址返回赋给引用 str1，这样，str1 就指向了堆中创建的这个 \"aaa\" 字符串对象；如果没有，则首先在字符串常量池池中创建一个 \"aaa\" 字符串对象，然后再在堆中创建一个 \"aaa\" 字符串对象，然后将堆中这个 \"aaa\" 字符串对象的地址返回赋给 str1 引用，这样，str1 指向了堆中创建的这个 \"aaa\" 字符串对象。\n\n> 对于上述的例子：因为，采用new关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str1和str2指向的是两个不同的对象，因此语句System.out.println(str1 == str2)输出：false\n\n- 使用**拼接字符串常量**的方法来创建新的字符串时，因为**内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab**，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。\n- 使用**拼接字符串变量**的方法来创建新的字符串时，因为内容是变量，只能**在运行期确定它的值，所以需要使用StringBuilder来创建**\n\n\n\n\n2. **字符串拼接问题**\n\n（1）字符串变量拼接\n\n```java\npublic class StringTableStudy {\n\tpublic static void main(String[] args) {\n\t\tString a = \"a\";\n\t\tString b = \"b\";\n\t\tString ab = \"ab\";\n\t\t//拼接字符串对象来创建新的字符串\n\t\tString ab2 = a+b; \n        System.out.println(ab == ab2);  //false\n\t}\n}\n```\n\n\n> 通过变量拼接的方式来创建字符串的**过程**是：StringBuilder().append(“a”).append(“b”).toString()\n> 最后的toString方法的返回值是一个**新的字符串**，但字符串的**值**和拼接的字符串一致，但是两个不同的字符串，**一个存在于串池之中，一个存在于堆内存之中**\n\n（2）字符串拼接\n\n```java\npublic class StringTableStudy {\n\tpublic static void main(String[] args) {\n\t\tString a = \"a\";\n\t\tString b = \"b\";\n\t\tString ab = \"ab\";\n\t\t//拼接字符串对象来创建新的字符串\n\t\tString ab2 = \"a\"+\"b\"; \n        System.out.println(ab == ab2);  //true\n\t}\n}\n```\n\n\n> 使用**拼接字符串常量**的方法来创建新的字符串时，因为**内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab**，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接引用串池中的地址，所以进行的操作和 ab = “ab” 一致。\n\n\n3. i**ntern方法**\n\njdk1.8调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中，如果有则不会放入\n\n> jdk1.6调用字符串对象的intern方法，会将该字符串对象复制一份放入到串池中，如果有则不会放入\n\n```java\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\t//\"a\" \"b\" 被放入串池中，str则存在于堆内存之中\n\t\tString str = new String(\"a\") + new String(\"b\");\n\t\t//调用str的intern方法，这时串池中没有\"ab\"，则会将串池引用指向堆，此时堆内存与串池中的\"ab\"是同一个对象\n\t\tString st2 = str.intern();\n\t\t//给str3赋值，因为此时串池中已有\"ab\"，则直接将串池中的内容返回\n\t\tString str3 = \"ab\";\n\t\t//因为堆内存与串池中的\"ab\"是同一个对象，所以以下两条语句打印的都为true\n        // 注意：上面的结果是在1.8下，在1.6下都为false（字符串常量池和堆不是一个对象）\n\t\tSystem.out.println(str == st2);\n\t\tSystem.out.println(str == str3);\n\t}\n}\n```\n\n4. 思考\n\n（1）String str = new String(“abc”);创建了几个对象，常量池有abc字段是1个，常量池没有\"abc\"字段则是2个。\n（2）String str=“abc”;创建了几个对象（如果常量池里面已经有对象了就是0个。如果没有就是1个）;\n（3）new String(“abc”).intern();创建了几个对象（如果常量池里面已经有该字符串对象了就是1个，如果没有就是两个）\n（4）string a = \"a\"+”b“创建几个对象？0个或1个。因为编译器优化，不会创建\"a\"或\"b\".\n# 3、垃圾回收算法\n## 3.1、如何判断一个对象可以被回收\n\n1. 引用计数法\n\n每个对象关联一个引用计数器属性，任何一个对象引用了A，引用计数器的值加1.当引用失效时，引用计数器就减1.当引用计数器的值为0时，表示对象不再被使用，可进行回收\n\n> 缺点：（1）需要单独的字段存储计数器，这样增加了存储空间的开销 （2）每次赋值都要更新计数器值，增加了时间开销 （3）存在循环引用的问题（所以jvm不用）\n\n\n2. 可达性分析法\n\n设立若干根对象（GC Root Object），当任何一个根对象到某一个对象均不可达时，认为这个对象可以被回收\n\n> 哪些对象可以被作为根对象？\n> - 虚拟机栈(栈帧中的本地变量表)中引用的对象。就是在方法中new的对象\n> - 方法区中静态属性引用的对象用static修饰的全局的静态的对象\n> - 方法区中常量引用的对象static final关键字\n> - 本地方法栈中(Native方法)引用的对象引用Native方法的所有对象\n> \n为什么这些对象可以作为根对象？\n> GC Root 需要确保引用所指的对象都是活着的,而当前线程栈帧中的对象，在这一时刻是存活的。\n\n## 3.2、五种引用\n\n![五种引用](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222241216.png)\n\n\n1. **强引用**：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它\n\n> 在java程序中，一般由Object object = new Object();定义的object就是一个强引用\n> 如上图B、C对象都不引用A1对象时，A1对象才会被回收\n\n2. **软引用**：当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象\n\n> 如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收\n> 作用：软引用是用来描述一些有用但并不是必需的对象，JVM 内存空间充足的时候将数据缓存在内存中，如果空间不足了就将其回收掉\n\n```java\n\n    String str = new String(\"456\");\n    SoftReference<String> softReference = new SoftReference<String>(str);\n\n```\n\n3. **弱引用**：有弱引用引用该对象时，在垃圾回收时，**无论内存是否充足**，都会回收弱引用所引用的对象\n\n> 如上图如果B对象不再引用A3对象，则A3对象会被回收\n\n```java\neakReference<String> sr = new WeakReference<String>(new String(\"hello\"));\n```\n\n4. **虚引用**：  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列\n\n当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。你声明虚引用的时候是要传入一个queue的。当你的虚引用所引用的对象已经执行完finalize函数的时候，就会把对象加到queue里面。你可以通过判断queue里面是不是有对象来判断你的对象是不是要被回收了\n\n> 如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存\n\n```java\nPhantomReference<String> abcWeakRef = new PhantomReference<String>(abc, referenceQueue);\n```\n\n5. **引用强度**\n\n强引用>软引用>弱引用>虚引用\n\n## 3.3、垃圾回收算法\n### 3.3.1、标记清除算法\n\n1. 概念：通过根节点，标记所有根节点开始的可达对象，清除未被标记对象\n2. 优点：算法简单\n3. 缺点：（1）产生内存碎片，造成新来的大对象（如数组）可能没有有效的内存空间\n\n### 3.3.2、标记整理算法（老年代默认）\n\n1. 概念：将标记的对象移动到内存的一端，清除边界外的所有空间\n2. 优点：解决了标记清除算法的碎片问题\n3. 缺点：效率低（整理后依赖这个对象的对象更新一下引用地址信息）\n\n### 3.3.3、复制算法（新生代默认）\n\n1. 概念：将内存分为一块较大的Eden和两块较小的survivor，每次使用Eden和其中一块survivo,gc时将Eden存活对象复制到suvivorTo,suvivorFrom存活的对象没有达到分代年龄阈值时复制到suvivorTo，达到分带年龄阈值复制到老年区，之后清除Eden和suvivorFrom的对象,交换两个suvivor的角色,后面以此类推\n2. 优点：（1）不会产生内存碎片（2）在存活对象不多的情况下，效率较高，适合新生代\n3. 缺点：浪费内存空间，始终要有一个空闲的survivor\n\n## 3.4、FULL GC原因\n\n> Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，元空间等。是说在这次GC的全过程中所有用户线程都是处于暂停的状态（stop the world）\n\n\n1. **System.gc()方法的调用**\n\n在代码中调用System.gc()方法会建议JVM进行Full GC，但是注意这只是建议，JVM执行不执行是另外一回事儿，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。\n\n2. **老年代空间不足**\n\n旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space\n\n# 4、垃圾回收器\n## 4.1、新生代垃圾收集器\n### 4.1.1、Serial（串行）收集器\n\n1. **概念**：Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程\n\n> 优点：简单高效，拥有很高的单线程收集效率\n  缺点：收集过程需要暂停所有线程\n  算法：复制算法应用\n\n2. **收集过程**\n\n![image (23).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242409.png)\n\n\n### 4.1.2、ParNew 收集器\n\n1. **概念：**可以把这个收集器理解为Serial收集器的多线程版本\n\n> 优点：在多CPU时，比Serial效率高。\n  缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。\n  算法：复制算法\n\n\n![image (24).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242011.png)\n\n\n### 4.1.3、Parallel Scavenge 收集器\n\n1. **概念**：Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的吞吐量 。\n2. **可设置参数**：-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间， -XX:GC Time Ratio直接设置吞吐量的大小\n\n> 吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 垃圾收集时间)\n  比如虚拟机总共运行了120秒，垃圾收集时间用了1秒，吞吐量=(120-1)/120=99.167%。\n  若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。\n\n\n## 4.2、老年代收集器\n\n\n### 4.2.1、serial old\nSerial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用\"标记-整理算法\"，运行过程和Serial收集器一样。\n\n### 4.2.2、Parallel old\nParallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和\"标记-整理算法\"进行垃圾回收，吞吐量优先。\n**回收算法**：标记-整理\n**适用场景**：为了替代serial old与Parallel Scanvenge配合使用。\n\n### 4.2.3、CMS\n\n1. **特点：**最短回收停顿时间，\n2. **回收算法：**标记-清除\n3. **回收步骤：**\n   （1）初始标记：标记GC Roots直接关联的对象，速度快\n   （2）并发标记：GC Roots Tracing过程，耗时长，与用户进程并发工作\n   （3）重新标记：修正并发标记期间用户进程运行而产生变化的标记，好事比初始标记长，但是远远小于并发标记\n   （4）并发清除：清除标记的对象\n1. **缺点**：\n\n对CPU资源非常敏感，CPU少于4个时，CMS岁用户程序的影响可能变得很大，由此虚拟机提供了“增量式并发收集器”；无法回收浮动垃圾；采用标记清除算法会产生内存碎片，不过可以通过参数开启内存碎片的合并整理。\n\n![image (25).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222243378.png)\n\n\n## 4.3、整堆收集器\n### 4.3.1、G1\n\n1. **基本概念**\n\nG1将整个JVM堆划分成多个大小相等的独立区域regin，跟踪各个regin里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收最大的regin，当然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离了，他们都是一部分regin集合。内存“化整为零”的思路：在GC根节点的枚举范围汇总加入remembered set 即可保证不对全堆扫面也不会遗漏。\n\n2. **回收步骤**：\n   （1）初始标记：标记GC Roots直接关联的对象\n   （2）并发标记：对堆中对象进行可达性分析，找出存活对象，耗时长，与用户进程并发工作\n   （3）重新标记：修正并发标记期间用户进程继续运行而产生变化的标记\n   （4）筛选回收：对各个regin的回收价值进行排序，然后根据期望的GC停顿时间制定回收计划\n\n![G1垃圾收集器](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222244637.png)\n\n\n \n### 4.3.2、ZGC\n\nZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。\n在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。\n**优点**：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小\n**缺点**：浮动垃圾\n目前使用的非常少，真正普及还是需要写时间的。\n\n## 4.4、垃圾收集器的选择？\n\njdk1.8 前默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）\njdk1.9 默认垃圾收集器G1\n\n1. 如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益\n\n```java\n参数：-XX:+UseSerialGC。\n```\n\n\n2. 如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的\n\n```java\n参数：-XX:+UseParallelGC。\n```\n\n\n3. 如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择G1、ZGC、CMS都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些\n\n```java\n参数：\n-XX:+UseConcMarkSweepGC、\n-XX:+UseG1GC、\n-XX:+UseZGC 等。\n```\n\n# 5、类加载机制\n\n虚拟机把类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的类加载机制\n\n## 5.1、类加载过程\n### 5.1.1、加载阶段\n（1）通过一个类的全限定名来获取定义此类的二进制字节流\n（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口\n\n### 5.1.2、链接阶段\n（1）**验证**： 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全\n\n> **文件格式验证**：验证字节流是否符合Class文件格式的规范，如：是否以模数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内等等。\n**元数据验证**：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；如：这个类是否有父类，是否实现了父类的抽象方法，是否重写了父类的final方法，是否继承了被final修饰的类等等。\n**符号引用验证**：确保解析动作能正确执行；如：通过符合引用能找到对应的类和方法，符号引用中类、属性、方法的访问性是否能被当前类访问等等\n（验证阶段是非常重要的，但不是必须的。可以采用-Xverify:none参数来关闭大部分的类验证措施）\n\n\n（2）**准备**：为类的静态变量分配内存，并将其赋默认值\n\n> 为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：\n只对**static**修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。\n对**final**的静态字面值常量直接赋初值（赋初值不是赋默认值，如果不是字面值静态常量，那么会和静态变量一样赋默认值）\n\n\n（3）**解析**：将常量池中的符号引用替换为直接引用（内存地址）的过程\n\n> 符号引用：就是一组符号来描述目标，可以是任何字面量。属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符（eg:java.lang.String）。\n  直接引用：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。如指向方法区某个类的一个指针\n\n\n### 5.1.3、初始化阶段\n为类的静态变量赋初值\n\n> 赋初值两种方式：\n（1）定义静态变量时指定初始值。如 private static String x=\"123\";\n（2）在静态代码块里为静态变量赋值。如 static{ x=\"123\"; }\n 注意：只有对类的主动使用才会导致类的初始化。\n\n\n**初始化顺序：**\n（1）静态初始化 ：父类静态成员和static块-子类静态成员和static块\n（2）父类初始化：父类普通成员和非static块-父类构造函数\n（3）子类初始化：子类普通成员和非static块-子类构造函数\n## 5.2、类加载器分类\n\n1. **启动类加载器**\n\n使用c++实现，加载jre和jre/lib目录下的核心库\n\n2. **扩展类加载器**\n\njava编写，父加载器为启动类加载器，从jre/lib/ext下加载类库\n\n3. **应用类加载器**\n\n负责加载用户类路径（classpath）上的指定类库\n## 5.3、双亲委派机制\n\n当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类\n\n**好处：**\n\n1. 避免重复加载，通过委托去向上面问一问，加载过了，就不用再加载一遍\n2. 保证核心api定义的类型不会被随意篡改，比如自己定义一个java.lang.String，顶级加载器系统类加载器加载时会加载核心包下的String类而不是自定义的。保证了核心类的安全\n\n# 6、逃逸分析\n\n我们都知道，java里面绝大多数对象都是存放在堆里面的，然后当对象没用的时候就会靠垃圾回收器去回收对象。那么什么是栈上分配呢？\n## 6.1、逃逸方式\n\n1. 方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法\n2. 线程逃逸：这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程\n\n![逃逸分析](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222246915.png)\n\n## 6.2、逃逸结果\n\n1. 栈上分配\n\n如果通过**逃逸分析**，能够确认对象不会发生逃逸行为，就会在栈上分配对象。如果在栈上分配对象的话，这个对象占用的空间就会在栈帧出栈的时候被销毁，所以，通过栈上分配可以降低垃圾回收的压力\n\n2. 标量替换　　\n\nJava虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。\n\n","slug":"jvm","published":1,"updated":"2023-10-22T14:48:26.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9l000e00uj88xifwza","content":"<h1 id=\"1、jvm概念\"><a href=\"#1、jvm概念\" class=\"headerlink\" title=\"1、jvm概念\"></a>1、jvm概念</h1><h2 id=\"1-1、定义\"><a href=\"#1-1、定义\" class=\"headerlink\" title=\"1.1、定义\"></a>1.1、定义</h2><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>\n<h2 id=\"1-2、好处\"><a href=\"#1-2、好处\" class=\"headerlink\" title=\"1.2、好处\"></a>1.2、好处</h2><ul>\n<li>跨平台，一次编写，到处运行</li>\n<li>自动内存管理，垃圾回收机制</li>\n<li>数组下标越界检查</li>\n</ul>\n<h2 id=\"1-3、jvm-jre-jdk的区别\"><a href=\"#1-3、jvm-jre-jdk的区别\" class=\"headerlink\" title=\"1.3、jvm jre jdk的区别\"></a>1.3、jvm jre jdk的区别</h2><h1 id=\"2、内存结构\"><a href=\"#2、内存结构\" class=\"headerlink\" title=\"2、内存结构\"></a>2、内存结构</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222232072.jpg\" alt=\"jvm内存结构\"></p>\n<p>注意：常量池，运行时常量池，字符串常量池逻辑上属于方法区，只是存储的物理位置在堆（所以他们属于方法区）</p>\n<h2 id=\"2-1、程序计数器\"><a href=\"#2-1、程序计数器\" class=\"headerlink\" title=\"2.1、程序计数器\"></a>2.1、程序计数器</h2><h3 id=\"2-1-1、作用\"><a href=\"#2-1-1、作用\" class=\"headerlink\" title=\"2.1.1、作用\"></a>2.1.1、作用</h3><p>当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>\n<h3 id=\"2-1-2、特点\"><a href=\"#2-1-2、特点\" class=\"headerlink\" title=\"2.1.2、特点\"></a>2.1.2、特点</h3><ol>\n<li>为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，独立存储，互不影响。所以，程序计数器是<strong>线程私有</strong>的内存区域</li>\n<li>Java虚拟机规范中<strong>唯一一个没有规定任何OutOfMemoryError情况的区域</strong></li>\n</ol>\n<h2 id=\"2-2、虚拟机栈\"><a href=\"#2-2、虚拟机栈\" class=\"headerlink\" title=\"2.2、虚拟机栈\"></a>2.2、虚拟机栈</h2><h3 id=\"2-2-1、定义\"><a href=\"#2-2-1、定义\" class=\"headerlink\" title=\"2.2.1、定义\"></a>2.2.1、定义</h3><p>每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈是线程私有的，它的生命周期与线程相同</p>\n<blockquote>\n<p>局部变量表：存放方法参数和方法内部定义的局部变量<br>  操作数栈：操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区<br>  动态链接：将这些符号引用转换为调用方法的直接引用</p>\n</blockquote>\n<h3 id=\"2-2-2、问题辨析\"><a href=\"#2-2-2、问题辨析\" class=\"headerlink\" title=\"2.2.2、问题辨析\"></a>2.2.2、问题辨析</h3><ol>\n<li>垃圾回收是否涉及栈内存？<ul>\n<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>\n</ul>\n</li>\n<li>栈内存的分配越大越好吗？<ul>\n<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-2-4、线程运行诊断（CPU占用过高）\"><a href=\"#2-2-4、线程运行诊断（CPU占用过高）\" class=\"headerlink\" title=\"2.2.4、线程运行诊断（CPU占用过高）\"></a>2.2.4、线程运行诊断（CPU占用过高）</h3><ol>\n<li>查询占用cpu过高程序pid（top）</li>\n<li>查询该进程下各线程的CPU占用情况  （ ps H -eo pid,tid,%cpu|grep 27598）</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235151.png\" alt=\"image (17).png\"></p>\n<ol start=\"3\">\n<li>找到cpu占用最高的线程id，转为16进制</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235572.png\" alt=\"image (18).png\"></p>\n<ol start=\"4\">\n<li>打印堆栈 （jstack pid）</li>\n</ol>\n<p>jstack 27598 | grep -A 100 6bdf</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222236269.png\" alt=\"image (19).png\"></p>\n<h2 id=\"2-3、本地方法栈\"><a href=\"#2-3、本地方法栈\" class=\"headerlink\" title=\"2.3、本地方法栈\"></a>2.3、本地方法栈</h2><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p>\n<h2 id=\"2-4、堆\"><a href=\"#2-4、堆\" class=\"headerlink\" title=\"2.4、堆\"></a>2.4、堆</h2><h3 id=\"2-4-1、定义\"><a href=\"#2-4-1、定义\" class=\"headerlink\" title=\"2.4.1、定义\"></a>2.4.1、定义</h3><p>Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存（特例：栈上分配策略）</p>\n<blockquote>\n<ol>\n<li>从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代。新生代又可分为Eden和Suvivor区</li>\n<li>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2  通过参数 –XX:NewRatio 来指定</li>\n<li>最大物理内存大小不超过192兆字节（MB）时默认最大堆大小是物理内存的一半，否则占用物理内存的四分之一</li>\n</ol>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222237526.png\" alt=\"image (20).png\"></p>\n<h3 id=\"2-4-4、堆内存诊断\"><a href=\"#2-4-4、堆内存诊断\" class=\"headerlink\" title=\"2.4.4、堆内存诊断\"></a>2.4.4、堆内存诊断</h3><p>jps：查看java进程<br>jmap：查看堆内存占用情况 jmap -heap 进程id<br>jconsole：图形界面，检测堆栈，CPU占用，类加载情况等（可以连续监测）<br>jvisualvm：和jconsole功能类似，但功能更强。可以抓取和导入堆dump快照</p>\n<h2 id=\"2-6、内存泄漏\"><a href=\"#2-6、内存泄漏\" class=\"headerlink\" title=\"2.6、内存泄漏\"></a>2.6、内存泄漏</h2><ol>\n<li><strong>什么是内存泄露</strong></li>\n</ol>\n<p>内存泄露：内存空间使用完毕之后未回收</p>\n<ol start=\"2\">\n<li><strong>内存泄露的原因？</strong></li>\n</ol>\n<p>（1）static字段引起的内存泄露<br>大量使用static字段会潜在的导致内存泄露，在Java中，静态字段通常拥有与整个应用程序相匹配的生命周期。<br>解决办法：最大限度的减少静态变量的使用；单例模式时，依赖于延迟加载对象而不是立即加载方式</p>\n<p>（2）未关闭的资源导致内存泄露<br>每当创建连接或者打开流时，JVM都会为这些资源分配内存。如果没有关闭连接，会导致持续占有内存。在任意情况下，资源留下的开放连接都会消耗内存，如果我们不处理，就会降低性能，甚至OOM。<br>解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；jdk1.7后，可以使用try-with-resource块</p>\n<h2 id=\"2-5、方法区\"><a href=\"#2-5、方法区\" class=\"headerlink\" title=\"2.5、方法区\"></a>2.5、方法区</h2><h3 id=\"2-5-1、结构\"><a href=\"#2-5-1、结构\" class=\"headerlink\" title=\"2.5.1、结构\"></a>2.5.1、结构</h3><p>方法区是java虚拟机的一个模型规范，具体实现是永久代和元空间。方法区存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等<br>方法区在程序启动时被创建，方法区是一个概念。具体实现有永久代（1.8前）和元空间（1.8）永久代用的是堆内存，元空间用的是本地内存（也就是操作系统的内存）</p>\n<blockquote>\n<p>方法区如果内存不足，也会抛出<strong>OutofMemoryError</strong> 的异常</p>\n</blockquote>\n<h3 id=\"2-5-2、class常量池\"><a href=\"#2-5-2、class常量池\" class=\"headerlink\" title=\"2.5.2、class常量池\"></a>2.5.2、class常量池</h3><p>Java 文件被编译成 Class 文件，Class 文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是 Class 常量池，<strong>Class 常量池是当 Class 文件被 Java 虚拟机加载进来后存放各种字面量和符号引用</strong></p>\n<blockquote>\n<p>类的加载过程中的链接部分的解析步骤就是把符号引用替换为直接引用，即把那些描述符（名字）替换为能直接定位到字段、方法的引用或句柄（地址）</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222238635.png\" alt=\"image (21).png\"></p>\n<p>System.out.println(“hello”)经过反编译后的内容如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.class</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222239362.png\" alt=\"class常量池\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1658211741107-6e92db9f-e7b1-4fe3-9b54-0f608dad19b6.png#clientId=u2849290d-6927-4&from=paste&id=u0f35b784&originHeight=410&originWidth=1118&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3e3cb8ec-7f59-44f8-b925-f1bce7b280b&title=\"><br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1658211750067-5a5fe357-17ac-4ed5-8463-862b32649804.png#clientId=u2849290d-6927-4&from=paste&id=u52353eda&originHeight=236&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue01b07e2-503e-45f1-b6a7-3479b81cc26&title=\"></p>\n<p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p>\n<h3 id=\"2-5-3、运行时常量池\"><a href=\"#2-5-3、运行时常量池\" class=\"headerlink\" title=\"2.5.3、运行时常量池\"></a>2.5.3、运行时常量池</h3><p>运行时常量池是方法区的一部分。运行时常量池是当 Class 文件被加载到内存后，Java虚拟机会将 Class 文件常量池里的内容转移到运行时常量池里，<strong>并且把里面的符号地址变为真实地址</strong></p>\n<h3 id=\"2-5-4、字符串常量池\"><a href=\"#2-5-4、字符串常量池\" class=\"headerlink\" title=\"2.5.4、字符串常量池\"></a>2.5.4、字符串常量池</h3><p>JVM为了提高性能，减少内存开销，维护的一个存放字符串常量的内存区域，里面的字符串不允许重复，有长度限制，最大为65535字节</p>\n<ol>\n<li><strong>两种创建字符串对象不同方式的比较</strong></li>\n</ol>\n<p>（1）采用字面值的方式创建字符串对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Str</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        String str1=<span class=\"string\">&quot;aaa&quot;</span>;</span><br><span class=\"line\">        String str2=<span class=\"string\">&quot;aaa&quot;</span>;</span><br><span class=\"line\">        System.out.println(str1==str2);   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 运行结果：</span></span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>采用字面值的方式创建一个字符串时，JVM 首先会去字符串池中查找是否存在 “aaa” 这个对象，如果不存在，则在字符串池中创建 “aaa” 这个对象，然后将池中 “aaa” 这个对象的引用地址返回给字符串常量 str，这样 str 会指向池中”aaa”这个字符串对象；如果存在，则不创建任何对象，直接将池中 “aaa” 这个对象的地址返回，赋给字符串常量。</p>\n</blockquote>\n<blockquote>\n<p>对于上述的例子：这是因为，创建字符串对象 str2 时，字符串池中已经存在 “aaa” 这个对象，直接把对象 “aaa” 的引用地址返回给 str2，这样 str2 指向了池中 “aaa” 这个对象，也就是说 str1 和 str2 指向了同一个对象，因此语句 System.out.println(str1&#x3D;&#x3D; str2) 输出：true。</p>\n</blockquote>\n<p>2）采用 new 关键字新建一个字符串对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Str</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        String str1=<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">        String str2=<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">        System.out.println(str1==str2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 运行结果：</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>采用 new 关键字新建一个字符串对象时，JVM 首先在字符串常量池中查找有没有 “aaa” 这个字符串对象，如果有，则不在池中再去创建 “aaa” 这个对象了，直接在堆中创建一个 “aaa” 字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用 str1，这样，str1 就指向了堆中创建的这个 “aaa” 字符串对象；如果没有，则首先在字符串常量池池中创建一个 “aaa” 字符串对象，然后再在堆中创建一个 “aaa” 字符串对象，然后将堆中这个 “aaa” 字符串对象的地址返回赋给 str1 引用，这样，str1 指向了堆中创建的这个 “aaa” 字符串对象。</p>\n</blockquote>\n<blockquote>\n<p>对于上述的例子：因为，采用new关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str1和str2指向的是两个不同的对象，因此语句System.out.println(str1 &#x3D;&#x3D; str2)输出：false</p>\n</blockquote>\n<ul>\n<li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab &#x3D; “ab” 一致。</li>\n<li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li>\n</ul>\n<ol start=\"2\">\n<li><strong>字符串拼接问题</strong></li>\n</ol>\n<p>（1）字符串变量拼接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StringTableStudy</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;a&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;b&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">ab</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//拼接字符串对象来创建新的字符串</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">ab2</span> <span class=\"operator\">=</span> a+b; </span><br><span class=\"line\">        System.out.println(ab == ab2);  <span class=\"comment\">//false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>通过变量拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()<br>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>\n</blockquote>\n<p>（2）字符串拼接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StringTableStudy</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;a&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;b&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">ab</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//拼接字符串对象来创建新的字符串</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">ab2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;a&quot;</span>+<span class=\"string\">&quot;b&quot;</span>; </span><br><span class=\"line\">        System.out.println(ab == ab2);  <span class=\"comment\">//true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接引用串池中的地址，所以进行的操作和 ab &#x3D; “ab” 一致。</p>\n</blockquote>\n<ol start=\"3\">\n<li>i<strong>ntern方法</strong></li>\n</ol>\n<p>jdk1.8调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中，如果有则不会放入</p>\n<blockquote>\n<p>jdk1.6调用字符串对象的intern方法，会将该字符串对象复制一份放入到串池中，如果有则不会放入</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;a&quot;</span>) + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将串池引用指向堆，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">st2</span> <span class=\"operator\">=</span> str.intern();</span><br><span class=\"line\">\t\t<span class=\"comment\">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">str3</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意：上面的结果是在1.8下，在1.6下都为false（字符串常量池和堆不是一个对象）</span></span><br><span class=\"line\">\t\tSystem.out.println(str == st2);</span><br><span class=\"line\">\t\tSystem.out.println(str == str3);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>思考</li>\n</ol>\n<p>（1）String str &#x3D; new String(“abc”);创建了几个对象，常量池有abc字段是1个，常量池没有”abc”字段则是2个。<br>（2）String str&#x3D;“abc”;创建了几个对象（如果常量池里面已经有对象了就是0个。如果没有就是1个）;<br>（3）new String(“abc”).intern();创建了几个对象（如果常量池里面已经有该字符串对象了就是1个，如果没有就是两个）<br>（4）string a &#x3D; “a”+”b“创建几个对象？0个或1个。因为编译器优化，不会创建”a”或”b”.</p>\n<h1 id=\"3、垃圾回收算法\"><a href=\"#3、垃圾回收算法\" class=\"headerlink\" title=\"3、垃圾回收算法\"></a>3、垃圾回收算法</h1><h2 id=\"3-1、如何判断一个对象可以被回收\"><a href=\"#3-1、如何判断一个对象可以被回收\" class=\"headerlink\" title=\"3.1、如何判断一个对象可以被回收\"></a>3.1、如何判断一个对象可以被回收</h2><ol>\n<li>引用计数法</li>\n</ol>\n<p>每个对象关联一个引用计数器属性，任何一个对象引用了A，引用计数器的值加1.当引用失效时，引用计数器就减1.当引用计数器的值为0时，表示对象不再被使用，可进行回收</p>\n<blockquote>\n<p>缺点：（1）需要单独的字段存储计数器，这样增加了存储空间的开销 （2）每次赋值都要更新计数器值，增加了时间开销 （3）存在循环引用的问题（所以jvm不用）</p>\n</blockquote>\n<ol start=\"2\">\n<li>可达性分析法</li>\n</ol>\n<p>设立若干根对象（GC Root Object），当任何一个根对象到某一个对象均不可达时，认为这个对象可以被回收</p>\n<blockquote>\n<p>哪些对象可以被作为根对象？</p>\n<ul>\n<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。就是在方法中new的对象</li>\n<li>方法区中静态属性引用的对象用static修饰的全局的静态的对象</li>\n<li>方法区中常量引用的对象static final关键字</li>\n<li>本地方法栈中(Native方法)引用的对象引用Native方法的所有对象</li>\n</ul>\n</blockquote>\n<p>为什么这些对象可以作为根对象？</p>\n<blockquote>\n<p>GC Root 需要确保引用所指的对象都是活着的,而当前线程栈帧中的对象，在这一时刻是存活的。</p>\n</blockquote>\n<h2 id=\"3-2、五种引用\"><a href=\"#3-2、五种引用\" class=\"headerlink\" title=\"3.2、五种引用\"></a>3.2、五种引用</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222241216.png\" alt=\"五种引用\"></p>\n<ol>\n<li><strong>强引用</strong>：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它</li>\n</ol>\n<blockquote>\n<p>在java程序中，一般由Object object &#x3D; new Object();定义的object就是一个强引用<br>如上图B、C对象都不引用A1对象时，A1对象才会被回收</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>软引用</strong>：当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象</li>\n</ol>\n<blockquote>\n<p>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收<br>作用：软引用是用来描述一些有用但并不是必需的对象，JVM 内存空间充足的时候将数据缓存在内存中，如果空间不足了就将其回收掉</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;String&gt;(str);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>弱引用</strong>：有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</li>\n</ol>\n<blockquote>\n<p>如上图如果B对象不再引用A3对象，则A3对象会被回收</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eakReference&lt;String&gt; sr = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;String&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>虚引用</strong>：  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列</li>\n</ol>\n<p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。你声明虚引用的时候是要传入一个queue的。当你的虚引用所引用的对象已经执行完finalize函数的时候，就会把对象加到queue里面。你可以通过判断queue里面是不是有对象来判断你的对象是不是要被回收了</p>\n<blockquote>\n<p>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PhantomReference&lt;String&gt; abcWeakRef = <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>&lt;String&gt;(abc, referenceQueue);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>引用强度</strong></li>\n</ol>\n<p>强引用&gt;软引用&gt;弱引用&gt;虚引用</p>\n<h2 id=\"3-3、垃圾回收算法\"><a href=\"#3-3、垃圾回收算法\" class=\"headerlink\" title=\"3.3、垃圾回收算法\"></a>3.3、垃圾回收算法</h2><h3 id=\"3-3-1、标记清除算法\"><a href=\"#3-3-1、标记清除算法\" class=\"headerlink\" title=\"3.3.1、标记清除算法\"></a>3.3.1、标记清除算法</h3><ol>\n<li>概念：通过根节点，标记所有根节点开始的可达对象，清除未被标记对象</li>\n<li>优点：算法简单</li>\n<li>缺点：（1）产生内存碎片，造成新来的大对象（如数组）可能没有有效的内存空间</li>\n</ol>\n<h3 id=\"3-3-2、标记整理算法（老年代默认）\"><a href=\"#3-3-2、标记整理算法（老年代默认）\" class=\"headerlink\" title=\"3.3.2、标记整理算法（老年代默认）\"></a>3.3.2、标记整理算法（老年代默认）</h3><ol>\n<li>概念：将标记的对象移动到内存的一端，清除边界外的所有空间</li>\n<li>优点：解决了标记清除算法的碎片问题</li>\n<li>缺点：效率低（整理后依赖这个对象的对象更新一下引用地址信息）</li>\n</ol>\n<h3 id=\"3-3-3、复制算法（新生代默认）\"><a href=\"#3-3-3、复制算法（新生代默认）\" class=\"headerlink\" title=\"3.3.3、复制算法（新生代默认）\"></a>3.3.3、复制算法（新生代默认）</h3><ol>\n<li>概念：将内存分为一块较大的Eden和两块较小的survivor，每次使用Eden和其中一块survivo,gc时将Eden存活对象复制到suvivorTo,suvivorFrom存活的对象没有达到分代年龄阈值时复制到suvivorTo，达到分带年龄阈值复制到老年区，之后清除Eden和suvivorFrom的对象,交换两个suvivor的角色,后面以此类推</li>\n<li>优点：（1）不会产生内存碎片（2）在存活对象不多的情况下，效率较高，适合新生代</li>\n<li>缺点：浪费内存空间，始终要有一个空闲的survivor</li>\n</ol>\n<h2 id=\"3-4、FULL-GC原因\"><a href=\"#3-4、FULL-GC原因\" class=\"headerlink\" title=\"3.4、FULL GC原因\"></a>3.4、FULL GC原因</h2><blockquote>\n<p>Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，元空间等。是说在这次GC的全过程中所有用户线程都是处于暂停的状态（stop the world）</p>\n</blockquote>\n<ol>\n<li><strong>System.gc()方法的调用</strong></li>\n</ol>\n<p>在代码中调用System.gc()方法会建议JVM进行Full GC，但是注意这只是建议，JVM执行不执行是另外一回事儿，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p>\n<ol start=\"2\">\n<li><strong>老年代空间不足</strong></li>\n</ol>\n<p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space</p>\n<h1 id=\"4、垃圾回收器\"><a href=\"#4、垃圾回收器\" class=\"headerlink\" title=\"4、垃圾回收器\"></a>4、垃圾回收器</h1><h2 id=\"4-1、新生代垃圾收集器\"><a href=\"#4-1、新生代垃圾收集器\" class=\"headerlink\" title=\"4.1、新生代垃圾收集器\"></a>4.1、新生代垃圾收集器</h2><h3 id=\"4-1-1、Serial（串行）收集器\"><a href=\"#4-1-1、Serial（串行）收集器\" class=\"headerlink\" title=\"4.1.1、Serial（串行）收集器\"></a>4.1.1、Serial（串行）收集器</h3><ol>\n<li><strong>概念</strong>：Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程</li>\n</ol>\n<blockquote>\n<p>优点：简单高效，拥有很高的单线程收集效率<br>  缺点：收集过程需要暂停所有线程<br>  算法：复制算法应用</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>收集过程</strong></li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242409.png\" alt=\"image (23).png\"></p>\n<h3 id=\"4-1-2、ParNew-收集器\"><a href=\"#4-1-2、ParNew-收集器\" class=\"headerlink\" title=\"4.1.2、ParNew 收集器\"></a>4.1.2、ParNew 收集器</h3><ol>\n<li><strong>概念：</strong>可以把这个收集器理解为Serial收集器的多线程版本</li>\n</ol>\n<blockquote>\n<p>优点：在多CPU时，比Serial效率高。<br>  缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。<br>  算法：复制算法</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242011.png\" alt=\"image (24).png\"></p>\n<h3 id=\"4-1-3、Parallel-Scavenge-收集器\"><a href=\"#4-1-3、Parallel-Scavenge-收集器\" class=\"headerlink\" title=\"4.1.3、Parallel Scavenge 收集器\"></a>4.1.3、Parallel Scavenge 收集器</h3><ol>\n<li><strong>概念</strong>：Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的吞吐量 。</li>\n<li><strong>可设置参数</strong>：-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间， -XX:GC Time Ratio直接设置吞吐量的大小</li>\n</ol>\n<blockquote>\n<p>吞吐量 &#x3D; 运行用户代码的时间 &#x2F; (运行用户代码的时间 + 垃圾收集时间)<br>  比如虚拟机总共运行了120秒，垃圾收集时间用了1秒，吞吐量&#x3D;(120-1)&#x2F;120&#x3D;99.167%。<br>  若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</p>\n</blockquote>\n<h2 id=\"4-2、老年代收集器\"><a href=\"#4-2、老年代收集器\" class=\"headerlink\" title=\"4.2、老年代收集器\"></a>4.2、老年代收集器</h2><h3 id=\"4-2-1、serial-old\"><a href=\"#4-2-1、serial-old\" class=\"headerlink\" title=\"4.2.1、serial old\"></a>4.2.1、serial old</h3><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用”标记-整理算法”，运行过程和Serial收集器一样。</p>\n<h3 id=\"4-2-2、Parallel-old\"><a href=\"#4-2-2、Parallel-old\" class=\"headerlink\" title=\"4.2.2、Parallel old\"></a>4.2.2、Parallel old</h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理算法”进行垃圾回收，吞吐量优先。<br><strong>回收算法</strong>：标记-整理<br><strong>适用场景</strong>：为了替代serial old与Parallel Scanvenge配合使用。</p>\n<h3 id=\"4-2-3、CMS\"><a href=\"#4-2-3、CMS\" class=\"headerlink\" title=\"4.2.3、CMS\"></a>4.2.3、CMS</h3><ol>\n<li><strong>特点：</strong>最短回收停顿时间，</li>\n<li><strong>回收算法：</strong>标记-清除</li>\n<li><strong>回收步骤：</strong><br>（1）初始标记：标记GC Roots直接关联的对象，速度快<br>（2）并发标记：GC Roots Tracing过程，耗时长，与用户进程并发工作<br>（3）重新标记：修正并发标记期间用户进程运行而产生变化的标记，好事比初始标记长，但是远远小于并发标记<br>（4）并发清除：清除标记的对象</li>\n<li><strong>缺点</strong>：</li>\n</ol>\n<p>对CPU资源非常敏感，CPU少于4个时，CMS岁用户程序的影响可能变得很大，由此虚拟机提供了“增量式并发收集器”；无法回收浮动垃圾；采用标记清除算法会产生内存碎片，不过可以通过参数开启内存碎片的合并整理。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222243378.png\" alt=\"image (25).png\"></p>\n<h2 id=\"4-3、整堆收集器\"><a href=\"#4-3、整堆收集器\" class=\"headerlink\" title=\"4.3、整堆收集器\"></a>4.3、整堆收集器</h2><h3 id=\"4-3-1、G1\"><a href=\"#4-3-1、G1\" class=\"headerlink\" title=\"4.3.1、G1\"></a>4.3.1、G1</h3><ol>\n<li><strong>基本概念</strong></li>\n</ol>\n<p>G1将整个JVM堆划分成多个大小相等的独立区域regin，跟踪各个regin里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收最大的regin，当然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离了，他们都是一部分regin集合。内存“化整为零”的思路：在GC根节点的枚举范围汇总加入remembered set 即可保证不对全堆扫面也不会遗漏。</p>\n<ol start=\"2\">\n<li><strong>回收步骤</strong>：<br>（1）初始标记：标记GC Roots直接关联的对象<br>（2）并发标记：对堆中对象进行可达性分析，找出存活对象，耗时长，与用户进程并发工作<br>（3）重新标记：修正并发标记期间用户进程继续运行而产生变化的标记<br>（4）筛选回收：对各个regin的回收价值进行排序，然后根据期望的GC停顿时间制定回收计划</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222244637.png\" alt=\"G1垃圾收集器\"></p>\n<h3 id=\"4-3-2、ZGC\"><a href=\"#4-3-2、ZGC\" class=\"headerlink\" title=\"4.3.2、ZGC\"></a>4.3.2、ZGC</h3><p>ZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。<br>在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。<br><strong>优点</strong>：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小<br><strong>缺点</strong>：浮动垃圾<br>目前使用的非常少，真正普及还是需要写时间的。</p>\n<h2 id=\"4-4、垃圾收集器的选择？\"><a href=\"#4-4、垃圾收集器的选择？\" class=\"headerlink\" title=\"4.4、垃圾收集器的选择？\"></a>4.4、垃圾收集器的选择？</h2><p>jdk1.8 前默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）<br>jdk1.9 默认垃圾收集器G1</p>\n<ol>\n<li>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数：-XX:+UseSerialGC。</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li>如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数：-XX:+UseParallelGC。</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li>如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择G1、ZGC、CMS都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数：</span><br><span class=\"line\">-XX:+UseConcMarkSweepGC、</span><br><span class=\"line\">-XX:+UseG1GC、</span><br><span class=\"line\">-XX:+UseZGC 等。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5、类加载机制\"><a href=\"#5、类加载机制\" class=\"headerlink\" title=\"5、类加载机制\"></a>5、类加载机制</h1><p>虚拟机把类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的类加载机制</p>\n<h2 id=\"5-1、类加载过程\"><a href=\"#5-1、类加载过程\" class=\"headerlink\" title=\"5.1、类加载过程\"></a>5.1、类加载过程</h2><h3 id=\"5-1-1、加载阶段\"><a href=\"#5-1-1、加载阶段\" class=\"headerlink\" title=\"5.1.1、加载阶段\"></a>5.1.1、加载阶段</h3><p>（1）通过一个类的全限定名来获取定义此类的二进制字节流<br>（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>\n<h3 id=\"5-1-2、链接阶段\"><a href=\"#5-1-2、链接阶段\" class=\"headerlink\" title=\"5.1.2、链接阶段\"></a>5.1.2、链接阶段</h3><p>（1）<strong>验证</strong>： 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p>\n<blockquote>\n<p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，如：是否以模数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内等等。<br><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；如：这个类是否有父类，是否实现了父类的抽象方法，是否重写了父类的final方法，是否继承了被final修饰的类等等。<br><strong>符号引用验证</strong>：确保解析动作能正确执行；如：通过符合引用能找到对应的类和方法，符号引用中类、属性、方法的访问性是否能被当前类访问等等<br>（验证阶段是非常重要的，但不是必须的。可以采用-Xverify:none参数来关闭大部分的类验证措施）</p>\n</blockquote>\n<p>（2）<strong>准备</strong>：为类的静态变量分配内存，并将其赋默认值</p>\n<blockquote>\n<p>为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：<br>只对<strong>static</strong>修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。<br>对<strong>final</strong>的静态字面值常量直接赋初值（赋初值不是赋默认值，如果不是字面值静态常量，那么会和静态变量一样赋默认值）</p>\n</blockquote>\n<p>（3）<strong>解析</strong>：将常量池中的符号引用替换为直接引用（内存地址）的过程</p>\n<blockquote>\n<p>符号引用：就是一组符号来描述目标，可以是任何字面量。属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符（eg:java.lang.String）。<br>  直接引用：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。如指向方法区某个类的一个指针</p>\n</blockquote>\n<h3 id=\"5-1-3、初始化阶段\"><a href=\"#5-1-3、初始化阶段\" class=\"headerlink\" title=\"5.1.3、初始化阶段\"></a>5.1.3、初始化阶段</h3><p>为类的静态变量赋初值</p>\n<blockquote>\n<p>赋初值两种方式：<br>（1）定义静态变量时指定初始值。如 private static String x&#x3D;”123”;<br>（2）在静态代码块里为静态变量赋值。如 static{ x&#x3D;”123”; }<br> 注意：只有对类的主动使用才会导致类的初始化。</p>\n</blockquote>\n<p><strong>初始化顺序：</strong><br>（1）静态初始化 ：父类静态成员和static块-子类静态成员和static块<br>（2）父类初始化：父类普通成员和非static块-父类构造函数<br>（3）子类初始化：子类普通成员和非static块-子类构造函数</p>\n<h2 id=\"5-2、类加载器分类\"><a href=\"#5-2、类加载器分类\" class=\"headerlink\" title=\"5.2、类加载器分类\"></a>5.2、类加载器分类</h2><ol>\n<li><strong>启动类加载器</strong></li>\n</ol>\n<p>使用c++实现，加载jre和jre&#x2F;lib目录下的核心库</p>\n<ol start=\"2\">\n<li><strong>扩展类加载器</strong></li>\n</ol>\n<p>java编写，父加载器为启动类加载器，从jre&#x2F;lib&#x2F;ext下加载类库</p>\n<ol start=\"3\">\n<li><strong>应用类加载器</strong></li>\n</ol>\n<p>负责加载用户类路径（classpath）上的指定类库</p>\n<h2 id=\"5-3、双亲委派机制\"><a href=\"#5-3、双亲委派机制\" class=\"headerlink\" title=\"5.3、双亲委派机制\"></a>5.3、双亲委派机制</h2><p>当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类</p>\n<p><strong>好处：</strong></p>\n<ol>\n<li>避免重复加载，通过委托去向上面问一问，加载过了，就不用再加载一遍</li>\n<li>保证核心api定义的类型不会被随意篡改，比如自己定义一个java.lang.String，顶级加载器系统类加载器加载时会加载核心包下的String类而不是自定义的。保证了核心类的安全</li>\n</ol>\n<h1 id=\"6、逃逸分析\"><a href=\"#6、逃逸分析\" class=\"headerlink\" title=\"6、逃逸分析\"></a>6、逃逸分析</h1><p>我们都知道，java里面绝大多数对象都是存放在堆里面的，然后当对象没用的时候就会靠垃圾回收器去回收对象。那么什么是栈上分配呢？</p>\n<h2 id=\"6-1、逃逸方式\"><a href=\"#6-1、逃逸方式\" class=\"headerlink\" title=\"6.1、逃逸方式\"></a>6.1、逃逸方式</h2><ol>\n<li>方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法</li>\n<li>线程逃逸：这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222246915.png\" alt=\"逃逸分析\"></p>\n<h2 id=\"6-2、逃逸结果\"><a href=\"#6-2、逃逸结果\" class=\"headerlink\" title=\"6.2、逃逸结果\"></a>6.2、逃逸结果</h2><ol>\n<li>栈上分配</li>\n</ol>\n<p>如果通过<strong>逃逸分析</strong>，能够确认对象不会发生逃逸行为，就会在栈上分配对象。如果在栈上分配对象的话，这个对象占用的空间就会在栈帧出栈的时候被销毁，所以，通过栈上分配可以降低垃圾回收的压力</p>\n<ol start=\"2\">\n<li>标量替换</li>\n</ol>\n<p>　　</p>\n<p>Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、jvm概念\"><a href=\"#1、jvm概念\" class=\"headerlink\" title=\"1、jvm概念\"></a>1、jvm概念</h1><h2 id=\"1-1、定义\"><a href=\"#1-1、定义\" class=\"headerlink\" title=\"1.1、定义\"></a>1.1、定义</h2><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p>\n<h2 id=\"1-2、好处\"><a href=\"#1-2、好处\" class=\"headerlink\" title=\"1.2、好处\"></a>1.2、好处</h2><ul>\n<li>跨平台，一次编写，到处运行</li>\n<li>自动内存管理，垃圾回收机制</li>\n<li>数组下标越界检查</li>\n</ul>\n<h2 id=\"1-3、jvm-jre-jdk的区别\"><a href=\"#1-3、jvm-jre-jdk的区别\" class=\"headerlink\" title=\"1.3、jvm jre jdk的区别\"></a>1.3、jvm jre jdk的区别</h2><h1 id=\"2、内存结构\"><a href=\"#2、内存结构\" class=\"headerlink\" title=\"2、内存结构\"></a>2、内存结构</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222232072.jpg\" alt=\"jvm内存结构\"></p>\n<p>注意：常量池，运行时常量池，字符串常量池逻辑上属于方法区，只是存储的物理位置在堆（所以他们属于方法区）</p>\n<h2 id=\"2-1、程序计数器\"><a href=\"#2-1、程序计数器\" class=\"headerlink\" title=\"2.1、程序计数器\"></a>2.1、程序计数器</h2><h3 id=\"2-1-1、作用\"><a href=\"#2-1-1、作用\" class=\"headerlink\" title=\"2.1.1、作用\"></a>2.1.1、作用</h3><p>当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p>\n<h3 id=\"2-1-2、特点\"><a href=\"#2-1-2、特点\" class=\"headerlink\" title=\"2.1.2、特点\"></a>2.1.2、特点</h3><ol>\n<li>为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，独立存储，互不影响。所以，程序计数器是<strong>线程私有</strong>的内存区域</li>\n<li>Java虚拟机规范中<strong>唯一一个没有规定任何OutOfMemoryError情况的区域</strong></li>\n</ol>\n<h2 id=\"2-2、虚拟机栈\"><a href=\"#2-2、虚拟机栈\" class=\"headerlink\" title=\"2.2、虚拟机栈\"></a>2.2、虚拟机栈</h2><h3 id=\"2-2-1、定义\"><a href=\"#2-2-1、定义\" class=\"headerlink\" title=\"2.2.1、定义\"></a>2.2.1、定义</h3><p>每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈是线程私有的，它的生命周期与线程相同</p>\n<blockquote>\n<p>局部变量表：存放方法参数和方法内部定义的局部变量<br>  操作数栈：操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区<br>  动态链接：将这些符号引用转换为调用方法的直接引用</p>\n</blockquote>\n<h3 id=\"2-2-2、问题辨析\"><a href=\"#2-2-2、问题辨析\" class=\"headerlink\" title=\"2.2.2、问题辨析\"></a>2.2.2、问题辨析</h3><ol>\n<li>垃圾回收是否涉及栈内存？<ul>\n<li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li>\n</ul>\n</li>\n<li>栈内存的分配越大越好吗？<ul>\n<li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"2-2-4、线程运行诊断（CPU占用过高）\"><a href=\"#2-2-4、线程运行诊断（CPU占用过高）\" class=\"headerlink\" title=\"2.2.4、线程运行诊断（CPU占用过高）\"></a>2.2.4、线程运行诊断（CPU占用过高）</h3><ol>\n<li>查询占用cpu过高程序pid（top）</li>\n<li>查询该进程下各线程的CPU占用情况  （ ps H -eo pid,tid,%cpu|grep 27598）</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235151.png\" alt=\"image (17).png\"></p>\n<ol start=\"3\">\n<li>找到cpu占用最高的线程id，转为16进制</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235572.png\" alt=\"image (18).png\"></p>\n<ol start=\"4\">\n<li>打印堆栈 （jstack pid）</li>\n</ol>\n<p>jstack 27598 | grep -A 100 6bdf</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222236269.png\" alt=\"image (19).png\"></p>\n<h2 id=\"2-3、本地方法栈\"><a href=\"#2-3、本地方法栈\" class=\"headerlink\" title=\"2.3、本地方法栈\"></a>2.3、本地方法栈</h2><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p>\n<h2 id=\"2-4、堆\"><a href=\"#2-4、堆\" class=\"headerlink\" title=\"2.4、堆\"></a>2.4、堆</h2><h3 id=\"2-4-1、定义\"><a href=\"#2-4-1、定义\" class=\"headerlink\" title=\"2.4.1、定义\"></a>2.4.1、定义</h3><p>Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存（特例：栈上分配策略）</p>\n<blockquote>\n<ol>\n<li>从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代。新生代又可分为Eden和Suvivor区</li>\n<li>新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2  通过参数 –XX:NewRatio 来指定</li>\n<li>最大物理内存大小不超过192兆字节（MB）时默认最大堆大小是物理内存的一半，否则占用物理内存的四分之一</li>\n</ol>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222237526.png\" alt=\"image (20).png\"></p>\n<h3 id=\"2-4-4、堆内存诊断\"><a href=\"#2-4-4、堆内存诊断\" class=\"headerlink\" title=\"2.4.4、堆内存诊断\"></a>2.4.4、堆内存诊断</h3><p>jps：查看java进程<br>jmap：查看堆内存占用情况 jmap -heap 进程id<br>jconsole：图形界面，检测堆栈，CPU占用，类加载情况等（可以连续监测）<br>jvisualvm：和jconsole功能类似，但功能更强。可以抓取和导入堆dump快照</p>\n<h2 id=\"2-6、内存泄漏\"><a href=\"#2-6、内存泄漏\" class=\"headerlink\" title=\"2.6、内存泄漏\"></a>2.6、内存泄漏</h2><ol>\n<li><strong>什么是内存泄露</strong></li>\n</ol>\n<p>内存泄露：内存空间使用完毕之后未回收</p>\n<ol start=\"2\">\n<li><strong>内存泄露的原因？</strong></li>\n</ol>\n<p>（1）static字段引起的内存泄露<br>大量使用static字段会潜在的导致内存泄露，在Java中，静态字段通常拥有与整个应用程序相匹配的生命周期。<br>解决办法：最大限度的减少静态变量的使用；单例模式时，依赖于延迟加载对象而不是立即加载方式</p>\n<p>（2）未关闭的资源导致内存泄露<br>每当创建连接或者打开流时，JVM都会为这些资源分配内存。如果没有关闭连接，会导致持续占有内存。在任意情况下，资源留下的开放连接都会消耗内存，如果我们不处理，就会降低性能，甚至OOM。<br>解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；jdk1.7后，可以使用try-with-resource块</p>\n<h2 id=\"2-5、方法区\"><a href=\"#2-5、方法区\" class=\"headerlink\" title=\"2.5、方法区\"></a>2.5、方法区</h2><h3 id=\"2-5-1、结构\"><a href=\"#2-5-1、结构\" class=\"headerlink\" title=\"2.5.1、结构\"></a>2.5.1、结构</h3><p>方法区是java虚拟机的一个模型规范，具体实现是永久代和元空间。方法区存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等<br>方法区在程序启动时被创建，方法区是一个概念。具体实现有永久代（1.8前）和元空间（1.8）永久代用的是堆内存，元空间用的是本地内存（也就是操作系统的内存）</p>\n<blockquote>\n<p>方法区如果内存不足，也会抛出<strong>OutofMemoryError</strong> 的异常</p>\n</blockquote>\n<h3 id=\"2-5-2、class常量池\"><a href=\"#2-5-2、class常量池\" class=\"headerlink\" title=\"2.5.2、class常量池\"></a>2.5.2、class常量池</h3><p>Java 文件被编译成 Class 文件，Class 文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项就是 Class 常量池，<strong>Class 常量池是当 Class 文件被 Java 虚拟机加载进来后存放各种字面量和符号引用</strong></p>\n<blockquote>\n<p>类的加载过程中的链接部分的解析步骤就是把符号引用替换为直接引用，即把那些描述符（名字）替换为能直接定位到字段、方法的引用或句柄（地址）</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222238635.png\" alt=\"image (21).png\"></p>\n<p>System.out.println(“hello”)经过反编译后的内容如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javap -v F:\\Thread_study\\src\\com\\nyima\\JVM\\day01\\Main.class</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222239362.png\" alt=\"class常量池\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1658211741107-6e92db9f-e7b1-4fe3-9b54-0f608dad19b6.png#clientId=u2849290d-6927-4&from=paste&id=u0f35b784&originHeight=410&originWidth=1118&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3e3cb8ec-7f59-44f8-b925-f1bce7b280b&title=\"><br><img src=\"https://cdn.nlark.com/yuque/0/2022/png/2996398/1658211750067-5a5fe357-17ac-4ed5-8463-862b32649804.png#clientId=u2849290d-6927-4&from=paste&id=u52353eda&originHeight=236&originWidth=1122&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ue01b07e2-503e-45f1-b6a7-3479b81cc26&title=\"></p>\n<p>虚拟机中执行编译的方法（框内的是真正编译执行的内容，**#号的内容需要在常量池中查找**）</p>\n<h3 id=\"2-5-3、运行时常量池\"><a href=\"#2-5-3、运行时常量池\" class=\"headerlink\" title=\"2.5.3、运行时常量池\"></a>2.5.3、运行时常量池</h3><p>运行时常量池是方法区的一部分。运行时常量池是当 Class 文件被加载到内存后，Java虚拟机会将 Class 文件常量池里的内容转移到运行时常量池里，<strong>并且把里面的符号地址变为真实地址</strong></p>\n<h3 id=\"2-5-4、字符串常量池\"><a href=\"#2-5-4、字符串常量池\" class=\"headerlink\" title=\"2.5.4、字符串常量池\"></a>2.5.4、字符串常量池</h3><p>JVM为了提高性能，减少内存开销，维护的一个存放字符串常量的内存区域，里面的字符串不允许重复，有长度限制，最大为65535字节</p>\n<ol>\n<li><strong>两种创建字符串对象不同方式的比较</strong></li>\n</ol>\n<p>（1）采用字面值的方式创建字符串对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Str</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        String str1=<span class=\"string\">&quot;aaa&quot;</span>;</span><br><span class=\"line\">        String str2=<span class=\"string\">&quot;aaa&quot;</span>;</span><br><span class=\"line\">        System.out.println(str1==str2);   </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 运行结果：</span></span><br><span class=\"line\"><span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>采用字面值的方式创建一个字符串时，JVM 首先会去字符串池中查找是否存在 “aaa” 这个对象，如果不存在，则在字符串池中创建 “aaa” 这个对象，然后将池中 “aaa” 这个对象的引用地址返回给字符串常量 str，这样 str 会指向池中”aaa”这个字符串对象；如果存在，则不创建任何对象，直接将池中 “aaa” 这个对象的地址返回，赋给字符串常量。</p>\n</blockquote>\n<blockquote>\n<p>对于上述的例子：这是因为，创建字符串对象 str2 时，字符串池中已经存在 “aaa” 这个对象，直接把对象 “aaa” 的引用地址返回给 str2，这样 str2 指向了池中 “aaa” 这个对象，也就是说 str1 和 str2 指向了同一个对象，因此语句 System.out.println(str1&#x3D;&#x3D; str2) 输出：true。</p>\n</blockquote>\n<p>2）采用 new 关键字新建一个字符串对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Str</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        String str1=<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">        String str2=<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;aaa&quot;</span>);</span><br><span class=\"line\">        System.out.println(str1==str2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 运行结果：</span></span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>采用 new 关键字新建一个字符串对象时，JVM 首先在字符串常量池中查找有没有 “aaa” 这个字符串对象，如果有，则不在池中再去创建 “aaa” 这个对象了，直接在堆中创建一个 “aaa” 字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用 str1，这样，str1 就指向了堆中创建的这个 “aaa” 字符串对象；如果没有，则首先在字符串常量池池中创建一个 “aaa” 字符串对象，然后再在堆中创建一个 “aaa” 字符串对象，然后将堆中这个 “aaa” 字符串对象的地址返回赋给 str1 引用，这样，str1 指向了堆中创建的这个 “aaa” 字符串对象。</p>\n</blockquote>\n<blockquote>\n<p>对于上述的例子：因为，采用new关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str1和str2指向的是两个不同的对象，因此语句System.out.println(str1 &#x3D;&#x3D; str2)输出：false</p>\n</blockquote>\n<ul>\n<li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab &#x3D; “ab” 一致。</li>\n<li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li>\n</ul>\n<ol start=\"2\">\n<li><strong>字符串拼接问题</strong></li>\n</ol>\n<p>（1）字符串变量拼接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StringTableStudy</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;a&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;b&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">ab</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//拼接字符串对象来创建新的字符串</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">ab2</span> <span class=\"operator\">=</span> a+b; </span><br><span class=\"line\">        System.out.println(ab == ab2);  <span class=\"comment\">//false</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>通过变量拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()<br>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>\n</blockquote>\n<p>（2）字符串拼接</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">StringTableStudy</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">a</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;a&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">b</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;b&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">ab</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//拼接字符串对象来创建新的字符串</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">ab2</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;a&quot;</span>+<span class=\"string\">&quot;b&quot;</span>; </span><br><span class=\"line\">        System.out.println(ab == ab2);  <span class=\"comment\">//true</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接引用串池中的地址，所以进行的操作和 ab &#x3D; “ab” 一致。</p>\n</blockquote>\n<ol start=\"3\">\n<li>i<strong>ntern方法</strong></li>\n</ol>\n<p>jdk1.8调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中，如果有则不会放入</p>\n<blockquote>\n<p>jdk1.6调用字符串对象的intern方法，会将该字符串对象复制一份放入到串池中，如果有则不会放入</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Main</span> &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;a&quot;</span>) + <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;b&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将串池引用指向堆，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">st2</span> <span class=\"operator\">=</span> str.intern();</span><br><span class=\"line\">\t\t<span class=\"comment\">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span></span><br><span class=\"line\">\t\t<span class=\"type\">String</span> <span class=\"variable\">str3</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;ab&quot;</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class=\"line\">        <span class=\"comment\">// 注意：上面的结果是在1.8下，在1.6下都为false（字符串常量池和堆不是一个对象）</span></span><br><span class=\"line\">\t\tSystem.out.println(str == st2);</span><br><span class=\"line\">\t\tSystem.out.println(str == str3);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>思考</li>\n</ol>\n<p>（1）String str &#x3D; new String(“abc”);创建了几个对象，常量池有abc字段是1个，常量池没有”abc”字段则是2个。<br>（2）String str&#x3D;“abc”;创建了几个对象（如果常量池里面已经有对象了就是0个。如果没有就是1个）;<br>（3）new String(“abc”).intern();创建了几个对象（如果常量池里面已经有该字符串对象了就是1个，如果没有就是两个）<br>（4）string a &#x3D; “a”+”b“创建几个对象？0个或1个。因为编译器优化，不会创建”a”或”b”.</p>\n<h1 id=\"3、垃圾回收算法\"><a href=\"#3、垃圾回收算法\" class=\"headerlink\" title=\"3、垃圾回收算法\"></a>3、垃圾回收算法</h1><h2 id=\"3-1、如何判断一个对象可以被回收\"><a href=\"#3-1、如何判断一个对象可以被回收\" class=\"headerlink\" title=\"3.1、如何判断一个对象可以被回收\"></a>3.1、如何判断一个对象可以被回收</h2><ol>\n<li>引用计数法</li>\n</ol>\n<p>每个对象关联一个引用计数器属性，任何一个对象引用了A，引用计数器的值加1.当引用失效时，引用计数器就减1.当引用计数器的值为0时，表示对象不再被使用，可进行回收</p>\n<blockquote>\n<p>缺点：（1）需要单独的字段存储计数器，这样增加了存储空间的开销 （2）每次赋值都要更新计数器值，增加了时间开销 （3）存在循环引用的问题（所以jvm不用）</p>\n</blockquote>\n<ol start=\"2\">\n<li>可达性分析法</li>\n</ol>\n<p>设立若干根对象（GC Root Object），当任何一个根对象到某一个对象均不可达时，认为这个对象可以被回收</p>\n<blockquote>\n<p>哪些对象可以被作为根对象？</p>\n<ul>\n<li>虚拟机栈(栈帧中的本地变量表)中引用的对象。就是在方法中new的对象</li>\n<li>方法区中静态属性引用的对象用static修饰的全局的静态的对象</li>\n<li>方法区中常量引用的对象static final关键字</li>\n<li>本地方法栈中(Native方法)引用的对象引用Native方法的所有对象</li>\n</ul>\n</blockquote>\n<p>为什么这些对象可以作为根对象？</p>\n<blockquote>\n<p>GC Root 需要确保引用所指的对象都是活着的,而当前线程栈帧中的对象，在这一时刻是存活的。</p>\n</blockquote>\n<h2 id=\"3-2、五种引用\"><a href=\"#3-2、五种引用\" class=\"headerlink\" title=\"3.2、五种引用\"></a>3.2、五种引用</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222241216.png\" alt=\"五种引用\"></p>\n<ol>\n<li><strong>强引用</strong>：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它</li>\n</ol>\n<blockquote>\n<p>在java程序中，一般由Object object &#x3D; new Object();定义的object就是一个强引用<br>如上图B、C对象都不引用A1对象时，A1对象才会被回收</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>软引用</strong>：当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象</li>\n</ol>\n<blockquote>\n<p>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收<br>作用：软引用是用来描述一些有用但并不是必需的对象，JVM 内存空间充足的时候将数据缓存在内存中，如果空间不足了就将其回收掉</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">String</span> <span class=\"variable\">str</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;456&quot;</span>);</span><br><span class=\"line\">SoftReference&lt;String&gt; softReference = <span class=\"keyword\">new</span> <span class=\"title class_\">SoftReference</span>&lt;String&gt;(str);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>弱引用</strong>：有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</li>\n</ol>\n<blockquote>\n<p>如上图如果B对象不再引用A3对象，则A3对象会被回收</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eakReference&lt;String&gt; sr = <span class=\"keyword\">new</span> <span class=\"title class_\">WeakReference</span>&lt;String&gt;(<span class=\"keyword\">new</span> <span class=\"title class_\">String</span>(<span class=\"string\">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><strong>虚引用</strong>：  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列</li>\n</ol>\n<p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。你声明虚引用的时候是要传入一个queue的。当你的虚引用所引用的对象已经执行完finalize函数的时候，就会把对象加到queue里面。你可以通过判断queue里面是不是有对象来判断你的对象是不是要被回收了</p>\n<blockquote>\n<p>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PhantomReference&lt;String&gt; abcWeakRef = <span class=\"keyword\">new</span> <span class=\"title class_\">PhantomReference</span>&lt;String&gt;(abc, referenceQueue);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li><strong>引用强度</strong></li>\n</ol>\n<p>强引用&gt;软引用&gt;弱引用&gt;虚引用</p>\n<h2 id=\"3-3、垃圾回收算法\"><a href=\"#3-3、垃圾回收算法\" class=\"headerlink\" title=\"3.3、垃圾回收算法\"></a>3.3、垃圾回收算法</h2><h3 id=\"3-3-1、标记清除算法\"><a href=\"#3-3-1、标记清除算法\" class=\"headerlink\" title=\"3.3.1、标记清除算法\"></a>3.3.1、标记清除算法</h3><ol>\n<li>概念：通过根节点，标记所有根节点开始的可达对象，清除未被标记对象</li>\n<li>优点：算法简单</li>\n<li>缺点：（1）产生内存碎片，造成新来的大对象（如数组）可能没有有效的内存空间</li>\n</ol>\n<h3 id=\"3-3-2、标记整理算法（老年代默认）\"><a href=\"#3-3-2、标记整理算法（老年代默认）\" class=\"headerlink\" title=\"3.3.2、标记整理算法（老年代默认）\"></a>3.3.2、标记整理算法（老年代默认）</h3><ol>\n<li>概念：将标记的对象移动到内存的一端，清除边界外的所有空间</li>\n<li>优点：解决了标记清除算法的碎片问题</li>\n<li>缺点：效率低（整理后依赖这个对象的对象更新一下引用地址信息）</li>\n</ol>\n<h3 id=\"3-3-3、复制算法（新生代默认）\"><a href=\"#3-3-3、复制算法（新生代默认）\" class=\"headerlink\" title=\"3.3.3、复制算法（新生代默认）\"></a>3.3.3、复制算法（新生代默认）</h3><ol>\n<li>概念：将内存分为一块较大的Eden和两块较小的survivor，每次使用Eden和其中一块survivo,gc时将Eden存活对象复制到suvivorTo,suvivorFrom存活的对象没有达到分代年龄阈值时复制到suvivorTo，达到分带年龄阈值复制到老年区，之后清除Eden和suvivorFrom的对象,交换两个suvivor的角色,后面以此类推</li>\n<li>优点：（1）不会产生内存碎片（2）在存活对象不多的情况下，效率较高，适合新生代</li>\n<li>缺点：浪费内存空间，始终要有一个空闲的survivor</li>\n</ol>\n<h2 id=\"3-4、FULL-GC原因\"><a href=\"#3-4、FULL-GC原因\" class=\"headerlink\" title=\"3.4、FULL GC原因\"></a>3.4、FULL GC原因</h2><blockquote>\n<p>Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，元空间等。是说在这次GC的全过程中所有用户线程都是处于暂停的状态（stop the world）</p>\n</blockquote>\n<ol>\n<li><strong>System.gc()方法的调用</strong></li>\n</ol>\n<p>在代码中调用System.gc()方法会建议JVM进行Full GC，但是注意这只是建议，JVM执行不执行是另外一回事儿，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p>\n<ol start=\"2\">\n<li><strong>老年代空间不足</strong></li>\n</ol>\n<p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space</p>\n<h1 id=\"4、垃圾回收器\"><a href=\"#4、垃圾回收器\" class=\"headerlink\" title=\"4、垃圾回收器\"></a>4、垃圾回收器</h1><h2 id=\"4-1、新生代垃圾收集器\"><a href=\"#4-1、新生代垃圾收集器\" class=\"headerlink\" title=\"4.1、新生代垃圾收集器\"></a>4.1、新生代垃圾收集器</h2><h3 id=\"4-1-1、Serial（串行）收集器\"><a href=\"#4-1-1、Serial（串行）收集器\" class=\"headerlink\" title=\"4.1.1、Serial（串行）收集器\"></a>4.1.1、Serial（串行）收集器</h3><ol>\n<li><strong>概念</strong>：Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程</li>\n</ol>\n<blockquote>\n<p>优点：简单高效，拥有很高的单线程收集效率<br>  缺点：收集过程需要暂停所有线程<br>  算法：复制算法应用</p>\n</blockquote>\n<ol start=\"2\">\n<li><strong>收集过程</strong></li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242409.png\" alt=\"image (23).png\"></p>\n<h3 id=\"4-1-2、ParNew-收集器\"><a href=\"#4-1-2、ParNew-收集器\" class=\"headerlink\" title=\"4.1.2、ParNew 收集器\"></a>4.1.2、ParNew 收集器</h3><ol>\n<li><strong>概念：</strong>可以把这个收集器理解为Serial收集器的多线程版本</li>\n</ol>\n<blockquote>\n<p>优点：在多CPU时，比Serial效率高。<br>  缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。<br>  算法：复制算法</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242011.png\" alt=\"image (24).png\"></p>\n<h3 id=\"4-1-3、Parallel-Scavenge-收集器\"><a href=\"#4-1-3、Parallel-Scavenge-收集器\" class=\"headerlink\" title=\"4.1.3、Parallel Scavenge 收集器\"></a>4.1.3、Parallel Scavenge 收集器</h3><ol>\n<li><strong>概念</strong>：Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的吞吐量 。</li>\n<li><strong>可设置参数</strong>：-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间， -XX:GC Time Ratio直接设置吞吐量的大小</li>\n</ol>\n<blockquote>\n<p>吞吐量 &#x3D; 运行用户代码的时间 &#x2F; (运行用户代码的时间 + 垃圾收集时间)<br>  比如虚拟机总共运行了120秒，垃圾收集时间用了1秒，吞吐量&#x3D;(120-1)&#x2F;120&#x3D;99.167%。<br>  若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</p>\n</blockquote>\n<h2 id=\"4-2、老年代收集器\"><a href=\"#4-2、老年代收集器\" class=\"headerlink\" title=\"4.2、老年代收集器\"></a>4.2、老年代收集器</h2><h3 id=\"4-2-1、serial-old\"><a href=\"#4-2-1、serial-old\" class=\"headerlink\" title=\"4.2.1、serial old\"></a>4.2.1、serial old</h3><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用”标记-整理算法”，运行过程和Serial收集器一样。</p>\n<h3 id=\"4-2-2、Parallel-old\"><a href=\"#4-2-2、Parallel-old\" class=\"headerlink\" title=\"4.2.2、Parallel old\"></a>4.2.2、Parallel old</h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理算法”进行垃圾回收，吞吐量优先。<br><strong>回收算法</strong>：标记-整理<br><strong>适用场景</strong>：为了替代serial old与Parallel Scanvenge配合使用。</p>\n<h3 id=\"4-2-3、CMS\"><a href=\"#4-2-3、CMS\" class=\"headerlink\" title=\"4.2.3、CMS\"></a>4.2.3、CMS</h3><ol>\n<li><strong>特点：</strong>最短回收停顿时间，</li>\n<li><strong>回收算法：</strong>标记-清除</li>\n<li><strong>回收步骤：</strong><br>（1）初始标记：标记GC Roots直接关联的对象，速度快<br>（2）并发标记：GC Roots Tracing过程，耗时长，与用户进程并发工作<br>（3）重新标记：修正并发标记期间用户进程运行而产生变化的标记，好事比初始标记长，但是远远小于并发标记<br>（4）并发清除：清除标记的对象</li>\n<li><strong>缺点</strong>：</li>\n</ol>\n<p>对CPU资源非常敏感，CPU少于4个时，CMS岁用户程序的影响可能变得很大，由此虚拟机提供了“增量式并发收集器”；无法回收浮动垃圾；采用标记清除算法会产生内存碎片，不过可以通过参数开启内存碎片的合并整理。</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222243378.png\" alt=\"image (25).png\"></p>\n<h2 id=\"4-3、整堆收集器\"><a href=\"#4-3、整堆收集器\" class=\"headerlink\" title=\"4.3、整堆收集器\"></a>4.3、整堆收集器</h2><h3 id=\"4-3-1、G1\"><a href=\"#4-3-1、G1\" class=\"headerlink\" title=\"4.3.1、G1\"></a>4.3.1、G1</h3><ol>\n<li><strong>基本概念</strong></li>\n</ol>\n<p>G1将整个JVM堆划分成多个大小相等的独立区域regin，跟踪各个regin里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收最大的regin，当然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离了，他们都是一部分regin集合。内存“化整为零”的思路：在GC根节点的枚举范围汇总加入remembered set 即可保证不对全堆扫面也不会遗漏。</p>\n<ol start=\"2\">\n<li><strong>回收步骤</strong>：<br>（1）初始标记：标记GC Roots直接关联的对象<br>（2）并发标记：对堆中对象进行可达性分析，找出存活对象，耗时长，与用户进程并发工作<br>（3）重新标记：修正并发标记期间用户进程继续运行而产生变化的标记<br>（4）筛选回收：对各个regin的回收价值进行排序，然后根据期望的GC停顿时间制定回收计划</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222244637.png\" alt=\"G1垃圾收集器\"></p>\n<h3 id=\"4-3-2、ZGC\"><a href=\"#4-3-2、ZGC\" class=\"headerlink\" title=\"4.3.2、ZGC\"></a>4.3.2、ZGC</h3><p>ZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。<br>在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。<br><strong>优点</strong>：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小<br><strong>缺点</strong>：浮动垃圾<br>目前使用的非常少，真正普及还是需要写时间的。</p>\n<h2 id=\"4-4、垃圾收集器的选择？\"><a href=\"#4-4、垃圾收集器的选择？\" class=\"headerlink\" title=\"4.4、垃圾收集器的选择？\"></a>4.4、垃圾收集器的选择？</h2><p>jdk1.8 前默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）<br>jdk1.9 默认垃圾收集器G1</p>\n<ol>\n<li>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数：-XX:+UseSerialGC。</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"2\">\n<li>如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数：-XX:+UseParallelGC。</span><br></pre></td></tr></table></figure>\n\n\n<ol start=\"3\">\n<li>如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择G1、ZGC、CMS都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">参数：</span><br><span class=\"line\">-XX:+UseConcMarkSweepGC、</span><br><span class=\"line\">-XX:+UseG1GC、</span><br><span class=\"line\">-XX:+UseZGC 等。</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5、类加载机制\"><a href=\"#5、类加载机制\" class=\"headerlink\" title=\"5、类加载机制\"></a>5、类加载机制</h1><p>虚拟机把类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的类加载机制</p>\n<h2 id=\"5-1、类加载过程\"><a href=\"#5-1、类加载过程\" class=\"headerlink\" title=\"5.1、类加载过程\"></a>5.1、类加载过程</h2><h3 id=\"5-1-1、加载阶段\"><a href=\"#5-1-1、加载阶段\" class=\"headerlink\" title=\"5.1.1、加载阶段\"></a>5.1.1、加载阶段</h3><p>（1）通过一个类的全限定名来获取定义此类的二进制字节流<br>（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p>\n<h3 id=\"5-1-2、链接阶段\"><a href=\"#5-1-2、链接阶段\" class=\"headerlink\" title=\"5.1.2、链接阶段\"></a>5.1.2、链接阶段</h3><p>（1）<strong>验证</strong>： 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p>\n<blockquote>\n<p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，如：是否以模数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内等等。<br><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；如：这个类是否有父类，是否实现了父类的抽象方法，是否重写了父类的final方法，是否继承了被final修饰的类等等。<br><strong>符号引用验证</strong>：确保解析动作能正确执行；如：通过符合引用能找到对应的类和方法，符号引用中类、属性、方法的访问性是否能被当前类访问等等<br>（验证阶段是非常重要的，但不是必须的。可以采用-Xverify:none参数来关闭大部分的类验证措施）</p>\n</blockquote>\n<p>（2）<strong>准备</strong>：为类的静态变量分配内存，并将其赋默认值</p>\n<blockquote>\n<p>为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：<br>只对<strong>static</strong>修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。<br>对<strong>final</strong>的静态字面值常量直接赋初值（赋初值不是赋默认值，如果不是字面值静态常量，那么会和静态变量一样赋默认值）</p>\n</blockquote>\n<p>（3）<strong>解析</strong>：将常量池中的符号引用替换为直接引用（内存地址）的过程</p>\n<blockquote>\n<p>符号引用：就是一组符号来描述目标，可以是任何字面量。属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符（eg:java.lang.String）。<br>  直接引用：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。如指向方法区某个类的一个指针</p>\n</blockquote>\n<h3 id=\"5-1-3、初始化阶段\"><a href=\"#5-1-3、初始化阶段\" class=\"headerlink\" title=\"5.1.3、初始化阶段\"></a>5.1.3、初始化阶段</h3><p>为类的静态变量赋初值</p>\n<blockquote>\n<p>赋初值两种方式：<br>（1）定义静态变量时指定初始值。如 private static String x&#x3D;”123”;<br>（2）在静态代码块里为静态变量赋值。如 static{ x&#x3D;”123”; }<br> 注意：只有对类的主动使用才会导致类的初始化。</p>\n</blockquote>\n<p><strong>初始化顺序：</strong><br>（1）静态初始化 ：父类静态成员和static块-子类静态成员和static块<br>（2）父类初始化：父类普通成员和非static块-父类构造函数<br>（3）子类初始化：子类普通成员和非static块-子类构造函数</p>\n<h2 id=\"5-2、类加载器分类\"><a href=\"#5-2、类加载器分类\" class=\"headerlink\" title=\"5.2、类加载器分类\"></a>5.2、类加载器分类</h2><ol>\n<li><strong>启动类加载器</strong></li>\n</ol>\n<p>使用c++实现，加载jre和jre&#x2F;lib目录下的核心库</p>\n<ol start=\"2\">\n<li><strong>扩展类加载器</strong></li>\n</ol>\n<p>java编写，父加载器为启动类加载器，从jre&#x2F;lib&#x2F;ext下加载类库</p>\n<ol start=\"3\">\n<li><strong>应用类加载器</strong></li>\n</ol>\n<p>负责加载用户类路径（classpath）上的指定类库</p>\n<h2 id=\"5-3、双亲委派机制\"><a href=\"#5-3、双亲委派机制\" class=\"headerlink\" title=\"5.3、双亲委派机制\"></a>5.3、双亲委派机制</h2><p>当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类</p>\n<p><strong>好处：</strong></p>\n<ol>\n<li>避免重复加载，通过委托去向上面问一问，加载过了，就不用再加载一遍</li>\n<li>保证核心api定义的类型不会被随意篡改，比如自己定义一个java.lang.String，顶级加载器系统类加载器加载时会加载核心包下的String类而不是自定义的。保证了核心类的安全</li>\n</ol>\n<h1 id=\"6、逃逸分析\"><a href=\"#6、逃逸分析\" class=\"headerlink\" title=\"6、逃逸分析\"></a>6、逃逸分析</h1><p>我们都知道，java里面绝大多数对象都是存放在堆里面的，然后当对象没用的时候就会靠垃圾回收器去回收对象。那么什么是栈上分配呢？</p>\n<h2 id=\"6-1、逃逸方式\"><a href=\"#6-1、逃逸方式\" class=\"headerlink\" title=\"6.1、逃逸方式\"></a>6.1、逃逸方式</h2><ol>\n<li>方法逃逸：在一个方法体内，定义一个局部变量，而它可能被外部方法引用，比如作为调用参数传递给方法，或作为对象直接返回。或者，可以理解成对象跳出了方法</li>\n<li>线程逃逸：这个对象被其他线程访问到，比如赋值给了实例变量，并被其他线程访问到了。对象逃出了当前线程</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222246915.png\" alt=\"逃逸分析\"></p>\n<h2 id=\"6-2、逃逸结果\"><a href=\"#6-2、逃逸结果\" class=\"headerlink\" title=\"6.2、逃逸结果\"></a>6.2、逃逸结果</h2><ol>\n<li>栈上分配</li>\n</ol>\n<p>如果通过<strong>逃逸分析</strong>，能够确认对象不会发生逃逸行为，就会在栈上分配对象。如果在栈上分配对象的话，这个对象占用的空间就会在栈帧出栈的时候被销毁，所以，通过栈上分配可以降低垃圾回收的压力</p>\n<ol start=\"2\">\n<li>标量替换</li>\n</ol>\n<p>　　</p>\n<p>Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。</p>\n"},{"title":"dubbo","date":"2023-08-03T16:00:00.000Z","abbrlink":22179,"_content":"\n# 1、基本概念\nApache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现\n\n >**dubbo可以是微服务的一部分，但不能以偏概全说dubbo就是微服务**，微服务涉及的面比较广，比如服务发现，服务治理，服务网关，服务监控，链路追踪等等，可以用到的组件也比较多，而dubbo最多只能说是专注于服务治理的组件，所以从这一点上来看，可替代它的技术也是相当之多的，比如一系列rpc框架都可以\n\n## 1.1、基本架构\n\n![dubbo架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308041522327.png)\n\n\nProvider 暴露服务的服务提供方\nConsumer 调用远程服务的服务消费方\nRegistry 服务注册与发现的注册中心\nMonitor 统计服务的调用次数和调用时间的监控中心\n\n## 1.2、调用流程\n\n1. 服务启动，包括服务提供者和消费者的启动，封装服务调用链路。\n2. 服务提供者在启动时，向注册中心注册自己提供的服务。\n3. 服务消费者在启动时，向注册中心订阅自己所需的服务。\n4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n5. 服务消费者，从提供者地址列表中，基于服务路由信息、负载均衡规则，选一台提供者进行调用。\n6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时发送一次统计数据到监控中心。\n7. 服务提供方停止服务或者服务调用方关闭JVM的时候，会将provider及consumer进行销毁处理。\n\n\n# 2、Dubbo环境搭建\n## 2.1、安装zookeeper\n\n1. 下载zookeeper\n\n网址:\n[https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/](https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/)  \n\n2. 解压zookeeper\n解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件 \n\n3. 修改zoo.cfg配置文件\n将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可,修改完成后再次启动zookeeper \n\n>注意几个重要位置:\ndataDir=./   临时数据存储的目录（可写相对路径）\nclientPort=2181   zookeeper的端口号\n\n4. 使用zkCli.cmd/sh测试\n\n>ls /：列出zookeeper根下保存的所有节点\ncreate –e /kaka123：创建一个kaka节点，值为123\nget /kaka：获取/kaka节点的值\n>(dubbo注册后一个group是一个节点)\n\n\n## 2.2、安装监控中心\n为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用\n\n1. 下载dubbo-admin\n[https://github.com/apache/incubator-dubbo-ops](https://github.com/apache/incubator-dubbo-ops) \n（注意是master分支） |\n\n\n2. 进入目录，修改dubbo-admin配置\n修改src\\\\main\\\\resources\\\\application.properties 指定zookeeper地址\n\n3. 打包dubbo-admin\n\n```shell\nmvn clean package\n```\n\n4. 运行dubbo-admin\n\n```shell\njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar\n```\n\n默认使用root/root 登陆\n\n## 2.3、父工程\n创建依赖\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>dubboDemo</artifactId>\n    <packaging>pom</packaging>\n    <version>1.0-SNAPSHOT</version>\n    <modules>\n        <module>provider</module>\n        <module>api</module>\n        <module>consumer</module>\n    </modules>\n\n    <!-- 父级引用 -->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.1.RELEASE</version>\n        <relativePath/>\n    </parent>\n\n\n    <!--配置-->\n    <properties>\n        <java.version>1.8</java.version>\n        <dubbo.version>2.7.5</dubbo.version>\n        <zookeeper.version>3.4.14</zookeeper.version>\n    </properties>\n\n\n    <!--声明全局依赖（子项目需要显示的引用才会继承依赖）-->\n    <dependencyManagement>\n        <dependencies>\n            <!-- dubbo-start依赖 -->\n            <dependency>\n                <groupId>org.apache.dubbo</groupId>\n                <artifactId>dubbo-spring-boot-starter</artifactId>\n                <version>${dubbo.version}</version>\n            </dependency>\n            <!--zookeeper 注册中心客户端引入 使用的是curator客户端 -->\n            <dependency>\n                <groupId>org.apache.dubbo</groupId>\n                <artifactId>dubbo-dependencies-zookeeper</artifactId>\n                <version>${dubbo.version}</version>\n                <type>pom</type>\n                <exclusions>\n                    <exclusion>\n                        <artifactId>slf4j-log4j12</artifactId>\n                        <groupId>org.slf4j</groupId>\n                    </exclusion>\n                </exclusions>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <!--声明全局依赖（子项目不需要显示的引用，自动继承依赖）-->\n    <dependencies>\n        <!-- spring boot 依赖 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <!-- 打包插件 -->\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n## 2.4、api模块\n创建接口\n\n```java\npublic interface Api1 {\n    public String test();\n}\n\n```\n\n## 2.5、服务提供者模块\n\n1. 引入依赖\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <parent>\n        <artifactId>dubboDemo</artifactId>\n        <groupId>org.example</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>provider</artifactId>\n\n    <dependencies>\n        <!--接口模块-->\n        <dependency>\n            <groupId>org.example</groupId>\n            <artifactId>api</artifactId>\n            <version>1.0-SNAPSHOT</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-spring-boot-starter</artifactId>\n        </dependency>\n        <!-- zookeeper依赖 -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-dependencies-zookeeper</artifactId>\n            <version>${dubbo.version}</version>\n            <type>pom</type>\n            <exclusions>\n                <exclusion>\n                    <artifactId>slf4j-log4j12</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n2. 配置文件\n\n```java\nserver:\n  # 服务端口\n  port: 7777\nspring:\n  application:\n    name: provider\n# dubbo 相关配置(dubbo 的配置不再以 Spring 开头)\ndubbo:\n  application:\n    # 应用名称\n    name: provider\n  scan:\n    # 接口实现者（服务实现）包\n    base-packages: com.kaka.service\n  # 注册中心信息\n  registry:\n    address: zookeeper://127.0.0.1:2181\n  protocol:\n    # 协议名称\n    name: dubbo\n    # 协议端口\n    port: 20880\n```\n\n3. 服务实现\n\n```java\n@Service\npublic class Service1 implements Api1 {\n    @Override\n    public String test() {\n        System.out.println(\"服务提供者提供服务...\");\n        return \"success\";\n    }\n}\n```\n## 2.6、服务消费者\n\n1. 依赖\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <parent>\n        <artifactId>dubboDemo</artifactId>\n        <groupId>org.example</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>consumer</artifactId>\n    <dependencies>\n        <!--接口模块-->\n        <dependency>\n            <groupId>org.example</groupId>\n            <artifactId>api</artifactId>\n            <version>1.0-SNAPSHOT</version>\n        </dependency>\n\n        <!-- web项目依赖 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!-- dubbo依赖 -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-spring-boot-starter</artifactId>\n        </dependency>\n\n        <!-- dubbo的zookeeper依赖 -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-dependencies-zookeeper</artifactId>\n            <version>${dubbo.version}</version>\n            <type>pom</type>\n            <exclusions>\n                <exclusion>\n                    <artifactId>slf4j-log4j12</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n2. 配置文件\n\n```java\nserver:\n  port: 7000\nspring:\n  application:\n    name: consumer\n# dubbo 相关配置\ndubbo:\n  application:\n    name: consumer\n  registry:\n    address: zookeeper://127.0.0.1:2181\n```\n\n3. 消费者类\n\n```java\n@RestController\npublic class Consumer1 {\n    @Reference\n    Api1 api1;\n\n    @GetMapping(\"/test\")\n    public String getOrder() {\n        String test = api1.test();\n        return test;\n    }\n}\n```\n","source":"_posts/dubbo.md","raw":"---\ntitle: dubbo\ndate: 2023/08/04\ncategories:\n  - coding\ntags:\n  - dubbo\n  - 编程基础\nabbrlink: 22179\n---\n\n# 1、基本概念\nApache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现\n\n >**dubbo可以是微服务的一部分，但不能以偏概全说dubbo就是微服务**，微服务涉及的面比较广，比如服务发现，服务治理，服务网关，服务监控，链路追踪等等，可以用到的组件也比较多，而dubbo最多只能说是专注于服务治理的组件，所以从这一点上来看，可替代它的技术也是相当之多的，比如一系列rpc框架都可以\n\n## 1.1、基本架构\n\n![dubbo架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308041522327.png)\n\n\nProvider 暴露服务的服务提供方\nConsumer 调用远程服务的服务消费方\nRegistry 服务注册与发现的注册中心\nMonitor 统计服务的调用次数和调用时间的监控中心\n\n## 1.2、调用流程\n\n1. 服务启动，包括服务提供者和消费者的启动，封装服务调用链路。\n2. 服务提供者在启动时，向注册中心注册自己提供的服务。\n3. 服务消费者在启动时，向注册中心订阅自己所需的服务。\n4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。\n5. 服务消费者，从提供者地址列表中，基于服务路由信息、负载均衡规则，选一台提供者进行调用。\n6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时发送一次统计数据到监控中心。\n7. 服务提供方停止服务或者服务调用方关闭JVM的时候，会将provider及consumer进行销毁处理。\n\n\n# 2、Dubbo环境搭建\n## 2.1、安装zookeeper\n\n1. 下载zookeeper\n\n网址:\n[https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/](https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/)  \n\n2. 解压zookeeper\n解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件 \n\n3. 修改zoo.cfg配置文件\n将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可,修改完成后再次启动zookeeper \n\n>注意几个重要位置:\ndataDir=./   临时数据存储的目录（可写相对路径）\nclientPort=2181   zookeeper的端口号\n\n4. 使用zkCli.cmd/sh测试\n\n>ls /：列出zookeeper根下保存的所有节点\ncreate –e /kaka123：创建一个kaka节点，值为123\nget /kaka：获取/kaka节点的值\n>(dubbo注册后一个group是一个节点)\n\n\n## 2.2、安装监控中心\n为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用\n\n1. 下载dubbo-admin\n[https://github.com/apache/incubator-dubbo-ops](https://github.com/apache/incubator-dubbo-ops) \n（注意是master分支） |\n\n\n2. 进入目录，修改dubbo-admin配置\n修改src\\\\main\\\\resources\\\\application.properties 指定zookeeper地址\n\n3. 打包dubbo-admin\n\n```shell\nmvn clean package\n```\n\n4. 运行dubbo-admin\n\n```shell\njava -jar dubbo-admin-0.0.1-SNAPSHOT.jar\n```\n\n默认使用root/root 登陆\n\n## 2.3、父工程\n创建依赖\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>org.example</groupId>\n    <artifactId>dubboDemo</artifactId>\n    <packaging>pom</packaging>\n    <version>1.0-SNAPSHOT</version>\n    <modules>\n        <module>provider</module>\n        <module>api</module>\n        <module>consumer</module>\n    </modules>\n\n    <!-- 父级引用 -->\n    <parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.1.1.RELEASE</version>\n        <relativePath/>\n    </parent>\n\n\n    <!--配置-->\n    <properties>\n        <java.version>1.8</java.version>\n        <dubbo.version>2.7.5</dubbo.version>\n        <zookeeper.version>3.4.14</zookeeper.version>\n    </properties>\n\n\n    <!--声明全局依赖（子项目需要显示的引用才会继承依赖）-->\n    <dependencyManagement>\n        <dependencies>\n            <!-- dubbo-start依赖 -->\n            <dependency>\n                <groupId>org.apache.dubbo</groupId>\n                <artifactId>dubbo-spring-boot-starter</artifactId>\n                <version>${dubbo.version}</version>\n            </dependency>\n            <!--zookeeper 注册中心客户端引入 使用的是curator客户端 -->\n            <dependency>\n                <groupId>org.apache.dubbo</groupId>\n                <artifactId>dubbo-dependencies-zookeeper</artifactId>\n                <version>${dubbo.version}</version>\n                <type>pom</type>\n                <exclusions>\n                    <exclusion>\n                        <artifactId>slf4j-log4j12</artifactId>\n                        <groupId>org.slf4j</groupId>\n                    </exclusion>\n                </exclusions>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n\n    <!--声明全局依赖（子项目不需要显示的引用，自动继承依赖）-->\n    <dependencies>\n        <!-- spring boot 依赖 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <!-- 打包插件 -->\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n## 2.4、api模块\n创建接口\n\n```java\npublic interface Api1 {\n    public String test();\n}\n\n```\n\n## 2.5、服务提供者模块\n\n1. 引入依赖\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <parent>\n        <artifactId>dubboDemo</artifactId>\n        <groupId>org.example</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>provider</artifactId>\n\n    <dependencies>\n        <!--接口模块-->\n        <dependency>\n            <groupId>org.example</groupId>\n            <artifactId>api</artifactId>\n            <version>1.0-SNAPSHOT</version>\n        </dependency>\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-spring-boot-starter</artifactId>\n        </dependency>\n        <!-- zookeeper依赖 -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-dependencies-zookeeper</artifactId>\n            <version>${dubbo.version}</version>\n            <type>pom</type>\n            <exclusions>\n                <exclusion>\n                    <artifactId>slf4j-log4j12</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n2. 配置文件\n\n```java\nserver:\n  # 服务端口\n  port: 7777\nspring:\n  application:\n    name: provider\n# dubbo 相关配置(dubbo 的配置不再以 Spring 开头)\ndubbo:\n  application:\n    # 应用名称\n    name: provider\n  scan:\n    # 接口实现者（服务实现）包\n    base-packages: com.kaka.service\n  # 注册中心信息\n  registry:\n    address: zookeeper://127.0.0.1:2181\n  protocol:\n    # 协议名称\n    name: dubbo\n    # 协议端口\n    port: 20880\n```\n\n3. 服务实现\n\n```java\n@Service\npublic class Service1 implements Api1 {\n    @Override\n    public String test() {\n        System.out.println(\"服务提供者提供服务...\");\n        return \"success\";\n    }\n}\n```\n## 2.6、服务消费者\n\n1. 依赖\n\n```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n    <parent>\n        <artifactId>dubboDemo</artifactId>\n        <groupId>org.example</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>consumer</artifactId>\n    <dependencies>\n        <!--接口模块-->\n        <dependency>\n            <groupId>org.example</groupId>\n            <artifactId>api</artifactId>\n            <version>1.0-SNAPSHOT</version>\n        </dependency>\n\n        <!-- web项目依赖 -->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <!-- dubbo依赖 -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-spring-boot-starter</artifactId>\n        </dependency>\n\n        <!-- dubbo的zookeeper依赖 -->\n        <dependency>\n            <groupId>org.apache.dubbo</groupId>\n            <artifactId>dubbo-dependencies-zookeeper</artifactId>\n            <version>${dubbo.version}</version>\n            <type>pom</type>\n            <exclusions>\n                <exclusion>\n                    <artifactId>slf4j-log4j12</artifactId>\n                    <groupId>org.slf4j</groupId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n```\n\n2. 配置文件\n\n```java\nserver:\n  port: 7000\nspring:\n  application:\n    name: consumer\n# dubbo 相关配置\ndubbo:\n  application:\n    name: consumer\n  registry:\n    address: zookeeper://127.0.0.1:2181\n```\n\n3. 消费者类\n\n```java\n@RestController\npublic class Consumer1 {\n    @Reference\n    Api1 api1;\n\n    @GetMapping(\"/test\")\n    public String getOrder() {\n        String test = api1.test();\n        return test;\n    }\n}\n```\n","slug":"dubbo","published":1,"updated":"2023-08-05T09:26:33.560Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9m000f00uj4nym77m0","content":"<h1 id=\"1、基本概念\"><a href=\"#1、基本概念\" class=\"headerlink\" title=\"1、基本概念\"></a>1、基本概念</h1><p>Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</p>\n<blockquote>\n<p><strong>dubbo可以是微服务的一部分，但不能以偏概全说dubbo就是微服务</strong>，微服务涉及的面比较广，比如服务发现，服务治理，服务网关，服务监控，链路追踪等等，可以用到的组件也比较多，而dubbo最多只能说是专注于服务治理的组件，所以从这一点上来看，可替代它的技术也是相当之多的，比如一系列rpc框架都可以</p>\n</blockquote>\n<h2 id=\"1-1、基本架构\"><a href=\"#1-1、基本架构\" class=\"headerlink\" title=\"1.1、基本架构\"></a>1.1、基本架构</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308041522327.png\" alt=\"dubbo架构\"></p>\n<p>Provider 暴露服务的服务提供方<br>Consumer 调用远程服务的服务消费方<br>Registry 服务注册与发现的注册中心<br>Monitor 统计服务的调用次数和调用时间的监控中心</p>\n<h2 id=\"1-2、调用流程\"><a href=\"#1-2、调用流程\" class=\"headerlink\" title=\"1.2、调用流程\"></a>1.2、调用流程</h2><ol>\n<li>服务启动，包括服务提供者和消费者的启动，封装服务调用链路。</li>\n<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>\n<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>\n<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>\n<li>服务消费者，从提供者地址列表中，基于服务路由信息、负载均衡规则，选一台提供者进行调用。</li>\n<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时发送一次统计数据到监控中心。</li>\n<li>服务提供方停止服务或者服务调用方关闭JVM的时候，会将provider及consumer进行销毁处理。</li>\n</ol>\n<h1 id=\"2、Dubbo环境搭建\"><a href=\"#2、Dubbo环境搭建\" class=\"headerlink\" title=\"2、Dubbo环境搭建\"></a>2、Dubbo环境搭建</h1><h2 id=\"2-1、安装zookeeper\"><a href=\"#2-1、安装zookeeper\" class=\"headerlink\" title=\"2.1、安装zookeeper\"></a>2.1、安装zookeeper</h2><ol>\n<li>下载zookeeper</li>\n</ol>\n<p>网址:<br><a href=\"https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/\">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/</a>  </p>\n<ol start=\"2\">\n<li><p>解压zookeeper<br>解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件 </p>\n</li>\n<li><p>修改zoo.cfg配置文件<br>将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可,修改完成后再次启动zookeeper</p>\n</li>\n</ol>\n<blockquote>\n<p>注意几个重要位置:<br>dataDir&#x3D;.&#x2F;   临时数据存储的目录（可写相对路径）<br>clientPort&#x3D;2181   zookeeper的端口号</p>\n</blockquote>\n<ol start=\"4\">\n<li>使用zkCli.cmd&#x2F;sh测试</li>\n</ol>\n<blockquote>\n<p>ls &#x2F;：列出zookeeper根下保存的所有节点<br>create –e &#x2F;kaka123：创建一个kaka节点，值为123<br>get &#x2F;kaka：获取&#x2F;kaka节点的值<br>(dubbo注册后一个group是一个节点)</p>\n</blockquote>\n<h2 id=\"2-2、安装监控中心\"><a href=\"#2-2、安装监控中心\" class=\"headerlink\" title=\"2.2、安装监控中心\"></a>2.2、安装监控中心</h2><p>为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用</p>\n<ol>\n<li><p>下载dubbo-admin<br><a href=\"https://github.com/apache/incubator-dubbo-ops\">https://github.com/apache/incubator-dubbo-ops</a><br>（注意是master分支） |</p>\n</li>\n<li><p>进入目录，修改dubbo-admin配置<br>修改src\\main\\resources\\application.properties 指定zookeeper地址</p>\n</li>\n<li><p>打包dubbo-admin</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean package</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>运行dubbo-admin</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>\n\n<p>默认使用root&#x2F;root 登陆</p>\n<h2 id=\"2-3、父工程\"><a href=\"#2-3、父工程\" class=\"headerlink\" title=\"2.3、父工程\"></a>2.3、父工程</h2><p>创建依赖</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;<span class=\"number\">4.0</span><span class=\"number\">.0</span>&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;modules&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">module</span>&gt;provider&lt;/<span class=\"keyword\">module</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">module</span>&gt;api&lt;/<span class=\"keyword\">module</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">module</span>&gt;consumer&lt;/<span class=\"keyword\">module</span>&gt;</span><br><span class=\"line\">    &lt;/modules&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 父级引用 --&gt;</span><br><span class=\"line\">    &lt;parent&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;<span class=\"number\">2.1</span><span class=\"number\">.1</span>.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;relativePath/&gt;</span><br><span class=\"line\">    &lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--配置--&gt;</span><br><span class=\"line\">    &lt;properties&gt;</span><br><span class=\"line\">        &lt;java.version&gt;<span class=\"number\">1.8</span>&lt;/java.version&gt;</span><br><span class=\"line\">        &lt;dubbo.version&gt;<span class=\"number\">2.7</span><span class=\"number\">.5</span>&lt;/dubbo.version&gt;</span><br><span class=\"line\">        &lt;zookeeper.version&gt;<span class=\"number\">3.4</span><span class=\"number\">.14</span>&lt;/zookeeper.version&gt;</span><br><span class=\"line\">    &lt;/properties&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--声明全局依赖（子项目需要显示的引用才会继承依赖）--&gt;</span><br><span class=\"line\">    &lt;dependencyManagement&gt;</span><br><span class=\"line\">        &lt;dependencies&gt;</span><br><span class=\"line\">            &lt;!-- dubbo-start依赖 --&gt;</span><br><span class=\"line\">            &lt;dependency&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class=\"line\">            &lt;/dependency&gt;</span><br><span class=\"line\">            &lt;!--zookeeper 注册中心客户端引入 使用的是curator客户端 --&gt;</span><br><span class=\"line\">            &lt;dependency&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">                &lt;exclusions&gt;</span><br><span class=\"line\">                    &lt;exclusion&gt;</span><br><span class=\"line\">                        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class=\"line\">                        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class=\"line\">                    &lt;/exclusion&gt;</span><br><span class=\"line\">                &lt;/exclusions&gt;</span><br><span class=\"line\">            &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;/dependencies&gt;</span><br><span class=\"line\">    &lt;/dependencyManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--声明全局依赖（子项目不需要显示的引用，自动继承依赖）--&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;!-- spring boot 依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">            &lt;exclusions&gt;</span><br><span class=\"line\">                &lt;exclusion&gt;</span><br><span class=\"line\">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class=\"line\">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;/exclusion&gt;</span><br><span class=\"line\">            &lt;/exclusions&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 打包插件 --&gt;</span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4、api模块\"><a href=\"#2-4、api模块\" class=\"headerlink\" title=\"2.4、api模块\"></a>2.4、api模块</h2><p>创建接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Api1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5、服务提供者模块\"><a href=\"#2-5、服务提供者模块\" class=\"headerlink\" title=\"2.5、服务提供者模块\"></a>2.5、服务提供者模块</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class=\"line\">    &lt;parent&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;/parent&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;<span class=\"number\">4.0</span><span class=\"number\">.0</span>&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;artifactId&gt;provider&lt;/artifactId&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;!--接口模块--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;!-- zookeeper依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class=\"line\">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">            &lt;exclusions&gt;</span><br><span class=\"line\">                &lt;exclusion&gt;</span><br><span class=\"line\">                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class=\"line\">                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;/exclusion&gt;</span><br><span class=\"line\">            &lt;/exclusions&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>配置文件</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  # 服务端口</span><br><span class=\"line\">  port: <span class=\"number\">7777</span></span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: provider</span><br><span class=\"line\"># dubbo 相关配置(dubbo 的配置不再以 Spring 开头)</span><br><span class=\"line\">dubbo:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    # 应用名称</span><br><span class=\"line\">    name: provider</span><br><span class=\"line\">  scan:</span><br><span class=\"line\">    # 接口实现者（服务实现）包</span><br><span class=\"line\">    base-packages: com.kaka.service</span><br><span class=\"line\">  # 注册中心信息</span><br><span class=\"line\">  registry:</span><br><span class=\"line\">    address: zookeeper:<span class=\"comment\">//127.0.0.1:2181</span></span><br><span class=\"line\">  protocol:</span><br><span class=\"line\">    # 协议名称</span><br><span class=\"line\">    name: dubbo</span><br><span class=\"line\">    # 协议端口</span><br><span class=\"line\">    port: <span class=\"number\">20880</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>服务实现</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service1</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Api1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;服务提供者提供服务...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-6、服务消费者\"><a href=\"#2-6、服务消费者\" class=\"headerlink\" title=\"2.6、服务消费者\"></a>2.6、服务消费者</h2><ol>\n<li>依赖</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class=\"line\">    &lt;parent&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;/parent&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;<span class=\"number\">4.0</span><span class=\"number\">.0</span>&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;artifactId&gt;consumer&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;!--接口模块--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- web项目依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- dubbo依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- dubbo的zookeeper依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class=\"line\">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">            &lt;exclusions&gt;</span><br><span class=\"line\">                &lt;exclusion&gt;</span><br><span class=\"line\">                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class=\"line\">                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;/exclusion&gt;</span><br><span class=\"line\">            &lt;/exclusions&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>配置文件</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: <span class=\"number\">7000</span></span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: consumer</span><br><span class=\"line\"># dubbo 相关配置</span><br><span class=\"line\">dubbo:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: consumer</span><br><span class=\"line\">  registry:</span><br><span class=\"line\">    address: zookeeper:<span class=\"comment\">//127.0.0.1:2181</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>消费者类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Reference</span></span><br><span class=\"line\">    Api1 api1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getOrder</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> api1.test();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、基本概念\"><a href=\"#1、基本概念\" class=\"headerlink\" title=\"1、基本概念\"></a>1、基本概念</h1><p>Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</p>\n<blockquote>\n<p><strong>dubbo可以是微服务的一部分，但不能以偏概全说dubbo就是微服务</strong>，微服务涉及的面比较广，比如服务发现，服务治理，服务网关，服务监控，链路追踪等等，可以用到的组件也比较多，而dubbo最多只能说是专注于服务治理的组件，所以从这一点上来看，可替代它的技术也是相当之多的，比如一系列rpc框架都可以</p>\n</blockquote>\n<h2 id=\"1-1、基本架构\"><a href=\"#1-1、基本架构\" class=\"headerlink\" title=\"1.1、基本架构\"></a>1.1、基本架构</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308041522327.png\" alt=\"dubbo架构\"></p>\n<p>Provider 暴露服务的服务提供方<br>Consumer 调用远程服务的服务消费方<br>Registry 服务注册与发现的注册中心<br>Monitor 统计服务的调用次数和调用时间的监控中心</p>\n<h2 id=\"1-2、调用流程\"><a href=\"#1-2、调用流程\" class=\"headerlink\" title=\"1.2、调用流程\"></a>1.2、调用流程</h2><ol>\n<li>服务启动，包括服务提供者和消费者的启动，封装服务调用链路。</li>\n<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>\n<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>\n<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>\n<li>服务消费者，从提供者地址列表中，基于服务路由信息、负载均衡规则，选一台提供者进行调用。</li>\n<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时发送一次统计数据到监控中心。</li>\n<li>服务提供方停止服务或者服务调用方关闭JVM的时候，会将provider及consumer进行销毁处理。</li>\n</ol>\n<h1 id=\"2、Dubbo环境搭建\"><a href=\"#2、Dubbo环境搭建\" class=\"headerlink\" title=\"2、Dubbo环境搭建\"></a>2、Dubbo环境搭建</h1><h2 id=\"2-1、安装zookeeper\"><a href=\"#2-1、安装zookeeper\" class=\"headerlink\" title=\"2.1、安装zookeeper\"></a>2.1、安装zookeeper</h2><ol>\n<li>下载zookeeper</li>\n</ol>\n<p>网址:<br><a href=\"https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/\">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/</a>  </p>\n<ol start=\"2\">\n<li><p>解压zookeeper<br>解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件 </p>\n</li>\n<li><p>修改zoo.cfg配置文件<br>将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可,修改完成后再次启动zookeeper</p>\n</li>\n</ol>\n<blockquote>\n<p>注意几个重要位置:<br>dataDir&#x3D;.&#x2F;   临时数据存储的目录（可写相对路径）<br>clientPort&#x3D;2181   zookeeper的端口号</p>\n</blockquote>\n<ol start=\"4\">\n<li>使用zkCli.cmd&#x2F;sh测试</li>\n</ol>\n<blockquote>\n<p>ls &#x2F;：列出zookeeper根下保存的所有节点<br>create –e &#x2F;kaka123：创建一个kaka节点，值为123<br>get &#x2F;kaka：获取&#x2F;kaka节点的值<br>(dubbo注册后一个group是一个节点)</p>\n</blockquote>\n<h2 id=\"2-2、安装监控中心\"><a href=\"#2-2、安装监控中心\" class=\"headerlink\" title=\"2.2、安装监控中心\"></a>2.2、安装监控中心</h2><p>为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用</p>\n<ol>\n<li><p>下载dubbo-admin<br><a href=\"https://github.com/apache/incubator-dubbo-ops\">https://github.com/apache/incubator-dubbo-ops</a><br>（注意是master分支） |</p>\n</li>\n<li><p>进入目录，修改dubbo-admin配置<br>修改src\\main\\resources\\application.properties 指定zookeeper地址</p>\n</li>\n<li><p>打包dubbo-admin</p>\n</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mvn clean package</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>运行dubbo-admin</li>\n</ol>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>\n\n<p>默认使用root&#x2F;root 登陆</p>\n<h2 id=\"2-3、父工程\"><a href=\"#2-3、父工程\" class=\"headerlink\" title=\"2.3、父工程\"></a>2.3、父工程</h2><p>创建依赖</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;<span class=\"number\">4.0</span><span class=\"number\">.0</span>&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class=\"line\">    &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;modules&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">module</span>&gt;provider&lt;/<span class=\"keyword\">module</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">module</span>&gt;api&lt;/<span class=\"keyword\">module</span>&gt;</span><br><span class=\"line\">        &lt;<span class=\"keyword\">module</span>&gt;consumer&lt;/<span class=\"keyword\">module</span>&gt;</span><br><span class=\"line\">    &lt;/modules&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 父级引用 --&gt;</span><br><span class=\"line\">    &lt;parent&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;version&gt;<span class=\"number\">2.1</span><span class=\"number\">.1</span>.RELEASE&lt;/version&gt;</span><br><span class=\"line\">        &lt;relativePath/&gt;</span><br><span class=\"line\">    &lt;/parent&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--配置--&gt;</span><br><span class=\"line\">    &lt;properties&gt;</span><br><span class=\"line\">        &lt;java.version&gt;<span class=\"number\">1.8</span>&lt;/java.version&gt;</span><br><span class=\"line\">        &lt;dubbo.version&gt;<span class=\"number\">2.7</span><span class=\"number\">.5</span>&lt;/dubbo.version&gt;</span><br><span class=\"line\">        &lt;zookeeper.version&gt;<span class=\"number\">3.4</span><span class=\"number\">.14</span>&lt;/zookeeper.version&gt;</span><br><span class=\"line\">    &lt;/properties&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--声明全局依赖（子项目需要显示的引用才会继承依赖）--&gt;</span><br><span class=\"line\">    &lt;dependencyManagement&gt;</span><br><span class=\"line\">        &lt;dependencies&gt;</span><br><span class=\"line\">            &lt;!-- dubbo-start依赖 --&gt;</span><br><span class=\"line\">            &lt;dependency&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class=\"line\">            &lt;/dependency&gt;</span><br><span class=\"line\">            &lt;!--zookeeper 注册中心客户端引入 使用的是curator客户端 --&gt;</span><br><span class=\"line\">            &lt;dependency&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class=\"line\">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">                &lt;exclusions&gt;</span><br><span class=\"line\">                    &lt;exclusion&gt;</span><br><span class=\"line\">                        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class=\"line\">                        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class=\"line\">                    &lt;/exclusion&gt;</span><br><span class=\"line\">                &lt;/exclusions&gt;</span><br><span class=\"line\">            &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;/dependencies&gt;</span><br><span class=\"line\">    &lt;/dependencyManagement&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!--声明全局依赖（子项目不需要显示的引用，自动继承依赖）--&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;!-- spring boot 依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class=\"line\">            &lt;exclusions&gt;</span><br><span class=\"line\">                &lt;exclusion&gt;</span><br><span class=\"line\">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class=\"line\">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class=\"line\">                &lt;/exclusion&gt;</span><br><span class=\"line\">            &lt;/exclusions&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;!-- 打包插件 --&gt;</span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4、api模块\"><a href=\"#2-4、api模块\" class=\"headerlink\" title=\"2.4、api模块\"></a>2.4、api模块</h2><p>创建接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Api1</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5、服务提供者模块\"><a href=\"#2-5、服务提供者模块\" class=\"headerlink\" title=\"2.5、服务提供者模块\"></a>2.5、服务提供者模块</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class=\"line\">    &lt;parent&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;/parent&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;<span class=\"number\">4.0</span><span class=\"number\">.0</span>&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;artifactId&gt;provider&lt;/artifactId&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;!--接口模块--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">        &lt;!-- zookeeper依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class=\"line\">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">            &lt;exclusions&gt;</span><br><span class=\"line\">                &lt;exclusion&gt;</span><br><span class=\"line\">                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class=\"line\">                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;/exclusion&gt;</span><br><span class=\"line\">            &lt;/exclusions&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>配置文件</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  # 服务端口</span><br><span class=\"line\">  port: <span class=\"number\">7777</span></span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: provider</span><br><span class=\"line\"># dubbo 相关配置(dubbo 的配置不再以 Spring 开头)</span><br><span class=\"line\">dubbo:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    # 应用名称</span><br><span class=\"line\">    name: provider</span><br><span class=\"line\">  scan:</span><br><span class=\"line\">    # 接口实现者（服务实现）包</span><br><span class=\"line\">    base-packages: com.kaka.service</span><br><span class=\"line\">  # 注册中心信息</span><br><span class=\"line\">  registry:</span><br><span class=\"line\">    address: zookeeper:<span class=\"comment\">//127.0.0.1:2181</span></span><br><span class=\"line\">  protocol:</span><br><span class=\"line\">    # 协议名称</span><br><span class=\"line\">    name: dubbo</span><br><span class=\"line\">    # 协议端口</span><br><span class=\"line\">    port: <span class=\"number\">20880</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>服务实现</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Service1</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Api1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;服务提供者提供服务...&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;success&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-6、服务消费者\"><a href=\"#2-6、服务消费者\" class=\"headerlink\" title=\"2.6、服务消费者\"></a>2.6、服务消费者</h2><ol>\n<li>依赖</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span><br><span class=\"line\">&lt;project xmlns=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class=\"line\">         xmlns:xsi=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class=\"line\">         xsi:schemaLocation=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class=\"line\">    &lt;parent&gt;</span><br><span class=\"line\">        &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">        &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">    &lt;/parent&gt;</span><br><span class=\"line\">    &lt;modelVersion&gt;<span class=\"number\">4.0</span><span class=\"number\">.0</span>&lt;/modelVersion&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;artifactId&gt;consumer&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;dependencies&gt;</span><br><span class=\"line\">        &lt;!--接口模块--&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;<span class=\"number\">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- web项目依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- dubbo依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">        &lt;!-- dubbo的zookeeper依赖 --&gt;</span><br><span class=\"line\">        &lt;dependency&gt;</span><br><span class=\"line\">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class=\"line\">            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class=\"line\">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class=\"line\">            &lt;exclusions&gt;</span><br><span class=\"line\">                &lt;exclusion&gt;</span><br><span class=\"line\">                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class=\"line\">                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;/exclusion&gt;</span><br><span class=\"line\">            &lt;/exclusions&gt;</span><br><span class=\"line\">        &lt;/dependency&gt;</span><br><span class=\"line\">    &lt;/dependencies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">    &lt;build&gt;</span><br><span class=\"line\">        &lt;plugins&gt;</span><br><span class=\"line\">            &lt;plugin&gt;</span><br><span class=\"line\">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class=\"line\">            &lt;/plugin&gt;</span><br><span class=\"line\">        &lt;/plugins&gt;</span><br><span class=\"line\">    &lt;/build&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/project&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>配置文件</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server:</span><br><span class=\"line\">  port: <span class=\"number\">7000</span></span><br><span class=\"line\">spring:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: consumer</span><br><span class=\"line\"># dubbo 相关配置</span><br><span class=\"line\">dubbo:</span><br><span class=\"line\">  application:</span><br><span class=\"line\">    name: consumer</span><br><span class=\"line\">  registry:</span><br><span class=\"line\">    address: zookeeper:<span class=\"comment\">//127.0.0.1:2181</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>消费者类</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Consumer1</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Reference</span></span><br><span class=\"line\">    Api1 api1;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">getOrder</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> api1.test();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> test;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"redis","date":"2023-08-06T16:00:00.000Z","abbrlink":44296,"_content":"\n# 1、基本概念\n\nRedis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。\n\n## 1.1、redis特性\n\n1. 键值（key-value）型，value支持多种不同数据结构，功能丰富\n2. 单线程，每个命令具备原子性\n\n> Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行\n\n3. 低延迟，速度快\n\n>原因：基于内存、采用多路复用非阻塞I/O、单线程\n\n\n1. 支持数据持久化\n2. 支持主从集群、分片集群\n3. 支持多语言客户端\n\n## 1.2、数据类型\n\n> Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样\n\n![redis数据类型](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308071403029.png)\n\n\n# 2、redis常见命令\n## 2.1、String\n\n> String类型，也就是字符串类型，是Redis中最简单的存储类型\n> 底层SDS结构。为什么不直接实用字符串？①C 语言字符数组最后一个元素总是 '\\0'，而在Redis中\\0可能会被判定为提前结束而识别不了字符串②获取字符串长度为O(n)，因为C字符串需要去遍历，开销较大，SDS对象有len属性直接获取\n\n其value是字符串，不过根据字符串的格式不同，又可以分为3类：\n（1）string：普通字符串\n（2）int：整数类型，可以做自增、自减操作\n（3）float：浮点类型，可以做自增、自减操作\n\n| 命令 | 描述 |\n| --- | --- |\n| SET | 添加或者修改已经存在的一个String类型的键值对 |\n| GET | 根据key获取String类型的value |\n| MSET | 批量添加多个String类型的键值对 |\n| MGET | 根据多个key获取多个String类型的value |\n| INCR | 让一个整型的key自增1 |\n| INCRBY | 让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 |\n| INCRBYFLOAT | 让一个浮点类型的数字自增并指定步长 |\n| SETNX | 添加一个String类型的键值对，前提是这个key不存在，否则不执行 |\n| SETEX | 添加一个String类型的键值对，并且指定有效期 |\n\n> **Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：**\n\n```java\n项目名:业务名:类型:id\n```\n## 2.2、Hash\n\n> Hash类型，也叫散列，底层是hashtable，其value是一个无序字典，类似于Java中的HashMap结构。\n\nHash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD\n\n| **命令** | **描述** |\n| --- | --- |\n| HSET key field value | 添加或者修改hash类型key的field的值 |\n| HGET key field | 获取一个hash类型key的field的值 |\n| HMSET | hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了 |\n| HMGET | 批量获取多个hash类型key的field的值 |\n| HGETALL | 获取一个hash类型的key中的所有的field和value |\n| HKEYS | 获取一个hash类型的key中的所有的field |\n| HVALS | 获取一个hash类型的key中的所有的value |\n| HINCRBY | 让一个hash类型key的字段值自增并指定步长 |\n| HSETNX | 添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 |\n\n## 2.3、List\n\n> list列表的数据结构使用的是压缩列表ziplist和普通的双向链表linkedlist组成。元素少的时候会用ziplist，元素多的时候会用linkedlist\n  ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的,当数据量较大的时候因为需要重新分配，开销较大\n\n常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等\n\n| **命令** | **描述** |\n| --- | --- |\n| LPUSH key element … | 向列表左侧插入一个或多个元素 |\n| LPOP key | 移除并返回列表左侧的第一个元素，没有则返回nil |\n| **RPUSH key element …** | 向列表右侧插入一个或多个元素 |\n| RPOP key | 移除并返回列表右侧的第一个元素 |\n| LRANGE key star end | 返回一段角标范围内的所有元素 |\n| BLPOP和BRPOP | 与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil |\n\n## 2.4、SET\n\n> Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征。数据结构的底层实现有两种方式：Intset 和 Hashtable。当集合中的所有元素都是整数，并且元素数量较少时，Redis 会使用 Intset 作为底层实现。当集合中的元素不仅限于整数，或者元素数量较多时，Redis 会使用 Hashtable 作为底层实现\n \n\n| **命令** | **描述** |\n| --- | --- |\n| SADD key member … | 向set中添加一个或多个元素 |\n| SREM key member … | 移除set中的指定元素 |\n| SCARD key | 返回set中元素的个数 |\n| SISMEMBER key member | 判断一个元素是否存在于set中 |\n| SMEMBERS | 获取set中的所有元素 |\n| SINTER key1 key2 … | 求key1与key2的交集 |\n| SDIFF key1 key2 … | 求key1与key2的差集 |\n| SUNION key1 key2 … | 求key1和key2的并集 |\n\n## 2.5、SortedSet\n\n> Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\n\n因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能\n\n| **命令** | **描述** |\n| --- | --- |\n| ZADD key score member | 添加一个或多个元素到sorted set ，如果已经存在则更新其score值 |\n| ZREM key member | 删除sorted set中的一个指定元素 |\n| ZSCORE key member | 获取sorted set中的指定元素的score值 |\n| ZRANK key member | 获取sorted set 中的指定元素的排名 |\n| ZCARD key | 获取sorted set中的元素个数 |\n| ZCOUNT key min max | 统计score值在给定范围内的所有元素的个数 |\n| ZINCRBY key increment member | 让sorted set中的指定元素自增，步长为指定的increment值 |\n| ZRANGE key min max | 按照score排序后，获取指定排名范围内的元素 |\n| ZRANGEBYSCORE key min max | 按照score排序后，获取指定score范围内的元素 |\n| ZDIFF、ZINTER、ZUNION | 求差集、交集、并集 |\n\n> **注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可**\n\n\n# 3、java客户端\n## 3.1、springboot整合redis\n### 3.1.1、引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n### 3.1.2、redis基本配置\n\n```properties\n#redis基本配置\nspring.redis.host=127.0.0.1\nspring.redis.port=6379\n```\n### 3.1.3、redis固定配置\n\n```java\n@Configuration\npublic class RedisConfig {\n    @Bean\n    @SuppressWarnings(\"all\")\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();\n        // 配置连接池工厂\n        template.setConnectionFactory(factory);\n\n        // Jackson序列化配置\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        // 属性访问器为全部，作用域为全部\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        // 序列化输入类型必须是非final类型的\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n\n        // String 的序列化\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n\n        // key采用String的序列化方式\n        template.setKeySerializer(stringRedisSerializer);\n        // hash的key也采用String的序列化方式\n        template.setHashKeySerializer(stringRedisSerializer);\n        // value序列化方式采用jackson\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        // hash的value序列化方式采用jackson\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\n\n> redis使用JDK提供的序列化功能。 优点是反序列化时不需要提供类型信息(class)，但缺点是需要实现Serializable接口，还有序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存\n> 所以我们需要  使用Jackson库将对象序列化为JSON字符串。优点是速度快，序列化后的字符串短小精悍，易读\n\n### 3.1.4、工具类\n\n\n```java\npackage com.kaka.redis;\n\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.CollectionUtils;\n\nimport javax.annotation.Resource;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic final class RedisUtils {\n\n    @Resource\n    private RedisTemplate<String, Object> redisTemplate;\n\n\n    public Set<String> keys(String keys){\n        try {\n            return redisTemplate.keys(keys);\n        }catch (Exception e){\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * 指定缓存失效时间\n     * @param key 键\n     * @param time 时间(秒)\n     * @return\n     */\n    public boolean expire(String key, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.expire(key, time, TimeUnit.SECONDS);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 根据key 获取过期时间\n     * @param key 键 不能为null\n     * @return 时间(秒) 返回0代表为永久有效\n     */\n    public long getExpire(String key) {\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    }\n    /**\n     * 判断key是否存在\n     * @param key 键\n     * @return true 存在 false不存在\n     */\n    public boolean hasKey(String key) {\n        try {\n            return redisTemplate.hasKey(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 删除缓存\n     * @param key 可以传一个值 或多个\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void del(String... key) {\n        if (key != null && key.length > 0) {\n            if (key.length == 1) {\n                redisTemplate.delete(key[0]);\n            } else {\n                redisTemplate.delete((Collection<String>) CollectionUtils.arrayToList(key));\n            }\n        }\n    }\n    /**\n     * 普通缓存获取\n     * @param key 键\n     * @return 值\n     */\n    public Object get(String key) {\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n    }\n    /**\n     * 普通缓存放入\n     * @param key 键\n     * @param value 值\n     * @return true成功 false失败\n     */\n    public boolean set(String key, Object value) {\n        try {\n            redisTemplate.opsForValue().set(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 普通缓存放入, 不存在放入，存在返回\n     * @param key 键\n     * @param value 值\n     * @return true成功 false失败\n     */\n    public boolean setnx(String key, Object value) {\n        try {\n            redisTemplate.opsForValue().setIfAbsent(key,value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 普通缓存放入并设置时间\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期\n     * @return true成功 false 失败\n     */\n    public boolean set(String key, Object value, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n            } else {\n                set(key, value);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 普通缓存放入并设置时间,不存在放入，存在返回\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期\n     * @return true成功 false 失败\n     */\n    public boolean setnx(String key, Object value, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.opsForValue().setIfAbsent(key, value, time, TimeUnit.SECONDS);\n            } else {\n                set(key, value);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 递增\n     * @param key 键\n     * @param delta 要增加几(大于0)\n     * @return\n     */\n    public long incr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递增因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, delta);\n    }\n    /**\n     * 递减\n     * @param key 键\n     * @param delta 要减少几(小于0)\n     * @return\n     */\n    public long decr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递减因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, -delta);\n    }\n    /**\n     * HashGet\n     * @param key 键 不能为null\n     * @param item 项 不能为null\n     * @return 值\n     */\n    public Object hget(String key, String item) {\n        return redisTemplate.opsForHash().get(key, item);\n    }\n    /**\n     * 获取hashKey对应的所有键值\n     * @param key 键\n     * @return 对应的多个键值\n     */\n    public Map<Object, Object> hmget(String key) {\n        return redisTemplate.opsForHash().entries(key);\n    }\n    /**\n     * HashSet\n     * @param key 键\n     * @param map 对应多个键值\n     * @return true 成功 false 失败\n     */\n    public boolean hmset(String key, Map<String, Object> map) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * HashSet 并设置时间\n     * @param key 键\n     * @param map 对应多个键值\n     * @param time 时间(秒)\n     * @return true成功 false失败\n     */\n    public boolean hmset(String key, Map<String, Object> map, long time) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     * @param key 键\n     * @param item 项\n     * @param value 值\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     * @param key 键\n     * @param item 项\n     * @param value 值\n     * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value, long time) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 删除hash表中的值\n     * @param key 键 不能为null\n     * @param item 项 可以使多个 不能为null\n     */\n    public void hdel(String key, Object... item) {\n        redisTemplate.opsForHash().delete(key, item);\n    }\n    /**\n     * 判断hash表中是否有该项的值\n     * @param key 键 不能为null\n     * @param item 项 不能为null\n     * @return true 存在 false不存在\n     */\n    public boolean hHasKey(String key, String item) {\n        return redisTemplate.opsForHash().hasKey(key, item);\n    }\n    /**\n     * hash递增 如果不存在,就会创建一个 并把新增后的值返回\n     * @param key 键\n     * @param item 项\n     * @param by 要增加几(大于0)\n     * @return\n     */\n    public double hincr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, by);\n    }\n    /**\n     * hash递减\n     * @param key 键\n     * @param item 项\n     * @param by 要减少记(小于0)\n     * @return\n     */\n    public double hdecr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, -by);\n    }\n    /**\n     * 根据key获取Set中的所有值\n     * @param key 键\n     * @return\n     */\n    public Set<Object> sGet(String key) {\n        try {\n            return redisTemplate.opsForSet().members(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    /**\n     * 根据value从一个set中查询,是否存在\n     * @param key 键\n     * @param value 值\n     * @return true 存在 false不存在\n     */\n    public boolean sHasKey(String key, Object value) {\n        try {\n            return redisTemplate.opsForSet().isMember(key, value);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 将数据放入set缓存\n     * @param key 键\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSet(String key, Object... values) {\n        try {\n            return redisTemplate.opsForSet().add(key, values);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    /**\n     * 将set数据放入缓存\n     * @param key 键\n     * @param time 时间(秒)\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSetAndTime(String key, long time, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().add(key, values);\n            if (time > 0){\n                expire(key, time);\n            }\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    /**\n     * 获取set缓存的长度\n     * @param key 键\n     * @return\n     */\n    public long sGetSetSize(String key) {\n        try {\n            return redisTemplate.opsForSet().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    /**\n     * 移除值为value的\n     * @param key 键\n     * @param values 值 可以是多个\n     * @return 移除的个数\n     */\n    public long setRemove(String key, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().remove(key, values);\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    // ===============================list=================================\n    /**\n     * 获取list缓存的内容\n     * @param key 键\n     * @param start 开始\n     * @param end 结束 0 到 -1代表所有值\n     * @return\n     */\n    public List<Object> lGet(String key, long start, long end) {\n        try {\n            return redisTemplate.opsForList().range(key, start, end);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    /**\n     * 获取list缓存的长度\n     * @param key 键\n     * @return\n     */\n    public long lGetListSize(String key) {\n        try {\n            return redisTemplate.opsForList().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    /**\n     * 通过索引 获取list中的值\n     * @param key 键\n     * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推\n     * @return\n     */\n    public Object lGetIndex(String key, long index) {\n        try {\n            return redisTemplate.opsForList().index(key, index);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    /**\n     * 将list放入缓存\n     * @param key 键\n     * @param value 值\n     * @return\n     */\n    public boolean lSet(String key, Object value) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 将list放入缓存\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒)\n     * @return\n     */\n    public boolean lSet(String key, Object value, long time) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            if (time > 0){\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 将list放入缓存\n     * @param key 键\n     * @param value 值\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 将list放入缓存\n     *\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒)\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value, long time) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            if (time > 0){\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 根据索引修改list中的某条数据\n     * @param key 键\n     * @param index 索引\n     * @param value 值\n     * @return\n     */\n    public boolean lUpdateIndex(String key, long index, Object value) {\n        try {\n            redisTemplate.opsForList().set(key, index, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 移除N个值为value\n     * @param key 键\n     * @param count 移除多少个\n     * @param value 值\n     * @return 移除的个数\n     */\n    public long lRemove(String key, long count, Object value) {\n        try {\n            Long remove = redisTemplate.opsForList().remove(key, count, value);\n            return remove;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n}\n```\n\n5. 使用\n\n```java\n@RestController\npublic class Demo {\n    @Autowired\n    RedisUtils redisUtils;\n    @RequestMapping(\"/redisTest\")\n    public String test(){\n        redisUtils.set(\"test3:key3\",\"hello,redis\");\n        return redisUtils.get(\"test3:key3\").toString();\n    }\n}\n```\n\n# 4、进阶\n## 4.1、redis持久化\n### 4.1.1、rdb\n\n把当前内存中的快照写入磁盘\n\n（1）save：save指令执行会阻塞当前redis服务器，直到当前rdb过程执行完，可能造成长时间阻塞，线上环境不建议使用\n（2）bgsave：调用fork函数生成子进程，解决了save的阻塞问题\n（3）自动执行：（redis配置文件中配置）save 900 1   save 300 10   save 60 1000\n\n### 4.1.2、aof\n\n以日志的方式记录每次写命令，重启时再执行aof中的命令达到数据恢复的目的（是目前redis持久化的主流方式）\n\naof写数据策略：\n\n（1）always：服务器每写入一个命令,就调用一次fdatasync（不会丢失数据）\n（2）Everysec：服务器每一秒重调用一次fdatasync（数据同步），最多丢失1秒的数据\n（3）NO：操作系统决定任何将缓冲区里面的命令写入磁盘里面，数据丢失量是不确定的\n\n> 注：always策略持久化数据：先把写命令追加到aof buffer中，下一次进入事件循环循环后，再将buffer写到磁盘上。也就是说，这次写到磁盘上的内容是上一个事件循环产生的所以，即使设置为always，也会丢失一个循环的数据\n\n\n### 4.1.3、对比\n\n|  | rdb | aof |\n| --- | --- | --- |\n| 占用存储空间 | 小（数据级） | 大（指令级） |\n| 恢复速度 | 快 | 慢（需要执行指令） |\n| 数据安全性 | 可能会丢失最后一次持久化后的数据 | 根据策略决定 |\n\n## 4.2、redis淘汰策略\n\n### 4.2.1、定时删除\n方式：创建一个定时器,当设置的key到达到期时间时,由定时器任务立即执行对key的删除操作\n\n优缺点：\n（1）节约内存,到时就删,快速释放掉不必要的内存占用 \n（2）CPU压力变大,无论CPU此时负载量多高,均占用CPU\n\n### 4.2.2、惰性删除\n方式：数据到期时不做删除,等下次访问时进行删除\n\n优缺点：\n（1）节约cpu性能  \n（2）若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）\n\n### 4.2.3、定期删除\n方式：每隔一段时间主动检查一批过期键，并将其删除。这样可以保证过期键及时地从内存中释放\n\n>（1）Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置健为\n hz 它的默认值是 hz 10。\n 【注意】:Redis 每次扫描并不是遍历过期字典中的所有健，而是采用随机抽取判断并删除过期健的形式执行的。\n\n删除流程：\n（1）从过期字典随机取20个键\n（2）删除这20个键中过期的键\n（3）如果过期key的比例超过25%，重复步骤1\n\n优缺点：\n（1）分批处理，以避免对cpu产生过大的负载\n\n## 4.3、redis内存淘汰策略\n\nRedis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据\n\n>LRU：淘汰最长时间没有被使用的\n LFU：一定时间内使用频次越低的\n random：随机\n ttl：越早过期的数据\n \n|淘汰策略名称|策略含义|\n|---|---|\n|noeviction|默认策略，不淘汰数据；大部分写命令都将返回错误（DEL等少数除外）|\n|allkeys-lru|从所有数据中根据 LRU 算法挑选数据淘汰|\n|volatile-lru|从设置了过期时间的数据中根据 LRU 算法挑选数据淘汰|\n|allkeys-random|从所有数据中随机挑选数据淘汰|\n|volatile-random|从设置了过期时间的数据中随机挑选数据淘汰|\n|volatile-ttl|从设置了过期时间的数据中，挑选越早过期的数据进行删除|\n|allkeys-lfu|从所有数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）|\n|volatile-lfu|从设置了过期时间的数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）|\n\n  \n## 4.4、redis工作模式\n\n### 4.4.1、单机模式\n\n单机模式是最简单的 Redis 工作模式。在单机模式下，Redis 只运行在单个节点上，数据存储在该节点的内存中。这种模式适用于小规模应用或开发环境\n\n### 4.4.2、主从复制模式\n\n主从复制模式通过将数据从主节点复制到一个或多个从节点来提高数据的可靠性和读取性能。主节点负责处理写入操作，从节点复制主节点的数据，并可以处理读取操作。主从复制模式适用于需要读取扩展和数据冗余的场景\n\n\n### 4.4.3、哨兵模式\n\n主从复制的基础上，引入了哨兵节点来监控主节点的状态。当主节点发生故障时，哨兵节点会自动将一个从节点升级为新的主节点，并将其他从节点重新配置为复制新的主节点。这种模式提供了故障转移和自动主节点切换的功能\n\n### 4.4.4、集群模式\n\n即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据。cluster是为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，提高并发量\n\n## 4.5、redis发布订阅机制\n\nRedis 发布订阅（Pus/Sub）是一种消息通信模式：发送者通过 PUBLISH发布消息，订阅者通过 SUBSCRIBE 订阅接收消息或通过UNSUBSCRIBE 取消订阅。\n发布者和订阅者属于客户端，Channel 是 Redis 服务端，发布者将消息发布到频道，订阅这个频道的订阅者则收到消息。从而实现消息的广播和实时通知\n\n\n> Redis 的发布订阅机制是一种简单的消息传递方式，并不提供消息持久化和消息队列的功能。如果需要更高级的消息队列功能，可以考虑rabbitmq，kafka等\n\n```shell\n# A订阅频道\nSUBSCRIBE channel1\n\n# B向频道发送消息，A就可以收到消息\nPUBLISH channel1 \"Redis PUBLISH test\"\n\n```\n\n## 4.6、缓存穿透、击穿、雪崩\n###  4.6.1、缓存穿透\n\n某些不存在的数据，被大量的查询访问，缓存层中没有这些数据的缓存，请求就直达存储层，造成宕机\n\n> 解决方法：\n1.返回空对象，将该key的空值返回给缓存层，缓存层会直接返回空对象。\n2.布隆过滤器：将所有的key都存在过滤器中，在访问缓存层的时候会首先访问过滤器，如果过滤器中不存在这个值，那么直接返回空值\n\n\n### 4.6.2、缓存击穿？\n\n一份热点数据，在它缓存失效期间，大量的请求直接命中存储层\n\n> 解决方法：\n 1.设置热点数据永不过期的策略。\n 2.加互斥锁，在一个请求访问时另一个不能访问，这样，在这个请求访问过后，缓存重建，其他线程就可以访问了\n\n### 4.6.3、缓存雪崩？\n\n当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。\n\n> 解决方法：\n>1.不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀\n>2.在系统启动或低峰期(比如系统刚启动)，提前加载热门数据到缓存中，避免在高峰期大量请求同时访问导致缓存失效\n\n\n","source":"_posts/redis.md","raw":"---\ntitle: redis\ndate: 2023/08/07\ncategories:\n  - coding\ntags:\n  - redis\n  - 缓存中间件\n  - 编程基础\nabbrlink: 44296\n---\n\n# 1、基本概念\n\nRedis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。\n\n## 1.1、redis特性\n\n1. 键值（key-value）型，value支持多种不同数据结构，功能丰富\n2. 单线程，每个命令具备原子性\n\n> Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行\n\n3. 低延迟，速度快\n\n>原因：基于内存、采用多路复用非阻塞I/O、单线程\n\n\n1. 支持数据持久化\n2. 支持主从集群、分片集群\n3. 支持多语言客户端\n\n## 1.2、数据类型\n\n> Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样\n\n![redis数据类型](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308071403029.png)\n\n\n# 2、redis常见命令\n## 2.1、String\n\n> String类型，也就是字符串类型，是Redis中最简单的存储类型\n> 底层SDS结构。为什么不直接实用字符串？①C 语言字符数组最后一个元素总是 '\\0'，而在Redis中\\0可能会被判定为提前结束而识别不了字符串②获取字符串长度为O(n)，因为C字符串需要去遍历，开销较大，SDS对象有len属性直接获取\n\n其value是字符串，不过根据字符串的格式不同，又可以分为3类：\n（1）string：普通字符串\n（2）int：整数类型，可以做自增、自减操作\n（3）float：浮点类型，可以做自增、自减操作\n\n| 命令 | 描述 |\n| --- | --- |\n| SET | 添加或者修改已经存在的一个String类型的键值对 |\n| GET | 根据key获取String类型的value |\n| MSET | 批量添加多个String类型的键值对 |\n| MGET | 根据多个key获取多个String类型的value |\n| INCR | 让一个整型的key自增1 |\n| INCRBY | 让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2 |\n| INCRBYFLOAT | 让一个浮点类型的数字自增并指定步长 |\n| SETNX | 添加一个String类型的键值对，前提是这个key不存在，否则不执行 |\n| SETEX | 添加一个String类型的键值对，并且指定有效期 |\n\n> **Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：**\n\n```java\n项目名:业务名:类型:id\n```\n## 2.2、Hash\n\n> Hash类型，也叫散列，底层是hashtable，其value是一个无序字典，类似于Java中的HashMap结构。\n\nHash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD\n\n| **命令** | **描述** |\n| --- | --- |\n| HSET key field value | 添加或者修改hash类型key的field的值 |\n| HGET key field | 获取一个hash类型key的field的值 |\n| HMSET | hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了 |\n| HMGET | 批量获取多个hash类型key的field的值 |\n| HGETALL | 获取一个hash类型的key中的所有的field和value |\n| HKEYS | 获取一个hash类型的key中的所有的field |\n| HVALS | 获取一个hash类型的key中的所有的value |\n| HINCRBY | 让一个hash类型key的字段值自增并指定步长 |\n| HSETNX | 添加一个hash类型的key的field值，前提是这个field不存在，否则不执行 |\n\n## 2.3、List\n\n> list列表的数据结构使用的是压缩列表ziplist和普通的双向链表linkedlist组成。元素少的时候会用ziplist，元素多的时候会用linkedlist\n  ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的,当数据量较大的时候因为需要重新分配，开销较大\n\n常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等\n\n| **命令** | **描述** |\n| --- | --- |\n| LPUSH key element … | 向列表左侧插入一个或多个元素 |\n| LPOP key | 移除并返回列表左侧的第一个元素，没有则返回nil |\n| **RPUSH key element …** | 向列表右侧插入一个或多个元素 |\n| RPOP key | 移除并返回列表右侧的第一个元素 |\n| LRANGE key star end | 返回一段角标范围内的所有元素 |\n| BLPOP和BRPOP | 与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil |\n\n## 2.4、SET\n\n> Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征。数据结构的底层实现有两种方式：Intset 和 Hashtable。当集合中的所有元素都是整数，并且元素数量较少时，Redis 会使用 Intset 作为底层实现。当集合中的元素不仅限于整数，或者元素数量较多时，Redis 会使用 Hashtable 作为底层实现\n \n\n| **命令** | **描述** |\n| --- | --- |\n| SADD key member … | 向set中添加一个或多个元素 |\n| SREM key member … | 移除set中的指定元素 |\n| SCARD key | 返回set中元素的个数 |\n| SISMEMBER key member | 判断一个元素是否存在于set中 |\n| SMEMBERS | 获取set中的所有元素 |\n| SINTER key1 key2 … | 求key1与key2的交集 |\n| SDIFF key1 key2 … | 求key1与key2的差集 |\n| SUNION key1 key2 … | 求key1和key2的并集 |\n\n## 2.5、SortedSet\n\n> Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。\n\n因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能\n\n| **命令** | **描述** |\n| --- | --- |\n| ZADD key score member | 添加一个或多个元素到sorted set ，如果已经存在则更新其score值 |\n| ZREM key member | 删除sorted set中的一个指定元素 |\n| ZSCORE key member | 获取sorted set中的指定元素的score值 |\n| ZRANK key member | 获取sorted set 中的指定元素的排名 |\n| ZCARD key | 获取sorted set中的元素个数 |\n| ZCOUNT key min max | 统计score值在给定范围内的所有元素的个数 |\n| ZINCRBY key increment member | 让sorted set中的指定元素自增，步长为指定的increment值 |\n| ZRANGE key min max | 按照score排序后，获取指定排名范围内的元素 |\n| ZRANGEBYSCORE key min max | 按照score排序后，获取指定score范围内的元素 |\n| ZDIFF、ZINTER、ZUNION | 求差集、交集、并集 |\n\n> **注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可**\n\n\n# 3、java客户端\n## 3.1、springboot整合redis\n### 3.1.1、引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n### 3.1.2、redis基本配置\n\n```properties\n#redis基本配置\nspring.redis.host=127.0.0.1\nspring.redis.port=6379\n```\n### 3.1.3、redis固定配置\n\n```java\n@Configuration\npublic class RedisConfig {\n    @Bean\n    @SuppressWarnings(\"all\")\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {\n        RedisTemplate<String, Object> template = new RedisTemplate<String, Object>();\n        // 配置连接池工厂\n        template.setConnectionFactory(factory);\n\n        // Jackson序列化配置\n        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);\n        ObjectMapper om = new ObjectMapper();\n        // 属性访问器为全部，作用域为全部\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        // 序列化输入类型必须是非final类型的\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n\n        // String 的序列化\n        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();\n\n        // key采用String的序列化方式\n        template.setKeySerializer(stringRedisSerializer);\n        // hash的key也采用String的序列化方式\n        template.setHashKeySerializer(stringRedisSerializer);\n        // value序列化方式采用jackson\n        template.setValueSerializer(jackson2JsonRedisSerializer);\n        // hash的value序列化方式采用jackson\n        template.setHashValueSerializer(jackson2JsonRedisSerializer);\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\n\n> redis使用JDK提供的序列化功能。 优点是反序列化时不需要提供类型信息(class)，但缺点是需要实现Serializable接口，还有序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存\n> 所以我们需要  使用Jackson库将对象序列化为JSON字符串。优点是速度快，序列化后的字符串短小精悍，易读\n\n### 3.1.4、工具类\n\n\n```java\npackage com.kaka.redis;\n\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.stereotype.Component;\nimport org.springframework.util.CollectionUtils;\n\nimport javax.annotation.Resource;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\n@Component\npublic final class RedisUtils {\n\n    @Resource\n    private RedisTemplate<String, Object> redisTemplate;\n\n\n    public Set<String> keys(String keys){\n        try {\n            return redisTemplate.keys(keys);\n        }catch (Exception e){\n            e.printStackTrace();\n            return null;\n        }\n    }\n\n    /**\n     * 指定缓存失效时间\n     * @param key 键\n     * @param time 时间(秒)\n     * @return\n     */\n    public boolean expire(String key, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.expire(key, time, TimeUnit.SECONDS);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 根据key 获取过期时间\n     * @param key 键 不能为null\n     * @return 时间(秒) 返回0代表为永久有效\n     */\n    public long getExpire(String key) {\n        return redisTemplate.getExpire(key, TimeUnit.SECONDS);\n    }\n    /**\n     * 判断key是否存在\n     * @param key 键\n     * @return true 存在 false不存在\n     */\n    public boolean hasKey(String key) {\n        try {\n            return redisTemplate.hasKey(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 删除缓存\n     * @param key 可以传一个值 或多个\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void del(String... key) {\n        if (key != null && key.length > 0) {\n            if (key.length == 1) {\n                redisTemplate.delete(key[0]);\n            } else {\n                redisTemplate.delete((Collection<String>) CollectionUtils.arrayToList(key));\n            }\n        }\n    }\n    /**\n     * 普通缓存获取\n     * @param key 键\n     * @return 值\n     */\n    public Object get(String key) {\n        return key == null ? null : redisTemplate.opsForValue().get(key);\n    }\n    /**\n     * 普通缓存放入\n     * @param key 键\n     * @param value 值\n     * @return true成功 false失败\n     */\n    public boolean set(String key, Object value) {\n        try {\n            redisTemplate.opsForValue().set(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 普通缓存放入, 不存在放入，存在返回\n     * @param key 键\n     * @param value 值\n     * @return true成功 false失败\n     */\n    public boolean setnx(String key, Object value) {\n        try {\n            redisTemplate.opsForValue().setIfAbsent(key,value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 普通缓存放入并设置时间\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期\n     * @return true成功 false 失败\n     */\n    public boolean set(String key, Object value, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);\n            } else {\n                set(key, value);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 普通缓存放入并设置时间,不存在放入，存在返回\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期\n     * @return true成功 false 失败\n     */\n    public boolean setnx(String key, Object value, long time) {\n        try {\n            if (time > 0) {\n                redisTemplate.opsForValue().setIfAbsent(key, value, time, TimeUnit.SECONDS);\n            } else {\n                set(key, value);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n\n    /**\n     * 递增\n     * @param key 键\n     * @param delta 要增加几(大于0)\n     * @return\n     */\n    public long incr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递增因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, delta);\n    }\n    /**\n     * 递减\n     * @param key 键\n     * @param delta 要减少几(小于0)\n     * @return\n     */\n    public long decr(String key, long delta) {\n        if (delta < 0) {\n            throw new RuntimeException(\"递减因子必须大于0\");\n        }\n        return redisTemplate.opsForValue().increment(key, -delta);\n    }\n    /**\n     * HashGet\n     * @param key 键 不能为null\n     * @param item 项 不能为null\n     * @return 值\n     */\n    public Object hget(String key, String item) {\n        return redisTemplate.opsForHash().get(key, item);\n    }\n    /**\n     * 获取hashKey对应的所有键值\n     * @param key 键\n     * @return 对应的多个键值\n     */\n    public Map<Object, Object> hmget(String key) {\n        return redisTemplate.opsForHash().entries(key);\n    }\n    /**\n     * HashSet\n     * @param key 键\n     * @param map 对应多个键值\n     * @return true 成功 false 失败\n     */\n    public boolean hmset(String key, Map<String, Object> map) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * HashSet 并设置时间\n     * @param key 键\n     * @param map 对应多个键值\n     * @param time 时间(秒)\n     * @return true成功 false失败\n     */\n    public boolean hmset(String key, Map<String, Object> map, long time) {\n        try {\n            redisTemplate.opsForHash().putAll(key, map);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     * @param key 键\n     * @param item 项\n     * @param value 值\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 向一张hash表中放入数据,如果不存在将创建\n     * @param key 键\n     * @param item 项\n     * @param value 值\n     * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间\n     * @return true 成功 false失败\n     */\n    public boolean hset(String key, String item, Object value, long time) {\n        try {\n            redisTemplate.opsForHash().put(key, item, value);\n            if (time > 0) {\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 删除hash表中的值\n     * @param key 键 不能为null\n     * @param item 项 可以使多个 不能为null\n     */\n    public void hdel(String key, Object... item) {\n        redisTemplate.opsForHash().delete(key, item);\n    }\n    /**\n     * 判断hash表中是否有该项的值\n     * @param key 键 不能为null\n     * @param item 项 不能为null\n     * @return true 存在 false不存在\n     */\n    public boolean hHasKey(String key, String item) {\n        return redisTemplate.opsForHash().hasKey(key, item);\n    }\n    /**\n     * hash递增 如果不存在,就会创建一个 并把新增后的值返回\n     * @param key 键\n     * @param item 项\n     * @param by 要增加几(大于0)\n     * @return\n     */\n    public double hincr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, by);\n    }\n    /**\n     * hash递减\n     * @param key 键\n     * @param item 项\n     * @param by 要减少记(小于0)\n     * @return\n     */\n    public double hdecr(String key, String item, double by) {\n        return redisTemplate.opsForHash().increment(key, item, -by);\n    }\n    /**\n     * 根据key获取Set中的所有值\n     * @param key 键\n     * @return\n     */\n    public Set<Object> sGet(String key) {\n        try {\n            return redisTemplate.opsForSet().members(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    /**\n     * 根据value从一个set中查询,是否存在\n     * @param key 键\n     * @param value 值\n     * @return true 存在 false不存在\n     */\n    public boolean sHasKey(String key, Object value) {\n        try {\n            return redisTemplate.opsForSet().isMember(key, value);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 将数据放入set缓存\n     * @param key 键\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSet(String key, Object... values) {\n        try {\n            return redisTemplate.opsForSet().add(key, values);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    /**\n     * 将set数据放入缓存\n     * @param key 键\n     * @param time 时间(秒)\n     * @param values 值 可以是多个\n     * @return 成功个数\n     */\n    public long sSetAndTime(String key, long time, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().add(key, values);\n            if (time > 0){\n                expire(key, time);\n            }\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    /**\n     * 获取set缓存的长度\n     * @param key 键\n     * @return\n     */\n    public long sGetSetSize(String key) {\n        try {\n            return redisTemplate.opsForSet().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    /**\n     * 移除值为value的\n     * @param key 键\n     * @param values 值 可以是多个\n     * @return 移除的个数\n     */\n    public long setRemove(String key, Object... values) {\n        try {\n            Long count = redisTemplate.opsForSet().remove(key, values);\n            return count;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    // ===============================list=================================\n    /**\n     * 获取list缓存的内容\n     * @param key 键\n     * @param start 开始\n     * @param end 结束 0 到 -1代表所有值\n     * @return\n     */\n    public List<Object> lGet(String key, long start, long end) {\n        try {\n            return redisTemplate.opsForList().range(key, start, end);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    /**\n     * 获取list缓存的长度\n     * @param key 键\n     * @return\n     */\n    public long lGetListSize(String key) {\n        try {\n            return redisTemplate.opsForList().size(key);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n    /**\n     * 通过索引 获取list中的值\n     * @param key 键\n     * @param index 索引 index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推\n     * @return\n     */\n    public Object lGetIndex(String key, long index) {\n        try {\n            return redisTemplate.opsForList().index(key, index);\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    /**\n     * 将list放入缓存\n     * @param key 键\n     * @param value 值\n     * @return\n     */\n    public boolean lSet(String key, Object value) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 将list放入缓存\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒)\n     * @return\n     */\n    public boolean lSet(String key, Object value, long time) {\n        try {\n            redisTemplate.opsForList().rightPush(key, value);\n            if (time > 0){\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 将list放入缓存\n     * @param key 键\n     * @param value 值\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 将list放入缓存\n     *\n     * @param key 键\n     * @param value 值\n     * @param time 时间(秒)\n     * @return\n     */\n    public boolean lSet(String key, List<Object> value, long time) {\n        try {\n            redisTemplate.opsForList().rightPushAll(key, value);\n            if (time > 0){\n                expire(key, time);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 根据索引修改list中的某条数据\n     * @param key 键\n     * @param index 索引\n     * @param value 值\n     * @return\n     */\n    public boolean lUpdateIndex(String key, long index, Object value) {\n        try {\n            redisTemplate.opsForList().set(key, index, value);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n    /**\n     * 移除N个值为value\n     * @param key 键\n     * @param count 移除多少个\n     * @param value 值\n     * @return 移除的个数\n     */\n    public long lRemove(String key, long count, Object value) {\n        try {\n            Long remove = redisTemplate.opsForList().remove(key, count, value);\n            return remove;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return 0;\n        }\n    }\n}\n```\n\n5. 使用\n\n```java\n@RestController\npublic class Demo {\n    @Autowired\n    RedisUtils redisUtils;\n    @RequestMapping(\"/redisTest\")\n    public String test(){\n        redisUtils.set(\"test3:key3\",\"hello,redis\");\n        return redisUtils.get(\"test3:key3\").toString();\n    }\n}\n```\n\n# 4、进阶\n## 4.1、redis持久化\n### 4.1.1、rdb\n\n把当前内存中的快照写入磁盘\n\n（1）save：save指令执行会阻塞当前redis服务器，直到当前rdb过程执行完，可能造成长时间阻塞，线上环境不建议使用\n（2）bgsave：调用fork函数生成子进程，解决了save的阻塞问题\n（3）自动执行：（redis配置文件中配置）save 900 1   save 300 10   save 60 1000\n\n### 4.1.2、aof\n\n以日志的方式记录每次写命令，重启时再执行aof中的命令达到数据恢复的目的（是目前redis持久化的主流方式）\n\naof写数据策略：\n\n（1）always：服务器每写入一个命令,就调用一次fdatasync（不会丢失数据）\n（2）Everysec：服务器每一秒重调用一次fdatasync（数据同步），最多丢失1秒的数据\n（3）NO：操作系统决定任何将缓冲区里面的命令写入磁盘里面，数据丢失量是不确定的\n\n> 注：always策略持久化数据：先把写命令追加到aof buffer中，下一次进入事件循环循环后，再将buffer写到磁盘上。也就是说，这次写到磁盘上的内容是上一个事件循环产生的所以，即使设置为always，也会丢失一个循环的数据\n\n\n### 4.1.3、对比\n\n|  | rdb | aof |\n| --- | --- | --- |\n| 占用存储空间 | 小（数据级） | 大（指令级） |\n| 恢复速度 | 快 | 慢（需要执行指令） |\n| 数据安全性 | 可能会丢失最后一次持久化后的数据 | 根据策略决定 |\n\n## 4.2、redis淘汰策略\n\n### 4.2.1、定时删除\n方式：创建一个定时器,当设置的key到达到期时间时,由定时器任务立即执行对key的删除操作\n\n优缺点：\n（1）节约内存,到时就删,快速释放掉不必要的内存占用 \n（2）CPU压力变大,无论CPU此时负载量多高,均占用CPU\n\n### 4.2.2、惰性删除\n方式：数据到期时不做删除,等下次访问时进行删除\n\n优缺点：\n（1）节约cpu性能  \n（2）若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）\n\n### 4.2.3、定期删除\n方式：每隔一段时间主动检查一批过期键，并将其删除。这样可以保证过期键及时地从内存中释放\n\n>（1）Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置健为\n hz 它的默认值是 hz 10。\n 【注意】:Redis 每次扫描并不是遍历过期字典中的所有健，而是采用随机抽取判断并删除过期健的形式执行的。\n\n删除流程：\n（1）从过期字典随机取20个键\n（2）删除这20个键中过期的键\n（3）如果过期key的比例超过25%，重复步骤1\n\n优缺点：\n（1）分批处理，以避免对cpu产生过大的负载\n\n## 4.3、redis内存淘汰策略\n\nRedis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据\n\n>LRU：淘汰最长时间没有被使用的\n LFU：一定时间内使用频次越低的\n random：随机\n ttl：越早过期的数据\n \n|淘汰策略名称|策略含义|\n|---|---|\n|noeviction|默认策略，不淘汰数据；大部分写命令都将返回错误（DEL等少数除外）|\n|allkeys-lru|从所有数据中根据 LRU 算法挑选数据淘汰|\n|volatile-lru|从设置了过期时间的数据中根据 LRU 算法挑选数据淘汰|\n|allkeys-random|从所有数据中随机挑选数据淘汰|\n|volatile-random|从设置了过期时间的数据中随机挑选数据淘汰|\n|volatile-ttl|从设置了过期时间的数据中，挑选越早过期的数据进行删除|\n|allkeys-lfu|从所有数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）|\n|volatile-lfu|从设置了过期时间的数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）|\n\n  \n## 4.4、redis工作模式\n\n### 4.4.1、单机模式\n\n单机模式是最简单的 Redis 工作模式。在单机模式下，Redis 只运行在单个节点上，数据存储在该节点的内存中。这种模式适用于小规模应用或开发环境\n\n### 4.4.2、主从复制模式\n\n主从复制模式通过将数据从主节点复制到一个或多个从节点来提高数据的可靠性和读取性能。主节点负责处理写入操作，从节点复制主节点的数据，并可以处理读取操作。主从复制模式适用于需要读取扩展和数据冗余的场景\n\n\n### 4.4.3、哨兵模式\n\n主从复制的基础上，引入了哨兵节点来监控主节点的状态。当主节点发生故障时，哨兵节点会自动将一个从节点升级为新的主节点，并将其他从节点重新配置为复制新的主节点。这种模式提供了故障转移和自动主节点切换的功能\n\n### 4.4.4、集群模式\n\n即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据。cluster是为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，提高并发量\n\n## 4.5、redis发布订阅机制\n\nRedis 发布订阅（Pus/Sub）是一种消息通信模式：发送者通过 PUBLISH发布消息，订阅者通过 SUBSCRIBE 订阅接收消息或通过UNSUBSCRIBE 取消订阅。\n发布者和订阅者属于客户端，Channel 是 Redis 服务端，发布者将消息发布到频道，订阅这个频道的订阅者则收到消息。从而实现消息的广播和实时通知\n\n\n> Redis 的发布订阅机制是一种简单的消息传递方式，并不提供消息持久化和消息队列的功能。如果需要更高级的消息队列功能，可以考虑rabbitmq，kafka等\n\n```shell\n# A订阅频道\nSUBSCRIBE channel1\n\n# B向频道发送消息，A就可以收到消息\nPUBLISH channel1 \"Redis PUBLISH test\"\n\n```\n\n## 4.6、缓存穿透、击穿、雪崩\n###  4.6.1、缓存穿透\n\n某些不存在的数据，被大量的查询访问，缓存层中没有这些数据的缓存，请求就直达存储层，造成宕机\n\n> 解决方法：\n1.返回空对象，将该key的空值返回给缓存层，缓存层会直接返回空对象。\n2.布隆过滤器：将所有的key都存在过滤器中，在访问缓存层的时候会首先访问过滤器，如果过滤器中不存在这个值，那么直接返回空值\n\n\n### 4.6.2、缓存击穿？\n\n一份热点数据，在它缓存失效期间，大量的请求直接命中存储层\n\n> 解决方法：\n 1.设置热点数据永不过期的策略。\n 2.加互斥锁，在一个请求访问时另一个不能访问，这样，在这个请求访问过后，缓存重建，其他线程就可以访问了\n\n### 4.6.3、缓存雪崩？\n\n当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。\n\n> 解决方法：\n>1.不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀\n>2.在系统启动或低峰期(比如系统刚启动)，提前加载热门数据到缓存中，避免在高峰期大量请求同时访问导致缓存失效\n\n\n","slug":"redis","published":1,"updated":"2023-08-09T16:22:57.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9m000j00ujajry99k1","content":"<h1 id=\"1、基本概念\"><a href=\"#1、基本概念\" class=\"headerlink\" title=\"1、基本概念\"></a>1、基本概念</h1><p>Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p>\n<h2 id=\"1-1、redis特性\"><a href=\"#1-1、redis特性\" class=\"headerlink\" title=\"1.1、redis特性\"></a>1.1、redis特性</h2><ol>\n<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>\n<li>单线程，每个命令具备原子性</li>\n</ol>\n<blockquote>\n<p>Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行</p>\n</blockquote>\n<ol start=\"3\">\n<li>低延迟，速度快</li>\n</ol>\n<blockquote>\n<p>原因：基于内存、采用多路复用非阻塞I&#x2F;O、单线程</p>\n</blockquote>\n<ol>\n<li>支持数据持久化</li>\n<li>支持主从集群、分片集群</li>\n<li>支持多语言客户端</li>\n</ol>\n<h2 id=\"1-2、数据类型\"><a href=\"#1-2、数据类型\" class=\"headerlink\" title=\"1.2、数据类型\"></a>1.2、数据类型</h2><blockquote>\n<p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308071403029.png\" alt=\"redis数据类型\"></p>\n<h1 id=\"2、redis常见命令\"><a href=\"#2、redis常见命令\" class=\"headerlink\" title=\"2、redis常见命令\"></a>2、redis常见命令</h1><h2 id=\"2-1、String\"><a href=\"#2-1、String\" class=\"headerlink\" title=\"2.1、String\"></a>2.1、String</h2><blockquote>\n<p>String类型，也就是字符串类型，是Redis中最简单的存储类型<br>底层SDS结构。为什么不直接实用字符串？①C 语言字符数组最后一个元素总是 ‘\\0’，而在Redis中\\0可能会被判定为提前结束而识别不了字符串②获取字符串长度为O(n)，因为C字符串需要去遍历，开销较大，SDS对象有len属性直接获取</p>\n</blockquote>\n<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：<br>（1）string：普通字符串<br>（2）int：整数类型，可以做自增、自减操作<br>（3）float：浮点类型，可以做自增、自减操作</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SET</td>\n<td>添加或者修改已经存在的一个String类型的键值对</td>\n</tr>\n<tr>\n<td>GET</td>\n<td>根据key获取String类型的value</td>\n</tr>\n<tr>\n<td>MSET</td>\n<td>批量添加多个String类型的键值对</td>\n</tr>\n<tr>\n<td>MGET</td>\n<td>根据多个key获取多个String类型的value</td>\n</tr>\n<tr>\n<td>INCR</td>\n<td>让一个整型的key自增1</td>\n</tr>\n<tr>\n<td>INCRBY</td>\n<td>让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td>\n</tr>\n<tr>\n<td>INCRBYFLOAT</td>\n<td>让一个浮点类型的数字自增并指定步长</td>\n</tr>\n<tr>\n<td>SETNX</td>\n<td>添加一个String类型的键值对，前提是这个key不存在，否则不执行</td>\n</tr>\n<tr>\n<td>SETEX</td>\n<td>添加一个String类型的键值对，并且指定有效期</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、Hash\"><a href=\"#2-2、Hash\" class=\"headerlink\" title=\"2.2、Hash\"></a>2.2、Hash</h2><blockquote>\n<p>Hash类型，也叫散列，底层是hashtable，其value是一个无序字典，类似于Java中的HashMap结构。</p>\n</blockquote>\n<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</p>\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HSET key field value</td>\n<td>添加或者修改hash类型key的field的值</td>\n</tr>\n<tr>\n<td>HGET key field</td>\n<td>获取一个hash类型key的field的值</td>\n</tr>\n<tr>\n<td>HMSET</td>\n<td>hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了</td>\n</tr>\n<tr>\n<td>HMGET</td>\n<td>批量获取多个hash类型key的field的值</td>\n</tr>\n<tr>\n<td>HGETALL</td>\n<td>获取一个hash类型的key中的所有的field和value</td>\n</tr>\n<tr>\n<td>HKEYS</td>\n<td>获取一个hash类型的key中的所有的field</td>\n</tr>\n<tr>\n<td>HVALS</td>\n<td>获取一个hash类型的key中的所有的value</td>\n</tr>\n<tr>\n<td>HINCRBY</td>\n<td>让一个hash类型key的字段值自增并指定步长</td>\n</tr>\n<tr>\n<td>HSETNX</td>\n<td>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-3、List\"><a href=\"#2-3、List\" class=\"headerlink\" title=\"2.3、List\"></a>2.3、List</h2><blockquote>\n<p>list列表的数据结构使用的是压缩列表ziplist和普通的双向链表linkedlist组成。元素少的时候会用ziplist，元素多的时候会用linkedlist<br>  ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的,当数据量较大的时候因为需要重新分配，开销较大</p>\n</blockquote>\n<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等</p>\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LPUSH key element …</td>\n<td>向列表左侧插入一个或多个元素</td>\n</tr>\n<tr>\n<td>LPOP key</td>\n<td>移除并返回列表左侧的第一个元素，没有则返回nil</td>\n</tr>\n<tr>\n<td><strong>RPUSH key element …</strong></td>\n<td>向列表右侧插入一个或多个元素</td>\n</tr>\n<tr>\n<td>RPOP key</td>\n<td>移除并返回列表右侧的第一个元素</td>\n</tr>\n<tr>\n<td>LRANGE key star end</td>\n<td>返回一段角标范围内的所有元素</td>\n</tr>\n<tr>\n<td>BLPOP和BRPOP</td>\n<td>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-4、SET\"><a href=\"#2-4、SET\" class=\"headerlink\" title=\"2.4、SET\"></a>2.4、SET</h2><blockquote>\n<p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征。数据结构的底层实现有两种方式：Intset 和 Hashtable。当集合中的所有元素都是整数，并且元素数量较少时，Redis 会使用 Intset 作为底层实现。当集合中的元素不仅限于整数，或者元素数量较多时，Redis 会使用 Hashtable 作为底层实现</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SADD key member …</td>\n<td>向set中添加一个或多个元素</td>\n</tr>\n<tr>\n<td>SREM key member …</td>\n<td>移除set中的指定元素</td>\n</tr>\n<tr>\n<td>SCARD key</td>\n<td>返回set中元素的个数</td>\n</tr>\n<tr>\n<td>SISMEMBER key member</td>\n<td>判断一个元素是否存在于set中</td>\n</tr>\n<tr>\n<td>SMEMBERS</td>\n<td>获取set中的所有元素</td>\n</tr>\n<tr>\n<td>SINTER key1 key2 …</td>\n<td>求key1与key2的交集</td>\n</tr>\n<tr>\n<td>SDIFF key1 key2 …</td>\n<td>求key1与key2的差集</td>\n</tr>\n<tr>\n<td>SUNION key1 key2 …</td>\n<td>求key1和key2的并集</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-5、SortedSet\"><a href=\"#2-5、SortedSet\" class=\"headerlink\" title=\"2.5、SortedSet\"></a>2.5、SortedSet</h2><blockquote>\n<p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>\n</blockquote>\n<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能</p>\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ZADD key score member</td>\n<td>添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td>\n</tr>\n<tr>\n<td>ZREM key member</td>\n<td>删除sorted set中的一个指定元素</td>\n</tr>\n<tr>\n<td>ZSCORE key member</td>\n<td>获取sorted set中的指定元素的score值</td>\n</tr>\n<tr>\n<td>ZRANK key member</td>\n<td>获取sorted set 中的指定元素的排名</td>\n</tr>\n<tr>\n<td>ZCARD key</td>\n<td>获取sorted set中的元素个数</td>\n</tr>\n<tr>\n<td>ZCOUNT key min max</td>\n<td>统计score值在给定范围内的所有元素的个数</td>\n</tr>\n<tr>\n<td>ZINCRBY key increment member</td>\n<td>让sorted set中的指定元素自增，步长为指定的increment值</td>\n</tr>\n<tr>\n<td>ZRANGE key min max</td>\n<td>按照score排序后，获取指定排名范围内的元素</td>\n</tr>\n<tr>\n<td>ZRANGEBYSCORE key min max</td>\n<td>按照score排序后，获取指定score范围内的元素</td>\n</tr>\n<tr>\n<td>ZDIFF、ZINTER、ZUNION</td>\n<td>求差集、交集、并集</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</strong></p>\n</blockquote>\n<h1 id=\"3、java客户端\"><a href=\"#3、java客户端\" class=\"headerlink\" title=\"3、java客户端\"></a>3、java客户端</h1><h2 id=\"3-1、springboot整合redis\"><a href=\"#3-1、springboot整合redis\" class=\"headerlink\" title=\"3.1、springboot整合redis\"></a>3.1、springboot整合redis</h2><h3 id=\"3-1-1、引入依赖\"><a href=\"#3-1-1、引入依赖\" class=\"headerlink\" title=\"3.1.1、引入依赖\"></a>3.1.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-2、redis基本配置\"><a href=\"#3-1-2、redis基本配置\" class=\"headerlink\" title=\"3.1.2、redis基本配置\"></a>3.1.2、redis基本配置</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#redis基本配置</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.host</span>=<span class=\"string\">127.0.0.1</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.port</span>=<span class=\"string\">6379</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-3、redis固定配置\"><a href=\"#3-1-3、redis固定配置\" class=\"headerlink\" title=\"3.1.3、redis固定配置\"></a>3.1.3、redis固定配置</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title function_\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory factory)</span> &#123;</span><br><span class=\"line\">        RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 配置连接池工厂</span></span><br><span class=\"line\">        template.setConnectionFactory(factory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Jackson序列化配置</span></span><br><span class=\"line\">        <span class=\"type\">Jackson2JsonRedisSerializer</span> <span class=\"variable\">jackson2JsonRedisSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class=\"line\">        <span class=\"type\">ObjectMapper</span> <span class=\"variable\">om</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 属性访问器为全部，作用域为全部</span></span><br><span class=\"line\">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class=\"line\">        <span class=\"comment\">// 序列化输入类型必须是非final类型的</span></span><br><span class=\"line\">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class=\"line\">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// String 的序列化</span></span><br><span class=\"line\">        <span class=\"type\">StringRedisSerializer</span> <span class=\"variable\">stringRedisSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// key采用String的序列化方式</span></span><br><span class=\"line\">        template.setKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// hash的key也采用String的序列化方式</span></span><br><span class=\"line\">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// value序列化方式采用jackson</span></span><br><span class=\"line\">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// hash的value序列化方式采用jackson</span></span><br><span class=\"line\">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class=\"line\">        template.afterPropertiesSet();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>redis使用JDK提供的序列化功能。 优点是反序列化时不需要提供类型信息(class)，但缺点是需要实现Serializable接口，还有序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存<br>所以我们需要  使用Jackson库将对象序列化为JSON字符串。优点是速度快，序列化后的字符串短小精悍，易读</p>\n</blockquote>\n<h3 id=\"3-1-4、工具类\"><a href=\"#3-1-4、工具类\" class=\"headerlink\" title=\"3.1.4、工具类\"></a>3.1.4、工具类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kaka.redis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.CollectionUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.Resource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisUtils</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title function_\">keys</span><span class=\"params\">(String keys)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.keys(keys);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定缓存失效时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">expire</span><span class=\"params\">(String key, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据key 获取过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getExpire</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断key是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasKey</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.hasKey(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 可以传一个值 或多个</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">del</span><span class=\"params\">(String... key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; key.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                redisTemplate.delete(key[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存获取</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">get</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key == <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">set</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForValue().set(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入, 不存在放入，存在返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">setnx</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForValue().setIfAbsent(key,value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入并设置时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false 失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">set</span><span class=\"params\">(String key, Object value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                set(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入并设置时间,不存在放入，存在返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false 失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">setnx</span><span class=\"params\">(String key, Object value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.opsForValue().setIfAbsent(key, value, time, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                set(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递增</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delta 要增加几(大于0)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">incr</span><span class=\"params\">(String key, <span class=\"type\">long</span> delta)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;递增因子必须大于0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递减</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delta 要减少几(小于0)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">decr</span><span class=\"params\">(String key, <span class=\"type\">long</span> delta)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;递减因子必须大于0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashGet</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">hget</span><span class=\"params\">(String key, String item)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取hashKey对应的所有键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 对应的多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Object, Object&gt; <span class=\"title function_\">hmget</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashSet</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 对应多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false 失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hmset</span><span class=\"params\">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashSet 并设置时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 对应多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hmset</span><span class=\"params\">(String key, Map&lt;String, Object&gt; map, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hset</span><span class=\"params\">(String key, String item, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hset</span><span class=\"params\">(String key, String item, Object value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除hash表中的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 可以使多个 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hdel</span><span class=\"params\">(String key, Object... item)</span> &#123;</span><br><span class=\"line\">        redisTemplate.opsForHash().delete(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断hash表中是否有该项的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hHasKey</span><span class=\"params\">(String key, String item)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> by 要增加几(大于0)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">hincr</span><span class=\"params\">(String key, String item, <span class=\"type\">double</span> by)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash递减</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> by 要减少记(小于0)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">hdecr</span><span class=\"params\">(String key, String item, <span class=\"type\">double</span> by)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据key获取Set中的所有值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Set&lt;Object&gt; <span class=\"title function_\">sGet</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().members(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据value从一个set中查询,是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sHasKey</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将数据放入set缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">sSet</span><span class=\"params\">(String key, Object... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将set数据放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">sSetAndTime</span><span class=\"params\">(String key, <span class=\"type\">long</span> time, Object... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取set缓存的长度</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">sGetSetSize</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().size(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除值为value的</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 移除的个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">setRemove</span><span class=\"params\">(String key, Object... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ===============================list=================================</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取list缓存的内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> start 开始</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Object&gt; <span class=\"title function_\">lGet</span><span class=\"params\">(String key, <span class=\"type\">long</span> start, <span class=\"type\">long</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取list缓存的长度</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">lGetListSize</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().size(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过索引 获取list中的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">lGetIndex</span><span class=\"params\">(String key, <span class=\"type\">long</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lSet</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lSet</span><span class=\"params\">(String key, Object value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lSet</span><span class=\"params\">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lSet</span><span class=\"params\">(String key, List&lt;Object&gt; value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据索引修改list中的某条数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index 索引</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lUpdateIndex</span><span class=\"params\">(String key, <span class=\"type\">long</span> index, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().set(key, index, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除N个值为value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count 移除多少个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 移除的个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">lRemove</span><span class=\"params\">(String key, <span class=\"type\">long</span> count, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">remove</span> <span class=\"operator\">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> remove;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>使用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisUtils redisUtils;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        redisUtils.set(<span class=\"string\">&quot;test3:key3&quot;</span>,<span class=\"string\">&quot;hello,redis&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisUtils.get(<span class=\"string\">&quot;test3:key3&quot;</span>).toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、进阶\"><a href=\"#4、进阶\" class=\"headerlink\" title=\"4、进阶\"></a>4、进阶</h1><h2 id=\"4-1、redis持久化\"><a href=\"#4-1、redis持久化\" class=\"headerlink\" title=\"4.1、redis持久化\"></a>4.1、redis持久化</h2><h3 id=\"4-1-1、rdb\"><a href=\"#4-1-1、rdb\" class=\"headerlink\" title=\"4.1.1、rdb\"></a>4.1.1、rdb</h3><p>把当前内存中的快照写入磁盘</p>\n<p>（1）save：save指令执行会阻塞当前redis服务器，直到当前rdb过程执行完，可能造成长时间阻塞，线上环境不建议使用<br>（2）bgsave：调用fork函数生成子进程，解决了save的阻塞问题<br>（3）自动执行：（redis配置文件中配置）save 900 1   save 300 10   save 60 1000</p>\n<h3 id=\"4-1-2、aof\"><a href=\"#4-1-2、aof\" class=\"headerlink\" title=\"4.1.2、aof\"></a>4.1.2、aof</h3><p>以日志的方式记录每次写命令，重启时再执行aof中的命令达到数据恢复的目的（是目前redis持久化的主流方式）</p>\n<p>aof写数据策略：</p>\n<p>（1）always：服务器每写入一个命令,就调用一次fdatasync（不会丢失数据）<br>（2）Everysec：服务器每一秒重调用一次fdatasync（数据同步），最多丢失1秒的数据<br>（3）NO：操作系统决定任何将缓冲区里面的命令写入磁盘里面，数据丢失量是不确定的</p>\n<blockquote>\n<p>注：always策略持久化数据：先把写命令追加到aof buffer中，下一次进入事件循环循环后，再将buffer写到磁盘上。也就是说，这次写到磁盘上的内容是上一个事件循环产生的所以，即使设置为always，也会丢失一个循环的数据</p>\n</blockquote>\n<h3 id=\"4-1-3、对比\"><a href=\"#4-1-3、对比\" class=\"headerlink\" title=\"4.1.3、对比\"></a>4.1.3、对比</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>rdb</th>\n<th>aof</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>占用存储空间</td>\n<td>小（数据级）</td>\n<td>大（指令级）</td>\n</tr>\n<tr>\n<td>恢复速度</td>\n<td>快</td>\n<td>慢（需要执行指令）</td>\n</tr>\n<tr>\n<td>数据安全性</td>\n<td>可能会丢失最后一次持久化后的数据</td>\n<td>根据策略决定</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-2、redis淘汰策略\"><a href=\"#4-2、redis淘汰策略\" class=\"headerlink\" title=\"4.2、redis淘汰策略\"></a>4.2、redis淘汰策略</h2><h3 id=\"4-2-1、定时删除\"><a href=\"#4-2-1、定时删除\" class=\"headerlink\" title=\"4.2.1、定时删除\"></a>4.2.1、定时删除</h3><p>方式：创建一个定时器,当设置的key到达到期时间时,由定时器任务立即执行对key的删除操作</p>\n<p>优缺点：<br>（1）节约内存,到时就删,快速释放掉不必要的内存占用<br>（2）CPU压力变大,无论CPU此时负载量多高,均占用CPU</p>\n<h3 id=\"4-2-2、惰性删除\"><a href=\"#4-2-2、惰性删除\" class=\"headerlink\" title=\"4.2.2、惰性删除\"></a>4.2.2、惰性删除</h3><p>方式：数据到期时不做删除,等下次访问时进行删除</p>\n<p>优缺点：<br>（1）节约cpu性能  <br>（2）若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>\n<h3 id=\"4-2-3、定期删除\"><a href=\"#4-2-3、定期删除\" class=\"headerlink\" title=\"4.2.3、定期删除\"></a>4.2.3、定期删除</h3><p>方式：每隔一段时间主动检查一批过期键，并将其删除。这样可以保证过期键及时地从内存中释放</p>\n<blockquote>\n<p>（1）Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置健为<br> hz 它的默认值是 hz 10。<br> 【注意】:Redis 每次扫描并不是遍历过期字典中的所有健，而是采用随机抽取判断并删除过期健的形式执行的。</p>\n</blockquote>\n<p>删除流程：<br>（1）从过期字典随机取20个键<br>（2）删除这20个键中过期的键<br>（3）如果过期key的比例超过25%，重复步骤1</p>\n<p>优缺点：<br>（1）分批处理，以避免对cpu产生过大的负载</p>\n<h2 id=\"4-3、redis内存淘汰策略\"><a href=\"#4-3、redis内存淘汰策略\" class=\"headerlink\" title=\"4.3、redis内存淘汰策略\"></a>4.3、redis内存淘汰策略</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据</p>\n<blockquote>\n<p>LRU：淘汰最长时间没有被使用的<br> LFU：一定时间内使用频次越低的<br> random：随机<br> ttl：越早过期的数据</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>淘汰策略名称</th>\n<th>策略含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>noeviction</td>\n<td>默认策略，不淘汰数据；大部分写命令都将返回错误（DEL等少数除外）</td>\n</tr>\n<tr>\n<td>allkeys-lru</td>\n<td>从所有数据中根据 LRU 算法挑选数据淘汰</td>\n</tr>\n<tr>\n<td>volatile-lru</td>\n<td>从设置了过期时间的数据中根据 LRU 算法挑选数据淘汰</td>\n</tr>\n<tr>\n<td>allkeys-random</td>\n<td>从所有数据中随机挑选数据淘汰</td>\n</tr>\n<tr>\n<td>volatile-random</td>\n<td>从设置了过期时间的数据中随机挑选数据淘汰</td>\n</tr>\n<tr>\n<td>volatile-ttl</td>\n<td>从设置了过期时间的数据中，挑选越早过期的数据进行删除</td>\n</tr>\n<tr>\n<td>allkeys-lfu</td>\n<td>从所有数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）</td>\n</tr>\n<tr>\n<td>volatile-lfu</td>\n<td>从设置了过期时间的数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-4、redis工作模式\"><a href=\"#4-4、redis工作模式\" class=\"headerlink\" title=\"4.4、redis工作模式\"></a>4.4、redis工作模式</h2><h3 id=\"4-4-1、单机模式\"><a href=\"#4-4-1、单机模式\" class=\"headerlink\" title=\"4.4.1、单机模式\"></a>4.4.1、单机模式</h3><p>单机模式是最简单的 Redis 工作模式。在单机模式下，Redis 只运行在单个节点上，数据存储在该节点的内存中。这种模式适用于小规模应用或开发环境</p>\n<h3 id=\"4-4-2、主从复制模式\"><a href=\"#4-4-2、主从复制模式\" class=\"headerlink\" title=\"4.4.2、主从复制模式\"></a>4.4.2、主从复制模式</h3><p>主从复制模式通过将数据从主节点复制到一个或多个从节点来提高数据的可靠性和读取性能。主节点负责处理写入操作，从节点复制主节点的数据，并可以处理读取操作。主从复制模式适用于需要读取扩展和数据冗余的场景</p>\n<h3 id=\"4-4-3、哨兵模式\"><a href=\"#4-4-3、哨兵模式\" class=\"headerlink\" title=\"4.4.3、哨兵模式\"></a>4.4.3、哨兵模式</h3><p>主从复制的基础上，引入了哨兵节点来监控主节点的状态。当主节点发生故障时，哨兵节点会自动将一个从节点升级为新的主节点，并将其他从节点重新配置为复制新的主节点。这种模式提供了故障转移和自动主节点切换的功能</p>\n<h3 id=\"4-4-4、集群模式\"><a href=\"#4-4-4、集群模式\" class=\"headerlink\" title=\"4.4.4、集群模式\"></a>4.4.4、集群模式</h3><p>即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据。cluster是为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，提高并发量</p>\n<h2 id=\"4-5、redis发布订阅机制\"><a href=\"#4-5、redis发布订阅机制\" class=\"headerlink\" title=\"4.5、redis发布订阅机制\"></a>4.5、redis发布订阅机制</h2><p>Redis 发布订阅（Pus&#x2F;Sub）是一种消息通信模式：发送者通过 PUBLISH发布消息，订阅者通过 SUBSCRIBE 订阅接收消息或通过UNSUBSCRIBE 取消订阅。<br>发布者和订阅者属于客户端，Channel 是 Redis 服务端，发布者将消息发布到频道，订阅这个频道的订阅者则收到消息。从而实现消息的广播和实时通知</p>\n<blockquote>\n<p>Redis 的发布订阅机制是一种简单的消息传递方式，并不提供消息持久化和消息队列的功能。如果需要更高级的消息队列功能，可以考虑rabbitmq，kafka等</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">A订阅频道</span></span><br><span class=\"line\">SUBSCRIBE channel1</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">B向频道发送消息，A就可以收到消息</span></span><br><span class=\"line\">PUBLISH channel1 &quot;Redis PUBLISH test&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-6、缓存穿透、击穿、雪崩\"><a href=\"#4-6、缓存穿透、击穿、雪崩\" class=\"headerlink\" title=\"4.6、缓存穿透、击穿、雪崩\"></a>4.6、缓存穿透、击穿、雪崩</h2><h3 id=\"4-6-1、缓存穿透\"><a href=\"#4-6-1、缓存穿透\" class=\"headerlink\" title=\"4.6.1、缓存穿透\"></a>4.6.1、缓存穿透</h3><p>某些不存在的数据，被大量的查询访问，缓存层中没有这些数据的缓存，请求就直达存储层，造成宕机</p>\n<blockquote>\n<p>解决方法：<br>1.返回空对象，将该key的空值返回给缓存层，缓存层会直接返回空对象。<br>2.布隆过滤器：将所有的key都存在过滤器中，在访问缓存层的时候会首先访问过滤器，如果过滤器中不存在这个值，那么直接返回空值</p>\n</blockquote>\n<h3 id=\"4-6-2、缓存击穿？\"><a href=\"#4-6-2、缓存击穿？\" class=\"headerlink\" title=\"4.6.2、缓存击穿？\"></a>4.6.2、缓存击穿？</h3><p>一份热点数据，在它缓存失效期间，大量的请求直接命中存储层</p>\n<blockquote>\n<p>解决方法：<br> 1.设置热点数据永不过期的策略。<br> 2.加互斥锁，在一个请求访问时另一个不能访问，这样，在这个请求访问过后，缓存重建，其他线程就可以访问了</p>\n</blockquote>\n<h3 id=\"4-6-3、缓存雪崩？\"><a href=\"#4-6-3、缓存雪崩？\" class=\"headerlink\" title=\"4.6.3、缓存雪崩？\"></a>4.6.3、缓存雪崩？</h3><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>\n<blockquote>\n<p>解决方法：<br>1.不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀<br>2.在系统启动或低峰期(比如系统刚启动)，提前加载热门数据到缓存中，避免在高峰期大量请求同时访问导致缓存失效</p>\n</blockquote>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、基本概念\"><a href=\"#1、基本概念\" class=\"headerlink\" title=\"1、基本概念\"></a>1、基本概念</h1><p>Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p>\n<h2 id=\"1-1、redis特性\"><a href=\"#1-1、redis特性\" class=\"headerlink\" title=\"1.1、redis特性\"></a>1.1、redis特性</h2><ol>\n<li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li>\n<li>单线程，每个命令具备原子性</li>\n</ol>\n<blockquote>\n<p>Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行</p>\n</blockquote>\n<ol start=\"3\">\n<li>低延迟，速度快</li>\n</ol>\n<blockquote>\n<p>原因：基于内存、采用多路复用非阻塞I&#x2F;O、单线程</p>\n</blockquote>\n<ol>\n<li>支持数据持久化</li>\n<li>支持主从集群、分片集群</li>\n<li>支持多语言客户端</li>\n</ol>\n<h2 id=\"1-2、数据类型\"><a href=\"#1-2、数据类型\" class=\"headerlink\" title=\"1.2、数据类型\"></a>1.2、数据类型</h2><blockquote>\n<p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308071403029.png\" alt=\"redis数据类型\"></p>\n<h1 id=\"2、redis常见命令\"><a href=\"#2、redis常见命令\" class=\"headerlink\" title=\"2、redis常见命令\"></a>2、redis常见命令</h1><h2 id=\"2-1、String\"><a href=\"#2-1、String\" class=\"headerlink\" title=\"2.1、String\"></a>2.1、String</h2><blockquote>\n<p>String类型，也就是字符串类型，是Redis中最简单的存储类型<br>底层SDS结构。为什么不直接实用字符串？①C 语言字符数组最后一个元素总是 ‘\\0’，而在Redis中\\0可能会被判定为提前结束而识别不了字符串②获取字符串长度为O(n)，因为C字符串需要去遍历，开销较大，SDS对象有len属性直接获取</p>\n</blockquote>\n<p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：<br>（1）string：普通字符串<br>（2）int：整数类型，可以做自增、自减操作<br>（3）float：浮点类型，可以做自增、自减操作</p>\n<table>\n<thead>\n<tr>\n<th>命令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SET</td>\n<td>添加或者修改已经存在的一个String类型的键值对</td>\n</tr>\n<tr>\n<td>GET</td>\n<td>根据key获取String类型的value</td>\n</tr>\n<tr>\n<td>MSET</td>\n<td>批量添加多个String类型的键值对</td>\n</tr>\n<tr>\n<td>MGET</td>\n<td>根据多个key获取多个String类型的value</td>\n</tr>\n<tr>\n<td>INCR</td>\n<td>让一个整型的key自增1</td>\n</tr>\n<tr>\n<td>INCRBY</td>\n<td>让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td>\n</tr>\n<tr>\n<td>INCRBYFLOAT</td>\n<td>让一个浮点类型的数字自增并指定步长</td>\n</tr>\n<tr>\n<td>SETNX</td>\n<td>添加一个String类型的键值对，前提是这个key不存在，否则不执行</td>\n</tr>\n<tr>\n<td>SETEX</td>\n<td>添加一个String类型的键值对，并且指定有效期</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：</strong></p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、Hash\"><a href=\"#2-2、Hash\" class=\"headerlink\" title=\"2.2、Hash\"></a>2.2、Hash</h2><blockquote>\n<p>Hash类型，也叫散列，底层是hashtable，其value是一个无序字典，类似于Java中的HashMap结构。</p>\n</blockquote>\n<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</p>\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HSET key field value</td>\n<td>添加或者修改hash类型key的field的值</td>\n</tr>\n<tr>\n<td>HGET key field</td>\n<td>获取一个hash类型key的field的值</td>\n</tr>\n<tr>\n<td>HMSET</td>\n<td>hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了</td>\n</tr>\n<tr>\n<td>HMGET</td>\n<td>批量获取多个hash类型key的field的值</td>\n</tr>\n<tr>\n<td>HGETALL</td>\n<td>获取一个hash类型的key中的所有的field和value</td>\n</tr>\n<tr>\n<td>HKEYS</td>\n<td>获取一个hash类型的key中的所有的field</td>\n</tr>\n<tr>\n<td>HVALS</td>\n<td>获取一个hash类型的key中的所有的value</td>\n</tr>\n<tr>\n<td>HINCRBY</td>\n<td>让一个hash类型key的字段值自增并指定步长</td>\n</tr>\n<tr>\n<td>HSETNX</td>\n<td>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-3、List\"><a href=\"#2-3、List\" class=\"headerlink\" title=\"2.3、List\"></a>2.3、List</h2><blockquote>\n<p>list列表的数据结构使用的是压缩列表ziplist和普通的双向链表linkedlist组成。元素少的时候会用ziplist，元素多的时候会用linkedlist<br>  ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的,当数据量较大的时候因为需要重新分配，开销较大</p>\n</blockquote>\n<p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等</p>\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>LPUSH key element …</td>\n<td>向列表左侧插入一个或多个元素</td>\n</tr>\n<tr>\n<td>LPOP key</td>\n<td>移除并返回列表左侧的第一个元素，没有则返回nil</td>\n</tr>\n<tr>\n<td><strong>RPUSH key element …</strong></td>\n<td>向列表右侧插入一个或多个元素</td>\n</tr>\n<tr>\n<td>RPOP key</td>\n<td>移除并返回列表右侧的第一个元素</td>\n</tr>\n<tr>\n<td>LRANGE key star end</td>\n<td>返回一段角标范围内的所有元素</td>\n</tr>\n<tr>\n<td>BLPOP和BRPOP</td>\n<td>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-4、SET\"><a href=\"#2-4、SET\" class=\"headerlink\" title=\"2.4、SET\"></a>2.4、SET</h2><blockquote>\n<p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征。数据结构的底层实现有两种方式：Intset 和 Hashtable。当集合中的所有元素都是整数，并且元素数量较少时，Redis 会使用 Intset 作为底层实现。当集合中的元素不仅限于整数，或者元素数量较多时，Redis 会使用 Hashtable 作为底层实现</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SADD key member …</td>\n<td>向set中添加一个或多个元素</td>\n</tr>\n<tr>\n<td>SREM key member …</td>\n<td>移除set中的指定元素</td>\n</tr>\n<tr>\n<td>SCARD key</td>\n<td>返回set中元素的个数</td>\n</tr>\n<tr>\n<td>SISMEMBER key member</td>\n<td>判断一个元素是否存在于set中</td>\n</tr>\n<tr>\n<td>SMEMBERS</td>\n<td>获取set中的所有元素</td>\n</tr>\n<tr>\n<td>SINTER key1 key2 …</td>\n<td>求key1与key2的交集</td>\n</tr>\n<tr>\n<td>SDIFF key1 key2 …</td>\n<td>求key1与key2的差集</td>\n</tr>\n<tr>\n<td>SUNION key1 key2 …</td>\n<td>求key1和key2的并集</td>\n</tr>\n</tbody></table>\n<h2 id=\"2-5、SortedSet\"><a href=\"#2-5、SortedSet\" class=\"headerlink\" title=\"2.5、SortedSet\"></a>2.5、SortedSet</h2><blockquote>\n<p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p>\n</blockquote>\n<p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能</p>\n<table>\n<thead>\n<tr>\n<th><strong>命令</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ZADD key score member</td>\n<td>添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td>\n</tr>\n<tr>\n<td>ZREM key member</td>\n<td>删除sorted set中的一个指定元素</td>\n</tr>\n<tr>\n<td>ZSCORE key member</td>\n<td>获取sorted set中的指定元素的score值</td>\n</tr>\n<tr>\n<td>ZRANK key member</td>\n<td>获取sorted set 中的指定元素的排名</td>\n</tr>\n<tr>\n<td>ZCARD key</td>\n<td>获取sorted set中的元素个数</td>\n</tr>\n<tr>\n<td>ZCOUNT key min max</td>\n<td>统计score值在给定范围内的所有元素的个数</td>\n</tr>\n<tr>\n<td>ZINCRBY key increment member</td>\n<td>让sorted set中的指定元素自增，步长为指定的increment值</td>\n</tr>\n<tr>\n<td>ZRANGE key min max</td>\n<td>按照score排序后，获取指定排名范围内的元素</td>\n</tr>\n<tr>\n<td>ZRANGEBYSCORE key min max</td>\n<td>按照score排序后，获取指定score范围内的元素</td>\n</tr>\n<tr>\n<td>ZDIFF、ZINTER、ZUNION</td>\n<td>求差集、交集、并集</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</strong></p>\n</blockquote>\n<h1 id=\"3、java客户端\"><a href=\"#3、java客户端\" class=\"headerlink\" title=\"3、java客户端\"></a>3、java客户端</h1><h2 id=\"3-1、springboot整合redis\"><a href=\"#3-1、springboot整合redis\" class=\"headerlink\" title=\"3.1、springboot整合redis\"></a>3.1、springboot整合redis</h2><h3 id=\"3-1-1、引入依赖\"><a href=\"#3-1-1、引入依赖\" class=\"headerlink\" title=\"3.1.1、引入依赖\"></a>3.1.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-2、redis基本配置\"><a href=\"#3-1-2、redis基本配置\" class=\"headerlink\" title=\"3.1.2、redis基本配置\"></a>3.1.2、redis基本配置</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#redis基本配置</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.host</span>=<span class=\"string\">127.0.0.1</span></span><br><span class=\"line\"><span class=\"attr\">spring.redis.port</span>=<span class=\"string\">6379</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-3、redis固定配置\"><a href=\"#3-1-3、redis固定配置\" class=\"headerlink\" title=\"3.1.3、redis固定配置\"></a>3.1.3、redis固定配置</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RedisTemplate&lt;String, Object&gt; <span class=\"title function_\">redisTemplate</span><span class=\"params\">(RedisConnectionFactory factory)</span> &#123;</span><br><span class=\"line\">        RedisTemplate&lt;String, Object&gt; template = <span class=\"keyword\">new</span> <span class=\"title class_\">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class=\"line\">        <span class=\"comment\">// 配置连接池工厂</span></span><br><span class=\"line\">        template.setConnectionFactory(factory);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Jackson序列化配置</span></span><br><span class=\"line\">        <span class=\"type\">Jackson2JsonRedisSerializer</span> <span class=\"variable\">jackson2JsonRedisSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class=\"line\">        <span class=\"type\">ObjectMapper</span> <span class=\"variable\">om</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ObjectMapper</span>();</span><br><span class=\"line\">        <span class=\"comment\">// 属性访问器为全部，作用域为全部</span></span><br><span class=\"line\">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class=\"line\">        <span class=\"comment\">// 序列化输入类型必须是非final类型的</span></span><br><span class=\"line\">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class=\"line\">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// String 的序列化</span></span><br><span class=\"line\">        <span class=\"type\">StringRedisSerializer</span> <span class=\"variable\">stringRedisSerializer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringRedisSerializer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// key采用String的序列化方式</span></span><br><span class=\"line\">        template.setKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// hash的key也采用String的序列化方式</span></span><br><span class=\"line\">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// value序列化方式采用jackson</span></span><br><span class=\"line\">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class=\"line\">        <span class=\"comment\">// hash的value序列化方式采用jackson</span></span><br><span class=\"line\">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class=\"line\">        template.afterPropertiesSet();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> template;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<blockquote>\n<p>redis使用JDK提供的序列化功能。 优点是反序列化时不需要提供类型信息(class)，但缺点是需要实现Serializable接口，还有序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存<br>所以我们需要  使用Jackson库将对象序列化为JSON字符串。优点是速度快，序列化后的字符串短小精悍，易读</p>\n</blockquote>\n<h3 id=\"3-1-4、工具类\"><a href=\"#3-1-4、工具类\" class=\"headerlink\" title=\"3.1.4、工具类\"></a>3.1.4、工具类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br><span class=\"line\">372</span><br><span class=\"line\">373</span><br><span class=\"line\">374</span><br><span class=\"line\">375</span><br><span class=\"line\">376</span><br><span class=\"line\">377</span><br><span class=\"line\">378</span><br><span class=\"line\">379</span><br><span class=\"line\">380</span><br><span class=\"line\">381</span><br><span class=\"line\">382</span><br><span class=\"line\">383</span><br><span class=\"line\">384</span><br><span class=\"line\">385</span><br><span class=\"line\">386</span><br><span class=\"line\">387</span><br><span class=\"line\">388</span><br><span class=\"line\">389</span><br><span class=\"line\">390</span><br><span class=\"line\">391</span><br><span class=\"line\">392</span><br><span class=\"line\">393</span><br><span class=\"line\">394</span><br><span class=\"line\">395</span><br><span class=\"line\">396</span><br><span class=\"line\">397</span><br><span class=\"line\">398</span><br><span class=\"line\">399</span><br><span class=\"line\">400</span><br><span class=\"line\">401</span><br><span class=\"line\">402</span><br><span class=\"line\">403</span><br><span class=\"line\">404</span><br><span class=\"line\">405</span><br><span class=\"line\">406</span><br><span class=\"line\">407</span><br><span class=\"line\">408</span><br><span class=\"line\">409</span><br><span class=\"line\">410</span><br><span class=\"line\">411</span><br><span class=\"line\">412</span><br><span class=\"line\">413</span><br><span class=\"line\">414</span><br><span class=\"line\">415</span><br><span class=\"line\">416</span><br><span class=\"line\">417</span><br><span class=\"line\">418</span><br><span class=\"line\">419</span><br><span class=\"line\">420</span><br><span class=\"line\">421</span><br><span class=\"line\">422</span><br><span class=\"line\">423</span><br><span class=\"line\">424</span><br><span class=\"line\">425</span><br><span class=\"line\">426</span><br><span class=\"line\">427</span><br><span class=\"line\">428</span><br><span class=\"line\">429</span><br><span class=\"line\">430</span><br><span class=\"line\">431</span><br><span class=\"line\">432</span><br><span class=\"line\">433</span><br><span class=\"line\">434</span><br><span class=\"line\">435</span><br><span class=\"line\">436</span><br><span class=\"line\">437</span><br><span class=\"line\">438</span><br><span class=\"line\">439</span><br><span class=\"line\">440</span><br><span class=\"line\">441</span><br><span class=\"line\">442</span><br><span class=\"line\">443</span><br><span class=\"line\">444</span><br><span class=\"line\">445</span><br><span class=\"line\">446</span><br><span class=\"line\">447</span><br><span class=\"line\">448</span><br><span class=\"line\">449</span><br><span class=\"line\">450</span><br><span class=\"line\">451</span><br><span class=\"line\">452</span><br><span class=\"line\">453</span><br><span class=\"line\">454</span><br><span class=\"line\">455</span><br><span class=\"line\">456</span><br><span class=\"line\">457</span><br><span class=\"line\">458</span><br><span class=\"line\">459</span><br><span class=\"line\">460</span><br><span class=\"line\">461</span><br><span class=\"line\">462</span><br><span class=\"line\">463</span><br><span class=\"line\">464</span><br><span class=\"line\">465</span><br><span class=\"line\">466</span><br><span class=\"line\">467</span><br><span class=\"line\">468</span><br><span class=\"line\">469</span><br><span class=\"line\">470</span><br><span class=\"line\">471</span><br><span class=\"line\">472</span><br><span class=\"line\">473</span><br><span class=\"line\">474</span><br><span class=\"line\">475</span><br><span class=\"line\">476</span><br><span class=\"line\">477</span><br><span class=\"line\">478</span><br><span class=\"line\">479</span><br><span class=\"line\">480</span><br><span class=\"line\">481</span><br><span class=\"line\">482</span><br><span class=\"line\">483</span><br><span class=\"line\">484</span><br><span class=\"line\">485</span><br><span class=\"line\">486</span><br><span class=\"line\">487</span><br><span class=\"line\">488</span><br><span class=\"line\">489</span><br><span class=\"line\">490</span><br><span class=\"line\">491</span><br><span class=\"line\">492</span><br><span class=\"line\">493</span><br><span class=\"line\">494</span><br><span class=\"line\">495</span><br><span class=\"line\">496</span><br><span class=\"line\">497</span><br><span class=\"line\">498</span><br><span class=\"line\">499</span><br><span class=\"line\">500</span><br><span class=\"line\">501</span><br><span class=\"line\">502</span><br><span class=\"line\">503</span><br><span class=\"line\">504</span><br><span class=\"line\">505</span><br><span class=\"line\">506</span><br><span class=\"line\">507</span><br><span class=\"line\">508</span><br><span class=\"line\">509</span><br><span class=\"line\">510</span><br><span class=\"line\">511</span><br><span class=\"line\">512</span><br><span class=\"line\">513</span><br><span class=\"line\">514</span><br><span class=\"line\">515</span><br><span class=\"line\">516</span><br><span class=\"line\">517</span><br><span class=\"line\">518</span><br><span class=\"line\">519</span><br><span class=\"line\">520</span><br><span class=\"line\">521</span><br><span class=\"line\">522</span><br><span class=\"line\">523</span><br><span class=\"line\">524</span><br><span class=\"line\">525</span><br><span class=\"line\">526</span><br><span class=\"line\">527</span><br><span class=\"line\">528</span><br><span class=\"line\">529</span><br><span class=\"line\">530</span><br><span class=\"line\">531</span><br><span class=\"line\">532</span><br><span class=\"line\">533</span><br><span class=\"line\">534</span><br><span class=\"line\">535</span><br><span class=\"line\">536</span><br><span class=\"line\">537</span><br><span class=\"line\">538</span><br><span class=\"line\">539</span><br><span class=\"line\">540</span><br><span class=\"line\">541</span><br><span class=\"line\">542</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.kaka.redis;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Component;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.util.CollectionUtils;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.annotation.Resource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.TimeUnit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">class</span> <span class=\"title class_\">RedisUtils</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Resource</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Set&lt;String&gt; <span class=\"title function_\">keys</span><span class=\"params\">(String keys)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.keys(keys);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (Exception e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 指定缓存失效时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">expire</span><span class=\"params\">(String key, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据key 获取过期时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">getExpire</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断key是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hasKey</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.hasKey(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 可以传一个值 或多个</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">del</span><span class=\"params\">(String... key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key != <span class=\"literal\">null</span> &amp;&amp; key.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                redisTemplate.delete(key[<span class=\"number\">0</span>]);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存获取</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">get</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key == <span class=\"literal\">null</span> ? <span class=\"literal\">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">set</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForValue().set(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入, 不存在放入，存在返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">setnx</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForValue().setIfAbsent(key,value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入并设置时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false 失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">set</span><span class=\"params\">(String key, Object value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                set(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 普通缓存放入并设置时间,不存在放入，存在返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false 失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">setnx</span><span class=\"params\">(String key, Object value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                redisTemplate.opsForValue().setIfAbsent(key, value, time, TimeUnit.SECONDS);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                set(key, value);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递增</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delta 要增加几(大于0)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">incr</span><span class=\"params\">(String key, <span class=\"type\">long</span> delta)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;递增因子必须大于0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 递减</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> delta 要减少几(小于0)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">decr</span><span class=\"params\">(String key, <span class=\"type\">long</span> delta)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (delta &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;递减因子必须大于0&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashGet</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">hget</span><span class=\"params\">(String key, String item)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取hashKey对应的所有键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 对应的多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Map&lt;Object, Object&gt; <span class=\"title function_\">hmget</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashSet</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 对应多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false 失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hmset</span><span class=\"params\">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * HashSet 并设置时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> map 对应多个键值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hmset</span><span class=\"params\">(String key, Map&lt;String, Object&gt; map, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hset</span><span class=\"params\">(String key, String item, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 成功 false失败</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hset</span><span class=\"params\">(String key, String item, Object value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 删除hash表中的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 可以使多个 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">hdel</span><span class=\"params\">(String key, Object... item)</span> &#123;</span><br><span class=\"line\">        redisTemplate.opsForHash().delete(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 判断hash表中是否有该项的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项 不能为null</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">hHasKey</span><span class=\"params\">(String key, String item)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> by 要增加几(大于0)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">hincr</span><span class=\"params\">(String key, String item, <span class=\"type\">double</span> by)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * hash递减</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> item 项</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> by 要减少记(小于0)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">double</span> <span class=\"title function_\">hdecr</span><span class=\"params\">(String key, String item, <span class=\"type\">double</span> by)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据key获取Set中的所有值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Set&lt;Object&gt; <span class=\"title function_\">sGet</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().members(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据value从一个set中查询,是否存在</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> true 存在 false不存在</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">sHasKey</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将数据放入set缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">sSet</span><span class=\"params\">(String key, Object... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将set数据放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 成功个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">sSetAndTime</span><span class=\"params\">(String key, <span class=\"type\">long</span> time, Object... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取set缓存的长度</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">sGetSetSize</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForSet().size(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除值为value的</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> values 值 可以是多个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 移除的个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">setRemove</span><span class=\"params\">(String key, Object... values)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">count</span> <span class=\"operator\">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ===============================list=================================</span></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取list缓存的内容</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> start 开始</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> List&lt;Object&gt; <span class=\"title function_\">lGet</span><span class=\"params\">(String key, <span class=\"type\">long</span> start, <span class=\"type\">long</span> end)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取list缓存的长度</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">lGetListSize</span><span class=\"params\">(String key)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().size(key);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过索引 获取list中的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">lGetIndex</span><span class=\"params\">(String key, <span class=\"type\">long</span> index)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lSet</span><span class=\"params\">(String key, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lSet</span><span class=\"params\">(String key, Object value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lSet</span><span class=\"params\">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 将list放入缓存</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> time 时间(秒)</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lSet</span><span class=\"params\">(String key, List&lt;Object&gt; value, <span class=\"type\">long</span> time)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (time &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                expire(key, time);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据索引修改list中的某条数据</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> index 索引</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">lUpdateIndex</span><span class=\"params\">(String key, <span class=\"type\">long</span> index, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            redisTemplate.opsForList().set(key, index, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 移除N个值为value</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> key 键</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> count 移除多少个</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value 值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 移除的个数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">long</span> <span class=\"title function_\">lRemove</span><span class=\"params\">(String key, <span class=\"type\">long</span> count, Object value)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Long</span> <span class=\"variable\">remove</span> <span class=\"operator\">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> remove;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>使用</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    RedisUtils redisUtils;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        redisUtils.set(<span class=\"string\">&quot;test3:key3&quot;</span>,<span class=\"string\">&quot;hello,redis&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> redisUtils.get(<span class=\"string\">&quot;test3:key3&quot;</span>).toString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、进阶\"><a href=\"#4、进阶\" class=\"headerlink\" title=\"4、进阶\"></a>4、进阶</h1><h2 id=\"4-1、redis持久化\"><a href=\"#4-1、redis持久化\" class=\"headerlink\" title=\"4.1、redis持久化\"></a>4.1、redis持久化</h2><h3 id=\"4-1-1、rdb\"><a href=\"#4-1-1、rdb\" class=\"headerlink\" title=\"4.1.1、rdb\"></a>4.1.1、rdb</h3><p>把当前内存中的快照写入磁盘</p>\n<p>（1）save：save指令执行会阻塞当前redis服务器，直到当前rdb过程执行完，可能造成长时间阻塞，线上环境不建议使用<br>（2）bgsave：调用fork函数生成子进程，解决了save的阻塞问题<br>（3）自动执行：（redis配置文件中配置）save 900 1   save 300 10   save 60 1000</p>\n<h3 id=\"4-1-2、aof\"><a href=\"#4-1-2、aof\" class=\"headerlink\" title=\"4.1.2、aof\"></a>4.1.2、aof</h3><p>以日志的方式记录每次写命令，重启时再执行aof中的命令达到数据恢复的目的（是目前redis持久化的主流方式）</p>\n<p>aof写数据策略：</p>\n<p>（1）always：服务器每写入一个命令,就调用一次fdatasync（不会丢失数据）<br>（2）Everysec：服务器每一秒重调用一次fdatasync（数据同步），最多丢失1秒的数据<br>（3）NO：操作系统决定任何将缓冲区里面的命令写入磁盘里面，数据丢失量是不确定的</p>\n<blockquote>\n<p>注：always策略持久化数据：先把写命令追加到aof buffer中，下一次进入事件循环循环后，再将buffer写到磁盘上。也就是说，这次写到磁盘上的内容是上一个事件循环产生的所以，即使设置为always，也会丢失一个循环的数据</p>\n</blockquote>\n<h3 id=\"4-1-3、对比\"><a href=\"#4-1-3、对比\" class=\"headerlink\" title=\"4.1.3、对比\"></a>4.1.3、对比</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>rdb</th>\n<th>aof</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>占用存储空间</td>\n<td>小（数据级）</td>\n<td>大（指令级）</td>\n</tr>\n<tr>\n<td>恢复速度</td>\n<td>快</td>\n<td>慢（需要执行指令）</td>\n</tr>\n<tr>\n<td>数据安全性</td>\n<td>可能会丢失最后一次持久化后的数据</td>\n<td>根据策略决定</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-2、redis淘汰策略\"><a href=\"#4-2、redis淘汰策略\" class=\"headerlink\" title=\"4.2、redis淘汰策略\"></a>4.2、redis淘汰策略</h2><h3 id=\"4-2-1、定时删除\"><a href=\"#4-2-1、定时删除\" class=\"headerlink\" title=\"4.2.1、定时删除\"></a>4.2.1、定时删除</h3><p>方式：创建一个定时器,当设置的key到达到期时间时,由定时器任务立即执行对key的删除操作</p>\n<p>优缺点：<br>（1）节约内存,到时就删,快速释放掉不必要的内存占用<br>（2）CPU压力变大,无论CPU此时负载量多高,均占用CPU</p>\n<h3 id=\"4-2-2、惰性删除\"><a href=\"#4-2-2、惰性删除\" class=\"headerlink\" title=\"4.2.2、惰性删除\"></a>4.2.2、惰性删除</h3><p>方式：数据到期时不做删除,等下次访问时进行删除</p>\n<p>优缺点：<br>（1）节约cpu性能  <br>（2）若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>\n<h3 id=\"4-2-3、定期删除\"><a href=\"#4-2-3、定期删除\" class=\"headerlink\" title=\"4.2.3、定期删除\"></a>4.2.3、定期删除</h3><p>方式：每隔一段时间主动检查一批过期键，并将其删除。这样可以保证过期键及时地从内存中释放</p>\n<blockquote>\n<p>（1）Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置健为<br> hz 它的默认值是 hz 10。<br> 【注意】:Redis 每次扫描并不是遍历过期字典中的所有健，而是采用随机抽取判断并删除过期健的形式执行的。</p>\n</blockquote>\n<p>删除流程：<br>（1）从过期字典随机取20个键<br>（2）删除这20个键中过期的键<br>（3）如果过期key的比例超过25%，重复步骤1</p>\n<p>优缺点：<br>（1）分批处理，以避免对cpu产生过大的负载</p>\n<h2 id=\"4-3、redis内存淘汰策略\"><a href=\"#4-3、redis内存淘汰策略\" class=\"headerlink\" title=\"4.3、redis内存淘汰策略\"></a>4.3、redis内存淘汰策略</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据</p>\n<blockquote>\n<p>LRU：淘汰最长时间没有被使用的<br> LFU：一定时间内使用频次越低的<br> random：随机<br> ttl：越早过期的数据</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>淘汰策略名称</th>\n<th>策略含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>noeviction</td>\n<td>默认策略，不淘汰数据；大部分写命令都将返回错误（DEL等少数除外）</td>\n</tr>\n<tr>\n<td>allkeys-lru</td>\n<td>从所有数据中根据 LRU 算法挑选数据淘汰</td>\n</tr>\n<tr>\n<td>volatile-lru</td>\n<td>从设置了过期时间的数据中根据 LRU 算法挑选数据淘汰</td>\n</tr>\n<tr>\n<td>allkeys-random</td>\n<td>从所有数据中随机挑选数据淘汰</td>\n</tr>\n<tr>\n<td>volatile-random</td>\n<td>从设置了过期时间的数据中随机挑选数据淘汰</td>\n</tr>\n<tr>\n<td>volatile-ttl</td>\n<td>从设置了过期时间的数据中，挑选越早过期的数据进行删除</td>\n</tr>\n<tr>\n<td>allkeys-lfu</td>\n<td>从所有数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）</td>\n</tr>\n<tr>\n<td>volatile-lfu</td>\n<td>从设置了过期时间的数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-4、redis工作模式\"><a href=\"#4-4、redis工作模式\" class=\"headerlink\" title=\"4.4、redis工作模式\"></a>4.4、redis工作模式</h2><h3 id=\"4-4-1、单机模式\"><a href=\"#4-4-1、单机模式\" class=\"headerlink\" title=\"4.4.1、单机模式\"></a>4.4.1、单机模式</h3><p>单机模式是最简单的 Redis 工作模式。在单机模式下，Redis 只运行在单个节点上，数据存储在该节点的内存中。这种模式适用于小规模应用或开发环境</p>\n<h3 id=\"4-4-2、主从复制模式\"><a href=\"#4-4-2、主从复制模式\" class=\"headerlink\" title=\"4.4.2、主从复制模式\"></a>4.4.2、主从复制模式</h3><p>主从复制模式通过将数据从主节点复制到一个或多个从节点来提高数据的可靠性和读取性能。主节点负责处理写入操作，从节点复制主节点的数据，并可以处理读取操作。主从复制模式适用于需要读取扩展和数据冗余的场景</p>\n<h3 id=\"4-4-3、哨兵模式\"><a href=\"#4-4-3、哨兵模式\" class=\"headerlink\" title=\"4.4.3、哨兵模式\"></a>4.4.3、哨兵模式</h3><p>主从复制的基础上，引入了哨兵节点来监控主节点的状态。当主节点发生故障时，哨兵节点会自动将一个从节点升级为新的主节点，并将其他从节点重新配置为复制新的主节点。这种模式提供了故障转移和自动主节点切换的功能</p>\n<h3 id=\"4-4-4、集群模式\"><a href=\"#4-4-4、集群模式\" class=\"headerlink\" title=\"4.4.4、集群模式\"></a>4.4.4、集群模式</h3><p>即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据。cluster是为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，提高并发量</p>\n<h2 id=\"4-5、redis发布订阅机制\"><a href=\"#4-5、redis发布订阅机制\" class=\"headerlink\" title=\"4.5、redis发布订阅机制\"></a>4.5、redis发布订阅机制</h2><p>Redis 发布订阅（Pus&#x2F;Sub）是一种消息通信模式：发送者通过 PUBLISH发布消息，订阅者通过 SUBSCRIBE 订阅接收消息或通过UNSUBSCRIBE 取消订阅。<br>发布者和订阅者属于客户端，Channel 是 Redis 服务端，发布者将消息发布到频道，订阅这个频道的订阅者则收到消息。从而实现消息的广播和实时通知</p>\n<blockquote>\n<p>Redis 的发布订阅机制是一种简单的消息传递方式，并不提供消息持久化和消息队列的功能。如果需要更高级的消息队列功能，可以考虑rabbitmq，kafka等</p>\n</blockquote>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">A订阅频道</span></span><br><span class=\"line\">SUBSCRIBE channel1</span><br><span class=\"line\"><span class=\"meta prompt_\"></span></span><br><span class=\"line\"><span class=\"meta prompt_\"># </span><span class=\"language-bash\">B向频道发送消息，A就可以收到消息</span></span><br><span class=\"line\">PUBLISH channel1 &quot;Redis PUBLISH test&quot;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-6、缓存穿透、击穿、雪崩\"><a href=\"#4-6、缓存穿透、击穿、雪崩\" class=\"headerlink\" title=\"4.6、缓存穿透、击穿、雪崩\"></a>4.6、缓存穿透、击穿、雪崩</h2><h3 id=\"4-6-1、缓存穿透\"><a href=\"#4-6-1、缓存穿透\" class=\"headerlink\" title=\"4.6.1、缓存穿透\"></a>4.6.1、缓存穿透</h3><p>某些不存在的数据，被大量的查询访问，缓存层中没有这些数据的缓存，请求就直达存储层，造成宕机</p>\n<blockquote>\n<p>解决方法：<br>1.返回空对象，将该key的空值返回给缓存层，缓存层会直接返回空对象。<br>2.布隆过滤器：将所有的key都存在过滤器中，在访问缓存层的时候会首先访问过滤器，如果过滤器中不存在这个值，那么直接返回空值</p>\n</blockquote>\n<h3 id=\"4-6-2、缓存击穿？\"><a href=\"#4-6-2、缓存击穿？\" class=\"headerlink\" title=\"4.6.2、缓存击穿？\"></a>4.6.2、缓存击穿？</h3><p>一份热点数据，在它缓存失效期间，大量的请求直接命中存储层</p>\n<blockquote>\n<p>解决方法：<br> 1.设置热点数据永不过期的策略。<br> 2.加互斥锁，在一个请求访问时另一个不能访问，这样，在这个请求访问过后，缓存重建，其他线程就可以访问了</p>\n</blockquote>\n<h3 id=\"4-6-3、缓存雪崩？\"><a href=\"#4-6-3、缓存雪崩？\" class=\"headerlink\" title=\"4.6.3、缓存雪崩？\"></a>4.6.3、缓存雪崩？</h3><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p>\n<blockquote>\n<p>解决方法：<br>1.不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀<br>2.在系统启动或低峰期(比如系统刚启动)，提前加载热门数据到缓存中，避免在高峰期大量请求同时访问导致缓存失效</p>\n</blockquote>\n"},{"title":"mysql","date":"2023-08-11T16:00:00.000Z","abbrlink":13153,"_content":"\n# 1、数据库基础概念\n## 1.1、mysql数据类型\n\n| **分类** | **类型名称** | **类型说明** |\n| --- | --- | --- |\n| 整数 | tinyInt | 微整型：占8位二进制，1个字节 （-128-127） |\n| | smallint | 小整型：占16位二进制，2个字节（-32768-32767） |\n|  | mediumint | 中整型：占24位二进制，3个字节（-8388608-8388607） |\n|  | **int**(integer) | 整型：占32位二进制，4个字节（-2147483648-2147483647） |\n|  | **bigint** | 大整型：占64位二进制，8个字节（-9223372036854775808-9223372036854775807） |\n| 小数 | **float** | 单精度浮点数，占4个字节 |\n|  | **double** | 双精度浮点数，占8个字节 |\n|  | decimal(m,n) | 高精度小数型，最大精度为65，最大占用空间30字节 |\n| 日期 | **time** | 表示时间类型 yyyy-MM-DD ，3字节|\n|  | **date** | 表示日期类型 hh:mm:ss ，3字节 |\n|  | **datetime** | 同时可以表示日期和时间类型，8字节 |\n| 字符串 | char(m) | **固定长度的字符串，无论使用几个字符都占满全部**，M为0~255之间的整数 如：char(20)，实际使用只用了1个字符，也占用20个字符 |\n|  | **varchar**(m) | **可变长度的字符串，使用几个字符就占用几个**，M为0~65535之间的整数。 如：varchar(20)，这个字符串最长是20，大于20会报错。 使用几个，占几个字符。 |\n\n# 2、数据库基本操作\n## 2.1、DDL数据定义语言\n### 2.1.1、数据库相关\n\n```sql\n-- 创建数据库并指定字符集\ncreate database db01 character set utf8;\n\n-- 查看所有的数据库\nshow databases;\n\n-- 查看某个数据库的DDL语句\nshow create database db01;\n\n-- 修改数据库编码\nalter database db01 character set utf8;\n\n-- 删除数据库\ndrop database db01;\n\n-- 切换数据库\ndrop database db01;\n\n```\n### 1.1.2、表相关\n\n```sql\n-- 创建表\ncreate table emp (\n    id int,\n  \t-- ` 是 MySQL 的转义符，避免和 mysql 的本身的关键字冲突，只要你不在列名、表名中使用 mysql 的保留字或中文，就不需要转义。\n    sex char(1),\n    `name` varchar(20), \n\taddress varchar(20)\n);\n\n-- 查看数据库所有表\nshow tables;\n\n-- 查看表结构\ndesc 表名;\n\n-- 查看创建表的sql语句\nshow create table emp;\n\n-- 复制表结构\nCREATE TABLE 新表 LIKE 旧表;\n\n-- 删除表\nDROP TABLE 表名; \n\n-- 判断表是否存在，存在删除表\nDROP TABLE IF EXIST 表名;\n\n-- 添加列\nalter table emp add age int;\n\n-- 删除列\nalter table emp drop age;\n\n-- 修改字段类型\nalter table emp modify address varchar(100);\n\n-- 修改字段名和字段类型\nalter table emp change address addr varchar(80);\n\n-- 修改表名（MySQL中没有直接修改库名的语句）\nrename table emp to employee;\n\n-- 修改表字符集\nalter table emp character set utf8;\n```\n## 2.2、DML数据操纵语言\n\n```sql\n-- 插入全部字段\ninsert into emp values(1,'张三','男','河南汤阴',39);\n\n-- 插入指定字段\ninsert into emp(id,name,sex) values(2,'李四','男');\n\n-- 插入多条数据\nINSERT INTO emp\nVALUES\n\t( 4, '小红', '女', '四川南充', 25 ),\n\t( 5, '小明', '女', '河南平顶山', 24 ),\n\t( 6, '小李', '男', '陕西榆林', 20 );\n\n-- 更新数据\nupdate emp set sex='男',addr='陕西忻州' where id=5;\n\n-- 删除表数据\ndelete from emp;\n\n-- 清空表（先删除表结构,再创建一个相同的表结构 相当于drop table emp，再create table emp）表中有自增长，会把自增长id 重置成1开始\ntruncate emp;\n```\n## 2.3、DQL数据查询语言\n### 2.3.1、基础查询\n\n```sql\n-- 查询指定列\nselect id,name,addr from emp;\n\n-- 指定列的别名\nselect id as 编号,name as 姓名,addr 地址 from emp;\n\n-- 去重id相同的行\nselect distinct id from emp;\n\n-- 查询时进行列运算\nselect id,name,addr,id+age from emp;\n\n-- 范围查询\nselect * from student where english between 60 and 90;\n\n-- 模糊查询\nselect * from student where address like '%西%'; -- 地址中带西的数据\nselect * from student where address like '_____';-- 查询五个字地址城市的学生\n\n-- 查询列为空的数据\nselect * from student where sex is null;\n\n-- limit查询offset：跳过多少条记录，默认是0 length：返回多少条记录\nselect * from table LIMIT offset,length\nselect * from student limit 2, 3; -- 从第二条开始查，显示三条\n\n-- case when（Case When语句用于选择判断，在执行时先对条件进行判断，然后根据判断结果做出相应的操作）\nSELECT\n\t*,\nCASE\n\t\tsex \n\t\tWHEN '男' THEN\n\t\t'man' \n\t\tWHEN '女' THEN\n\t\t'woman' \n\t\tELSE '其他'\n\tEND AS 'other' \nFROM\n\tstudent;\n\n```\n\n| **通配符** | **说明** |\n| --- | --- |\n| % | 匹配零个或多个字符 |\n| _ | 匹配一个字符 |\n\n### 2.3.2、排序\n\n```sql\n-- 升序排列\nselect * from student order by age asc;\n\n-- 降序排列\nselect * from student order by age desc;\n\n-- 组合排序（查询所有数据大于20岁的学生,在年龄降序排序的基础上,如果年龄相同再以数学成绩升序排序）\nselect * from student where age > 22 order by age desc, math asc;\n```\n\n### 2.3.3、聚合函数\n\n| **SQL中的聚合函数** | **作用** |\n| --- | --- |\n| count | 统计个数，如果这一列有NULL，null不会参与统计 |\n| max | 找这一列中的最大值，一般是数值类型进行操作。 |\n| min | 找这一列中的最小值 |\n| sum | 求这一列的总和 |\n| avg | 求这一列的平均，返回值小数average |\n\n\n### 2.3.4、分组\n\n分组一般搭配聚合函数一起使用\n\n```sql\n-- 查询年龄大于23岁的人，按性别分组，统计每组的人数\nselect sex, count(*) from student where age>23 group by sex;\n\n-- 查询年龄大于23岁的人，按性别分组，统计每组的人数，并只显示性别人数大于2的数据\nSELECT sex, COUNT(*) FROM student WHERE age > 23 GROUP BY sex having COUNT(*) >2;\n\n\n```\n\n| **子名** | **作用** |\n| --- | --- |\n| where 子句 | 先过滤掉行上的一些数据，再进行分组操作。(先过滤再分组) |\n| having子句 | 先分组后得到的结果上再进行过滤的操作。(先分组再过滤) |\n\n> **where子句后不能使用分组函数，having子句后可以使用聚合函数**\n\n### 2.3.5、连接查询\n#### 2.3.5.1、表的关系\n\n| **表与表的关系** | **示例** | **关系的维护** |\n| --- | --- | --- |\n| 一对多 | 班级合学生 | 通过从表中外键来维护 |\n| 多对多 | 学生和课程。拆分成学生，选课，课程 | 通过中间表，将两个一对多加到一起变成了一个多对多 |\n| 一对一 | 在实际的开发中应用不多，因为一对一可以创建成一张表 | （1）外键添加约束 （2）从表的主键又是外键 可以简化成一张表 |\n\n#### 2.3.5.2、笛卡尔积\n\n简单的说就是两个集合相乘的结果。笛卡尔（Descartes）乘积又叫直积。假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}\n\n```sql\n-- 笛卡尔查询示例\nSELECT * FROM table1 , table2\n```\n\n笛卡尔积产生，有两种情况：\n（1）表连接缺少关联条件，这个是必须要改的；\n（2）表连接有关联条件，但是数据库判断用笛卡尔积更快，也会出现笛卡尔积，这个时候要看实际执行速度；数据库这样判断，**一般是表比较小**，这个时候要特别检查表的数据量是不是真的很少，以免oracle因为统计信息错误而误判。\n\n#### 2.3.5.3、内连接\n\n用左边表的记录去匹配右边表的记录，如果符合条件的则显示\n\n1. 隐式内连接：看不到join关键字，条件使用where指定\n\n```sql\nselect * from dept,emp where dept.id=emp.dept_id;\n```\n\n2. 显示内连接：**使用INNER JOIN ... ON语句, 可以省略INNER\n\n```sql\nselect * from dept d inner join emp e on d.id = e.dept_id;\n```\n\n> 隐式内连接只能使用where来进行表的关联；显示内连接可以使用on和where来关联，推荐使用on\n\n\n#### 2.3.5.4、左外连接\n\n左外连接：使用LEFT OUTER JOIN ... ON，OUTER可以省略(查询的数据以左表为准，即使在其他表中没有匹配的记录也会显示出来)\n```sql\n-- 需要查询所有的部门和员工，无论这个部门下有没有员工\nselect * from dept left join emp on dept.id = emp.dept_id;\n```\n\n> 在使用left jion时，on和where条件的区别如下：\n> 1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。\n> 2、where条件是在临时表生成好后，再对临时表进行过滤的条件。\n\n#### 2.3.5.5、右外连接\n\n右外连接：使用RIGHT OUTER JOIN ... ON，OUTER可以省略（查询的数据以右表为准，即使在其他表中没有匹配的记录也会显示出来）\n\n```sql\nselect * from dept right join emp on dept.id = emp.dept_id;\n```\n#### 2.3.5.6、全连接\n全连接：左表和右表的数据都能够显示全面呢（在对方表中没有匹配的数据就以null补齐）\n\n> MySQL并没有提供全连接，但Oracle支持；虽然MySQL不支持全连接，但是我们可以利用MySQL提供的其它功能来完成全连接的功能：\n\n```sql\nselect * from dept d left join emp e on d.id=e.dept_id\nunion \nselect * from dept d right join emp e on d.id=e.dept_id;\n\n```\n\n> union关键字可以将两个或多个SQL语句的结果集拼接成一个结果集，前提是这些SQL语句的结果集列数必须相同；（union关键字自带去重功能，即去除重复的数据）\n\n\n#### 2.3.5.7、子查询\n一个查询语句结果做为另一个查询语句的条件查询语句有嵌套，里面的查询称为子查询，外面的查询称为父查询子查询要使用括号括起来\n\n1. 子查询结果为单行单列\n\n```sql\nselect * from emp where age = (select max(age) from emp);\n```\n\n2. 子查询结果为多行单列\n\n查询结果是多行单列的时候，子查询的结果相当于一个集合或数组。父查询要使用in/any/all这些关键字\n\n```sql\n-- 采用in 取结果集中的数据 in (1,2,3)\nselect * from dept where id in (select dept_id from emp where age > 23);\n-- 采用all 查询年龄大于1号部门所有员工的人\nselect * from emp where age > all (select age from emp where dept_id=1);\n-- 采用any 比1号部门任意一个大就行\nselect * from emp where age > any (select age from emp where dept_id=1);\n```\n\n3. 子查询结果为多行多列\n\n如果子查询的结果是多行多列，父查询可以将这个查询结果做为一个虚拟表，进行第2次查询。不是放在where后面，而是放在from的后面\n```sql\n-- 询出年龄大于23岁的员工信息和部门名称\nselect e.*,d.name 部门名称 from dept d, (select * from emp where age > 23) e where d.id = e.dept_id\n```\n\n## 2.4、DCL数据控制语言\nDCL是数据控制语言,主要是用来设置或更改数据库用户或角色权限的语句\n\n```sql\n-- 创建用户\nCREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';\n\n-- 查询数据库用户\nselect * from mysql.user;\n\n-- 授权\ngrant create,alter,insert,update,select on db03.* to 'zhangsan'@'localhost';\ngrant all on *.* to 'lisi'@'%';\n\n-- 撤销权限\nrevoke select on db03.* from 'zhangsan'@'localhost';\n\n-- 查看用户权限\nshow grants for 'zhangsan'@'localhost';\n\n-- 删除用户\ndrop user 'zhangsan'@'localhost';\n\n-- 修改管理员密码\nmysqladmin -uroot -p password 新密码\n\n```\n\n# 3、数据库约束\n\n一般在创建表的时候给表的字段添加各种约束，从而保证输入到表中的数据是正确的。保证数据的正确性，完整性和有效性。违反约束的数据是不能添加到表中去的。如果表已经存在，并且表中已经有数据，添加约束的时候如果表中的数据已经违反了现在要添加的约束，约束会添加失败。\n\n| **约束名** | **关键字** | **说明** |\n| --- | --- | --- |\n| 主键 | primary key | 唯一，非空 |\n| 默认 | default | 没有输入值，使用默认值 |\n| 非空 | not null | 必须输入 |\n| 唯一 | unique | 不能重复 |\n| 外键 | foregin key (外键) references 主表(主键) | 外键在从表 主表：1方 从表：多方 |\n\n## 3.1、主键约束\n用来唯一标识表中的每一行记录，在创建表的时候，每张表都应该创建一个主键，每个表只能有一个主键约束，只要有主键就有主键约束。\n\n> 特点：非空，唯一，一张表最多一个主键\n\n```sql\ncreate table t1(\n\tid int primary key auto_increment,\t\t\t\t-- 指定id列为主键\n    city varchar(20)\n)\n\n-- 在已有的表中添加主键\nalter table t1 add primary key(id);\n\n-- 删除主键\nalter table t1 drop primary key;\n\n-- 联合主键\ncreate table test(\n\tid int,\n\tid2 int,\n\tcity varchar(20),\n\tprimary key(id,id2)\t\t\t-- id和id2列组合为联合主键\n);\n```\n## 3.2、唯一约束\n\n这一列的值不能重复\n\n> 和主键约束区别：唯一性约束允许在该列上存在NULL值，主键约束允许\n\n```sql\ncreate table t3 (\n\tid int primary key auto_increment,\n\tcity varchar(20) unique\n);\n```\n## 3.3、非空约束\n这一列的值必须输入，不能为空\n\n```sql\ncreate table t4(\n\tid int,\n\tcity varchar(20) not null\t\t\t-- 非空约束\n);\n```\n## 3.4、检查约束\n检查约束可以使用一定的范围条件来约束我们的列的值，例如年龄应该在0~120岁之间，性别只能有男或女等；\n\n```sql\ncreate table t6(\n\tid int,\n\tname varchar(30),\n\tage int check(age>0 and age<120),\t\t\t-- 年龄只在0~120之间\n\tsex char(1) check('男' or '女') \t\t\t-- 性别只能在'男' 和 '女'之间选择\n);\n```\n## 3.5、外键约束\n外键出现在从表中，被主表的主键约束的那一列外键\n\n```sql\ncreate table employee(\n\tid int primary key auto_increment,\n\tdept_id int, -- 外键的数据类型与主表中的主键相同\n\tCONSTRAINT `employee_ibfk_1` foreign key (dept_id) references dept(id)\t\t-- 本表的dept_id列依赖于dept表的id列\n);\n\n-- 新增外键约束\nALTER TABLE 表名 ADD CONSTRAINT 约束名 FOREIGN KEY (外键字段) REFERENCES 主表(主键)\n```\n# 4、数据库事务\n\n如果一个业务操作中多次访问了数据库，必须保证每条SQL语句都执行成功。如果其中有一条执行失败，那么所有已经执行过的代码必须回滚（撤销）。回到没有执行前的状态。称为事务。简单来说就是要么所有的SQL语句全部执行成功，要么全部失败\n\n| **事务特性** | **含义** |\n| --- | --- |\n|  原子性（Atomicity） | 一个事务内的所有操作要么都执行，要么都执行失败 |\n|  一致性（Consistency） | 事务执行前与执行后，数据库中数据应该保持相同的状态 |\n|  隔离性（Isolation） | 指的是一个事务在最终提交前，对其它事务是不可见的 |\n|  持久性（Durability） |  如果事务执行成功，对数据库的操作是持久的。 |\n\n\n## 4.1、事务提交\n\n1. **手动提交事务**\n\n| **功能** | **SQL语句** |\n| --- | --- |\n| 开启事务 | start transaction/begin |\n| 提交事务 | commit |\n| 回滚事务 | rollback |\n\n\n```sql\n-- 开启事务\nstart transaction;\n\n-- a账号-500元\nupdate account set money=money-500 where name='a';\n\n-- b账号+500元\nupdate account set money=money+500 where name='b';\n\n-- 查询账号信息\nselect * from account;\n\n-- 提交事务\ncommit;\n\n```\n\n2. **自动提交事务，默认是自动提交**\n\nMySQL默认每一条DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，执行完毕自动提交事务，MySQL默认开始自动提交事务\n\n```sql\n-- 取消自动提交事务\nset @@autocommit = 0;\n\nselect @@autocommit;\n\n```\n\n## 4.2、并发访问下事务产生的问题\n当同时有多个用户在访问同一张表中的记录，每个用户在访问的时候都是一个单独的事务。事务在操作时的理想状态是：事务之间不应该相互影响，实际应用的时候会引发下面三种问题：\n\n1. 脏读： 一个事务（用户）读取到了另一个事务没有提交的数据\n2. 不可重复读：一个事务多次读取同一条记录，出现读取数据不一致的情况。一般因为另一个事务更新了这条记录而引发的。\n3. 幻读：在一次事务中，多次读取到的条数不一致\n\n## 4.3、事务的隔离级别\n为了尽量避免这些问题的发生。通过数据库本身的功能去避免，设置不同的隔离级别\n\n| **级别** | **名字** | **隔离级别** | **脏读** | **不可重复读** | **幻读** | **数据库默认隔离级别** | 解释 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 读未提交 | read uncommitted | 是 | 是 | 是 |  | 事务A可以读取到事务B未提交的数据 |\n| 2 | 读已提交 | read committed | 否 | 是 | 是 | Oracle和SQL Server | 事务A只能读取其它事务已提交的数据（避免了脏读） |\n| 3 | 可重复读 | repeatable read | 否 | 否 | 是 | MySQL | 保证在同一个事务中多次读取同样数据的结果是一样的 |\n| 4 | 串行化 | serializable | 否 | 否 | 否 |  | 事务串行化顺序执行 |\n\n> 隔离级别越高，安全性就越高，性能越低\n\n```sql\n-- 设置隔离级别\nset global transaction isolation level read uncommitted;\n```\n\n# 5、视图\n\n视图其实就是一个select返回的结果集，用于方便我们查询而创建的\"临时表\"，简化我们的查询语句\n\n```sql\ncreate view test4 as select * from student where class_id=1 with local check option;\n```\n# 6、触发器\n\n触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。\n\n| **触发器类型** | **NEW和OLD的使用** |\n| --- | --- |\n| insert触发器 | NEW 表示将要或者已经新增的数据 |\n| update触发器 | OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 |\n| delete触发器 | OLD 表示将要或者已经删除的数据 |\n\n> 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容\n\n```sql\n-- 基本语法\ncreate trigger trigger_name [after/before] [insert/update/delete] \non table_name\nfor each row\nbegin\n\t......\nend;\n```\n\n```sql\n-- insert触发器\ncreate trigger test1 after insert\non student\nfor each row\nbegin\n\tinsert into log values(null,new.name,now());\nend;\n\n-- update触发器\ncreate trigger test2 after update\non student\n for each row\nbegin\n\tinsert into log values(null,concat('之前的值: ',old.name,';之后的值: ',new.name),now());\nend;\n\n-- delete触发器\ncreate trigger test3 after delete\non student\n for each row\nbegin\n\tinsert into log values(null,concat('删除的值: ',old.name),now());\nend;\n\n-- 查看当前数据库中的触发器\nshow triggers;\n\n-- 删除触发器\ndrop trigger test1;\n```\n# 7、存储过程和存储函数\n\nMySQL中提供存储过程与存储函数机制，我们先将其统称为存储程序，一般的SQL语句需要先编译然后执行，存储程序是一组为了完成特定功能的SQL语句集，**经编译后存储在数据库中**，当用户通过指定存储程序的名字并给定参数（如果该存储程序带有参数）来调用才会执行\n\n## 7.1、存储过程语法\n### 7.1.1、变量\n\n1. declare：声明变量\n\n```sql\nCREATE PROCEDURE test2 ()\nbegin\n\t\n\tdeclare num int default 0;\t\t-- 声明变量,赋默认值为0\n\tselect num+10;\n\t\nend ;\n\ncall test2();\t\t\t-- 调用存储过程\n\n```\n\n2. set：赋值操作\n\n```sql\nCREATE PROCEDURE test3 ()\nbegin\n\t\n\tdeclare num int default 0;\n\tset num =20;\t\t\t-- 给num变量赋值\n\tselect num;\n\t\nend ;\n\ncall test3();\n\n```\n\n3. into：赋值\n\n```sql\nCREATE PROCEDURE test4 ()\nbegin\n\t\n\tdeclare num int default 0;\t\t\t\n\tselect count(1) into num from student;\n\tselect num;\n\t\nend ;\n\ncall test4();\n\n```\n### 7.1.2、if语句\n\n\n```sql\n-- 根据class_id判断是Java还是UI还是产品\nCREATE PROCEDURE test5 ()\nbegin\n\t\n\tdeclare id int default 1;\t\t\t\n\tdeclare class_name varchar(30);\n\t\n\tif id=1 then\n\t\tset class_name='哇塞，Java大佬！';\n\telseif id=2 then\n\t\tset class_name='原来是UI的啊';\n\telse\n\t\tset class_name='不用想了，肯定是产品小样';\n\tend if;\n\t\n\tselect class_name;\n\t\nend ;\n\ncall test5();\n\n```\n### 7.1.3、传递参数\n\n```sql\ncreate procedure procedure_name([in/out/inout] 参数名  参数类型)\n```\n\n> in： 该参数可以作为输入，也就是需要调用方传入值 , 默认\n> out： 该参数作为输出，也就是该参数可以作为返回值\n> inout： 既可以作为输入参数，也可以作为输出参数\n\n\n\n```sql\n-- 定义一个输入参数和一个输出参数\nCREATE PROCEDURE test7 (in id int,out class_name varchar(100))\nbegin\n\tif id=1 then\n\t\tset class_name='哇塞，Java大佬！';\n\telseif id=2 then\n\t\tset class_name='原来是UI的啊';\n\telse\n\t\tset class_name='不用想了，肯定是产品小样';\n\tend if;\n\t\nend ;\n\n\ncall test7(1,@class_name);\t-- 创建会话变量\t\t\n\nselect @class_name;\t\t-- 引用会话变量\n\n```\n\n> @xxx：代表定义一个会话变量，整个会话都可以使用，当会话关闭（连接断开）时销毁\n> @@xxx：代表定义一个系统变量，永久生效，除非服务器重启\n\n\n### 7.1.4、case语句\n\n```sql\n-- 传递一个月份，返回所在季节\nCREATE PROCEDURE test8 (in month int,out season varchar(10))\nbegin\n\t\n\tcase \n\t\twhen month >=1 and month<=3 then\n\t\t\tset season='spring';\n\t\twhen month >=4 and month<=6 then\n\t\t\tset season='summer';\n\t\twhen month >=7 and month<=9 then\n\t\t\tset season='autumn';\n\t\twhen month >=10 and month<=12 then\n\t\t\tset season='winter';\n\tend case;\nend ;\n\ncall test8(9,@season);\t\t\t-- 定义会话变量来接收test8存储过程返回的值\n\nselect @season;\n\n```\n### 7.1.5、while循环\n\n```sql\n-- 计算任意数的累加和\nCREATE PROCEDURE test10 (in count int)\nbegin\n\tdeclare total int default 0;\n\tdeclare i int default 1;\n\t\n\twhile i<=count do\n\t\tset total=total+i;\n\t\tset i=i+1;\n\tend while;\n\tselect total;\nend ;\n\ncall test10(10);\n\n```\n\n### 7.1.6、repeat循环（while）\n\n```sql\nCREATE PROCEDURE test11 (count int)\t\t-- 默认是输入(in)参数\nbegin\n\tdeclare total int default 0;\n\trepeat \n\t\tset total=total+count;\n\t\tset count=count-1;\n\t\tuntil count=0\t\t\t\t-- 结束条件,注意不要打分号\n\tend repeat;\n\tselect total;\nend ;\n\ncall test11(10);\n\n```\n### 7.1.7、loop循环\n\n```sql\nCREATE PROCEDURE test12 (count int)\t\t-- 默认是输入(in)参数\nbegin\n\tdeclare total int default 0;\t\n\tsum:loop\t\t\t\t\t\t\t-- 定义循环标识\n\t\tset total=total+count;\n\t\tset count=count-1;\n\t\t\n\t\tif count < 1 then\n\t\t\tleave sum;\t\t\t\t\t-- 跳出循环\n\t\tend if;\n\tend loop sum;\t\t\t\t\t\t-- 标识循环结束\n\tselect total;\n\t\nend ;\n\ncall test12(10);\n\n```\n### 7.1.8、游标\n\n游标是用来存储查询结果集的数据类型，可以帮我们保存多条行记录结果，我们要做的操作就是读取游标中的数据获取每一行的数据。\n```sql\nCREATE PROCEDURE test13 ()\t\t-- 默认是输入(in)参数\nbegin\n\t\n\tdeclare id int(11);\n\tdeclare `name` varchar(20);\n\tdeclare class_id int(11);\n\t-- 定义游标结束标识符\n\tdeclare has_data int default 1;\n\t\n\tdeclare stu_result cursor for select * from student;\n\t-- 监测游标结束\n\tdeclare exit handler for not found set has_data=0;\n\t\n\t-- 打开游标\n\topen stu_result;\n\t\n\trepeat \n\t\tfetch stu_result into id,`name`,class_id;\n\t\t\n\t\tselect concat('id: ',id,';name: ',`name`,';class_id',class_id);\n\t\tuntil has_data=0\t\t-- 退出条件,注意不要打分号\n\tend repeat;\n\t\n\t-- 关闭游标\n\tclose stu_result;\n\t\nend ;\n\ncall test13();\n\n```\n## 7.2、存储函数\n### 7.2.1、存储函数和存储过程区别\n\n1. 存储函数的限制比较多，例如不能用临时表、不能执行查询语句、只能用表变量等；而存储过程的限制较少，存储过程的实现功能要复杂些,而函数的实现功能针对性比较强。\n2. 返回值不同。存储函数必须有返回值,且仅返回一个结果值；存储过程可以没有返回值,但是能返回结果集(out,inout)。\n3. 调用时的不同。存储函数select 存储函数名(变量值)；存储过程通过call语句调用 call 存储过程名。\n4. 参数的不同。存储函数的参数类型类似于IN参数，没有类似于OUT和INOUT的参数。存储过程的参数类型有三种，in、out和inout：in： 数据只是从外部传入内部使用(值传递),可以是数值也可以是变量\n\n### 7.2.2、创建方式\n\n```sql\n-- 无参函数\ncreate function test1()\nreturns int\t\t\t\nbegin\n\n\tdeclare num int default 0;\n\t\n\tset num=10;\n\t\n\treturn num;\nend;\n\nselect test1()\n\n-- 带参函数\ncreate function test2(num int)\nreturns int\t\t\t\nbegin\n\treturn num;\nend;\n\nselect test2(22);\n```\n# 8、数据库范式\n## 8.1、三大范式\n\n1. **第一范式（1NF）**：保证每列的原子性。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库满足了第一范式\n> 比如用户表里的名字字段，在中国可能直接存完整的姓名就可以了。但在国外姓和名常常需要分开使用，所以需要分成姓和名两个字段存储。所以是否满足原子性需要根据实际需求来确定\n\n\n2.  **第二范式（2NF）**：满足第一范式前提，不能存在局部依赖。比如有联合主键有两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式 \n\n3.  **第三范式（3NF）**：消除传递依赖，每列都直接依赖于主键\n> 假设存在关系模式主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址。显然满足第一范式和第二范式，但是教师家庭地址传递依赖于教师名，所以不满足第三范式\n\n\n## 8.2、反范式化\n\n所谓反范式化，是一种对范式化设计的数据库的**性能优化策略**，通过在表中增加冗余或重复的数据来提供数据库的读取性能。没有冗余的数据库不一定是最好的数据库，有时为了提高查询效率，就必须降低范式标准，适当保留冗余数据。具体操作就是在一个表中增加别一个表的冗余字段，减少了两个表查询时的关联，从而提高查询效率。\n\n# 9、数据库备份与恢复\nmysqldump命令主要用于数据库的备份\n\n> options：\n> -h：mysql服务器的IP\n> -P：mysql服务器的端口\n> -u：mysql用户名\n> -p：mysql密码\n> -n（--no-create-db）：不包含创建数据库语句（包含建表语句和数据）\n> -t（--no-create-info）：不包含创建表语句（只要插入语句）\n> -d（--no-data）：不包含数据\n> -B（--database）：导出数据库（也包含建库语句也包含数据）\n> -A（--all-databases）：导出所有数据库\n\n```sql\n-- 导出指定表（没有指定表则导出所有）\nmysqldump -h127.0.0.1 -P3306 -uroot -padmin db02 student > D:/test.sql\n-- 导出数据库（比导表增加了 加了create database db_name语句）\nmysqldump -uroot -padmin --all-databases > D:/test.sql\n-- 恢复（执行sql文件）\nsource d:/test.sql;\n```\n# 10、JDBC\n\n是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了操作数据库的所有方法。JDBC是一组接口，没有具体的实现。核心功能也就是实现类由各 **数据库厂商去实现**这些实现类也被成为数据库的驱动。\n## 10.1、JDBC常用接口\n\n| **接口或类** | **作用** |\n| --- | --- |\n| Driver | 驱动接口，定义建立链接的方式 |\n| DriverManager | 1. 加载和注册第三方厂商的驱动程序 2. 创建一个数据库的连接对象 |\n| Connection | 与数据库的一个连接对象 |\n| Statement | SQL语句对象，用于封装SQL语句发送给MySQL服务器 |\n| PreparedStatement | 是Statement接口的子接口，功能更加强大 |\n| ResultSet | 封装从数据库中查询到的结果集 |\n\n## 10.2、PreparedStatement\nPreparedStatement 是 Statement 的子类，也能执行Statement之前的所有操作，其中最主要的功能就是提供了占位符传参处理、预编译等功能；我们实际开发中PreparedStatement会使用的更多\n### 10.2.1、sql注入问题\n**用户输入的内容作为了SQL语句语法的一部分，改变了原有SQL真正的意义**，以上问题称为SQL注入。要解决SQL注入就不能让用户输入的密码和我们的SQL语句进行简单的字符串拼接\n如 用户输入密码：\n\n> abc' or '1'='1\n\n执行的sql为：select * from user where name='admin' and password='abc' or '1'='1';\n\n```java\n// PreparedStatement解决sql注入问题：\n\n//创建预编译的SQL语句\nps = conn.prepareStatement(\"select * from user where name=? and password=?\");\n\n//替换占位符\nps.setString(1, name);\nps.setString(2, password);\n\n//执行SQL语句，查询\nrs = ps.executeQuery();\n\n```\n### 10.2.2、CallableStatement \n\nallableStatement是PreparedStatement的子类，主要是调用数据库中的存储过程/存储函数。并通过CallableStatement对象可以获取存储过程/存储函数的执行结果；\n\n```java\n\t// 定义存储过程\n    CallableStatement cs = connection.prepareCall(\"call test3(?,?,?)\");\n\n    // 输入参数\n    cs.setInt(1,2);\n\n    // 输出参数\n    cs.registerOutParameter(2, Types.VARBINARY);\n    cs.registerOutParameter(3, Types.VARBINARY);\n\n    // 执行存储过程\n    cs.execute();\n\n    // 根据参数名获取值\n    String str1 = cs.getString(\"str1\");\n    String str2 = cs.getString(\"str2\");\n\n```\n### 10.2.3、JDBC事务处理\n\n```java\npublic class Demo15_事务 {\n    @Test\n    public void test1() throws Exception{\n        //创建连接对象\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = JdbcUtils.getConnection();\n\n            // 设置事务不要自动提交(手动提交,默认情况下,事务是自动提交的)\n            conn.setAutoCommit(false);\n\n            //创建语句对象\n            stmt = conn.createStatement();\n\n            //a扣钱\n            stmt.executeUpdate(\"update account set money=money-500 where name='a'\");\n\n            // b加钱\n            stmt.executeUpdate(\"update account set money=money+500 where name='b'\");\n\n            // 提交事务\n            conn.commit();\n\n            System.out.println(\"转账成功\");\n        } catch (Exception e) {\n            try {\n                // 回滚事务\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            System.out.println(\"转账失败\");\n        } finally {\n            JdbcUtils.close(conn, stmt);\n        }\n    }\n}\n\n```\n","source":"_posts/mysql.md","raw":"---\ntitle: mysql\ndate: 2023/08/12\ncategories:\n  - coding\ntags:\n  - mysql\n  - 数据库\n  - 编程基础\nabbrlink: 13153\n---\n\n# 1、数据库基础概念\n## 1.1、mysql数据类型\n\n| **分类** | **类型名称** | **类型说明** |\n| --- | --- | --- |\n| 整数 | tinyInt | 微整型：占8位二进制，1个字节 （-128-127） |\n| | smallint | 小整型：占16位二进制，2个字节（-32768-32767） |\n|  | mediumint | 中整型：占24位二进制，3个字节（-8388608-8388607） |\n|  | **int**(integer) | 整型：占32位二进制，4个字节（-2147483648-2147483647） |\n|  | **bigint** | 大整型：占64位二进制，8个字节（-9223372036854775808-9223372036854775807） |\n| 小数 | **float** | 单精度浮点数，占4个字节 |\n|  | **double** | 双精度浮点数，占8个字节 |\n|  | decimal(m,n) | 高精度小数型，最大精度为65，最大占用空间30字节 |\n| 日期 | **time** | 表示时间类型 yyyy-MM-DD ，3字节|\n|  | **date** | 表示日期类型 hh:mm:ss ，3字节 |\n|  | **datetime** | 同时可以表示日期和时间类型，8字节 |\n| 字符串 | char(m) | **固定长度的字符串，无论使用几个字符都占满全部**，M为0~255之间的整数 如：char(20)，实际使用只用了1个字符，也占用20个字符 |\n|  | **varchar**(m) | **可变长度的字符串，使用几个字符就占用几个**，M为0~65535之间的整数。 如：varchar(20)，这个字符串最长是20，大于20会报错。 使用几个，占几个字符。 |\n\n# 2、数据库基本操作\n## 2.1、DDL数据定义语言\n### 2.1.1、数据库相关\n\n```sql\n-- 创建数据库并指定字符集\ncreate database db01 character set utf8;\n\n-- 查看所有的数据库\nshow databases;\n\n-- 查看某个数据库的DDL语句\nshow create database db01;\n\n-- 修改数据库编码\nalter database db01 character set utf8;\n\n-- 删除数据库\ndrop database db01;\n\n-- 切换数据库\ndrop database db01;\n\n```\n### 1.1.2、表相关\n\n```sql\n-- 创建表\ncreate table emp (\n    id int,\n  \t-- ` 是 MySQL 的转义符，避免和 mysql 的本身的关键字冲突，只要你不在列名、表名中使用 mysql 的保留字或中文，就不需要转义。\n    sex char(1),\n    `name` varchar(20), \n\taddress varchar(20)\n);\n\n-- 查看数据库所有表\nshow tables;\n\n-- 查看表结构\ndesc 表名;\n\n-- 查看创建表的sql语句\nshow create table emp;\n\n-- 复制表结构\nCREATE TABLE 新表 LIKE 旧表;\n\n-- 删除表\nDROP TABLE 表名; \n\n-- 判断表是否存在，存在删除表\nDROP TABLE IF EXIST 表名;\n\n-- 添加列\nalter table emp add age int;\n\n-- 删除列\nalter table emp drop age;\n\n-- 修改字段类型\nalter table emp modify address varchar(100);\n\n-- 修改字段名和字段类型\nalter table emp change address addr varchar(80);\n\n-- 修改表名（MySQL中没有直接修改库名的语句）\nrename table emp to employee;\n\n-- 修改表字符集\nalter table emp character set utf8;\n```\n## 2.2、DML数据操纵语言\n\n```sql\n-- 插入全部字段\ninsert into emp values(1,'张三','男','河南汤阴',39);\n\n-- 插入指定字段\ninsert into emp(id,name,sex) values(2,'李四','男');\n\n-- 插入多条数据\nINSERT INTO emp\nVALUES\n\t( 4, '小红', '女', '四川南充', 25 ),\n\t( 5, '小明', '女', '河南平顶山', 24 ),\n\t( 6, '小李', '男', '陕西榆林', 20 );\n\n-- 更新数据\nupdate emp set sex='男',addr='陕西忻州' where id=5;\n\n-- 删除表数据\ndelete from emp;\n\n-- 清空表（先删除表结构,再创建一个相同的表结构 相当于drop table emp，再create table emp）表中有自增长，会把自增长id 重置成1开始\ntruncate emp;\n```\n## 2.3、DQL数据查询语言\n### 2.3.1、基础查询\n\n```sql\n-- 查询指定列\nselect id,name,addr from emp;\n\n-- 指定列的别名\nselect id as 编号,name as 姓名,addr 地址 from emp;\n\n-- 去重id相同的行\nselect distinct id from emp;\n\n-- 查询时进行列运算\nselect id,name,addr,id+age from emp;\n\n-- 范围查询\nselect * from student where english between 60 and 90;\n\n-- 模糊查询\nselect * from student where address like '%西%'; -- 地址中带西的数据\nselect * from student where address like '_____';-- 查询五个字地址城市的学生\n\n-- 查询列为空的数据\nselect * from student where sex is null;\n\n-- limit查询offset：跳过多少条记录，默认是0 length：返回多少条记录\nselect * from table LIMIT offset,length\nselect * from student limit 2, 3; -- 从第二条开始查，显示三条\n\n-- case when（Case When语句用于选择判断，在执行时先对条件进行判断，然后根据判断结果做出相应的操作）\nSELECT\n\t*,\nCASE\n\t\tsex \n\t\tWHEN '男' THEN\n\t\t'man' \n\t\tWHEN '女' THEN\n\t\t'woman' \n\t\tELSE '其他'\n\tEND AS 'other' \nFROM\n\tstudent;\n\n```\n\n| **通配符** | **说明** |\n| --- | --- |\n| % | 匹配零个或多个字符 |\n| _ | 匹配一个字符 |\n\n### 2.3.2、排序\n\n```sql\n-- 升序排列\nselect * from student order by age asc;\n\n-- 降序排列\nselect * from student order by age desc;\n\n-- 组合排序（查询所有数据大于20岁的学生,在年龄降序排序的基础上,如果年龄相同再以数学成绩升序排序）\nselect * from student where age > 22 order by age desc, math asc;\n```\n\n### 2.3.3、聚合函数\n\n| **SQL中的聚合函数** | **作用** |\n| --- | --- |\n| count | 统计个数，如果这一列有NULL，null不会参与统计 |\n| max | 找这一列中的最大值，一般是数值类型进行操作。 |\n| min | 找这一列中的最小值 |\n| sum | 求这一列的总和 |\n| avg | 求这一列的平均，返回值小数average |\n\n\n### 2.3.4、分组\n\n分组一般搭配聚合函数一起使用\n\n```sql\n-- 查询年龄大于23岁的人，按性别分组，统计每组的人数\nselect sex, count(*) from student where age>23 group by sex;\n\n-- 查询年龄大于23岁的人，按性别分组，统计每组的人数，并只显示性别人数大于2的数据\nSELECT sex, COUNT(*) FROM student WHERE age > 23 GROUP BY sex having COUNT(*) >2;\n\n\n```\n\n| **子名** | **作用** |\n| --- | --- |\n| where 子句 | 先过滤掉行上的一些数据，再进行分组操作。(先过滤再分组) |\n| having子句 | 先分组后得到的结果上再进行过滤的操作。(先分组再过滤) |\n\n> **where子句后不能使用分组函数，having子句后可以使用聚合函数**\n\n### 2.3.5、连接查询\n#### 2.3.5.1、表的关系\n\n| **表与表的关系** | **示例** | **关系的维护** |\n| --- | --- | --- |\n| 一对多 | 班级合学生 | 通过从表中外键来维护 |\n| 多对多 | 学生和课程。拆分成学生，选课，课程 | 通过中间表，将两个一对多加到一起变成了一个多对多 |\n| 一对一 | 在实际的开发中应用不多，因为一对一可以创建成一张表 | （1）外键添加约束 （2）从表的主键又是外键 可以简化成一张表 |\n\n#### 2.3.5.2、笛卡尔积\n\n简单的说就是两个集合相乘的结果。笛卡尔（Descartes）乘积又叫直积。假设集合A={a,b}，集合B={0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}\n\n```sql\n-- 笛卡尔查询示例\nSELECT * FROM table1 , table2\n```\n\n笛卡尔积产生，有两种情况：\n（1）表连接缺少关联条件，这个是必须要改的；\n（2）表连接有关联条件，但是数据库判断用笛卡尔积更快，也会出现笛卡尔积，这个时候要看实际执行速度；数据库这样判断，**一般是表比较小**，这个时候要特别检查表的数据量是不是真的很少，以免oracle因为统计信息错误而误判。\n\n#### 2.3.5.3、内连接\n\n用左边表的记录去匹配右边表的记录，如果符合条件的则显示\n\n1. 隐式内连接：看不到join关键字，条件使用where指定\n\n```sql\nselect * from dept,emp where dept.id=emp.dept_id;\n```\n\n2. 显示内连接：**使用INNER JOIN ... ON语句, 可以省略INNER\n\n```sql\nselect * from dept d inner join emp e on d.id = e.dept_id;\n```\n\n> 隐式内连接只能使用where来进行表的关联；显示内连接可以使用on和where来关联，推荐使用on\n\n\n#### 2.3.5.4、左外连接\n\n左外连接：使用LEFT OUTER JOIN ... ON，OUTER可以省略(查询的数据以左表为准，即使在其他表中没有匹配的记录也会显示出来)\n```sql\n-- 需要查询所有的部门和员工，无论这个部门下有没有员工\nselect * from dept left join emp on dept.id = emp.dept_id;\n```\n\n> 在使用left jion时，on和where条件的区别如下：\n> 1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。\n> 2、where条件是在临时表生成好后，再对临时表进行过滤的条件。\n\n#### 2.3.5.5、右外连接\n\n右外连接：使用RIGHT OUTER JOIN ... ON，OUTER可以省略（查询的数据以右表为准，即使在其他表中没有匹配的记录也会显示出来）\n\n```sql\nselect * from dept right join emp on dept.id = emp.dept_id;\n```\n#### 2.3.5.6、全连接\n全连接：左表和右表的数据都能够显示全面呢（在对方表中没有匹配的数据就以null补齐）\n\n> MySQL并没有提供全连接，但Oracle支持；虽然MySQL不支持全连接，但是我们可以利用MySQL提供的其它功能来完成全连接的功能：\n\n```sql\nselect * from dept d left join emp e on d.id=e.dept_id\nunion \nselect * from dept d right join emp e on d.id=e.dept_id;\n\n```\n\n> union关键字可以将两个或多个SQL语句的结果集拼接成一个结果集，前提是这些SQL语句的结果集列数必须相同；（union关键字自带去重功能，即去除重复的数据）\n\n\n#### 2.3.5.7、子查询\n一个查询语句结果做为另一个查询语句的条件查询语句有嵌套，里面的查询称为子查询，外面的查询称为父查询子查询要使用括号括起来\n\n1. 子查询结果为单行单列\n\n```sql\nselect * from emp where age = (select max(age) from emp);\n```\n\n2. 子查询结果为多行单列\n\n查询结果是多行单列的时候，子查询的结果相当于一个集合或数组。父查询要使用in/any/all这些关键字\n\n```sql\n-- 采用in 取结果集中的数据 in (1,2,3)\nselect * from dept where id in (select dept_id from emp where age > 23);\n-- 采用all 查询年龄大于1号部门所有员工的人\nselect * from emp where age > all (select age from emp where dept_id=1);\n-- 采用any 比1号部门任意一个大就行\nselect * from emp where age > any (select age from emp where dept_id=1);\n```\n\n3. 子查询结果为多行多列\n\n如果子查询的结果是多行多列，父查询可以将这个查询结果做为一个虚拟表，进行第2次查询。不是放在where后面，而是放在from的后面\n```sql\n-- 询出年龄大于23岁的员工信息和部门名称\nselect e.*,d.name 部门名称 from dept d, (select * from emp where age > 23) e where d.id = e.dept_id\n```\n\n## 2.4、DCL数据控制语言\nDCL是数据控制语言,主要是用来设置或更改数据库用户或角色权限的语句\n\n```sql\n-- 创建用户\nCREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';\n\n-- 查询数据库用户\nselect * from mysql.user;\n\n-- 授权\ngrant create,alter,insert,update,select on db03.* to 'zhangsan'@'localhost';\ngrant all on *.* to 'lisi'@'%';\n\n-- 撤销权限\nrevoke select on db03.* from 'zhangsan'@'localhost';\n\n-- 查看用户权限\nshow grants for 'zhangsan'@'localhost';\n\n-- 删除用户\ndrop user 'zhangsan'@'localhost';\n\n-- 修改管理员密码\nmysqladmin -uroot -p password 新密码\n\n```\n\n# 3、数据库约束\n\n一般在创建表的时候给表的字段添加各种约束，从而保证输入到表中的数据是正确的。保证数据的正确性，完整性和有效性。违反约束的数据是不能添加到表中去的。如果表已经存在，并且表中已经有数据，添加约束的时候如果表中的数据已经违反了现在要添加的约束，约束会添加失败。\n\n| **约束名** | **关键字** | **说明** |\n| --- | --- | --- |\n| 主键 | primary key | 唯一，非空 |\n| 默认 | default | 没有输入值，使用默认值 |\n| 非空 | not null | 必须输入 |\n| 唯一 | unique | 不能重复 |\n| 外键 | foregin key (外键) references 主表(主键) | 外键在从表 主表：1方 从表：多方 |\n\n## 3.1、主键约束\n用来唯一标识表中的每一行记录，在创建表的时候，每张表都应该创建一个主键，每个表只能有一个主键约束，只要有主键就有主键约束。\n\n> 特点：非空，唯一，一张表最多一个主键\n\n```sql\ncreate table t1(\n\tid int primary key auto_increment,\t\t\t\t-- 指定id列为主键\n    city varchar(20)\n)\n\n-- 在已有的表中添加主键\nalter table t1 add primary key(id);\n\n-- 删除主键\nalter table t1 drop primary key;\n\n-- 联合主键\ncreate table test(\n\tid int,\n\tid2 int,\n\tcity varchar(20),\n\tprimary key(id,id2)\t\t\t-- id和id2列组合为联合主键\n);\n```\n## 3.2、唯一约束\n\n这一列的值不能重复\n\n> 和主键约束区别：唯一性约束允许在该列上存在NULL值，主键约束允许\n\n```sql\ncreate table t3 (\n\tid int primary key auto_increment,\n\tcity varchar(20) unique\n);\n```\n## 3.3、非空约束\n这一列的值必须输入，不能为空\n\n```sql\ncreate table t4(\n\tid int,\n\tcity varchar(20) not null\t\t\t-- 非空约束\n);\n```\n## 3.4、检查约束\n检查约束可以使用一定的范围条件来约束我们的列的值，例如年龄应该在0~120岁之间，性别只能有男或女等；\n\n```sql\ncreate table t6(\n\tid int,\n\tname varchar(30),\n\tage int check(age>0 and age<120),\t\t\t-- 年龄只在0~120之间\n\tsex char(1) check('男' or '女') \t\t\t-- 性别只能在'男' 和 '女'之间选择\n);\n```\n## 3.5、外键约束\n外键出现在从表中，被主表的主键约束的那一列外键\n\n```sql\ncreate table employee(\n\tid int primary key auto_increment,\n\tdept_id int, -- 外键的数据类型与主表中的主键相同\n\tCONSTRAINT `employee_ibfk_1` foreign key (dept_id) references dept(id)\t\t-- 本表的dept_id列依赖于dept表的id列\n);\n\n-- 新增外键约束\nALTER TABLE 表名 ADD CONSTRAINT 约束名 FOREIGN KEY (外键字段) REFERENCES 主表(主键)\n```\n# 4、数据库事务\n\n如果一个业务操作中多次访问了数据库，必须保证每条SQL语句都执行成功。如果其中有一条执行失败，那么所有已经执行过的代码必须回滚（撤销）。回到没有执行前的状态。称为事务。简单来说就是要么所有的SQL语句全部执行成功，要么全部失败\n\n| **事务特性** | **含义** |\n| --- | --- |\n|  原子性（Atomicity） | 一个事务内的所有操作要么都执行，要么都执行失败 |\n|  一致性（Consistency） | 事务执行前与执行后，数据库中数据应该保持相同的状态 |\n|  隔离性（Isolation） | 指的是一个事务在最终提交前，对其它事务是不可见的 |\n|  持久性（Durability） |  如果事务执行成功，对数据库的操作是持久的。 |\n\n\n## 4.1、事务提交\n\n1. **手动提交事务**\n\n| **功能** | **SQL语句** |\n| --- | --- |\n| 开启事务 | start transaction/begin |\n| 提交事务 | commit |\n| 回滚事务 | rollback |\n\n\n```sql\n-- 开启事务\nstart transaction;\n\n-- a账号-500元\nupdate account set money=money-500 where name='a';\n\n-- b账号+500元\nupdate account set money=money+500 where name='b';\n\n-- 查询账号信息\nselect * from account;\n\n-- 提交事务\ncommit;\n\n```\n\n2. **自动提交事务，默认是自动提交**\n\nMySQL默认每一条DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，执行完毕自动提交事务，MySQL默认开始自动提交事务\n\n```sql\n-- 取消自动提交事务\nset @@autocommit = 0;\n\nselect @@autocommit;\n\n```\n\n## 4.2、并发访问下事务产生的问题\n当同时有多个用户在访问同一张表中的记录，每个用户在访问的时候都是一个单独的事务。事务在操作时的理想状态是：事务之间不应该相互影响，实际应用的时候会引发下面三种问题：\n\n1. 脏读： 一个事务（用户）读取到了另一个事务没有提交的数据\n2. 不可重复读：一个事务多次读取同一条记录，出现读取数据不一致的情况。一般因为另一个事务更新了这条记录而引发的。\n3. 幻读：在一次事务中，多次读取到的条数不一致\n\n## 4.3、事务的隔离级别\n为了尽量避免这些问题的发生。通过数据库本身的功能去避免，设置不同的隔离级别\n\n| **级别** | **名字** | **隔离级别** | **脏读** | **不可重复读** | **幻读** | **数据库默认隔离级别** | 解释 |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n| 1 | 读未提交 | read uncommitted | 是 | 是 | 是 |  | 事务A可以读取到事务B未提交的数据 |\n| 2 | 读已提交 | read committed | 否 | 是 | 是 | Oracle和SQL Server | 事务A只能读取其它事务已提交的数据（避免了脏读） |\n| 3 | 可重复读 | repeatable read | 否 | 否 | 是 | MySQL | 保证在同一个事务中多次读取同样数据的结果是一样的 |\n| 4 | 串行化 | serializable | 否 | 否 | 否 |  | 事务串行化顺序执行 |\n\n> 隔离级别越高，安全性就越高，性能越低\n\n```sql\n-- 设置隔离级别\nset global transaction isolation level read uncommitted;\n```\n\n# 5、视图\n\n视图其实就是一个select返回的结果集，用于方便我们查询而创建的\"临时表\"，简化我们的查询语句\n\n```sql\ncreate view test4 as select * from student where class_id=1 with local check option;\n```\n# 6、触发器\n\n触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。\n\n| **触发器类型** | **NEW和OLD的使用** |\n| --- | --- |\n| insert触发器 | NEW 表示将要或者已经新增的数据 |\n| update触发器 | OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据 |\n| delete触发器 | OLD 表示将要或者已经删除的数据 |\n\n> 使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容\n\n```sql\n-- 基本语法\ncreate trigger trigger_name [after/before] [insert/update/delete] \non table_name\nfor each row\nbegin\n\t......\nend;\n```\n\n```sql\n-- insert触发器\ncreate trigger test1 after insert\non student\nfor each row\nbegin\n\tinsert into log values(null,new.name,now());\nend;\n\n-- update触发器\ncreate trigger test2 after update\non student\n for each row\nbegin\n\tinsert into log values(null,concat('之前的值: ',old.name,';之后的值: ',new.name),now());\nend;\n\n-- delete触发器\ncreate trigger test3 after delete\non student\n for each row\nbegin\n\tinsert into log values(null,concat('删除的值: ',old.name),now());\nend;\n\n-- 查看当前数据库中的触发器\nshow triggers;\n\n-- 删除触发器\ndrop trigger test1;\n```\n# 7、存储过程和存储函数\n\nMySQL中提供存储过程与存储函数机制，我们先将其统称为存储程序，一般的SQL语句需要先编译然后执行，存储程序是一组为了完成特定功能的SQL语句集，**经编译后存储在数据库中**，当用户通过指定存储程序的名字并给定参数（如果该存储程序带有参数）来调用才会执行\n\n## 7.1、存储过程语法\n### 7.1.1、变量\n\n1. declare：声明变量\n\n```sql\nCREATE PROCEDURE test2 ()\nbegin\n\t\n\tdeclare num int default 0;\t\t-- 声明变量,赋默认值为0\n\tselect num+10;\n\t\nend ;\n\ncall test2();\t\t\t-- 调用存储过程\n\n```\n\n2. set：赋值操作\n\n```sql\nCREATE PROCEDURE test3 ()\nbegin\n\t\n\tdeclare num int default 0;\n\tset num =20;\t\t\t-- 给num变量赋值\n\tselect num;\n\t\nend ;\n\ncall test3();\n\n```\n\n3. into：赋值\n\n```sql\nCREATE PROCEDURE test4 ()\nbegin\n\t\n\tdeclare num int default 0;\t\t\t\n\tselect count(1) into num from student;\n\tselect num;\n\t\nend ;\n\ncall test4();\n\n```\n### 7.1.2、if语句\n\n\n```sql\n-- 根据class_id判断是Java还是UI还是产品\nCREATE PROCEDURE test5 ()\nbegin\n\t\n\tdeclare id int default 1;\t\t\t\n\tdeclare class_name varchar(30);\n\t\n\tif id=1 then\n\t\tset class_name='哇塞，Java大佬！';\n\telseif id=2 then\n\t\tset class_name='原来是UI的啊';\n\telse\n\t\tset class_name='不用想了，肯定是产品小样';\n\tend if;\n\t\n\tselect class_name;\n\t\nend ;\n\ncall test5();\n\n```\n### 7.1.3、传递参数\n\n```sql\ncreate procedure procedure_name([in/out/inout] 参数名  参数类型)\n```\n\n> in： 该参数可以作为输入，也就是需要调用方传入值 , 默认\n> out： 该参数作为输出，也就是该参数可以作为返回值\n> inout： 既可以作为输入参数，也可以作为输出参数\n\n\n\n```sql\n-- 定义一个输入参数和一个输出参数\nCREATE PROCEDURE test7 (in id int,out class_name varchar(100))\nbegin\n\tif id=1 then\n\t\tset class_name='哇塞，Java大佬！';\n\telseif id=2 then\n\t\tset class_name='原来是UI的啊';\n\telse\n\t\tset class_name='不用想了，肯定是产品小样';\n\tend if;\n\t\nend ;\n\n\ncall test7(1,@class_name);\t-- 创建会话变量\t\t\n\nselect @class_name;\t\t-- 引用会话变量\n\n```\n\n> @xxx：代表定义一个会话变量，整个会话都可以使用，当会话关闭（连接断开）时销毁\n> @@xxx：代表定义一个系统变量，永久生效，除非服务器重启\n\n\n### 7.1.4、case语句\n\n```sql\n-- 传递一个月份，返回所在季节\nCREATE PROCEDURE test8 (in month int,out season varchar(10))\nbegin\n\t\n\tcase \n\t\twhen month >=1 and month<=3 then\n\t\t\tset season='spring';\n\t\twhen month >=4 and month<=6 then\n\t\t\tset season='summer';\n\t\twhen month >=7 and month<=9 then\n\t\t\tset season='autumn';\n\t\twhen month >=10 and month<=12 then\n\t\t\tset season='winter';\n\tend case;\nend ;\n\ncall test8(9,@season);\t\t\t-- 定义会话变量来接收test8存储过程返回的值\n\nselect @season;\n\n```\n### 7.1.5、while循环\n\n```sql\n-- 计算任意数的累加和\nCREATE PROCEDURE test10 (in count int)\nbegin\n\tdeclare total int default 0;\n\tdeclare i int default 1;\n\t\n\twhile i<=count do\n\t\tset total=total+i;\n\t\tset i=i+1;\n\tend while;\n\tselect total;\nend ;\n\ncall test10(10);\n\n```\n\n### 7.1.6、repeat循环（while）\n\n```sql\nCREATE PROCEDURE test11 (count int)\t\t-- 默认是输入(in)参数\nbegin\n\tdeclare total int default 0;\n\trepeat \n\t\tset total=total+count;\n\t\tset count=count-1;\n\t\tuntil count=0\t\t\t\t-- 结束条件,注意不要打分号\n\tend repeat;\n\tselect total;\nend ;\n\ncall test11(10);\n\n```\n### 7.1.7、loop循环\n\n```sql\nCREATE PROCEDURE test12 (count int)\t\t-- 默认是输入(in)参数\nbegin\n\tdeclare total int default 0;\t\n\tsum:loop\t\t\t\t\t\t\t-- 定义循环标识\n\t\tset total=total+count;\n\t\tset count=count-1;\n\t\t\n\t\tif count < 1 then\n\t\t\tleave sum;\t\t\t\t\t-- 跳出循环\n\t\tend if;\n\tend loop sum;\t\t\t\t\t\t-- 标识循环结束\n\tselect total;\n\t\nend ;\n\ncall test12(10);\n\n```\n### 7.1.8、游标\n\n游标是用来存储查询结果集的数据类型，可以帮我们保存多条行记录结果，我们要做的操作就是读取游标中的数据获取每一行的数据。\n```sql\nCREATE PROCEDURE test13 ()\t\t-- 默认是输入(in)参数\nbegin\n\t\n\tdeclare id int(11);\n\tdeclare `name` varchar(20);\n\tdeclare class_id int(11);\n\t-- 定义游标结束标识符\n\tdeclare has_data int default 1;\n\t\n\tdeclare stu_result cursor for select * from student;\n\t-- 监测游标结束\n\tdeclare exit handler for not found set has_data=0;\n\t\n\t-- 打开游标\n\topen stu_result;\n\t\n\trepeat \n\t\tfetch stu_result into id,`name`,class_id;\n\t\t\n\t\tselect concat('id: ',id,';name: ',`name`,';class_id',class_id);\n\t\tuntil has_data=0\t\t-- 退出条件,注意不要打分号\n\tend repeat;\n\t\n\t-- 关闭游标\n\tclose stu_result;\n\t\nend ;\n\ncall test13();\n\n```\n## 7.2、存储函数\n### 7.2.1、存储函数和存储过程区别\n\n1. 存储函数的限制比较多，例如不能用临时表、不能执行查询语句、只能用表变量等；而存储过程的限制较少，存储过程的实现功能要复杂些,而函数的实现功能针对性比较强。\n2. 返回值不同。存储函数必须有返回值,且仅返回一个结果值；存储过程可以没有返回值,但是能返回结果集(out,inout)。\n3. 调用时的不同。存储函数select 存储函数名(变量值)；存储过程通过call语句调用 call 存储过程名。\n4. 参数的不同。存储函数的参数类型类似于IN参数，没有类似于OUT和INOUT的参数。存储过程的参数类型有三种，in、out和inout：in： 数据只是从外部传入内部使用(值传递),可以是数值也可以是变量\n\n### 7.2.2、创建方式\n\n```sql\n-- 无参函数\ncreate function test1()\nreturns int\t\t\t\nbegin\n\n\tdeclare num int default 0;\n\t\n\tset num=10;\n\t\n\treturn num;\nend;\n\nselect test1()\n\n-- 带参函数\ncreate function test2(num int)\nreturns int\t\t\t\nbegin\n\treturn num;\nend;\n\nselect test2(22);\n```\n# 8、数据库范式\n## 8.1、三大范式\n\n1. **第一范式（1NF）**：保证每列的原子性。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库满足了第一范式\n> 比如用户表里的名字字段，在中国可能直接存完整的姓名就可以了。但在国外姓和名常常需要分开使用，所以需要分成姓和名两个字段存储。所以是否满足原子性需要根据实际需求来确定\n\n\n2.  **第二范式（2NF）**：满足第一范式前提，不能存在局部依赖。比如有联合主键有两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式 \n\n3.  **第三范式（3NF）**：消除传递依赖，每列都直接依赖于主键\n> 假设存在关系模式主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址。显然满足第一范式和第二范式，但是教师家庭地址传递依赖于教师名，所以不满足第三范式\n\n\n## 8.2、反范式化\n\n所谓反范式化，是一种对范式化设计的数据库的**性能优化策略**，通过在表中增加冗余或重复的数据来提供数据库的读取性能。没有冗余的数据库不一定是最好的数据库，有时为了提高查询效率，就必须降低范式标准，适当保留冗余数据。具体操作就是在一个表中增加别一个表的冗余字段，减少了两个表查询时的关联，从而提高查询效率。\n\n# 9、数据库备份与恢复\nmysqldump命令主要用于数据库的备份\n\n> options：\n> -h：mysql服务器的IP\n> -P：mysql服务器的端口\n> -u：mysql用户名\n> -p：mysql密码\n> -n（--no-create-db）：不包含创建数据库语句（包含建表语句和数据）\n> -t（--no-create-info）：不包含创建表语句（只要插入语句）\n> -d（--no-data）：不包含数据\n> -B（--database）：导出数据库（也包含建库语句也包含数据）\n> -A（--all-databases）：导出所有数据库\n\n```sql\n-- 导出指定表（没有指定表则导出所有）\nmysqldump -h127.0.0.1 -P3306 -uroot -padmin db02 student > D:/test.sql\n-- 导出数据库（比导表增加了 加了create database db_name语句）\nmysqldump -uroot -padmin --all-databases > D:/test.sql\n-- 恢复（执行sql文件）\nsource d:/test.sql;\n```\n# 10、JDBC\n\n是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了操作数据库的所有方法。JDBC是一组接口，没有具体的实现。核心功能也就是实现类由各 **数据库厂商去实现**这些实现类也被成为数据库的驱动。\n## 10.1、JDBC常用接口\n\n| **接口或类** | **作用** |\n| --- | --- |\n| Driver | 驱动接口，定义建立链接的方式 |\n| DriverManager | 1. 加载和注册第三方厂商的驱动程序 2. 创建一个数据库的连接对象 |\n| Connection | 与数据库的一个连接对象 |\n| Statement | SQL语句对象，用于封装SQL语句发送给MySQL服务器 |\n| PreparedStatement | 是Statement接口的子接口，功能更加强大 |\n| ResultSet | 封装从数据库中查询到的结果集 |\n\n## 10.2、PreparedStatement\nPreparedStatement 是 Statement 的子类，也能执行Statement之前的所有操作，其中最主要的功能就是提供了占位符传参处理、预编译等功能；我们实际开发中PreparedStatement会使用的更多\n### 10.2.1、sql注入问题\n**用户输入的内容作为了SQL语句语法的一部分，改变了原有SQL真正的意义**，以上问题称为SQL注入。要解决SQL注入就不能让用户输入的密码和我们的SQL语句进行简单的字符串拼接\n如 用户输入密码：\n\n> abc' or '1'='1\n\n执行的sql为：select * from user where name='admin' and password='abc' or '1'='1';\n\n```java\n// PreparedStatement解决sql注入问题：\n\n//创建预编译的SQL语句\nps = conn.prepareStatement(\"select * from user where name=? and password=?\");\n\n//替换占位符\nps.setString(1, name);\nps.setString(2, password);\n\n//执行SQL语句，查询\nrs = ps.executeQuery();\n\n```\n### 10.2.2、CallableStatement \n\nallableStatement是PreparedStatement的子类，主要是调用数据库中的存储过程/存储函数。并通过CallableStatement对象可以获取存储过程/存储函数的执行结果；\n\n```java\n\t// 定义存储过程\n    CallableStatement cs = connection.prepareCall(\"call test3(?,?,?)\");\n\n    // 输入参数\n    cs.setInt(1,2);\n\n    // 输出参数\n    cs.registerOutParameter(2, Types.VARBINARY);\n    cs.registerOutParameter(3, Types.VARBINARY);\n\n    // 执行存储过程\n    cs.execute();\n\n    // 根据参数名获取值\n    String str1 = cs.getString(\"str1\");\n    String str2 = cs.getString(\"str2\");\n\n```\n### 10.2.3、JDBC事务处理\n\n```java\npublic class Demo15_事务 {\n    @Test\n    public void test1() throws Exception{\n        //创建连接对象\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = JdbcUtils.getConnection();\n\n            // 设置事务不要自动提交(手动提交,默认情况下,事务是自动提交的)\n            conn.setAutoCommit(false);\n\n            //创建语句对象\n            stmt = conn.createStatement();\n\n            //a扣钱\n            stmt.executeUpdate(\"update account set money=money-500 where name='a'\");\n\n            // b加钱\n            stmt.executeUpdate(\"update account set money=money+500 where name='b'\");\n\n            // 提交事务\n            conn.commit();\n\n            System.out.println(\"转账成功\");\n        } catch (Exception e) {\n            try {\n                // 回滚事务\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            System.out.println(\"转账失败\");\n        } finally {\n            JdbcUtils.close(conn, stmt);\n        }\n    }\n}\n\n```\n","slug":"mysql","published":1,"updated":"2023-08-30T12:39:52.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9n000l00ujhgaeerdc","content":"<h1 id=\"1、数据库基础概念\"><a href=\"#1、数据库基础概念\" class=\"headerlink\" title=\"1、数据库基础概念\"></a>1、数据库基础概念</h1><h2 id=\"1-1、mysql数据类型\"><a href=\"#1-1、mysql数据类型\" class=\"headerlink\" title=\"1.1、mysql数据类型\"></a>1.1、mysql数据类型</h2><table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>类型名称</strong></th>\n<th><strong>类型说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>整数</td>\n<td>tinyInt</td>\n<td>微整型：占8位二进制，1个字节 （-128-127）</td>\n</tr>\n<tr>\n<td></td>\n<td>smallint</td>\n<td>小整型：占16位二进制，2个字节（-32768-32767）</td>\n</tr>\n<tr>\n<td></td>\n<td>mediumint</td>\n<td>中整型：占24位二进制，3个字节（-8388608-8388607）</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>int</strong>(integer)</td>\n<td>整型：占32位二进制，4个字节（-2147483648-2147483647）</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>bigint</strong></td>\n<td>大整型：占64位二进制，8个字节（-9223372036854775808-9223372036854775807）</td>\n</tr>\n<tr>\n<td>小数</td>\n<td><strong>float</strong></td>\n<td>单精度浮点数，占4个字节</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>double</strong></td>\n<td>双精度浮点数，占8个字节</td>\n</tr>\n<tr>\n<td></td>\n<td>decimal(m,n)</td>\n<td>高精度小数型，最大精度为65，最大占用空间30字节</td>\n</tr>\n<tr>\n<td>日期</td>\n<td><strong>time</strong></td>\n<td>表示时间类型 yyyy-MM-DD ，3字节</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>date</strong></td>\n<td>表示日期类型 hh:mm:ss ，3字节</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>datetime</strong></td>\n<td>同时可以表示日期和时间类型，8字节</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>char(m)</td>\n<td><strong>固定长度的字符串，无论使用几个字符都占满全部</strong>，M为0~255之间的整数 如：char(20)，实际使用只用了1个字符，也占用20个字符</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>varchar</strong>(m)</td>\n<td><strong>可变长度的字符串，使用几个字符就占用几个</strong>，M为0~65535之间的整数。 如：varchar(20)，这个字符串最长是20，大于20会报错。 使用几个，占几个字符。</td>\n</tr>\n</tbody></table>\n<h1 id=\"2、数据库基本操作\"><a href=\"#2、数据库基本操作\" class=\"headerlink\" title=\"2、数据库基本操作\"></a>2、数据库基本操作</h1><h2 id=\"2-1、DDL数据定义语言\"><a href=\"#2-1、DDL数据定义语言\" class=\"headerlink\" title=\"2.1、DDL数据定义语言\"></a>2.1、DDL数据定义语言</h2><h3 id=\"2-1-1、数据库相关\"><a href=\"#2-1-1、数据库相关\" class=\"headerlink\" title=\"2.1.1、数据库相关\"></a>2.1.1、数据库相关</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建数据库并指定字符集</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> database db01 <span class=\"type\">character</span> <span class=\"keyword\">set</span> utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看所有的数据库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> databases;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看某个数据库的DDL语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> database db01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改数据库编码</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> database db01 <span class=\"type\">character</span> <span class=\"keyword\">set</span> utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除数据库</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> database db01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 切换数据库</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> database db01;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-2、表相关\"><a href=\"#1-1-2、表相关\" class=\"headerlink\" title=\"1.1.2、表相关\"></a>1.1.2、表相关</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建表</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> emp (</span><br><span class=\"line\">    id <span class=\"type\">int</span>,</span><br><span class=\"line\">  \t<span class=\"comment\">-- ` 是 MySQL 的转义符，避免和 mysql 的本身的关键字冲突，只要你不在列名、表名中使用 mysql 的保留字或中文，就不需要转义。</span></span><br><span class=\"line\">    sex <span class=\"type\">char</span>(<span class=\"number\">1</span>),</span><br><span class=\"line\">    `name` <span class=\"type\">varchar</span>(<span class=\"number\">20</span>), </span><br><span class=\"line\">\taddress <span class=\"type\">varchar</span>(<span class=\"number\">20</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看数据库所有表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> tables;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看表结构</span></span><br><span class=\"line\"><span class=\"keyword\">desc</span> 表名;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看创建表的sql语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 复制表结构</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> 新表 <span class=\"keyword\">LIKE</span> 旧表;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> 表名; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 判断表是否存在，存在删除表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF EXIST 表名;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加列</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp <span class=\"keyword\">add</span> age <span class=\"type\">int</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除列</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp <span class=\"keyword\">drop</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改字段类型</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp modify address <span class=\"type\">varchar</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改字段名和字段类型</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp change address addr <span class=\"type\">varchar</span>(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改表名（MySQL中没有直接修改库名的语句）</span></span><br><span class=\"line\">rename <span class=\"keyword\">table</span> emp <span class=\"keyword\">to</span> employee;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改表字符集</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp <span class=\"type\">character</span> <span class=\"keyword\">set</span> utf8;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、DML数据操纵语言\"><a href=\"#2-2、DML数据操纵语言\" class=\"headerlink\" title=\"2.2、DML数据操纵语言\"></a>2.2、DML数据操纵语言</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 插入全部字段</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> emp <span class=\"keyword\">values</span>(<span class=\"number\">1</span>,<span class=\"string\">&#x27;张三&#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;河南汤阴&#x27;</span>,<span class=\"number\">39</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入指定字段</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> emp(id,name,sex) <span class=\"keyword\">values</span>(<span class=\"number\">2</span>,<span class=\"string\">&#x27;李四&#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入多条数据</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> emp</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">\t( <span class=\"number\">4</span>, <span class=\"string\">&#x27;小红&#x27;</span>, <span class=\"string\">&#x27;女&#x27;</span>, <span class=\"string\">&#x27;四川南充&#x27;</span>, <span class=\"number\">25</span> ),</span><br><span class=\"line\">\t( <span class=\"number\">5</span>, <span class=\"string\">&#x27;小明&#x27;</span>, <span class=\"string\">&#x27;女&#x27;</span>, <span class=\"string\">&#x27;河南平顶山&#x27;</span>, <span class=\"number\">24</span> ),</span><br><span class=\"line\">\t( <span class=\"number\">6</span>, <span class=\"string\">&#x27;小李&#x27;</span>, <span class=\"string\">&#x27;男&#x27;</span>, <span class=\"string\">&#x27;陕西榆林&#x27;</span>, <span class=\"number\">20</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 更新数据</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> emp <span class=\"keyword\">set</span> sex<span class=\"operator\">=</span><span class=\"string\">&#x27;男&#x27;</span>,addr<span class=\"operator\">=</span><span class=\"string\">&#x27;陕西忻州&#x27;</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表数据</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 清空表（先删除表结构,再创建一个相同的表结构 相当于drop table emp，再create table emp）表中有自增长，会把自增长id 重置成1开始</span></span><br><span class=\"line\"><span class=\"keyword\">truncate</span> emp;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3、DQL数据查询语言\"><a href=\"#2-3、DQL数据查询语言\" class=\"headerlink\" title=\"2.3、DQL数据查询语言\"></a>2.3、DQL数据查询语言</h2><h3 id=\"2-3-1、基础查询\"><a href=\"#2-3-1、基础查询\" class=\"headerlink\" title=\"2.3.1、基础查询\"></a>2.3.1、基础查询</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询指定列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> id,name,addr <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 指定列的别名</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> id <span class=\"keyword\">as</span> 编号,name <span class=\"keyword\">as</span> 姓名,addr 地址 <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 去重id相同的行</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">distinct</span> id <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询时进行列运算</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> id,name,addr,id<span class=\"operator\">+</span>age <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 范围查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> english <span class=\"keyword\">between</span> <span class=\"number\">60</span> <span class=\"keyword\">and</span> <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 模糊查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> address <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%西%&#x27;</span>; <span class=\"comment\">-- 地址中带西的数据</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> address <span class=\"keyword\">like</span> <span class=\"string\">&#x27;_____&#x27;</span>;<span class=\"comment\">-- 查询五个字地址城市的学生</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询列为空的数据</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> sex <span class=\"keyword\">is</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- limit查询offset：跳过多少条记录，默认是0 length：返回多少条记录</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> LIMIT <span class=\"keyword\">offset</span>,length</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student limit <span class=\"number\">2</span>, <span class=\"number\">3</span>; <span class=\"comment\">-- 从第二条开始查，显示三条</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- case when（Case When语句用于选择判断，在执行时先对条件进行判断，然后根据判断结果做出相应的操作）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\t<span class=\"operator\">*</span>,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\">\t\tsex </span><br><span class=\"line\">\t\t<span class=\"keyword\">WHEN</span> <span class=\"string\">&#x27;男&#x27;</span> <span class=\"keyword\">THEN</span></span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;man&#x27;</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">WHEN</span> <span class=\"string\">&#x27;女&#x27;</span> <span class=\"keyword\">THEN</span></span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;woman&#x27;</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;其他&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;other&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\tstudent;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>通配符</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%</td>\n<td>匹配零个或多个字符</td>\n</tr>\n<tr>\n<td>_</td>\n<td>匹配一个字符</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-2、排序\"><a href=\"#2-3-2、排序\" class=\"headerlink\" title=\"2.3.2、排序\"></a>2.3.2、排序</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 升序排列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> age <span class=\"keyword\">asc</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 降序排列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> age <span class=\"keyword\">desc</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 组合排序（查询所有数据大于20岁的学生,在年龄降序排序的基础上,如果年龄相同再以数学成绩升序排序）</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">22</span> <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> age <span class=\"keyword\">desc</span>, math <span class=\"keyword\">asc</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-3、聚合函数\"><a href=\"#2-3-3、聚合函数\" class=\"headerlink\" title=\"2.3.3、聚合函数\"></a>2.3.3、聚合函数</h3><table>\n<thead>\n<tr>\n<th><strong>SQL中的聚合函数</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>count</td>\n<td>统计个数，如果这一列有NULL，null不会参与统计</td>\n</tr>\n<tr>\n<td>max</td>\n<td>找这一列中的最大值，一般是数值类型进行操作。</td>\n</tr>\n<tr>\n<td>min</td>\n<td>找这一列中的最小值</td>\n</tr>\n<tr>\n<td>sum</td>\n<td>求这一列的总和</td>\n</tr>\n<tr>\n<td>avg</td>\n<td>求这一列的平均，返回值小数average</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-4、分组\"><a href=\"#2-3-4、分组\" class=\"headerlink\" title=\"2.3.4、分组\"></a>2.3.4、分组</h3><p>分组一般搭配聚合函数一起使用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询年龄大于23岁的人，按性别分组，统计每组的人数</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> sex, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> age<span class=\"operator\">&gt;</span><span class=\"number\">23</span> <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> sex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询年龄大于23岁的人，按性别分组，统计每组的人数，并只显示性别人数大于2的数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> sex, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> student <span class=\"keyword\">WHERE</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">23</span> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sex <span class=\"keyword\">having</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"operator\">&gt;</span><span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>子名</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>where 子句</td>\n<td>先过滤掉行上的一些数据，再进行分组操作。(先过滤再分组)</td>\n</tr>\n<tr>\n<td>having子句</td>\n<td>先分组后得到的结果上再进行过滤的操作。(先分组再过滤)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>where子句后不能使用分组函数，having子句后可以使用聚合函数</strong></p>\n</blockquote>\n<h3 id=\"2-3-5、连接查询\"><a href=\"#2-3-5、连接查询\" class=\"headerlink\" title=\"2.3.5、连接查询\"></a>2.3.5、连接查询</h3><h4 id=\"2-3-5-1、表的关系\"><a href=\"#2-3-5-1、表的关系\" class=\"headerlink\" title=\"2.3.5.1、表的关系\"></a>2.3.5.1、表的关系</h4><table>\n<thead>\n<tr>\n<th><strong>表与表的关系</strong></th>\n<th><strong>示例</strong></th>\n<th><strong>关系的维护</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一对多</td>\n<td>班级合学生</td>\n<td>通过从表中外键来维护</td>\n</tr>\n<tr>\n<td>多对多</td>\n<td>学生和课程。拆分成学生，选课，课程</td>\n<td>通过中间表，将两个一对多加到一起变成了一个多对多</td>\n</tr>\n<tr>\n<td>一对一</td>\n<td>在实际的开发中应用不多，因为一对一可以创建成一张表</td>\n<td>（1）外键添加约束 （2）从表的主键又是外键 可以简化成一张表</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-3-5-2、笛卡尔积\"><a href=\"#2-3-5-2、笛卡尔积\" class=\"headerlink\" title=\"2.3.5.2、笛卡尔积\"></a>2.3.5.2、笛卡尔积</h4><p>简单的说就是两个集合相乘的结果。笛卡尔（Descartes）乘积又叫直积。假设集合A&#x3D;{a,b}，集合B&#x3D;{0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 笛卡尔查询示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> table1 , table2</span><br></pre></td></tr></table></figure>\n\n<p>笛卡尔积产生，有两种情况：<br>（1）表连接缺少关联条件，这个是必须要改的；<br>（2）表连接有关联条件，但是数据库判断用笛卡尔积更快，也会出现笛卡尔积，这个时候要看实际执行速度；数据库这样判断，<strong>一般是表比较小</strong>，这个时候要特别检查表的数据量是不是真的很少，以免oracle因为统计信息错误而误判。</p>\n<h4 id=\"2-3-5-3、内连接\"><a href=\"#2-3-5-3、内连接\" class=\"headerlink\" title=\"2.3.5.3、内连接\"></a>2.3.5.3、内连接</h4><p>用左边表的记录去匹配右边表的记录，如果符合条件的则显示</p>\n<ol>\n<li>隐式内连接：看不到join关键字，条件使用where指定</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept,emp <span class=\"keyword\">where</span> dept.id<span class=\"operator\">=</span>emp.dept_id;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>显示内连接：**使用INNER JOIN … ON语句, 可以省略INNER</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept d <span class=\"keyword\">inner</span> <span class=\"keyword\">join</span> emp e <span class=\"keyword\">on</span> d.id <span class=\"operator\">=</span> e.dept_id;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>隐式内连接只能使用where来进行表的关联；显示内连接可以使用on和where来关联，推荐使用on</p>\n</blockquote>\n<h4 id=\"2-3-5-4、左外连接\"><a href=\"#2-3-5-4、左外连接\" class=\"headerlink\" title=\"2.3.5.4、左外连接\"></a>2.3.5.4、左外连接</h4><p>左外连接：使用LEFT OUTER JOIN … ON，OUTER可以省略(查询的数据以左表为准，即使在其他表中没有匹配的记录也会显示出来)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 需要查询所有的部门和员工，无论这个部门下有没有员工</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> emp <span class=\"keyword\">on</span> dept.id <span class=\"operator\">=</span> emp.dept_id;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在使用left jion时，on和where条件的区别如下：<br>1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。<br>2、where条件是在临时表生成好后，再对临时表进行过滤的条件。</p>\n</blockquote>\n<h4 id=\"2-3-5-5、右外连接\"><a href=\"#2-3-5-5、右外连接\" class=\"headerlink\" title=\"2.3.5.5、右外连接\"></a>2.3.5.5、右外连接</h4><p>右外连接：使用RIGHT OUTER JOIN … ON，OUTER可以省略（查询的数据以右表为准，即使在其他表中没有匹配的记录也会显示出来）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept <span class=\"keyword\">right</span> <span class=\"keyword\">join</span> emp <span class=\"keyword\">on</span> dept.id <span class=\"operator\">=</span> emp.dept_id;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-5-6、全连接\"><a href=\"#2-3-5-6、全连接\" class=\"headerlink\" title=\"2.3.5.6、全连接\"></a>2.3.5.6、全连接</h4><p>全连接：左表和右表的数据都能够显示全面呢（在对方表中没有匹配的数据就以null补齐）</p>\n<blockquote>\n<p>MySQL并没有提供全连接，但Oracle支持；虽然MySQL不支持全连接，但是我们可以利用MySQL提供的其它功能来完成全连接的功能：</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept d <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> emp e <span class=\"keyword\">on</span> d.id<span class=\"operator\">=</span>e.dept_id</span><br><span class=\"line\"><span class=\"keyword\">union</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept d <span class=\"keyword\">right</span> <span class=\"keyword\">join</span> emp e <span class=\"keyword\">on</span> d.id<span class=\"operator\">=</span>e.dept_id;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>union关键字可以将两个或多个SQL语句的结果集拼接成一个结果集，前提是这些SQL语句的结果集列数必须相同；（union关键字自带去重功能，即去除重复的数据）</p>\n</blockquote>\n<h4 id=\"2-3-5-7、子查询\"><a href=\"#2-3-5-7、子查询\" class=\"headerlink\" title=\"2.3.5.7、子查询\"></a>2.3.5.7、子查询</h4><p>一个查询语句结果做为另一个查询语句的条件查询语句有嵌套，里面的查询称为子查询，外面的查询称为父查询子查询要使用括号括起来</p>\n<ol>\n<li>子查询结果为单行单列</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">=</span> (<span class=\"keyword\">select</span> <span class=\"built_in\">max</span>(age) <span class=\"keyword\">from</span> emp);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>子查询结果为多行单列</li>\n</ol>\n<p>查询结果是多行单列的时候，子查询的结果相当于一个集合或数组。父查询要使用in&#x2F;any&#x2F;all这些关键字</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 采用in 取结果集中的数据 in (1,2,3)</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept <span class=\"keyword\">where</span> id <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> dept_id <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">23</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 采用all 查询年龄大于1号部门所有员工的人</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"keyword\">all</span> (<span class=\"keyword\">select</span> age <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> dept_id<span class=\"operator\">=</span><span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 采用any 比1号部门任意一个大就行</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"keyword\">any</span> (<span class=\"keyword\">select</span> age <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> dept_id<span class=\"operator\">=</span><span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>子查询结果为多行多列</li>\n</ol>\n<p>如果子查询的结果是多行多列，父查询可以将这个查询结果做为一个虚拟表，进行第2次查询。不是放在where后面，而是放在from的后面</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 询出年龄大于23岁的员工信息和部门名称</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> e.<span class=\"operator\">*</span>,d.name 部门名称 <span class=\"keyword\">from</span> dept d, (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">23</span>) e <span class=\"keyword\">where</span> d.id <span class=\"operator\">=</span> e.dept_id</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4、DCL数据控制语言\"><a href=\"#2-4、DCL数据控制语言\" class=\"headerlink\" title=\"2.4、DCL数据控制语言\"></a>2.4、DCL数据控制语言</h2><p>DCL是数据控制语言,主要是用来设置或更改数据库用户或角色权限的语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建用户</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"string\">&#x27;用户名&#x27;</span>@<span class=\"string\">&#x27;主机名&#x27;</span> IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;密码&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询数据库用户</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> mysql.user;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 授权</span></span><br><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">create</span>,<span class=\"keyword\">alter</span>,<span class=\"keyword\">insert</span>,<span class=\"keyword\">update</span>,<span class=\"keyword\">select</span> <span class=\"keyword\">on</span> db03.<span class=\"operator\">*</span> <span class=\"keyword\">to</span> <span class=\"string\">&#x27;zhangsan&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">all</span> <span class=\"keyword\">on</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">to</span> <span class=\"string\">&#x27;lisi&#x27;</span>@<span class=\"string\">&#x27;%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 撤销权限</span></span><br><span class=\"line\"><span class=\"keyword\">revoke</span> <span class=\"keyword\">select</span> <span class=\"keyword\">on</span> db03.<span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;zhangsan&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看用户权限</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> grants <span class=\"keyword\">for</span> <span class=\"string\">&#x27;zhangsan&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除用户</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">user</span> <span class=\"string\">&#x27;zhangsan&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改管理员密码</span></span><br><span class=\"line\">mysqladmin <span class=\"operator\">-</span>uroot <span class=\"operator\">-</span>p password 新密码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、数据库约束\"><a href=\"#3、数据库约束\" class=\"headerlink\" title=\"3、数据库约束\"></a>3、数据库约束</h1><p>一般在创建表的时候给表的字段添加各种约束，从而保证输入到表中的数据是正确的。保证数据的正确性，完整性和有效性。违反约束的数据是不能添加到表中去的。如果表已经存在，并且表中已经有数据，添加约束的时候如果表中的数据已经违反了现在要添加的约束，约束会添加失败。</p>\n<table>\n<thead>\n<tr>\n<th><strong>约束名</strong></th>\n<th><strong>关键字</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>主键</td>\n<td>primary key</td>\n<td>唯一，非空</td>\n</tr>\n<tr>\n<td>默认</td>\n<td>default</td>\n<td>没有输入值，使用默认值</td>\n</tr>\n<tr>\n<td>非空</td>\n<td>not null</td>\n<td>必须输入</td>\n</tr>\n<tr>\n<td>唯一</td>\n<td>unique</td>\n<td>不能重复</td>\n</tr>\n<tr>\n<td>外键</td>\n<td>foregin key (外键) references 主表(主键)</td>\n<td>外键在从表 主表：1方 从表：多方</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-1、主键约束\"><a href=\"#3-1、主键约束\" class=\"headerlink\" title=\"3.1、主键约束\"></a>3.1、主键约束</h2><p>用来唯一标识表中的每一行记录，在创建表的时候，每张表都应该创建一个主键，每个表只能有一个主键约束，只要有主键就有主键约束。</p>\n<blockquote>\n<p>特点：非空，唯一，一张表最多一个主键</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t1(</span><br><span class=\"line\">\tid <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key auto_increment,\t\t\t\t<span class=\"comment\">-- 指定id列为主键</span></span><br><span class=\"line\">    city <span class=\"type\">varchar</span>(<span class=\"number\">20</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 在已有的表中添加主键</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> t1 <span class=\"keyword\">add</span> <span class=\"keyword\">primary</span> key(id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除主键</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> t1 <span class=\"keyword\">drop</span> <span class=\"keyword\">primary</span> key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 联合主键</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test(</span><br><span class=\"line\">\tid <span class=\"type\">int</span>,</span><br><span class=\"line\">\tid2 <span class=\"type\">int</span>,</span><br><span class=\"line\">\tcity <span class=\"type\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">\t<span class=\"keyword\">primary</span> key(id,id2)\t\t\t<span class=\"comment\">-- id和id2列组合为联合主键</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2、唯一约束\"><a href=\"#3-2、唯一约束\" class=\"headerlink\" title=\"3.2、唯一约束\"></a>3.2、唯一约束</h2><p>这一列的值不能重复</p>\n<blockquote>\n<p>和主键约束区别：唯一性约束允许在该列上存在NULL值，主键约束允许</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t3 (</span><br><span class=\"line\">\tid <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key auto_increment,</span><br><span class=\"line\">\tcity <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">unique</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3、非空约束\"><a href=\"#3-3、非空约束\" class=\"headerlink\" title=\"3.3、非空约束\"></a>3.3、非空约束</h2><p>这一列的值必须输入，不能为空</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t4(</span><br><span class=\"line\">\tid <span class=\"type\">int</span>,</span><br><span class=\"line\">\tcity <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>\t\t\t<span class=\"comment\">-- 非空约束</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-4、检查约束\"><a href=\"#3-4、检查约束\" class=\"headerlink\" title=\"3.4、检查约束\"></a>3.4、检查约束</h2><p>检查约束可以使用一定的范围条件来约束我们的列的值，例如年龄应该在0~120岁之间，性别只能有男或女等；</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t6(</span><br><span class=\"line\">\tid <span class=\"type\">int</span>,</span><br><span class=\"line\">\tname <span class=\"type\">varchar</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">\tage <span class=\"type\">int</span> <span class=\"keyword\">check</span>(age<span class=\"operator\">&gt;</span><span class=\"number\">0</span> <span class=\"keyword\">and</span> age<span class=\"operator\">&lt;</span><span class=\"number\">120</span>),\t\t\t<span class=\"comment\">-- 年龄只在0~120之间</span></span><br><span class=\"line\">\tsex <span class=\"type\">char</span>(<span class=\"number\">1</span>) <span class=\"keyword\">check</span>(<span class=\"string\">&#x27;男&#x27;</span> <span class=\"keyword\">or</span> <span class=\"string\">&#x27;女&#x27;</span>) \t\t\t<span class=\"comment\">-- 性别只能在&#x27;男&#x27; 和 &#x27;女&#x27;之间选择</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-5、外键约束\"><a href=\"#3-5、外键约束\" class=\"headerlink\" title=\"3.5、外键约束\"></a>3.5、外键约束</h2><p>外键出现在从表中，被主表的主键约束的那一列外键</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> employee(</span><br><span class=\"line\">\tid <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key auto_increment,</span><br><span class=\"line\">\tdept_id <span class=\"type\">int</span>, <span class=\"comment\">-- 外键的数据类型与主表中的主键相同</span></span><br><span class=\"line\">\t<span class=\"keyword\">CONSTRAINT</span> `employee_ibfk_1` <span class=\"keyword\">foreign</span> key (dept_id) <span class=\"keyword\">references</span> dept(id)\t\t<span class=\"comment\">-- 本表的dept_id列依赖于dept表的id列</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 新增外键约束</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 表名 <span class=\"keyword\">ADD</span> <span class=\"keyword\">CONSTRAINT</span> 约束名 <span class=\"keyword\">FOREIGN</span> KEY (外键字段) <span class=\"keyword\">REFERENCES</span> 主表(主键)</span><br></pre></td></tr></table></figure>\n<h1 id=\"4、数据库事务\"><a href=\"#4、数据库事务\" class=\"headerlink\" title=\"4、数据库事务\"></a>4、数据库事务</h1><p>如果一个业务操作中多次访问了数据库，必须保证每条SQL语句都执行成功。如果其中有一条执行失败，那么所有已经执行过的代码必须回滚（撤销）。回到没有执行前的状态。称为事务。简单来说就是要么所有的SQL语句全部执行成功，要么全部失败</p>\n<table>\n<thead>\n<tr>\n<th><strong>事务特性</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>原子性（Atomicity）</td>\n<td>一个事务内的所有操作要么都执行，要么都执行失败</td>\n</tr>\n<tr>\n<td>一致性（Consistency）</td>\n<td>事务执行前与执行后，数据库中数据应该保持相同的状态</td>\n</tr>\n<tr>\n<td>隔离性（Isolation）</td>\n<td>指的是一个事务在最终提交前，对其它事务是不可见的</td>\n</tr>\n<tr>\n<td>持久性（Durability）</td>\n<td>如果事务执行成功，对数据库的操作是持久的。</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-1、事务提交\"><a href=\"#4-1、事务提交\" class=\"headerlink\" title=\"4.1、事务提交\"></a>4.1、事务提交</h2><ol>\n<li><strong>手动提交事务</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>功能</strong></th>\n<th><strong>SQL语句</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开启事务</td>\n<td>start transaction&#x2F;begin</td>\n</tr>\n<tr>\n<td>提交事务</td>\n<td>commit</td>\n</tr>\n<tr>\n<td>回滚事务</td>\n<td>rollback</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 开启事务</span></span><br><span class=\"line\"><span class=\"keyword\">start</span> transaction;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- a账号-500元</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> account <span class=\"keyword\">set</span> money<span class=\"operator\">=</span>money<span class=\"number\">-500</span> <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- b账号+500元</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> account <span class=\"keyword\">set</span> money<span class=\"operator\">=</span>money<span class=\"operator\">+</span><span class=\"number\">500</span> <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;b&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询账号信息</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> account;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 提交事务</span></span><br><span class=\"line\"><span class=\"keyword\">commit</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>自动提交事务，默认是自动提交</strong></li>\n</ol>\n<p>MySQL默认每一条DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，执行完毕自动提交事务，MySQL默认开始自动提交事务</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 取消自动提交事务</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> @<span class=\"variable\">@autocommit</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> @<span class=\"variable\">@autocommit</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2、并发访问下事务产生的问题\"><a href=\"#4-2、并发访问下事务产生的问题\" class=\"headerlink\" title=\"4.2、并发访问下事务产生的问题\"></a>4.2、并发访问下事务产生的问题</h2><p>当同时有多个用户在访问同一张表中的记录，每个用户在访问的时候都是一个单独的事务。事务在操作时的理想状态是：事务之间不应该相互影响，实际应用的时候会引发下面三种问题：</p>\n<ol>\n<li>脏读： 一个事务（用户）读取到了另一个事务没有提交的数据</li>\n<li>不可重复读：一个事务多次读取同一条记录，出现读取数据不一致的情况。一般因为另一个事务更新了这条记录而引发的。</li>\n<li>幻读：在一次事务中，多次读取到的条数不一致</li>\n</ol>\n<h2 id=\"4-3、事务的隔离级别\"><a href=\"#4-3、事务的隔离级别\" class=\"headerlink\" title=\"4.3、事务的隔离级别\"></a>4.3、事务的隔离级别</h2><p>为了尽量避免这些问题的发生。通过数据库本身的功能去避免，设置不同的隔离级别</p>\n<table>\n<thead>\n<tr>\n<th><strong>级别</strong></th>\n<th><strong>名字</strong></th>\n<th><strong>隔离级别</strong></th>\n<th><strong>脏读</strong></th>\n<th><strong>不可重复读</strong></th>\n<th><strong>幻读</strong></th>\n<th><strong>数据库默认隔离级别</strong></th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>读未提交</td>\n<td>read uncommitted</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td></td>\n<td>事务A可以读取到事务B未提交的数据</td>\n</tr>\n<tr>\n<td>2</td>\n<td>读已提交</td>\n<td>read committed</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>Oracle和SQL Server</td>\n<td>事务A只能读取其它事务已提交的数据（避免了脏读）</td>\n</tr>\n<tr>\n<td>3</td>\n<td>可重复读</td>\n<td>repeatable read</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n<td>MySQL</td>\n<td>保证在同一个事务中多次读取同样数据的结果是一样的</td>\n</tr>\n<tr>\n<td>4</td>\n<td>串行化</td>\n<td>serializable</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td></td>\n<td>事务串行化顺序执行</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>隔离级别越高，安全性就越高，性能越低</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 设置隔离级别</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5、视图\"><a href=\"#5、视图\" class=\"headerlink\" title=\"5、视图\"></a>5、视图</h1><p>视图其实就是一个select返回的结果集，用于方便我们查询而创建的”临时表”，简化我们的查询语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> test4 <span class=\"keyword\">as</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> class_id<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">with</span> <span class=\"keyword\">local</span> <span class=\"keyword\">check</span> option;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6、触发器\"><a href=\"#6、触发器\" class=\"headerlink\" title=\"6、触发器\"></a>6、触发器</h1><p>触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p>\n<table>\n<thead>\n<tr>\n<th><strong>触发器类型</strong></th>\n<th><strong>NEW和OLD的使用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>insert触发器</td>\n<td>NEW 表示将要或者已经新增的数据</td>\n</tr>\n<tr>\n<td>update触发器</td>\n<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>\n</tr>\n<tr>\n<td>delete触发器</td>\n<td>OLD 表示将要或者已经删除的数据</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 基本语法</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> trigger_name [after<span class=\"operator\">/</span>before] [<span class=\"keyword\">insert</span><span class=\"operator\">/</span><span class=\"keyword\">update</span><span class=\"operator\">/</span><span class=\"keyword\">delete</span>] </span><br><span class=\"line\"><span class=\"keyword\">on</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- insert触发器</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> test1 after <span class=\"keyword\">insert</span></span><br><span class=\"line\"><span class=\"keyword\">on</span> student</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> log <span class=\"keyword\">values</span>(<span class=\"keyword\">null</span>,new.name,now());</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- update触发器</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> test2 after <span class=\"keyword\">update</span></span><br><span class=\"line\"><span class=\"keyword\">on</span> student</span><br><span class=\"line\"> <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> log <span class=\"keyword\">values</span>(<span class=\"keyword\">null</span>,concat(<span class=\"string\">&#x27;之前的值: &#x27;</span>,old.name,<span class=\"string\">&#x27;;之后的值: &#x27;</span>,new.name),now());</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- delete触发器</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> test3 after <span class=\"keyword\">delete</span></span><br><span class=\"line\"><span class=\"keyword\">on</span> student</span><br><span class=\"line\"> <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> log <span class=\"keyword\">values</span>(<span class=\"keyword\">null</span>,concat(<span class=\"string\">&#x27;删除的值: &#x27;</span>,old.name),now());</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看当前数据库中的触发器</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> triggers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除触发器</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">trigger</span> test1;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、存储过程和存储函数\"><a href=\"#7、存储过程和存储函数\" class=\"headerlink\" title=\"7、存储过程和存储函数\"></a>7、存储过程和存储函数</h1><p>MySQL中提供存储过程与存储函数机制，我们先将其统称为存储程序，一般的SQL语句需要先编译然后执行，存储程序是一组为了完成特定功能的SQL语句集，<strong>经编译后存储在数据库中</strong>，当用户通过指定存储程序的名字并给定参数（如果该存储程序带有参数）来调用才会执行</p>\n<h2 id=\"7-1、存储过程语法\"><a href=\"#7-1、存储过程语法\" class=\"headerlink\" title=\"7.1、存储过程语法\"></a>7.1、存储过程语法</h2><h3 id=\"7-1-1、变量\"><a href=\"#7-1-1、变量\" class=\"headerlink\" title=\"7.1.1、变量\"></a>7.1.1、变量</h3><ol>\n<li>declare：声明变量</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test2 ()</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> num <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;\t\t<span class=\"comment\">-- 声明变量,赋默认值为0</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> num<span class=\"operator\">+</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test2();\t\t\t<span class=\"comment\">-- 调用存储过程</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>set：赋值操作</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test3 ()</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> num <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">set</span> num <span class=\"operator\">=</span><span class=\"number\">20</span>;\t\t\t<span class=\"comment\">-- 给num变量赋值</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> num;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test3();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>into：赋值</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test4 ()</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> num <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;\t\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(<span class=\"number\">1</span>) <span class=\"keyword\">into</span> num <span class=\"keyword\">from</span> student;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> num;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test4();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-2、if语句\"><a href=\"#7-1-2、if语句\" class=\"headerlink\" title=\"7.1.2、if语句\"></a>7.1.2、if语句</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 根据class_id判断是Java还是UI还是产品</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test5 ()</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> id <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">1</span>;\t\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> class_name <span class=\"type\">varchar</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tif id<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;哇塞，Java大佬！&#x27;</span>;</span><br><span class=\"line\">\telseif id<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;原来是UI的啊&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;不用想了，肯定是产品小样&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> if;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> class_name;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test5();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-3、传递参数\"><a href=\"#7-1-3、传递参数\" class=\"headerlink\" title=\"7.1.3、传递参数\"></a>7.1.3、传递参数</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">procedure</span> procedure_name([<span class=\"keyword\">in</span><span class=\"operator\">/</span><span class=\"keyword\">out</span><span class=\"operator\">/</span><span class=\"keyword\">inout</span>] 参数名  参数类型)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>in： 该参数可以作为输入，也就是需要调用方传入值 , 默认<br>out： 该参数作为输出，也就是该参数可以作为返回值<br>inout： 既可以作为输入参数，也可以作为输出参数</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 定义一个输入参数和一个输出参数</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test7 (<span class=\"keyword\">in</span> id <span class=\"type\">int</span>,<span class=\"keyword\">out</span> class_name <span class=\"type\">varchar</span>(<span class=\"number\">100</span>))</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\tif id<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;哇塞，Java大佬！&#x27;</span>;</span><br><span class=\"line\">\telseif id<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;原来是UI的啊&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;不用想了，肯定是产品小样&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> if;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test7(<span class=\"number\">1</span>,<span class=\"variable\">@class_name</span>);\t<span class=\"comment\">-- 创建会话变量\t\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@class_name</span>;\t\t<span class=\"comment\">-- 引用会话变量</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@xxx：代表定义一个会话变量，整个会话都可以使用，当会话关闭（连接断开）时销毁<br>@@xxx：代表定义一个系统变量，永久生效，除非服务器重启</p>\n</blockquote>\n<h3 id=\"7-1-4、case语句\"><a href=\"#7-1-4、case语句\" class=\"headerlink\" title=\"7.1.4、case语句\"></a>7.1.4、case语句</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 传递一个月份，返回所在季节</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test8 (<span class=\"keyword\">in</span> <span class=\"keyword\">month</span> <span class=\"type\">int</span>,<span class=\"keyword\">out</span> season <span class=\"type\">varchar</span>(<span class=\"number\">10</span>))</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> <span class=\"keyword\">month</span> <span class=\"operator\">&gt;=</span><span class=\"number\">1</span> <span class=\"keyword\">and</span> <span class=\"keyword\">month</span><span class=\"operator\">&lt;=</span><span class=\"number\">3</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">set</span> season<span class=\"operator\">=</span><span class=\"string\">&#x27;spring&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> <span class=\"keyword\">month</span> <span class=\"operator\">&gt;=</span><span class=\"number\">4</span> <span class=\"keyword\">and</span> <span class=\"keyword\">month</span><span class=\"operator\">&lt;=</span><span class=\"number\">6</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">set</span> season<span class=\"operator\">=</span><span class=\"string\">&#x27;summer&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> <span class=\"keyword\">month</span> <span class=\"operator\">&gt;=</span><span class=\"number\">7</span> <span class=\"keyword\">and</span> <span class=\"keyword\">month</span><span class=\"operator\">&lt;=</span><span class=\"number\">9</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">set</span> season<span class=\"operator\">=</span><span class=\"string\">&#x27;autumn&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> <span class=\"keyword\">month</span> <span class=\"operator\">&gt;=</span><span class=\"number\">10</span> <span class=\"keyword\">and</span> <span class=\"keyword\">month</span><span class=\"operator\">&lt;=</span><span class=\"number\">12</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">set</span> season<span class=\"operator\">=</span><span class=\"string\">&#x27;winter&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> <span class=\"keyword\">case</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test8(<span class=\"number\">9</span>,<span class=\"variable\">@season</span>);\t\t\t<span class=\"comment\">-- 定义会话变量来接收test8存储过程返回的值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@season</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-5、while循环\"><a href=\"#7-1-5、while循环\" class=\"headerlink\" title=\"7.1.5、while循环\"></a>7.1.5、while循环</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 计算任意数的累加和</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test10 (<span class=\"keyword\">in</span> count <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> total <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> i <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhile i<span class=\"operator\">&lt;=</span>count do</span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> total<span class=\"operator\">=</span>total<span class=\"operator\">+</span>i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> i<span class=\"operator\">=</span>i<span class=\"operator\">+</span><span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> while;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> total;</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test10(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-6、repeat循环（while）\"><a href=\"#7-1-6、repeat循环（while）\" class=\"headerlink\" title=\"7.1.6、repeat循环（while）\"></a>7.1.6、repeat循环（while）</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test11 (count <span class=\"type\">int</span>)\t\t<span class=\"comment\">-- 默认是输入(in)参数</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> total <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\trepeat </span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> total<span class=\"operator\">=</span>total<span class=\"operator\">+</span>count;</span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> count<span class=\"operator\">=</span>count<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tuntil count<span class=\"operator\">=</span><span class=\"number\">0</span>\t\t\t\t<span class=\"comment\">-- 结束条件,注意不要打分号</span></span><br><span class=\"line\">\t<span class=\"keyword\">end</span> repeat;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> total;</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test11(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-7、loop循环\"><a href=\"#7-1-7、loop循环\" class=\"headerlink\" title=\"7.1.7、loop循环\"></a>7.1.7、loop循环</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test12 (count <span class=\"type\">int</span>)\t\t<span class=\"comment\">-- 默认是输入(in)参数</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> total <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;\t</span><br><span class=\"line\">\tsum:loop\t\t\t\t\t\t\t<span class=\"comment\">-- 定义循环标识</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> total<span class=\"operator\">=</span>total<span class=\"operator\">+</span>count;</span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> count<span class=\"operator\">=</span>count<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tif count <span class=\"operator\">&lt;</span> <span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\tleave sum;\t\t\t\t\t<span class=\"comment\">-- 跳出循环</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">end</span> if;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> loop sum;\t\t\t\t\t\t<span class=\"comment\">-- 标识循环结束</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> total;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test12(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-8、游标\"><a href=\"#7-1-8、游标\" class=\"headerlink\" title=\"7.1.8、游标\"></a>7.1.8、游标</h3><p>游标是用来存储查询结果集的数据类型，可以帮我们保存多条行记录结果，我们要做的操作就是读取游标中的数据获取每一行的数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test13 ()\t\t<span class=\"comment\">-- 默认是输入(in)参数</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> id <span class=\"type\">int</span>(<span class=\"number\">11</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> `name` <span class=\"type\">varchar</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> class_id <span class=\"type\">int</span>(<span class=\"number\">11</span>);</span><br><span class=\"line\">\t<span class=\"comment\">-- 定义游标结束标识符</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> has_data <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> stu_result <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student;</span><br><span class=\"line\">\t<span class=\"comment\">-- 监测游标结束</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> exit handler <span class=\"keyword\">for</span> <span class=\"keyword\">not</span> found <span class=\"keyword\">set</span> has_data<span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">-- 打开游标</span></span><br><span class=\"line\">\t<span class=\"keyword\">open</span> stu_result;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trepeat </span><br><span class=\"line\">\t\t<span class=\"keyword\">fetch</span> stu_result <span class=\"keyword\">into</span> id,`name`,class_id;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> concat(<span class=\"string\">&#x27;id: &#x27;</span>,id,<span class=\"string\">&#x27;;name: &#x27;</span>,`name`,<span class=\"string\">&#x27;;class_id&#x27;</span>,class_id);</span><br><span class=\"line\">\t\tuntil has_data<span class=\"operator\">=</span><span class=\"number\">0</span>\t\t<span class=\"comment\">-- 退出条件,注意不要打分号</span></span><br><span class=\"line\">\t<span class=\"keyword\">end</span> repeat;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">-- 关闭游标</span></span><br><span class=\"line\">\t<span class=\"keyword\">close</span> stu_result;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test13();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-2、存储函数\"><a href=\"#7-2、存储函数\" class=\"headerlink\" title=\"7.2、存储函数\"></a>7.2、存储函数</h2><h3 id=\"7-2-1、存储函数和存储过程区别\"><a href=\"#7-2-1、存储函数和存储过程区别\" class=\"headerlink\" title=\"7.2.1、存储函数和存储过程区别\"></a>7.2.1、存储函数和存储过程区别</h3><ol>\n<li>存储函数的限制比较多，例如不能用临时表、不能执行查询语句、只能用表变量等；而存储过程的限制较少，存储过程的实现功能要复杂些,而函数的实现功能针对性比较强。</li>\n<li>返回值不同。存储函数必须有返回值,且仅返回一个结果值；存储过程可以没有返回值,但是能返回结果集(out,inout)。</li>\n<li>调用时的不同。存储函数select 存储函数名(变量值)；存储过程通过call语句调用 call 存储过程名。</li>\n<li>参数的不同。存储函数的参数类型类似于IN参数，没有类似于OUT和INOUT的参数。存储过程的参数类型有三种，in、out和inout：in： 数据只是从外部传入内部使用(值传递),可以是数值也可以是变量</li>\n</ol>\n<h3 id=\"7-2-2、创建方式\"><a href=\"#7-2-2、创建方式\" class=\"headerlink\" title=\"7.2.2、创建方式\"></a>7.2.2、创建方式</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 无参函数</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> test1()</span><br><span class=\"line\"><span class=\"keyword\">returns</span> <span class=\"type\">int</span>\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> num <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">set</span> num<span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num;</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> test1()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 带参函数</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> test2(num <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">returns</span> <span class=\"type\">int</span>\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num;</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> test2(<span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"8、数据库范式\"><a href=\"#8、数据库范式\" class=\"headerlink\" title=\"8、数据库范式\"></a>8、数据库范式</h1><h2 id=\"8-1、三大范式\"><a href=\"#8-1、三大范式\" class=\"headerlink\" title=\"8.1、三大范式\"></a>8.1、三大范式</h2><ol>\n<li><p><strong>第一范式（1NF）</strong>：保证每列的原子性。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库满足了第一范式</p>\n<blockquote>\n<p>比如用户表里的名字字段，在中国可能直接存完整的姓名就可以了。但在国外姓和名常常需要分开使用，所以需要分成姓和名两个字段存储。所以是否满足原子性需要根据实际需求来确定</p>\n</blockquote>\n</li>\n<li><p><strong>第二范式（2NF）</strong>：满足第一范式前提，不能存在局部依赖。比如有联合主键有两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式 </p>\n</li>\n<li><p><strong>第三范式（3NF）</strong>：消除传递依赖，每列都直接依赖于主键</p>\n<blockquote>\n<p>假设存在关系模式主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址。显然满足第一范式和第二范式，但是教师家庭地址传递依赖于教师名，所以不满足第三范式</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"8-2、反范式化\"><a href=\"#8-2、反范式化\" class=\"headerlink\" title=\"8.2、反范式化\"></a>8.2、反范式化</h2><p>所谓反范式化，是一种对范式化设计的数据库的<strong>性能优化策略</strong>，通过在表中增加冗余或重复的数据来提供数据库的读取性能。没有冗余的数据库不一定是最好的数据库，有时为了提高查询效率，就必须降低范式标准，适当保留冗余数据。具体操作就是在一个表中增加别一个表的冗余字段，减少了两个表查询时的关联，从而提高查询效率。</p>\n<h1 id=\"9、数据库备份与恢复\"><a href=\"#9、数据库备份与恢复\" class=\"headerlink\" title=\"9、数据库备份与恢复\"></a>9、数据库备份与恢复</h1><p>mysqldump命令主要用于数据库的备份</p>\n<blockquote>\n<p>options：<br>-h：mysql服务器的IP<br>-P：mysql服务器的端口<br>-u：mysql用户名<br>-p：mysql密码<br>-n（–no-create-db）：不包含创建数据库语句（包含建表语句和数据）<br>-t（–no-create-info）：不包含创建表语句（只要插入语句）<br>-d（–no-data）：不包含数据<br>-B（–database）：导出数据库（也包含建库语句也包含数据）<br>-A（–all-databases）：导出所有数据库</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 导出指定表（没有指定表则导出所有）</span></span><br><span class=\"line\">mysqldump <span class=\"operator\">-</span>h127<span class=\"number\">.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"operator\">-</span>P3306 <span class=\"operator\">-</span>uroot <span class=\"operator\">-</span>padmin db02 student <span class=\"operator\">&gt;</span> D:<span class=\"operator\">/</span>test.sql</span><br><span class=\"line\"><span class=\"comment\">-- 导出数据库（比导表增加了 加了create database db_name语句）</span></span><br><span class=\"line\">mysqldump <span class=\"operator\">-</span>uroot <span class=\"operator\">-</span>padmin <span class=\"comment\">--all-databases &gt; D:/test.sql</span></span><br><span class=\"line\"><span class=\"comment\">-- 恢复（执行sql文件）</span></span><br><span class=\"line\">source d:<span class=\"operator\">/</span>test.sql;</span><br></pre></td></tr></table></figure>\n<h1 id=\"10、JDBC\"><a href=\"#10、JDBC\" class=\"headerlink\" title=\"10、JDBC\"></a>10、JDBC</h1><p>是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了操作数据库的所有方法。JDBC是一组接口，没有具体的实现。核心功能也就是实现类由各 <strong>数据库厂商去实现</strong>这些实现类也被成为数据库的驱动。</p>\n<h2 id=\"10-1、JDBC常用接口\"><a href=\"#10-1、JDBC常用接口\" class=\"headerlink\" title=\"10.1、JDBC常用接口\"></a>10.1、JDBC常用接口</h2><table>\n<thead>\n<tr>\n<th><strong>接口或类</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Driver</td>\n<td>驱动接口，定义建立链接的方式</td>\n</tr>\n<tr>\n<td>DriverManager</td>\n<td>1. 加载和注册第三方厂商的驱动程序 2. 创建一个数据库的连接对象</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>与数据库的一个连接对象</td>\n</tr>\n<tr>\n<td>Statement</td>\n<td>SQL语句对象，用于封装SQL语句发送给MySQL服务器</td>\n</tr>\n<tr>\n<td>PreparedStatement</td>\n<td>是Statement接口的子接口，功能更加强大</td>\n</tr>\n<tr>\n<td>ResultSet</td>\n<td>封装从数据库中查询到的结果集</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-2、PreparedStatement\"><a href=\"#10-2、PreparedStatement\" class=\"headerlink\" title=\"10.2、PreparedStatement\"></a>10.2、PreparedStatement</h2><p>PreparedStatement 是 Statement 的子类，也能执行Statement之前的所有操作，其中最主要的功能就是提供了占位符传参处理、预编译等功能；我们实际开发中PreparedStatement会使用的更多</p>\n<h3 id=\"10-2-1、sql注入问题\"><a href=\"#10-2-1、sql注入问题\" class=\"headerlink\" title=\"10.2.1、sql注入问题\"></a>10.2.1、sql注入问题</h3><p><strong>用户输入的内容作为了SQL语句语法的一部分，改变了原有SQL真正的意义</strong>，以上问题称为SQL注入。要解决SQL注入就不能让用户输入的密码和我们的SQL语句进行简单的字符串拼接<br>如 用户输入密码：</p>\n<blockquote>\n<p>abc’ or ‘1’&#x3D;’1</p>\n</blockquote>\n<p>执行的sql为：select * from user where name&#x3D;’admin’ and password&#x3D;’abc’ or ‘1’&#x3D;’1’;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PreparedStatement解决sql注入问题：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建预编译的SQL语句</span></span><br><span class=\"line\">ps = conn.prepareStatement(<span class=\"string\">&quot;select * from user where name=? and password=?&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//替换占位符</span></span><br><span class=\"line\">ps.setString(<span class=\"number\">1</span>, name);</span><br><span class=\"line\">ps.setString(<span class=\"number\">2</span>, password);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行SQL语句，查询</span></span><br><span class=\"line\">rs = ps.executeQuery();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"10-2-2、CallableStatement\"><a href=\"#10-2-2、CallableStatement\" class=\"headerlink\" title=\"10.2.2、CallableStatement\"></a>10.2.2、CallableStatement</h3><p>allableStatement是PreparedStatement的子类，主要是调用数据库中的存储过程&#x2F;存储函数。并通过CallableStatement对象可以获取存储过程&#x2F;存储函数的执行结果；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义存储过程</span></span><br><span class=\"line\">   <span class=\"type\">CallableStatement</span> <span class=\"variable\">cs</span> <span class=\"operator\">=</span> connection.prepareCall(<span class=\"string\">&quot;call test3(?,?,?)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输入参数</span></span><br><span class=\"line\">   cs.setInt(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出参数</span></span><br><span class=\"line\">   cs.registerOutParameter(<span class=\"number\">2</span>, Types.VARBINARY);</span><br><span class=\"line\">   cs.registerOutParameter(<span class=\"number\">3</span>, Types.VARBINARY);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 执行存储过程</span></span><br><span class=\"line\">   cs.execute();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 根据参数名获取值</span></span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> cs.getString(<span class=\"string\">&quot;str1&quot;</span>);</span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> cs.getString(<span class=\"string\">&quot;str2&quot;</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"10-2-3、JDBC事务处理\"><a href=\"#10-2-3、JDBC事务处理\" class=\"headerlink\" title=\"10.2.3、JDBC事务处理\"></a>10.2.3、JDBC事务处理</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo15_</span>事务 &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建连接对象</span></span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">Statement</span> <span class=\"variable\">stmt</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            conn = JdbcUtils.getConnection();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 设置事务不要自动提交(手动提交,默认情况下,事务是自动提交的)</span></span><br><span class=\"line\">            conn.setAutoCommit(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//创建语句对象</span></span><br><span class=\"line\">            stmt = conn.createStatement();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//a扣钱</span></span><br><span class=\"line\">            stmt.executeUpdate(<span class=\"string\">&quot;update account set money=money-500 where name=&#x27;a&#x27;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// b加钱</span></span><br><span class=\"line\">            stmt.executeUpdate(<span class=\"string\">&quot;update account set money=money+500 where name=&#x27;b&#x27;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 提交事务</span></span><br><span class=\"line\">            conn.commit();</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;转账成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 回滚事务</span></span><br><span class=\"line\">                conn.rollback();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException e1) &#123;</span><br><span class=\"line\">                e1.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;转账失败&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            JdbcUtils.close(conn, stmt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、数据库基础概念\"><a href=\"#1、数据库基础概念\" class=\"headerlink\" title=\"1、数据库基础概念\"></a>1、数据库基础概念</h1><h2 id=\"1-1、mysql数据类型\"><a href=\"#1-1、mysql数据类型\" class=\"headerlink\" title=\"1.1、mysql数据类型\"></a>1.1、mysql数据类型</h2><table>\n<thead>\n<tr>\n<th><strong>分类</strong></th>\n<th><strong>类型名称</strong></th>\n<th><strong>类型说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>整数</td>\n<td>tinyInt</td>\n<td>微整型：占8位二进制，1个字节 （-128-127）</td>\n</tr>\n<tr>\n<td></td>\n<td>smallint</td>\n<td>小整型：占16位二进制，2个字节（-32768-32767）</td>\n</tr>\n<tr>\n<td></td>\n<td>mediumint</td>\n<td>中整型：占24位二进制，3个字节（-8388608-8388607）</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>int</strong>(integer)</td>\n<td>整型：占32位二进制，4个字节（-2147483648-2147483647）</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>bigint</strong></td>\n<td>大整型：占64位二进制，8个字节（-9223372036854775808-9223372036854775807）</td>\n</tr>\n<tr>\n<td>小数</td>\n<td><strong>float</strong></td>\n<td>单精度浮点数，占4个字节</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>double</strong></td>\n<td>双精度浮点数，占8个字节</td>\n</tr>\n<tr>\n<td></td>\n<td>decimal(m,n)</td>\n<td>高精度小数型，最大精度为65，最大占用空间30字节</td>\n</tr>\n<tr>\n<td>日期</td>\n<td><strong>time</strong></td>\n<td>表示时间类型 yyyy-MM-DD ，3字节</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>date</strong></td>\n<td>表示日期类型 hh:mm:ss ，3字节</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>datetime</strong></td>\n<td>同时可以表示日期和时间类型，8字节</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>char(m)</td>\n<td><strong>固定长度的字符串，无论使用几个字符都占满全部</strong>，M为0~255之间的整数 如：char(20)，实际使用只用了1个字符，也占用20个字符</td>\n</tr>\n<tr>\n<td></td>\n<td><strong>varchar</strong>(m)</td>\n<td><strong>可变长度的字符串，使用几个字符就占用几个</strong>，M为0~65535之间的整数。 如：varchar(20)，这个字符串最长是20，大于20会报错。 使用几个，占几个字符。</td>\n</tr>\n</tbody></table>\n<h1 id=\"2、数据库基本操作\"><a href=\"#2、数据库基本操作\" class=\"headerlink\" title=\"2、数据库基本操作\"></a>2、数据库基本操作</h1><h2 id=\"2-1、DDL数据定义语言\"><a href=\"#2-1、DDL数据定义语言\" class=\"headerlink\" title=\"2.1、DDL数据定义语言\"></a>2.1、DDL数据定义语言</h2><h3 id=\"2-1-1、数据库相关\"><a href=\"#2-1-1、数据库相关\" class=\"headerlink\" title=\"2.1.1、数据库相关\"></a>2.1.1、数据库相关</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建数据库并指定字符集</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> database db01 <span class=\"type\">character</span> <span class=\"keyword\">set</span> utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看所有的数据库</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> databases;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看某个数据库的DDL语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> database db01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改数据库编码</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> database db01 <span class=\"type\">character</span> <span class=\"keyword\">set</span> utf8;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除数据库</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> database db01;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 切换数据库</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> database db01;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"1-1-2、表相关\"><a href=\"#1-1-2、表相关\" class=\"headerlink\" title=\"1.1.2、表相关\"></a>1.1.2、表相关</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建表</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> emp (</span><br><span class=\"line\">    id <span class=\"type\">int</span>,</span><br><span class=\"line\">  \t<span class=\"comment\">-- ` 是 MySQL 的转义符，避免和 mysql 的本身的关键字冲突，只要你不在列名、表名中使用 mysql 的保留字或中文，就不需要转义。</span></span><br><span class=\"line\">    sex <span class=\"type\">char</span>(<span class=\"number\">1</span>),</span><br><span class=\"line\">    `name` <span class=\"type\">varchar</span>(<span class=\"number\">20</span>), </span><br><span class=\"line\">\taddress <span class=\"type\">varchar</span>(<span class=\"number\">20</span>)</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看数据库所有表</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> tables;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看表结构</span></span><br><span class=\"line\"><span class=\"keyword\">desc</span> 表名;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看创建表的sql语句</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> <span class=\"keyword\">create</span> <span class=\"keyword\">table</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 复制表结构</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> 新表 <span class=\"keyword\">LIKE</span> 旧表;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> 表名; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 判断表是否存在，存在删除表</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF EXIST 表名;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 添加列</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp <span class=\"keyword\">add</span> age <span class=\"type\">int</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除列</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp <span class=\"keyword\">drop</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改字段类型</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp modify address <span class=\"type\">varchar</span>(<span class=\"number\">100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改字段名和字段类型</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp change address addr <span class=\"type\">varchar</span>(<span class=\"number\">80</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改表名（MySQL中没有直接修改库名的语句）</span></span><br><span class=\"line\">rename <span class=\"keyword\">table</span> emp <span class=\"keyword\">to</span> employee;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改表字符集</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> emp <span class=\"type\">character</span> <span class=\"keyword\">set</span> utf8;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-2、DML数据操纵语言\"><a href=\"#2-2、DML数据操纵语言\" class=\"headerlink\" title=\"2.2、DML数据操纵语言\"></a>2.2、DML数据操纵语言</h2><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 插入全部字段</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> emp <span class=\"keyword\">values</span>(<span class=\"number\">1</span>,<span class=\"string\">&#x27;张三&#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>,<span class=\"string\">&#x27;河南汤阴&#x27;</span>,<span class=\"number\">39</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入指定字段</span></span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> emp(id,name,sex) <span class=\"keyword\">values</span>(<span class=\"number\">2</span>,<span class=\"string\">&#x27;李四&#x27;</span>,<span class=\"string\">&#x27;男&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 插入多条数据</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> emp</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">\t( <span class=\"number\">4</span>, <span class=\"string\">&#x27;小红&#x27;</span>, <span class=\"string\">&#x27;女&#x27;</span>, <span class=\"string\">&#x27;四川南充&#x27;</span>, <span class=\"number\">25</span> ),</span><br><span class=\"line\">\t( <span class=\"number\">5</span>, <span class=\"string\">&#x27;小明&#x27;</span>, <span class=\"string\">&#x27;女&#x27;</span>, <span class=\"string\">&#x27;河南平顶山&#x27;</span>, <span class=\"number\">24</span> ),</span><br><span class=\"line\">\t( <span class=\"number\">6</span>, <span class=\"string\">&#x27;小李&#x27;</span>, <span class=\"string\">&#x27;男&#x27;</span>, <span class=\"string\">&#x27;陕西榆林&#x27;</span>, <span class=\"number\">20</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 更新数据</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> emp <span class=\"keyword\">set</span> sex<span class=\"operator\">=</span><span class=\"string\">&#x27;男&#x27;</span>,addr<span class=\"operator\">=</span><span class=\"string\">&#x27;陕西忻州&#x27;</span> <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除表数据</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span> <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 清空表（先删除表结构,再创建一个相同的表结构 相当于drop table emp，再create table emp）表中有自增长，会把自增长id 重置成1开始</span></span><br><span class=\"line\"><span class=\"keyword\">truncate</span> emp;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3、DQL数据查询语言\"><a href=\"#2-3、DQL数据查询语言\" class=\"headerlink\" title=\"2.3、DQL数据查询语言\"></a>2.3、DQL数据查询语言</h2><h3 id=\"2-3-1、基础查询\"><a href=\"#2-3-1、基础查询\" class=\"headerlink\" title=\"2.3.1、基础查询\"></a>2.3.1、基础查询</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询指定列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> id,name,addr <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 指定列的别名</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> id <span class=\"keyword\">as</span> 编号,name <span class=\"keyword\">as</span> 姓名,addr 地址 <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 去重id相同的行</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">distinct</span> id <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询时进行列运算</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> id,name,addr,id<span class=\"operator\">+</span>age <span class=\"keyword\">from</span> emp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 范围查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> english <span class=\"keyword\">between</span> <span class=\"number\">60</span> <span class=\"keyword\">and</span> <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 模糊查询</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> address <span class=\"keyword\">like</span> <span class=\"string\">&#x27;%西%&#x27;</span>; <span class=\"comment\">-- 地址中带西的数据</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> address <span class=\"keyword\">like</span> <span class=\"string\">&#x27;_____&#x27;</span>;<span class=\"comment\">-- 查询五个字地址城市的学生</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询列为空的数据</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> sex <span class=\"keyword\">is</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- limit查询offset：跳过多少条记录，默认是0 length：返回多少条记录</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"keyword\">table</span> LIMIT <span class=\"keyword\">offset</span>,length</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student limit <span class=\"number\">2</span>, <span class=\"number\">3</span>; <span class=\"comment\">-- 从第二条开始查，显示三条</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- case when（Case When语句用于选择判断，在执行时先对条件进行判断，然后根据判断结果做出相应的操作）</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">\t<span class=\"operator\">*</span>,</span><br><span class=\"line\"><span class=\"keyword\">CASE</span></span><br><span class=\"line\">\t\tsex </span><br><span class=\"line\">\t\t<span class=\"keyword\">WHEN</span> <span class=\"string\">&#x27;男&#x27;</span> <span class=\"keyword\">THEN</span></span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;man&#x27;</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">WHEN</span> <span class=\"string\">&#x27;女&#x27;</span> <span class=\"keyword\">THEN</span></span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;woman&#x27;</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">ELSE</span> <span class=\"string\">&#x27;其他&#x27;</span></span><br><span class=\"line\">\t<span class=\"keyword\">END</span> <span class=\"keyword\">AS</span> <span class=\"string\">&#x27;other&#x27;</span> </span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">\tstudent;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>通配符</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>%</td>\n<td>匹配零个或多个字符</td>\n</tr>\n<tr>\n<td>_</td>\n<td>匹配一个字符</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-2、排序\"><a href=\"#2-3-2、排序\" class=\"headerlink\" title=\"2.3.2、排序\"></a>2.3.2、排序</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 升序排列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> age <span class=\"keyword\">asc</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 降序排列</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> age <span class=\"keyword\">desc</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 组合排序（查询所有数据大于20岁的学生,在年龄降序排序的基础上,如果年龄相同再以数学成绩升序排序）</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">22</span> <span class=\"keyword\">order</span> <span class=\"keyword\">by</span> age <span class=\"keyword\">desc</span>, math <span class=\"keyword\">asc</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-3、聚合函数\"><a href=\"#2-3-3、聚合函数\" class=\"headerlink\" title=\"2.3.3、聚合函数\"></a>2.3.3、聚合函数</h3><table>\n<thead>\n<tr>\n<th><strong>SQL中的聚合函数</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>count</td>\n<td>统计个数，如果这一列有NULL，null不会参与统计</td>\n</tr>\n<tr>\n<td>max</td>\n<td>找这一列中的最大值，一般是数值类型进行操作。</td>\n</tr>\n<tr>\n<td>min</td>\n<td>找这一列中的最小值</td>\n</tr>\n<tr>\n<td>sum</td>\n<td>求这一列的总和</td>\n</tr>\n<tr>\n<td>avg</td>\n<td>求这一列的平均，返回值小数average</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-4、分组\"><a href=\"#2-3-4、分组\" class=\"headerlink\" title=\"2.3.4、分组\"></a>2.3.4、分组</h3><p>分组一般搭配聚合函数一起使用</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 查询年龄大于23岁的人，按性别分组，统计每组的人数</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> sex, <span class=\"built_in\">count</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> age<span class=\"operator\">&gt;</span><span class=\"number\">23</span> <span class=\"keyword\">group</span> <span class=\"keyword\">by</span> sex;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询年龄大于23岁的人，按性别分组，统计每组的人数，并只显示性别人数大于2的数据</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> sex, <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"keyword\">FROM</span> student <span class=\"keyword\">WHERE</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">23</span> <span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> sex <span class=\"keyword\">having</span> <span class=\"built_in\">COUNT</span>(<span class=\"operator\">*</span>) <span class=\"operator\">&gt;</span><span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th><strong>子名</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>where 子句</td>\n<td>先过滤掉行上的一些数据，再进行分组操作。(先过滤再分组)</td>\n</tr>\n<tr>\n<td>having子句</td>\n<td>先分组后得到的结果上再进行过滤的操作。(先分组再过滤)</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p><strong>where子句后不能使用分组函数，having子句后可以使用聚合函数</strong></p>\n</blockquote>\n<h3 id=\"2-3-5、连接查询\"><a href=\"#2-3-5、连接查询\" class=\"headerlink\" title=\"2.3.5、连接查询\"></a>2.3.5、连接查询</h3><h4 id=\"2-3-5-1、表的关系\"><a href=\"#2-3-5-1、表的关系\" class=\"headerlink\" title=\"2.3.5.1、表的关系\"></a>2.3.5.1、表的关系</h4><table>\n<thead>\n<tr>\n<th><strong>表与表的关系</strong></th>\n<th><strong>示例</strong></th>\n<th><strong>关系的维护</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>一对多</td>\n<td>班级合学生</td>\n<td>通过从表中外键来维护</td>\n</tr>\n<tr>\n<td>多对多</td>\n<td>学生和课程。拆分成学生，选课，课程</td>\n<td>通过中间表，将两个一对多加到一起变成了一个多对多</td>\n</tr>\n<tr>\n<td>一对一</td>\n<td>在实际的开发中应用不多，因为一对一可以创建成一张表</td>\n<td>（1）外键添加约束 （2）从表的主键又是外键 可以简化成一张表</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-3-5-2、笛卡尔积\"><a href=\"#2-3-5-2、笛卡尔积\" class=\"headerlink\" title=\"2.3.5.2、笛卡尔积\"></a>2.3.5.2、笛卡尔积</h4><p>简单的说就是两个集合相乘的结果。笛卡尔（Descartes）乘积又叫直积。假设集合A&#x3D;{a,b}，集合B&#x3D;{0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 笛卡尔查询示例</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> table1 , table2</span><br></pre></td></tr></table></figure>\n\n<p>笛卡尔积产生，有两种情况：<br>（1）表连接缺少关联条件，这个是必须要改的；<br>（2）表连接有关联条件，但是数据库判断用笛卡尔积更快，也会出现笛卡尔积，这个时候要看实际执行速度；数据库这样判断，<strong>一般是表比较小</strong>，这个时候要特别检查表的数据量是不是真的很少，以免oracle因为统计信息错误而误判。</p>\n<h4 id=\"2-3-5-3、内连接\"><a href=\"#2-3-5-3、内连接\" class=\"headerlink\" title=\"2.3.5.3、内连接\"></a>2.3.5.3、内连接</h4><p>用左边表的记录去匹配右边表的记录，如果符合条件的则显示</p>\n<ol>\n<li>隐式内连接：看不到join关键字，条件使用where指定</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept,emp <span class=\"keyword\">where</span> dept.id<span class=\"operator\">=</span>emp.dept_id;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>显示内连接：**使用INNER JOIN … ON语句, 可以省略INNER</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept d <span class=\"keyword\">inner</span> <span class=\"keyword\">join</span> emp e <span class=\"keyword\">on</span> d.id <span class=\"operator\">=</span> e.dept_id;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>隐式内连接只能使用where来进行表的关联；显示内连接可以使用on和where来关联，推荐使用on</p>\n</blockquote>\n<h4 id=\"2-3-5-4、左外连接\"><a href=\"#2-3-5-4、左外连接\" class=\"headerlink\" title=\"2.3.5.4、左外连接\"></a>2.3.5.4、左外连接</h4><p>左外连接：使用LEFT OUTER JOIN … ON，OUTER可以省略(查询的数据以左表为准，即使在其他表中没有匹配的记录也会显示出来)</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 需要查询所有的部门和员工，无论这个部门下有没有员工</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> emp <span class=\"keyword\">on</span> dept.id <span class=\"operator\">=</span> emp.dept_id;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在使用left jion时，on和where条件的区别如下：<br>1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。<br>2、where条件是在临时表生成好后，再对临时表进行过滤的条件。</p>\n</blockquote>\n<h4 id=\"2-3-5-5、右外连接\"><a href=\"#2-3-5-5、右外连接\" class=\"headerlink\" title=\"2.3.5.5、右外连接\"></a>2.3.5.5、右外连接</h4><p>右外连接：使用RIGHT OUTER JOIN … ON，OUTER可以省略（查询的数据以右表为准，即使在其他表中没有匹配的记录也会显示出来）</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept <span class=\"keyword\">right</span> <span class=\"keyword\">join</span> emp <span class=\"keyword\">on</span> dept.id <span class=\"operator\">=</span> emp.dept_id;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-5-6、全连接\"><a href=\"#2-3-5-6、全连接\" class=\"headerlink\" title=\"2.3.5.6、全连接\"></a>2.3.5.6、全连接</h4><p>全连接：左表和右表的数据都能够显示全面呢（在对方表中没有匹配的数据就以null补齐）</p>\n<blockquote>\n<p>MySQL并没有提供全连接，但Oracle支持；虽然MySQL不支持全连接，但是我们可以利用MySQL提供的其它功能来完成全连接的功能：</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept d <span class=\"keyword\">left</span> <span class=\"keyword\">join</span> emp e <span class=\"keyword\">on</span> d.id<span class=\"operator\">=</span>e.dept_id</span><br><span class=\"line\"><span class=\"keyword\">union</span> </span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept d <span class=\"keyword\">right</span> <span class=\"keyword\">join</span> emp e <span class=\"keyword\">on</span> d.id<span class=\"operator\">=</span>e.dept_id;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>union关键字可以将两个或多个SQL语句的结果集拼接成一个结果集，前提是这些SQL语句的结果集列数必须相同；（union关键字自带去重功能，即去除重复的数据）</p>\n</blockquote>\n<h4 id=\"2-3-5-7、子查询\"><a href=\"#2-3-5-7、子查询\" class=\"headerlink\" title=\"2.3.5.7、子查询\"></a>2.3.5.7、子查询</h4><p>一个查询语句结果做为另一个查询语句的条件查询语句有嵌套，里面的查询称为子查询，外面的查询称为父查询子查询要使用括号括起来</p>\n<ol>\n<li>子查询结果为单行单列</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">=</span> (<span class=\"keyword\">select</span> <span class=\"built_in\">max</span>(age) <span class=\"keyword\">from</span> emp);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>子查询结果为多行单列</li>\n</ol>\n<p>查询结果是多行单列的时候，子查询的结果相当于一个集合或数组。父查询要使用in&#x2F;any&#x2F;all这些关键字</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 采用in 取结果集中的数据 in (1,2,3)</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> dept <span class=\"keyword\">where</span> id <span class=\"keyword\">in</span> (<span class=\"keyword\">select</span> dept_id <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">23</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 采用all 查询年龄大于1号部门所有员工的人</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"keyword\">all</span> (<span class=\"keyword\">select</span> age <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> dept_id<span class=\"operator\">=</span><span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">-- 采用any 比1号部门任意一个大就行</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"keyword\">any</span> (<span class=\"keyword\">select</span> age <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> dept_id<span class=\"operator\">=</span><span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>子查询结果为多行多列</li>\n</ol>\n<p>如果子查询的结果是多行多列，父查询可以将这个查询结果做为一个虚拟表，进行第2次查询。不是放在where后面，而是放在from的后面</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 询出年龄大于23岁的员工信息和部门名称</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> e.<span class=\"operator\">*</span>,d.name 部门名称 <span class=\"keyword\">from</span> dept d, (<span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> emp <span class=\"keyword\">where</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">23</span>) e <span class=\"keyword\">where</span> d.id <span class=\"operator\">=</span> e.dept_id</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4、DCL数据控制语言\"><a href=\"#2-4、DCL数据控制语言\" class=\"headerlink\" title=\"2.4、DCL数据控制语言\"></a>2.4、DCL数据控制语言</h2><p>DCL是数据控制语言,主要是用来设置或更改数据库用户或角色权限的语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 创建用户</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">USER</span> <span class=\"string\">&#x27;用户名&#x27;</span>@<span class=\"string\">&#x27;主机名&#x27;</span> IDENTIFIED <span class=\"keyword\">BY</span> <span class=\"string\">&#x27;密码&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询数据库用户</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> mysql.user;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 授权</span></span><br><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">create</span>,<span class=\"keyword\">alter</span>,<span class=\"keyword\">insert</span>,<span class=\"keyword\">update</span>,<span class=\"keyword\">select</span> <span class=\"keyword\">on</span> db03.<span class=\"operator\">*</span> <span class=\"keyword\">to</span> <span class=\"string\">&#x27;zhangsan&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">grant</span> <span class=\"keyword\">all</span> <span class=\"keyword\">on</span> <span class=\"operator\">*</span>.<span class=\"operator\">*</span> <span class=\"keyword\">to</span> <span class=\"string\">&#x27;lisi&#x27;</span>@<span class=\"string\">&#x27;%&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 撤销权限</span></span><br><span class=\"line\"><span class=\"keyword\">revoke</span> <span class=\"keyword\">select</span> <span class=\"keyword\">on</span> db03.<span class=\"operator\">*</span> <span class=\"keyword\">from</span> <span class=\"string\">&#x27;zhangsan&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看用户权限</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> grants <span class=\"keyword\">for</span> <span class=\"string\">&#x27;zhangsan&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除用户</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">user</span> <span class=\"string\">&#x27;zhangsan&#x27;</span>@<span class=\"string\">&#x27;localhost&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 修改管理员密码</span></span><br><span class=\"line\">mysqladmin <span class=\"operator\">-</span>uroot <span class=\"operator\">-</span>p password 新密码</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"3、数据库约束\"><a href=\"#3、数据库约束\" class=\"headerlink\" title=\"3、数据库约束\"></a>3、数据库约束</h1><p>一般在创建表的时候给表的字段添加各种约束，从而保证输入到表中的数据是正确的。保证数据的正确性，完整性和有效性。违反约束的数据是不能添加到表中去的。如果表已经存在，并且表中已经有数据，添加约束的时候如果表中的数据已经违反了现在要添加的约束，约束会添加失败。</p>\n<table>\n<thead>\n<tr>\n<th><strong>约束名</strong></th>\n<th><strong>关键字</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>主键</td>\n<td>primary key</td>\n<td>唯一，非空</td>\n</tr>\n<tr>\n<td>默认</td>\n<td>default</td>\n<td>没有输入值，使用默认值</td>\n</tr>\n<tr>\n<td>非空</td>\n<td>not null</td>\n<td>必须输入</td>\n</tr>\n<tr>\n<td>唯一</td>\n<td>unique</td>\n<td>不能重复</td>\n</tr>\n<tr>\n<td>外键</td>\n<td>foregin key (外键) references 主表(主键)</td>\n<td>外键在从表 主表：1方 从表：多方</td>\n</tr>\n</tbody></table>\n<h2 id=\"3-1、主键约束\"><a href=\"#3-1、主键约束\" class=\"headerlink\" title=\"3.1、主键约束\"></a>3.1、主键约束</h2><p>用来唯一标识表中的每一行记录，在创建表的时候，每张表都应该创建一个主键，每个表只能有一个主键约束，只要有主键就有主键约束。</p>\n<blockquote>\n<p>特点：非空，唯一，一张表最多一个主键</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t1(</span><br><span class=\"line\">\tid <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key auto_increment,\t\t\t\t<span class=\"comment\">-- 指定id列为主键</span></span><br><span class=\"line\">    city <span class=\"type\">varchar</span>(<span class=\"number\">20</span>)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 在已有的表中添加主键</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> t1 <span class=\"keyword\">add</span> <span class=\"keyword\">primary</span> key(id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除主键</span></span><br><span class=\"line\"><span class=\"keyword\">alter</span> <span class=\"keyword\">table</span> t1 <span class=\"keyword\">drop</span> <span class=\"keyword\">primary</span> key;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 联合主键</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> test(</span><br><span class=\"line\">\tid <span class=\"type\">int</span>,</span><br><span class=\"line\">\tid2 <span class=\"type\">int</span>,</span><br><span class=\"line\">\tcity <span class=\"type\">varchar</span>(<span class=\"number\">20</span>),</span><br><span class=\"line\">\t<span class=\"keyword\">primary</span> key(id,id2)\t\t\t<span class=\"comment\">-- id和id2列组合为联合主键</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2、唯一约束\"><a href=\"#3-2、唯一约束\" class=\"headerlink\" title=\"3.2、唯一约束\"></a>3.2、唯一约束</h2><p>这一列的值不能重复</p>\n<blockquote>\n<p>和主键约束区别：唯一性约束允许在该列上存在NULL值，主键约束允许</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t3 (</span><br><span class=\"line\">\tid <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key auto_increment,</span><br><span class=\"line\">\tcity <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">unique</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-3、非空约束\"><a href=\"#3-3、非空约束\" class=\"headerlink\" title=\"3.3、非空约束\"></a>3.3、非空约束</h2><p>这一列的值必须输入，不能为空</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t4(</span><br><span class=\"line\">\tid <span class=\"type\">int</span>,</span><br><span class=\"line\">\tcity <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">not</span> <span class=\"keyword\">null</span>\t\t\t<span class=\"comment\">-- 非空约束</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-4、检查约束\"><a href=\"#3-4、检查约束\" class=\"headerlink\" title=\"3.4、检查约束\"></a>3.4、检查约束</h2><p>检查约束可以使用一定的范围条件来约束我们的列的值，例如年龄应该在0~120岁之间，性别只能有男或女等；</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> t6(</span><br><span class=\"line\">\tid <span class=\"type\">int</span>,</span><br><span class=\"line\">\tname <span class=\"type\">varchar</span>(<span class=\"number\">30</span>),</span><br><span class=\"line\">\tage <span class=\"type\">int</span> <span class=\"keyword\">check</span>(age<span class=\"operator\">&gt;</span><span class=\"number\">0</span> <span class=\"keyword\">and</span> age<span class=\"operator\">&lt;</span><span class=\"number\">120</span>),\t\t\t<span class=\"comment\">-- 年龄只在0~120之间</span></span><br><span class=\"line\">\tsex <span class=\"type\">char</span>(<span class=\"number\">1</span>) <span class=\"keyword\">check</span>(<span class=\"string\">&#x27;男&#x27;</span> <span class=\"keyword\">or</span> <span class=\"string\">&#x27;女&#x27;</span>) \t\t\t<span class=\"comment\">-- 性别只能在&#x27;男&#x27; 和 &#x27;女&#x27;之间选择</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-5、外键约束\"><a href=\"#3-5、外键约束\" class=\"headerlink\" title=\"3.5、外键约束\"></a>3.5、外键约束</h2><p>外键出现在从表中，被主表的主键约束的那一列外键</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">table</span> employee(</span><br><span class=\"line\">\tid <span class=\"type\">int</span> <span class=\"keyword\">primary</span> key auto_increment,</span><br><span class=\"line\">\tdept_id <span class=\"type\">int</span>, <span class=\"comment\">-- 外键的数据类型与主表中的主键相同</span></span><br><span class=\"line\">\t<span class=\"keyword\">CONSTRAINT</span> `employee_ibfk_1` <span class=\"keyword\">foreign</span> key (dept_id) <span class=\"keyword\">references</span> dept(id)\t\t<span class=\"comment\">-- 本表的dept_id列依赖于dept表的id列</span></span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 新增外键约束</span></span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> 表名 <span class=\"keyword\">ADD</span> <span class=\"keyword\">CONSTRAINT</span> 约束名 <span class=\"keyword\">FOREIGN</span> KEY (外键字段) <span class=\"keyword\">REFERENCES</span> 主表(主键)</span><br></pre></td></tr></table></figure>\n<h1 id=\"4、数据库事务\"><a href=\"#4、数据库事务\" class=\"headerlink\" title=\"4、数据库事务\"></a>4、数据库事务</h1><p>如果一个业务操作中多次访问了数据库，必须保证每条SQL语句都执行成功。如果其中有一条执行失败，那么所有已经执行过的代码必须回滚（撤销）。回到没有执行前的状态。称为事务。简单来说就是要么所有的SQL语句全部执行成功，要么全部失败</p>\n<table>\n<thead>\n<tr>\n<th><strong>事务特性</strong></th>\n<th><strong>含义</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>原子性（Atomicity）</td>\n<td>一个事务内的所有操作要么都执行，要么都执行失败</td>\n</tr>\n<tr>\n<td>一致性（Consistency）</td>\n<td>事务执行前与执行后，数据库中数据应该保持相同的状态</td>\n</tr>\n<tr>\n<td>隔离性（Isolation）</td>\n<td>指的是一个事务在最终提交前，对其它事务是不可见的</td>\n</tr>\n<tr>\n<td>持久性（Durability）</td>\n<td>如果事务执行成功，对数据库的操作是持久的。</td>\n</tr>\n</tbody></table>\n<h2 id=\"4-1、事务提交\"><a href=\"#4-1、事务提交\" class=\"headerlink\" title=\"4.1、事务提交\"></a>4.1、事务提交</h2><ol>\n<li><strong>手动提交事务</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th><strong>功能</strong></th>\n<th><strong>SQL语句</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>开启事务</td>\n<td>start transaction&#x2F;begin</td>\n</tr>\n<tr>\n<td>提交事务</td>\n<td>commit</td>\n</tr>\n<tr>\n<td>回滚事务</td>\n<td>rollback</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 开启事务</span></span><br><span class=\"line\"><span class=\"keyword\">start</span> transaction;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- a账号-500元</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> account <span class=\"keyword\">set</span> money<span class=\"operator\">=</span>money<span class=\"number\">-500</span> <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- b账号+500元</span></span><br><span class=\"line\"><span class=\"keyword\">update</span> account <span class=\"keyword\">set</span> money<span class=\"operator\">=</span>money<span class=\"operator\">+</span><span class=\"number\">500</span> <span class=\"keyword\">where</span> name<span class=\"operator\">=</span><span class=\"string\">&#x27;b&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查询账号信息</span></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> account;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 提交事务</span></span><br><span class=\"line\"><span class=\"keyword\">commit</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>自动提交事务，默认是自动提交</strong></li>\n</ol>\n<p>MySQL默认每一条DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，执行完毕自动提交事务，MySQL默认开始自动提交事务</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 取消自动提交事务</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> @<span class=\"variable\">@autocommit</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> @<span class=\"variable\">@autocommit</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-2、并发访问下事务产生的问题\"><a href=\"#4-2、并发访问下事务产生的问题\" class=\"headerlink\" title=\"4.2、并发访问下事务产生的问题\"></a>4.2、并发访问下事务产生的问题</h2><p>当同时有多个用户在访问同一张表中的记录，每个用户在访问的时候都是一个单独的事务。事务在操作时的理想状态是：事务之间不应该相互影响，实际应用的时候会引发下面三种问题：</p>\n<ol>\n<li>脏读： 一个事务（用户）读取到了另一个事务没有提交的数据</li>\n<li>不可重复读：一个事务多次读取同一条记录，出现读取数据不一致的情况。一般因为另一个事务更新了这条记录而引发的。</li>\n<li>幻读：在一次事务中，多次读取到的条数不一致</li>\n</ol>\n<h2 id=\"4-3、事务的隔离级别\"><a href=\"#4-3、事务的隔离级别\" class=\"headerlink\" title=\"4.3、事务的隔离级别\"></a>4.3、事务的隔离级别</h2><p>为了尽量避免这些问题的发生。通过数据库本身的功能去避免，设置不同的隔离级别</p>\n<table>\n<thead>\n<tr>\n<th><strong>级别</strong></th>\n<th><strong>名字</strong></th>\n<th><strong>隔离级别</strong></th>\n<th><strong>脏读</strong></th>\n<th><strong>不可重复读</strong></th>\n<th><strong>幻读</strong></th>\n<th><strong>数据库默认隔离级别</strong></th>\n<th>解释</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>读未提交</td>\n<td>read uncommitted</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n<td></td>\n<td>事务A可以读取到事务B未提交的数据</td>\n</tr>\n<tr>\n<td>2</td>\n<td>读已提交</td>\n<td>read committed</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n<td>Oracle和SQL Server</td>\n<td>事务A只能读取其它事务已提交的数据（避免了脏读）</td>\n</tr>\n<tr>\n<td>3</td>\n<td>可重复读</td>\n<td>repeatable read</td>\n<td>否</td>\n<td>否</td>\n<td>是</td>\n<td>MySQL</td>\n<td>保证在同一个事务中多次读取同样数据的结果是一样的</td>\n</tr>\n<tr>\n<td>4</td>\n<td>串行化</td>\n<td>serializable</td>\n<td>否</td>\n<td>否</td>\n<td>否</td>\n<td></td>\n<td>事务串行化顺序执行</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>隔离级别越高，安全性就越高，性能越低</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 设置隔离级别</span></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">global</span> transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5、视图\"><a href=\"#5、视图\" class=\"headerlink\" title=\"5、视图\"></a>5、视图</h1><p>视图其实就是一个select返回的结果集，用于方便我们查询而创建的”临时表”，简化我们的查询语句</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">view</span> test4 <span class=\"keyword\">as</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student <span class=\"keyword\">where</span> class_id<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">with</span> <span class=\"keyword\">local</span> <span class=\"keyword\">check</span> option;</span><br></pre></td></tr></table></figure>\n<h1 id=\"6、触发器\"><a href=\"#6、触发器\" class=\"headerlink\" title=\"6、触发器\"></a>6、触发器</h1><p>触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p>\n<table>\n<thead>\n<tr>\n<th><strong>触发器类型</strong></th>\n<th><strong>NEW和OLD的使用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>insert触发器</td>\n<td>NEW 表示将要或者已经新增的数据</td>\n</tr>\n<tr>\n<td>update触发器</td>\n<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>\n</tr>\n<tr>\n<td>delete触发器</td>\n<td>OLD 表示将要或者已经删除的数据</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 基本语法</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> trigger_name [after<span class=\"operator\">/</span>before] [<span class=\"keyword\">insert</span><span class=\"operator\">/</span><span class=\"keyword\">update</span><span class=\"operator\">/</span><span class=\"keyword\">delete</span>] </span><br><span class=\"line\"><span class=\"keyword\">on</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t......</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- insert触发器</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> test1 after <span class=\"keyword\">insert</span></span><br><span class=\"line\"><span class=\"keyword\">on</span> student</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> log <span class=\"keyword\">values</span>(<span class=\"keyword\">null</span>,new.name,now());</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- update触发器</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> test2 after <span class=\"keyword\">update</span></span><br><span class=\"line\"><span class=\"keyword\">on</span> student</span><br><span class=\"line\"> <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> log <span class=\"keyword\">values</span>(<span class=\"keyword\">null</span>,concat(<span class=\"string\">&#x27;之前的值: &#x27;</span>,old.name,<span class=\"string\">&#x27;;之后的值: &#x27;</span>,new.name),now());</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- delete触发器</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">trigger</span> test3 after <span class=\"keyword\">delete</span></span><br><span class=\"line\"><span class=\"keyword\">on</span> student</span><br><span class=\"line\"> <span class=\"keyword\">for</span> <span class=\"keyword\">each</span> <span class=\"type\">row</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> log <span class=\"keyword\">values</span>(<span class=\"keyword\">null</span>,concat(<span class=\"string\">&#x27;删除的值: &#x27;</span>,old.name),now());</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 查看当前数据库中的触发器</span></span><br><span class=\"line\"><span class=\"keyword\">show</span> triggers;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 删除触发器</span></span><br><span class=\"line\"><span class=\"keyword\">drop</span> <span class=\"keyword\">trigger</span> test1;</span><br></pre></td></tr></table></figure>\n<h1 id=\"7、存储过程和存储函数\"><a href=\"#7、存储过程和存储函数\" class=\"headerlink\" title=\"7、存储过程和存储函数\"></a>7、存储过程和存储函数</h1><p>MySQL中提供存储过程与存储函数机制，我们先将其统称为存储程序，一般的SQL语句需要先编译然后执行，存储程序是一组为了完成特定功能的SQL语句集，<strong>经编译后存储在数据库中</strong>，当用户通过指定存储程序的名字并给定参数（如果该存储程序带有参数）来调用才会执行</p>\n<h2 id=\"7-1、存储过程语法\"><a href=\"#7-1、存储过程语法\" class=\"headerlink\" title=\"7.1、存储过程语法\"></a>7.1、存储过程语法</h2><h3 id=\"7-1-1、变量\"><a href=\"#7-1-1、变量\" class=\"headerlink\" title=\"7.1.1、变量\"></a>7.1.1、变量</h3><ol>\n<li>declare：声明变量</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test2 ()</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> num <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;\t\t<span class=\"comment\">-- 声明变量,赋默认值为0</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> num<span class=\"operator\">+</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test2();\t\t\t<span class=\"comment\">-- 调用存储过程</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>set：赋值操作</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test3 ()</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> num <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">set</span> num <span class=\"operator\">=</span><span class=\"number\">20</span>;\t\t\t<span class=\"comment\">-- 给num变量赋值</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> num;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test3();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>into：赋值</li>\n</ol>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test4 ()</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> num <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;\t\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> <span class=\"built_in\">count</span>(<span class=\"number\">1</span>) <span class=\"keyword\">into</span> num <span class=\"keyword\">from</span> student;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> num;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test4();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-2、if语句\"><a href=\"#7-1-2、if语句\" class=\"headerlink\" title=\"7.1.2、if语句\"></a>7.1.2、if语句</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 根据class_id判断是Java还是UI还是产品</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test5 ()</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> id <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">1</span>;\t\t\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> class_name <span class=\"type\">varchar</span>(<span class=\"number\">30</span>);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tif id<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;哇塞，Java大佬！&#x27;</span>;</span><br><span class=\"line\">\telseif id<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;原来是UI的啊&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;不用想了，肯定是产品小样&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> if;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> class_name;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test5();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-3、传递参数\"><a href=\"#7-1-3、传递参数\" class=\"headerlink\" title=\"7.1.3、传递参数\"></a>7.1.3、传递参数</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">procedure</span> procedure_name([<span class=\"keyword\">in</span><span class=\"operator\">/</span><span class=\"keyword\">out</span><span class=\"operator\">/</span><span class=\"keyword\">inout</span>] 参数名  参数类型)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>in： 该参数可以作为输入，也就是需要调用方传入值 , 默认<br>out： 该参数作为输出，也就是该参数可以作为返回值<br>inout： 既可以作为输入参数，也可以作为输出参数</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 定义一个输入参数和一个输出参数</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test7 (<span class=\"keyword\">in</span> id <span class=\"type\">int</span>,<span class=\"keyword\">out</span> class_name <span class=\"type\">varchar</span>(<span class=\"number\">100</span>))</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\tif id<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;哇塞，Java大佬！&#x27;</span>;</span><br><span class=\"line\">\telseif id<span class=\"operator\">=</span><span class=\"number\">2</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;原来是UI的啊&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> class_name<span class=\"operator\">=</span><span class=\"string\">&#x27;不用想了，肯定是产品小样&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> if;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test7(<span class=\"number\">1</span>,<span class=\"variable\">@class_name</span>);\t<span class=\"comment\">-- 创建会话变量\t\t</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@class_name</span>;\t\t<span class=\"comment\">-- 引用会话变量</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>@xxx：代表定义一个会话变量，整个会话都可以使用，当会话关闭（连接断开）时销毁<br>@@xxx：代表定义一个系统变量，永久生效，除非服务器重启</p>\n</blockquote>\n<h3 id=\"7-1-4、case语句\"><a href=\"#7-1-4、case语句\" class=\"headerlink\" title=\"7.1.4、case语句\"></a>7.1.4、case语句</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 传递一个月份，返回所在季节</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test8 (<span class=\"keyword\">in</span> <span class=\"keyword\">month</span> <span class=\"type\">int</span>,<span class=\"keyword\">out</span> season <span class=\"type\">varchar</span>(<span class=\"number\">10</span>))</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> </span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> <span class=\"keyword\">month</span> <span class=\"operator\">&gt;=</span><span class=\"number\">1</span> <span class=\"keyword\">and</span> <span class=\"keyword\">month</span><span class=\"operator\">&lt;=</span><span class=\"number\">3</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">set</span> season<span class=\"operator\">=</span><span class=\"string\">&#x27;spring&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> <span class=\"keyword\">month</span> <span class=\"operator\">&gt;=</span><span class=\"number\">4</span> <span class=\"keyword\">and</span> <span class=\"keyword\">month</span><span class=\"operator\">&lt;=</span><span class=\"number\">6</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">set</span> season<span class=\"operator\">=</span><span class=\"string\">&#x27;summer&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> <span class=\"keyword\">month</span> <span class=\"operator\">&gt;=</span><span class=\"number\">7</span> <span class=\"keyword\">and</span> <span class=\"keyword\">month</span><span class=\"operator\">&lt;=</span><span class=\"number\">9</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">set</span> season<span class=\"operator\">=</span><span class=\"string\">&#x27;autumn&#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">when</span> <span class=\"keyword\">month</span> <span class=\"operator\">&gt;=</span><span class=\"number\">10</span> <span class=\"keyword\">and</span> <span class=\"keyword\">month</span><span class=\"operator\">&lt;=</span><span class=\"number\">12</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">set</span> season<span class=\"operator\">=</span><span class=\"string\">&#x27;winter&#x27;</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> <span class=\"keyword\">case</span>;</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test8(<span class=\"number\">9</span>,<span class=\"variable\">@season</span>);\t\t\t<span class=\"comment\">-- 定义会话变量来接收test8存储过程返回的值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"variable\">@season</span>;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-5、while循环\"><a href=\"#7-1-5、while循环\" class=\"headerlink\" title=\"7.1.5、while循环\"></a>7.1.5、while循环</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 计算任意数的累加和</span></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test10 (<span class=\"keyword\">in</span> count <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> total <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> i <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\twhile i<span class=\"operator\">&lt;=</span>count do</span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> total<span class=\"operator\">=</span>total<span class=\"operator\">+</span>i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> i<span class=\"operator\">=</span>i<span class=\"operator\">+</span><span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> while;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> total;</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test10(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"7-1-6、repeat循环（while）\"><a href=\"#7-1-6、repeat循环（while）\" class=\"headerlink\" title=\"7.1.6、repeat循环（while）\"></a>7.1.6、repeat循环（while）</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test11 (count <span class=\"type\">int</span>)\t\t<span class=\"comment\">-- 默认是输入(in)参数</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> total <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\trepeat </span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> total<span class=\"operator\">=</span>total<span class=\"operator\">+</span>count;</span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> count<span class=\"operator\">=</span>count<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\tuntil count<span class=\"operator\">=</span><span class=\"number\">0</span>\t\t\t\t<span class=\"comment\">-- 结束条件,注意不要打分号</span></span><br><span class=\"line\">\t<span class=\"keyword\">end</span> repeat;</span><br><span class=\"line\">\t<span class=\"keyword\">select</span> total;</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test11(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-7、loop循环\"><a href=\"#7-1-7、loop循环\" class=\"headerlink\" title=\"7.1.7、loop循环\"></a>7.1.7、loop循环</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test12 (count <span class=\"type\">int</span>)\t\t<span class=\"comment\">-- 默认是输入(in)参数</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> total <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;\t</span><br><span class=\"line\">\tsum:loop\t\t\t\t\t\t\t<span class=\"comment\">-- 定义循环标识</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> total<span class=\"operator\">=</span>total<span class=\"operator\">+</span>count;</span><br><span class=\"line\">\t\t<span class=\"keyword\">set</span> count<span class=\"operator\">=</span>count<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tif count <span class=\"operator\">&lt;</span> <span class=\"number\">1</span> <span class=\"keyword\">then</span></span><br><span class=\"line\">\t\t\tleave sum;\t\t\t\t\t<span class=\"comment\">-- 跳出循环</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">end</span> if;</span><br><span class=\"line\">\t<span class=\"keyword\">end</span> loop sum;\t\t\t\t\t\t<span class=\"comment\">-- 标识循环结束</span></span><br><span class=\"line\">\t<span class=\"keyword\">select</span> total;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test12(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-1-8、游标\"><a href=\"#7-1-8、游标\" class=\"headerlink\" title=\"7.1.8、游标\"></a>7.1.8、游标</h3><p>游标是用来存储查询结果集的数据类型，可以帮我们保存多条行记录结果，我们要做的操作就是读取游标中的数据获取每一行的数据。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">PROCEDURE</span> test13 ()\t\t<span class=\"comment\">-- 默认是输入(in)参数</span></span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> id <span class=\"type\">int</span>(<span class=\"number\">11</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> `name` <span class=\"type\">varchar</span>(<span class=\"number\">20</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> class_id <span class=\"type\">int</span>(<span class=\"number\">11</span>);</span><br><span class=\"line\">\t<span class=\"comment\">-- 定义游标结束标识符</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> has_data <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> stu_result <span class=\"keyword\">cursor</span> <span class=\"keyword\">for</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> student;</span><br><span class=\"line\">\t<span class=\"comment\">-- 监测游标结束</span></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> exit handler <span class=\"keyword\">for</span> <span class=\"keyword\">not</span> found <span class=\"keyword\">set</span> has_data<span class=\"operator\">=</span><span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">-- 打开游标</span></span><br><span class=\"line\">\t<span class=\"keyword\">open</span> stu_result;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\trepeat </span><br><span class=\"line\">\t\t<span class=\"keyword\">fetch</span> stu_result <span class=\"keyword\">into</span> id,`name`,class_id;</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t<span class=\"keyword\">select</span> concat(<span class=\"string\">&#x27;id: &#x27;</span>,id,<span class=\"string\">&#x27;;name: &#x27;</span>,`name`,<span class=\"string\">&#x27;;class_id&#x27;</span>,class_id);</span><br><span class=\"line\">\t\tuntil has_data<span class=\"operator\">=</span><span class=\"number\">0</span>\t\t<span class=\"comment\">-- 退出条件,注意不要打分号</span></span><br><span class=\"line\">\t<span class=\"keyword\">end</span> repeat;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"comment\">-- 关闭游标</span></span><br><span class=\"line\">\t<span class=\"keyword\">close</span> stu_result;</span><br><span class=\"line\">\t</span><br><span class=\"line\"><span class=\"keyword\">end</span> ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">call</span> test13();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-2、存储函数\"><a href=\"#7-2、存储函数\" class=\"headerlink\" title=\"7.2、存储函数\"></a>7.2、存储函数</h2><h3 id=\"7-2-1、存储函数和存储过程区别\"><a href=\"#7-2-1、存储函数和存储过程区别\" class=\"headerlink\" title=\"7.2.1、存储函数和存储过程区别\"></a>7.2.1、存储函数和存储过程区别</h3><ol>\n<li>存储函数的限制比较多，例如不能用临时表、不能执行查询语句、只能用表变量等；而存储过程的限制较少，存储过程的实现功能要复杂些,而函数的实现功能针对性比较强。</li>\n<li>返回值不同。存储函数必须有返回值,且仅返回一个结果值；存储过程可以没有返回值,但是能返回结果集(out,inout)。</li>\n<li>调用时的不同。存储函数select 存储函数名(变量值)；存储过程通过call语句调用 call 存储过程名。</li>\n<li>参数的不同。存储函数的参数类型类似于IN参数，没有类似于OUT和INOUT的参数。存储过程的参数类型有三种，in、out和inout：in： 数据只是从外部传入内部使用(值传递),可以是数值也可以是变量</li>\n</ol>\n<h3 id=\"7-2-2、创建方式\"><a href=\"#7-2-2、创建方式\" class=\"headerlink\" title=\"7.2.2、创建方式\"></a>7.2.2、创建方式</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 无参函数</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> test1()</span><br><span class=\"line\"><span class=\"keyword\">returns</span> <span class=\"type\">int</span>\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">declare</span> num <span class=\"type\">int</span> <span class=\"keyword\">default</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">set</span> num<span class=\"operator\">=</span><span class=\"number\">10</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num;</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> test1()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 带参函数</span></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">function</span> test2(num <span class=\"type\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">returns</span> <span class=\"type\">int</span>\t\t\t</span><br><span class=\"line\"><span class=\"keyword\">begin</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> num;</span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">select</span> test2(<span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"8、数据库范式\"><a href=\"#8、数据库范式\" class=\"headerlink\" title=\"8、数据库范式\"></a>8、数据库范式</h1><h2 id=\"8-1、三大范式\"><a href=\"#8-1、三大范式\" class=\"headerlink\" title=\"8.1、三大范式\"></a>8.1、三大范式</h2><ol>\n<li><p><strong>第一范式（1NF）</strong>：保证每列的原子性。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库满足了第一范式</p>\n<blockquote>\n<p>比如用户表里的名字字段，在中国可能直接存完整的姓名就可以了。但在国外姓和名常常需要分开使用，所以需要分成姓和名两个字段存储。所以是否满足原子性需要根据实际需求来确定</p>\n</blockquote>\n</li>\n<li><p><strong>第二范式（2NF）</strong>：满足第一范式前提，不能存在局部依赖。比如有联合主键有两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式 </p>\n</li>\n<li><p><strong>第三范式（3NF）</strong>：消除传递依赖，每列都直接依赖于主键</p>\n<blockquote>\n<p>假设存在关系模式主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址。显然满足第一范式和第二范式，但是教师家庭地址传递依赖于教师名，所以不满足第三范式</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"8-2、反范式化\"><a href=\"#8-2、反范式化\" class=\"headerlink\" title=\"8.2、反范式化\"></a>8.2、反范式化</h2><p>所谓反范式化，是一种对范式化设计的数据库的<strong>性能优化策略</strong>，通过在表中增加冗余或重复的数据来提供数据库的读取性能。没有冗余的数据库不一定是最好的数据库，有时为了提高查询效率，就必须降低范式标准，适当保留冗余数据。具体操作就是在一个表中增加别一个表的冗余字段，减少了两个表查询时的关联，从而提高查询效率。</p>\n<h1 id=\"9、数据库备份与恢复\"><a href=\"#9、数据库备份与恢复\" class=\"headerlink\" title=\"9、数据库备份与恢复\"></a>9、数据库备份与恢复</h1><p>mysqldump命令主要用于数据库的备份</p>\n<blockquote>\n<p>options：<br>-h：mysql服务器的IP<br>-P：mysql服务器的端口<br>-u：mysql用户名<br>-p：mysql密码<br>-n（–no-create-db）：不包含创建数据库语句（包含建表语句和数据）<br>-t（–no-create-info）：不包含创建表语句（只要插入语句）<br>-d（–no-data）：不包含数据<br>-B（–database）：导出数据库（也包含建库语句也包含数据）<br>-A（–all-databases）：导出所有数据库</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 导出指定表（没有指定表则导出所有）</span></span><br><span class=\"line\">mysqldump <span class=\"operator\">-</span>h127<span class=\"number\">.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> <span class=\"operator\">-</span>P3306 <span class=\"operator\">-</span>uroot <span class=\"operator\">-</span>padmin db02 student <span class=\"operator\">&gt;</span> D:<span class=\"operator\">/</span>test.sql</span><br><span class=\"line\"><span class=\"comment\">-- 导出数据库（比导表增加了 加了create database db_name语句）</span></span><br><span class=\"line\">mysqldump <span class=\"operator\">-</span>uroot <span class=\"operator\">-</span>padmin <span class=\"comment\">--all-databases &gt; D:/test.sql</span></span><br><span class=\"line\"><span class=\"comment\">-- 恢复（执行sql文件）</span></span><br><span class=\"line\">source d:<span class=\"operator\">/</span>test.sql;</span><br></pre></td></tr></table></figure>\n<h1 id=\"10、JDBC\"><a href=\"#10、JDBC\" class=\"headerlink\" title=\"10、JDBC\"></a>10、JDBC</h1><p>是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了操作数据库的所有方法。JDBC是一组接口，没有具体的实现。核心功能也就是实现类由各 <strong>数据库厂商去实现</strong>这些实现类也被成为数据库的驱动。</p>\n<h2 id=\"10-1、JDBC常用接口\"><a href=\"#10-1、JDBC常用接口\" class=\"headerlink\" title=\"10.1、JDBC常用接口\"></a>10.1、JDBC常用接口</h2><table>\n<thead>\n<tr>\n<th><strong>接口或类</strong></th>\n<th><strong>作用</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Driver</td>\n<td>驱动接口，定义建立链接的方式</td>\n</tr>\n<tr>\n<td>DriverManager</td>\n<td>1. 加载和注册第三方厂商的驱动程序 2. 创建一个数据库的连接对象</td>\n</tr>\n<tr>\n<td>Connection</td>\n<td>与数据库的一个连接对象</td>\n</tr>\n<tr>\n<td>Statement</td>\n<td>SQL语句对象，用于封装SQL语句发送给MySQL服务器</td>\n</tr>\n<tr>\n<td>PreparedStatement</td>\n<td>是Statement接口的子接口，功能更加强大</td>\n</tr>\n<tr>\n<td>ResultSet</td>\n<td>封装从数据库中查询到的结果集</td>\n</tr>\n</tbody></table>\n<h2 id=\"10-2、PreparedStatement\"><a href=\"#10-2、PreparedStatement\" class=\"headerlink\" title=\"10.2、PreparedStatement\"></a>10.2、PreparedStatement</h2><p>PreparedStatement 是 Statement 的子类，也能执行Statement之前的所有操作，其中最主要的功能就是提供了占位符传参处理、预编译等功能；我们实际开发中PreparedStatement会使用的更多</p>\n<h3 id=\"10-2-1、sql注入问题\"><a href=\"#10-2-1、sql注入问题\" class=\"headerlink\" title=\"10.2.1、sql注入问题\"></a>10.2.1、sql注入问题</h3><p><strong>用户输入的内容作为了SQL语句语法的一部分，改变了原有SQL真正的意义</strong>，以上问题称为SQL注入。要解决SQL注入就不能让用户输入的密码和我们的SQL语句进行简单的字符串拼接<br>如 用户输入密码：</p>\n<blockquote>\n<p>abc’ or ‘1’&#x3D;’1</p>\n</blockquote>\n<p>执行的sql为：select * from user where name&#x3D;’admin’ and password&#x3D;’abc’ or ‘1’&#x3D;’1’;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// PreparedStatement解决sql注入问题：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建预编译的SQL语句</span></span><br><span class=\"line\">ps = conn.prepareStatement(<span class=\"string\">&quot;select * from user where name=? and password=?&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//替换占位符</span></span><br><span class=\"line\">ps.setString(<span class=\"number\">1</span>, name);</span><br><span class=\"line\">ps.setString(<span class=\"number\">2</span>, password);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行SQL语句，查询</span></span><br><span class=\"line\">rs = ps.executeQuery();</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"10-2-2、CallableStatement\"><a href=\"#10-2-2、CallableStatement\" class=\"headerlink\" title=\"10.2.2、CallableStatement\"></a>10.2.2、CallableStatement</h3><p>allableStatement是PreparedStatement的子类，主要是调用数据库中的存储过程&#x2F;存储函数。并通过CallableStatement对象可以获取存储过程&#x2F;存储函数的执行结果；</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义存储过程</span></span><br><span class=\"line\">   <span class=\"type\">CallableStatement</span> <span class=\"variable\">cs</span> <span class=\"operator\">=</span> connection.prepareCall(<span class=\"string\">&quot;call test3(?,?,?)&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输入参数</span></span><br><span class=\"line\">   cs.setInt(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 输出参数</span></span><br><span class=\"line\">   cs.registerOutParameter(<span class=\"number\">2</span>, Types.VARBINARY);</span><br><span class=\"line\">   cs.registerOutParameter(<span class=\"number\">3</span>, Types.VARBINARY);</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 执行存储过程</span></span><br><span class=\"line\">   cs.execute();</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 根据参数名获取值</span></span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">str1</span> <span class=\"operator\">=</span> cs.getString(<span class=\"string\">&quot;str1&quot;</span>);</span><br><span class=\"line\">   <span class=\"type\">String</span> <span class=\"variable\">str2</span> <span class=\"operator\">=</span> cs.getString(<span class=\"string\">&quot;str2&quot;</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"10-2-3、JDBC事务处理\"><a href=\"#10-2-3、JDBC事务处理\" class=\"headerlink\" title=\"10.2.3、JDBC事务处理\"></a>10.2.3、JDBC事务处理</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo15_</span>事务 &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test1</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception&#123;</span><br><span class=\"line\">        <span class=\"comment\">//创建连接对象</span></span><br><span class=\"line\">        <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">Statement</span> <span class=\"variable\">stmt</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            conn = JdbcUtils.getConnection();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 设置事务不要自动提交(手动提交,默认情况下,事务是自动提交的)</span></span><br><span class=\"line\">            conn.setAutoCommit(<span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//创建语句对象</span></span><br><span class=\"line\">            stmt = conn.createStatement();</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//a扣钱</span></span><br><span class=\"line\">            stmt.executeUpdate(<span class=\"string\">&quot;update account set money=money-500 where name=&#x27;a&#x27;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// b加钱</span></span><br><span class=\"line\">            stmt.executeUpdate(<span class=\"string\">&quot;update account set money=money+500 where name=&#x27;b&#x27;&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">// 提交事务</span></span><br><span class=\"line\">            conn.commit();</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;转账成功&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 回滚事务</span></span><br><span class=\"line\">                conn.rollback();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SQLException e1) &#123;</span><br><span class=\"line\">                e1.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;转账失败&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            JdbcUtils.close(conn, stmt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n"},{"title":"shiro","date":"2023-09-12T16:00:00.000Z","updated":"2023-09-12T16:00:00.000Z","abbrlink":15277,"_content":"# 1、shiro基本概念\n\nShiro是Apache组织下的一个开源的安全框架，常常用来做：安全认证、权限管理、会话管理、加密\n\n## 1.1、安全认证\n\n可用于验证用户的身份凭证，如用户名和密码。通过配置 Shiro 的 Realm（领域）来自定义身份验证的逻辑，通过 Subject 对象进行身份验证，可以获取用户的身份信息和执行相关操作\n\n## 1.2、权限管理\n\n可以通过配置 Shiro 的 Realm 来定义用户的角色和权限信息，或者使用注解方式进行权限控制。通过 Subject 对象进行权限检查，可以判断用户是否具有某个角色或权限，并根据结果进行相应的处理\n\n## 1.3、会话管理\n\nshiro 提供了会话管理的功能，用于跟踪用户的登录状态和管理用户的会话信息。Shiro 的会话管理可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理（redis等）\n\n## 1.4、加密\n\n对密码进行加密和解密操作，以保护用户的密码安全。Shiro 支持常用的加密算法，如MD5、SHA、AES等。你可以根据需求选择适当的加密算法进行使用\n\n# 2、shiro架构\n\n![shiro](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309131118959.jpg)\n\n## 2.1、主体（Subject）\n\nSubject即主体，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权\n\n\n## 2.2、安全管理器（Security Manager）\n\nSecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。\nSecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口\n\n## 2.3、认证器（Authenticator）\n\nAuthenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器\n\n\n## 2.4、授权器（Authorizer）\n\nAuthorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限\n\n## 2.5、领域（Realm）\nRealm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。\n\n> 注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。\n\n## 2.6、会话管理器（SessionManager）\n\n会话管理器负责管理主体的会话，跟踪用户的登录状态和管理会话数据。\n在 Shiro 中，会话管理器可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理\n\n# 3、认证\n\n在shiro中,用户需要提供principlas(身份)和credentials(证明)给shiro，从而应用能验证用户身份\n\n## 3.1、认证流程\n\n1. 提交身份凭证：用户在应用程序的登录页面或其他身份验证入口提交身份和凭证，例如用户名和密码\n2. 创建 Subject 对象：应用程序根据用户提交的身份凭证创建一个 Subject 对象，代表当前与应用程序交互的用户\n3. 提交身份凭证给认证器：Subject 对象将身份凭证提交给 Shiro 的认证器（Authenticator）进行验证\n4. 认证器验证身份凭证：认证器对身份凭证进行验证，通常是通过比对凭证与存储在数据源中的用户信息进行匹配。认证器可以使用一个或多个 Realm 来获取用户信息并进行验证。Realm 对获取到的用户信息与提交的身份凭证进行比对验证，判断凭证是否有效\n5. 结果处理：如果身份验证成功，认证器将成功的身份信息存储在 Subject 对象中，以便后续使用\n\n## 3.2、认证实现\n### 3.2.1、自定义Realm\n```java\n\n/**\n * 自定义Realm\n */\npublic class CustomerRealm extends AuthorizingRealm {\n    //授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        System.out.println(\"==================\");\n        return null;\n    }\n\n    //认证\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        //在token中获取 用户名\n        String principal = (String) token.getPrincipal();\n        System.out.println(principal);\n\n        //实际开发中应当 根据身份信息使用jdbc mybatis查询相关数据库\n        //在这里只做简单的演示\n        //假设username,password是从数据库获得的信息\n        String username=\"zhangsan\";\n        String password=\"123456\";\n        if(username.equals(principal)){\n            //参数1:返回数据库中正确的用户名\n            //参数2:返回数据库中正确密码\n            //参数3:提供当前realm的名字 this.getName();\n            SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(principal,password,this.getName());\n            return simpleAuthenticationInfo;\n        }\n        return null;\n    }\n}\n```\n\n### 3.2.2、用定义的Realm进行认证\n```java\n/**\n * 测试自定义的Realm\n */\npublic class TestAuthenticatorCusttomerRealm {\n\n    public static void main(String[] args) {\n        //1.创建安全管理对象 securityManager\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n\n        //2.给安全管理器设置realm（设置为自定义realm获取认证数据）\n        defaultSecurityManager.setRealm(new CustomerRealm());\n        //IniRealm realm = new IniRealm(\"classpath:shiro.ini\");\n\n        //3.给安装工具类中设置默认安全管理器\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n\n        //4.获取主体对象subject\n        Subject subject = SecurityUtils.getSubject();\n\n        //5.创建token令牌\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zhangsan\", \"123\");\n        try {\n            subject.login(token);//用户登录\n            System.out.println(\"登录成功~~\");\n        } catch (UnknownAccountException e) {\n            e.printStackTrace();\n            System.out.println(\"用户名错误!!\");\n        }catch (IncorrectCredentialsException e){\n            e.printStackTrace();\n            System.out.println(\"密码错误!!!\");\n        }\n    }\n}\n```\n\n\n# 4、授权\n## 4.1、授权流程\n认证成功后，Shiro会将用户的身份信息保存在Subject对象中。一旦用户通过认证，就可以进行授权操作。授权是基于用户的身份和角色进行的，用于确定用户是否有权进行特定的操作或访问特定的资源。Shiro提供了基于角色的访问控制（Role-Based Access Control）和基于权限的访问控制（Permission-Based Access Control）两种授权方式。授权的核心是Realm。Realm是用于获取安全数据的组件\n\n1. 用户发起访问请求。\n2. Shiro的Subject对象获取当前用户的身份信息，并创建相应的Principal对象。\n3. Subject将Principal对象传递给SecurityManager进行授权操作。\n4. SecurityManager委托Realm获取用户的角色和权限信息。\n5. Realm根据Principal对象从数据源（如数据库）中获取用户的角色和权限信息。\n6. Realm将获取的角色和权限信息返回给SecurityManager。\n7. SecurityManager根据获取的角色和权限信息进行授权判断，确定用户是否有权访问资源。\n8. 根据授权结果，SecurityManager返回授权成功或失败的结果给Subject对象。\n9. Subject根据授权结果执行相应的操作，允许或拒绝用户访问受限资源。\n\n\n## 4.2、授权方式\n### 4.2.1、基于角色的访问控制\n\n```java\nif(subject.hasRole(\"admin\")){\n   //操作什么资源\n}\n```\n\n### 4.2.2、基于资源的访问控制\n```java\nif(subject.isPermission(\"user:update:01\")){ //资源实例\n  //对资源01用户具有修改的权限\n}\nif(subject.isPermission(\"user:update:*\")){  //资源类型\n  //对 所有的资源 用户具有更新的权限\n}\n```\n\n>权限字符串的规则是：资源标识符：操作：资源实例标识符，意思是对哪个资源的哪个实例具有什么操作，“:”是资源/操作/实例的分割符，权限字符串也可以使用*通配符\n>用户创建权限：user:create，或user:create:*\n 用户修改实例001的权限：user:update:001\n 用户实例001的所有权限：user:*：001\n\n\n## 4.3、授权实现\n\n### 4.3.1、定义Reaml\n\n```java\n/**\n * 使用自定义realm\n * 实现授权操作\n */\npublic class CustomerMd5Realm extends AuthorizingRealm {\n\n    //授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n\n        String primaryPrincipal = (String)principals.getPrimaryPrincipal();\n        System.out.println(\"身份信息: \"+primaryPrincipal); //用户名\n\n        //根据身份信息 用户名 获取当前用户的角色信息，以及权限信息\n        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();\n        //假设 admin,user 是从数据库查到的 角色信息\n        simpleAuthorizationInfo.addRole(\"admin\");\n        simpleAuthorizationInfo.addRole(\"user\");\n        //假设 ... 是从数据库查到的 权限信息赋值给权限对象\n        simpleAuthorizationInfo.addStringPermission(\"user:*:01\");\n        simpleAuthorizationInfo.addStringPermission(\"prodect:*\");//第三个参数为*省略\n\n        return simpleAuthorizationInfo;\n    }\n\n    //认证\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n    }\n}\n```\n\n### 4.3.2、授权\n\n```java\npublic class TestCustomerMd5RealmAuthenicator {\n\n    public static void main(String[] args) {\n        //授权\n        if (subject.isAuthenticated()){\n\n            //基于角色权限控制\n            System.out.println(subject.hasRole(\"admin\"));\n            //基于多角色的权限控制\n            System.out.println(subject.hasAllRoles(Arrays.asList(\"admin\", \"user\")));//true\n            System.out.println(subject.hasAllRoles(Arrays.asList(\"admin\", \"manager\")));//false\n            //是否具有其中一个角色\n            boolean[] booleans = subject.hasRoles(Arrays.asList(\"admin\", \"user\", \"manager\"));\n            for (boolean aBoolean : booleans) {\n                System.out.println(aBoolean);\n            }\n\n            System.out.println(\"====这是一个分隔符====\");\n\n            //基于权限字符串的访问控制  资源标识符：操作：资源类型\n            //用户具有的权限 user:*:01  prodect:*\n            System.out.println(\"权限:\"+subject.isPermitted(\"user:update:01\"));\n            System.out.println(\"权限:\"+subject.isPermitted(\"prodect:update:02\"));\n\n            //分别具有哪些权限\n            boolean[] permitted = subject.isPermitted(\"user:*:01\", \"user:update:02\");\n            for (boolean b : permitted) {\n                System.out.println(b);\n            }\n\n            //同时具有哪些权限\n            boolean permittedAll = subject.isPermittedAll(\"prodect:*:01\", \"prodect:update:03\");\n            System.out.println(permittedAll);\n        }\n    }\n}\n```\n\n# 5、会话管理（cacheManager）\n\n![shiro会话管理](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309141528819.png)\n\n## 5.1、shiro会话管理实现(EhCache)\n\n### 5.1.1、引入依赖\n\n```xml\n<!--引入shiro和ehcache-->\n<dependency>\n  <groupId>org.apache.shiro</groupId>\n  <artifactId>shiro-ehcache</artifactId>\n  <version>1.5.3</version>\n</dependency>\n```\n\n### 5.1.2、开启缓存\n\n```java\n//3.创建自定义realm\n@Bean\npublic Realm getRealm(){\n    CustomerRealm customerRealm = new CustomerRealm();\n    //修改凭证校验匹配器\n    HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();\n    //设置加密算法为md5\n    credentialsMatcher.setHashAlgorithmName(\"MD5\");\n    //设置散列次数\n    credentialsMatcher.setHashIterations(1024);\n    customerRealm.setCredentialsMatcher(credentialsMatcher);\n    \n    //开启缓存管理器\n    customerRealm.setCachingEnabled(true);\n    customerRealm.setAuthorizationCachingEnabled(true);\n    customerRealm.setAuthorizationCachingEnabled(true);\n    customerRealm.setCacheManager(new EhCacheManager());\n    return customerRealm;\n}\n```\n\n# 6、springboot整合shiro\n## 6.1、引入依赖\n\n```xml\n        <!--增加Shiro的配置-->\n        <dependency>\n            <groupId>org.apache.shiro</groupId>\n            <artifactId>shiro-spring-boot-web-starter</artifactId>\n            <version>1.4.0</version>\n        </dependency>\n        <!--Thymeleaf模板引擎-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <!--在Thymeleaf中使用shiro标签-->\n        <dependency>\n            <groupId>com.github.theborakompanioni</groupId>\n            <artifactId>thymeleaf-extras-shiro</artifactId>\n            <version>2.0.0</version>\n        </dependency>\n\n```\n\n## 6.2、配置文件\n\n```properties\n#开启Shiro配置，默认为true\nshiro.enabled=true\n#开启ShiroWeb配置，默认为true\nshiro.web.enabled=true\n#登录地址\nshiro.loginUrl=/login\n#登录成功地址\nshiro.successUrl=/index\n#未获授权默认跳转地址\nshiro.unauthorizedUrl=/unauthorized\n#允许通过URL参数实现会话跟踪，如果网站支持Cookie，可以关闭这个选项。默认为true\nshiro.sessionManager.sessionIdUrlRewritingEnabled=true\n#是否允许通过Cookie实现会话跟踪，默认为true\nshiro.sessionManager.sessionIdCookieEnabled=true\n\n```\n\n## 6.3、配置类\n\n```java\n@Configuration\npublic class ShiroConfig {\n\n    /**\n     * 自定义Realm\n     * 直接配置了两个用户\n     * nihiu=123\n     * admin=123\n     * 角色分别对应user和admin两个角色\n     * @return\n     */\n    @Bean\n    public Realm realm(){\n        TextConfigurationRealm realm = new TextConfigurationRealm();\n        realm.setUserDefinitions(\"nihui=123,user\n admin=123,admin\");\n        realm.setRoleDefinitions(\"admin=read,write\n user=read\");\n        return realm;\n    }\n\n    /**\n     * ShiroFilterChainDefinition\n     * @return\n     */\n    @Bean\n    public ShiroFilterChainDefinition shiroFilterChainDefinition(){\n        DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();\n        chainDefinition.addPathDefinition(\"/login\",\"anon\");\n        chainDefinition.addPathDefinition(\"/doLogin\",\"anon\");\n        chainDefinition.addPathDefinition(\"logout\",\"logout\");\n        chainDefinition.addPathDefinition(\"/**\",\"authc\");\n        return chainDefinition;\n    }\n\n    /**\n     * 定义一个在Thymeleaf中支持Shiro标签。\n     * @return\n     */\n    @Bean\n    public ShiroDialect shiroDialect(){\n        return new ShiroDialect();\n    }\n}\n```\n\n## 6.4、登录接口控制类\n\n```java\n@Controller\npublic class UserController {\n    @PostMapping(\"/doLogin\")\n    public String doLogin(String username, String password, Model model){\n        //构造一个UsernamePasswordToken实例获取\n        UsernamePasswordToken token = new UsernamePasswordToken(username,password);\n        //获取Subject对象访问login方法当有异常的时候抛出异常\n        Subject subject = SecurityUtils.getSubject();\n        try{\n            subject.login(token);\n        }catch (AuthenticationException e){\n            model.addAttribute(\"error\",\"用户名密码输入错误\");\n            return \"login\";\n        }\n        return \"redirect:/index\";\n    }\n    @RequiresRoles(\"admin\")\n    @GetMapping(\"/admin\")\n    public String admin(){\n        return \"admin\";\n    }\n\n    @RequiresRoles(value = {\"admin\",\"user\"},logical = Logical.OR)\n    @GetMapping(\"/user\")\n    public String user(){\n        return \"user\";\n    }\n}\n```\n\n\n## 6.5、编写页面代码\n\n在对应的目录下面建立五个页面分别表示用户登录页面、首页、用户页面、管理员页面、认证错误页面","source":"_posts/shiro.md","raw":"---\ntitle: shiro\ndate: 2023/09/13\nupdated: 2023/09/13\ncategories:\n  - coding\ntags:\n  - shiro\n  - 编程基础\nabbrlink: 15277\n---\n# 1、shiro基本概念\n\nShiro是Apache组织下的一个开源的安全框架，常常用来做：安全认证、权限管理、会话管理、加密\n\n## 1.1、安全认证\n\n可用于验证用户的身份凭证，如用户名和密码。通过配置 Shiro 的 Realm（领域）来自定义身份验证的逻辑，通过 Subject 对象进行身份验证，可以获取用户的身份信息和执行相关操作\n\n## 1.2、权限管理\n\n可以通过配置 Shiro 的 Realm 来定义用户的角色和权限信息，或者使用注解方式进行权限控制。通过 Subject 对象进行权限检查，可以判断用户是否具有某个角色或权限，并根据结果进行相应的处理\n\n## 1.3、会话管理\n\nshiro 提供了会话管理的功能，用于跟踪用户的登录状态和管理用户的会话信息。Shiro 的会话管理可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理（redis等）\n\n## 1.4、加密\n\n对密码进行加密和解密操作，以保护用户的密码安全。Shiro 支持常用的加密算法，如MD5、SHA、AES等。你可以根据需求选择适当的加密算法进行使用\n\n# 2、shiro架构\n\n![shiro](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309131118959.jpg)\n\n## 2.1、主体（Subject）\n\nSubject即主体，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权\n\n\n## 2.2、安全管理器（Security Manager）\n\nSecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。\nSecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口\n\n## 2.3、认证器（Authenticator）\n\nAuthenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器\n\n\n## 2.4、授权器（Authorizer）\n\nAuthorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限\n\n## 2.5、领域（Realm）\nRealm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。\n\n> 注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。\n\n## 2.6、会话管理器（SessionManager）\n\n会话管理器负责管理主体的会话，跟踪用户的登录状态和管理会话数据。\n在 Shiro 中，会话管理器可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理\n\n# 3、认证\n\n在shiro中,用户需要提供principlas(身份)和credentials(证明)给shiro，从而应用能验证用户身份\n\n## 3.1、认证流程\n\n1. 提交身份凭证：用户在应用程序的登录页面或其他身份验证入口提交身份和凭证，例如用户名和密码\n2. 创建 Subject 对象：应用程序根据用户提交的身份凭证创建一个 Subject 对象，代表当前与应用程序交互的用户\n3. 提交身份凭证给认证器：Subject 对象将身份凭证提交给 Shiro 的认证器（Authenticator）进行验证\n4. 认证器验证身份凭证：认证器对身份凭证进行验证，通常是通过比对凭证与存储在数据源中的用户信息进行匹配。认证器可以使用一个或多个 Realm 来获取用户信息并进行验证。Realm 对获取到的用户信息与提交的身份凭证进行比对验证，判断凭证是否有效\n5. 结果处理：如果身份验证成功，认证器将成功的身份信息存储在 Subject 对象中，以便后续使用\n\n## 3.2、认证实现\n### 3.2.1、自定义Realm\n```java\n\n/**\n * 自定义Realm\n */\npublic class CustomerRealm extends AuthorizingRealm {\n    //授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        System.out.println(\"==================\");\n        return null;\n    }\n\n    //认证\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        //在token中获取 用户名\n        String principal = (String) token.getPrincipal();\n        System.out.println(principal);\n\n        //实际开发中应当 根据身份信息使用jdbc mybatis查询相关数据库\n        //在这里只做简单的演示\n        //假设username,password是从数据库获得的信息\n        String username=\"zhangsan\";\n        String password=\"123456\";\n        if(username.equals(principal)){\n            //参数1:返回数据库中正确的用户名\n            //参数2:返回数据库中正确密码\n            //参数3:提供当前realm的名字 this.getName();\n            SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(principal,password,this.getName());\n            return simpleAuthenticationInfo;\n        }\n        return null;\n    }\n}\n```\n\n### 3.2.2、用定义的Realm进行认证\n```java\n/**\n * 测试自定义的Realm\n */\npublic class TestAuthenticatorCusttomerRealm {\n\n    public static void main(String[] args) {\n        //1.创建安全管理对象 securityManager\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n\n        //2.给安全管理器设置realm（设置为自定义realm获取认证数据）\n        defaultSecurityManager.setRealm(new CustomerRealm());\n        //IniRealm realm = new IniRealm(\"classpath:shiro.ini\");\n\n        //3.给安装工具类中设置默认安全管理器\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n\n        //4.获取主体对象subject\n        Subject subject = SecurityUtils.getSubject();\n\n        //5.创建token令牌\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zhangsan\", \"123\");\n        try {\n            subject.login(token);//用户登录\n            System.out.println(\"登录成功~~\");\n        } catch (UnknownAccountException e) {\n            e.printStackTrace();\n            System.out.println(\"用户名错误!!\");\n        }catch (IncorrectCredentialsException e){\n            e.printStackTrace();\n            System.out.println(\"密码错误!!!\");\n        }\n    }\n}\n```\n\n\n# 4、授权\n## 4.1、授权流程\n认证成功后，Shiro会将用户的身份信息保存在Subject对象中。一旦用户通过认证，就可以进行授权操作。授权是基于用户的身份和角色进行的，用于确定用户是否有权进行特定的操作或访问特定的资源。Shiro提供了基于角色的访问控制（Role-Based Access Control）和基于权限的访问控制（Permission-Based Access Control）两种授权方式。授权的核心是Realm。Realm是用于获取安全数据的组件\n\n1. 用户发起访问请求。\n2. Shiro的Subject对象获取当前用户的身份信息，并创建相应的Principal对象。\n3. Subject将Principal对象传递给SecurityManager进行授权操作。\n4. SecurityManager委托Realm获取用户的角色和权限信息。\n5. Realm根据Principal对象从数据源（如数据库）中获取用户的角色和权限信息。\n6. Realm将获取的角色和权限信息返回给SecurityManager。\n7. SecurityManager根据获取的角色和权限信息进行授权判断，确定用户是否有权访问资源。\n8. 根据授权结果，SecurityManager返回授权成功或失败的结果给Subject对象。\n9. Subject根据授权结果执行相应的操作，允许或拒绝用户访问受限资源。\n\n\n## 4.2、授权方式\n### 4.2.1、基于角色的访问控制\n\n```java\nif(subject.hasRole(\"admin\")){\n   //操作什么资源\n}\n```\n\n### 4.2.2、基于资源的访问控制\n```java\nif(subject.isPermission(\"user:update:01\")){ //资源实例\n  //对资源01用户具有修改的权限\n}\nif(subject.isPermission(\"user:update:*\")){  //资源类型\n  //对 所有的资源 用户具有更新的权限\n}\n```\n\n>权限字符串的规则是：资源标识符：操作：资源实例标识符，意思是对哪个资源的哪个实例具有什么操作，“:”是资源/操作/实例的分割符，权限字符串也可以使用*通配符\n>用户创建权限：user:create，或user:create:*\n 用户修改实例001的权限：user:update:001\n 用户实例001的所有权限：user:*：001\n\n\n## 4.3、授权实现\n\n### 4.3.1、定义Reaml\n\n```java\n/**\n * 使用自定义realm\n * 实现授权操作\n */\npublic class CustomerMd5Realm extends AuthorizingRealm {\n\n    //授权\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n\n        String primaryPrincipal = (String)principals.getPrimaryPrincipal();\n        System.out.println(\"身份信息: \"+primaryPrincipal); //用户名\n\n        //根据身份信息 用户名 获取当前用户的角色信息，以及权限信息\n        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();\n        //假设 admin,user 是从数据库查到的 角色信息\n        simpleAuthorizationInfo.addRole(\"admin\");\n        simpleAuthorizationInfo.addRole(\"user\");\n        //假设 ... 是从数据库查到的 权限信息赋值给权限对象\n        simpleAuthorizationInfo.addStringPermission(\"user:*:01\");\n        simpleAuthorizationInfo.addStringPermission(\"prodect:*\");//第三个参数为*省略\n\n        return simpleAuthorizationInfo;\n    }\n\n    //认证\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n    }\n}\n```\n\n### 4.3.2、授权\n\n```java\npublic class TestCustomerMd5RealmAuthenicator {\n\n    public static void main(String[] args) {\n        //授权\n        if (subject.isAuthenticated()){\n\n            //基于角色权限控制\n            System.out.println(subject.hasRole(\"admin\"));\n            //基于多角色的权限控制\n            System.out.println(subject.hasAllRoles(Arrays.asList(\"admin\", \"user\")));//true\n            System.out.println(subject.hasAllRoles(Arrays.asList(\"admin\", \"manager\")));//false\n            //是否具有其中一个角色\n            boolean[] booleans = subject.hasRoles(Arrays.asList(\"admin\", \"user\", \"manager\"));\n            for (boolean aBoolean : booleans) {\n                System.out.println(aBoolean);\n            }\n\n            System.out.println(\"====这是一个分隔符====\");\n\n            //基于权限字符串的访问控制  资源标识符：操作：资源类型\n            //用户具有的权限 user:*:01  prodect:*\n            System.out.println(\"权限:\"+subject.isPermitted(\"user:update:01\"));\n            System.out.println(\"权限:\"+subject.isPermitted(\"prodect:update:02\"));\n\n            //分别具有哪些权限\n            boolean[] permitted = subject.isPermitted(\"user:*:01\", \"user:update:02\");\n            for (boolean b : permitted) {\n                System.out.println(b);\n            }\n\n            //同时具有哪些权限\n            boolean permittedAll = subject.isPermittedAll(\"prodect:*:01\", \"prodect:update:03\");\n            System.out.println(permittedAll);\n        }\n    }\n}\n```\n\n# 5、会话管理（cacheManager）\n\n![shiro会话管理](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309141528819.png)\n\n## 5.1、shiro会话管理实现(EhCache)\n\n### 5.1.1、引入依赖\n\n```xml\n<!--引入shiro和ehcache-->\n<dependency>\n  <groupId>org.apache.shiro</groupId>\n  <artifactId>shiro-ehcache</artifactId>\n  <version>1.5.3</version>\n</dependency>\n```\n\n### 5.1.2、开启缓存\n\n```java\n//3.创建自定义realm\n@Bean\npublic Realm getRealm(){\n    CustomerRealm customerRealm = new CustomerRealm();\n    //修改凭证校验匹配器\n    HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();\n    //设置加密算法为md5\n    credentialsMatcher.setHashAlgorithmName(\"MD5\");\n    //设置散列次数\n    credentialsMatcher.setHashIterations(1024);\n    customerRealm.setCredentialsMatcher(credentialsMatcher);\n    \n    //开启缓存管理器\n    customerRealm.setCachingEnabled(true);\n    customerRealm.setAuthorizationCachingEnabled(true);\n    customerRealm.setAuthorizationCachingEnabled(true);\n    customerRealm.setCacheManager(new EhCacheManager());\n    return customerRealm;\n}\n```\n\n# 6、springboot整合shiro\n## 6.1、引入依赖\n\n```xml\n        <!--增加Shiro的配置-->\n        <dependency>\n            <groupId>org.apache.shiro</groupId>\n            <artifactId>shiro-spring-boot-web-starter</artifactId>\n            <version>1.4.0</version>\n        </dependency>\n        <!--Thymeleaf模板引擎-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-thymeleaf</artifactId>\n        </dependency>\n        <!--在Thymeleaf中使用shiro标签-->\n        <dependency>\n            <groupId>com.github.theborakompanioni</groupId>\n            <artifactId>thymeleaf-extras-shiro</artifactId>\n            <version>2.0.0</version>\n        </dependency>\n\n```\n\n## 6.2、配置文件\n\n```properties\n#开启Shiro配置，默认为true\nshiro.enabled=true\n#开启ShiroWeb配置，默认为true\nshiro.web.enabled=true\n#登录地址\nshiro.loginUrl=/login\n#登录成功地址\nshiro.successUrl=/index\n#未获授权默认跳转地址\nshiro.unauthorizedUrl=/unauthorized\n#允许通过URL参数实现会话跟踪，如果网站支持Cookie，可以关闭这个选项。默认为true\nshiro.sessionManager.sessionIdUrlRewritingEnabled=true\n#是否允许通过Cookie实现会话跟踪，默认为true\nshiro.sessionManager.sessionIdCookieEnabled=true\n\n```\n\n## 6.3、配置类\n\n```java\n@Configuration\npublic class ShiroConfig {\n\n    /**\n     * 自定义Realm\n     * 直接配置了两个用户\n     * nihiu=123\n     * admin=123\n     * 角色分别对应user和admin两个角色\n     * @return\n     */\n    @Bean\n    public Realm realm(){\n        TextConfigurationRealm realm = new TextConfigurationRealm();\n        realm.setUserDefinitions(\"nihui=123,user\n admin=123,admin\");\n        realm.setRoleDefinitions(\"admin=read,write\n user=read\");\n        return realm;\n    }\n\n    /**\n     * ShiroFilterChainDefinition\n     * @return\n     */\n    @Bean\n    public ShiroFilterChainDefinition shiroFilterChainDefinition(){\n        DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();\n        chainDefinition.addPathDefinition(\"/login\",\"anon\");\n        chainDefinition.addPathDefinition(\"/doLogin\",\"anon\");\n        chainDefinition.addPathDefinition(\"logout\",\"logout\");\n        chainDefinition.addPathDefinition(\"/**\",\"authc\");\n        return chainDefinition;\n    }\n\n    /**\n     * 定义一个在Thymeleaf中支持Shiro标签。\n     * @return\n     */\n    @Bean\n    public ShiroDialect shiroDialect(){\n        return new ShiroDialect();\n    }\n}\n```\n\n## 6.4、登录接口控制类\n\n```java\n@Controller\npublic class UserController {\n    @PostMapping(\"/doLogin\")\n    public String doLogin(String username, String password, Model model){\n        //构造一个UsernamePasswordToken实例获取\n        UsernamePasswordToken token = new UsernamePasswordToken(username,password);\n        //获取Subject对象访问login方法当有异常的时候抛出异常\n        Subject subject = SecurityUtils.getSubject();\n        try{\n            subject.login(token);\n        }catch (AuthenticationException e){\n            model.addAttribute(\"error\",\"用户名密码输入错误\");\n            return \"login\";\n        }\n        return \"redirect:/index\";\n    }\n    @RequiresRoles(\"admin\")\n    @GetMapping(\"/admin\")\n    public String admin(){\n        return \"admin\";\n    }\n\n    @RequiresRoles(value = {\"admin\",\"user\"},logical = Logical.OR)\n    @GetMapping(\"/user\")\n    public String user(){\n        return \"user\";\n    }\n}\n```\n\n\n## 6.5、编写页面代码\n\n在对应的目录下面建立五个页面分别表示用户登录页面、首页、用户页面、管理员页面、认证错误页面","slug":"shiro","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9p000o00ujegltgsy9","content":"<h1 id=\"1、shiro基本概念\"><a href=\"#1、shiro基本概念\" class=\"headerlink\" title=\"1、shiro基本概念\"></a>1、shiro基本概念</h1><p>Shiro是Apache组织下的一个开源的安全框架，常常用来做：安全认证、权限管理、会话管理、加密</p>\n<h2 id=\"1-1、安全认证\"><a href=\"#1-1、安全认证\" class=\"headerlink\" title=\"1.1、安全认证\"></a>1.1、安全认证</h2><p>可用于验证用户的身份凭证，如用户名和密码。通过配置 Shiro 的 Realm（领域）来自定义身份验证的逻辑，通过 Subject 对象进行身份验证，可以获取用户的身份信息和执行相关操作</p>\n<h2 id=\"1-2、权限管理\"><a href=\"#1-2、权限管理\" class=\"headerlink\" title=\"1.2、权限管理\"></a>1.2、权限管理</h2><p>可以通过配置 Shiro 的 Realm 来定义用户的角色和权限信息，或者使用注解方式进行权限控制。通过 Subject 对象进行权限检查，可以判断用户是否具有某个角色或权限，并根据结果进行相应的处理</p>\n<h2 id=\"1-3、会话管理\"><a href=\"#1-3、会话管理\" class=\"headerlink\" title=\"1.3、会话管理\"></a>1.3、会话管理</h2><p>shiro 提供了会话管理的功能，用于跟踪用户的登录状态和管理用户的会话信息。Shiro 的会话管理可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理（redis等）</p>\n<h2 id=\"1-4、加密\"><a href=\"#1-4、加密\" class=\"headerlink\" title=\"1.4、加密\"></a>1.4、加密</h2><p>对密码进行加密和解密操作，以保护用户的密码安全。Shiro 支持常用的加密算法，如MD5、SHA、AES等。你可以根据需求选择适当的加密算法进行使用</p>\n<h1 id=\"2、shiro架构\"><a href=\"#2、shiro架构\" class=\"headerlink\" title=\"2、shiro架构\"></a>2、shiro架构</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309131118959.jpg\" alt=\"shiro\"></p>\n<h2 id=\"2-1、主体（Subject）\"><a href=\"#2-1、主体（Subject）\" class=\"headerlink\" title=\"2.1、主体（Subject）\"></a>2.1、主体（Subject）</h2><p>Subject即主体，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权</p>\n<h2 id=\"2-2、安全管理器（Security-Manager）\"><a href=\"#2-2、安全管理器（Security-Manager）\" class=\"headerlink\" title=\"2.2、安全管理器（Security Manager）\"></a>2.2、安全管理器（Security Manager）</h2><p>SecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。<br>SecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口</p>\n<h2 id=\"2-3、认证器（Authenticator）\"><a href=\"#2-3、认证器（Authenticator）\" class=\"headerlink\" title=\"2.3、认证器（Authenticator）\"></a>2.3、认证器（Authenticator）</h2><p>Authenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器</p>\n<h2 id=\"2-4、授权器（Authorizer）\"><a href=\"#2-4、授权器（Authorizer）\" class=\"headerlink\" title=\"2.4、授权器（Authorizer）\"></a>2.4、授权器（Authorizer）</h2><p>Authorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限</p>\n<h2 id=\"2-5、领域（Realm）\"><a href=\"#2-5、领域（Realm）\" class=\"headerlink\" title=\"2.5、领域（Realm）\"></a>2.5、领域（Realm）</h2><p>Realm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。</p>\n<blockquote>\n<p>注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。</p>\n</blockquote>\n<h2 id=\"2-6、会话管理器（SessionManager）\"><a href=\"#2-6、会话管理器（SessionManager）\" class=\"headerlink\" title=\"2.6、会话管理器（SessionManager）\"></a>2.6、会话管理器（SessionManager）</h2><p>会话管理器负责管理主体的会话，跟踪用户的登录状态和管理会话数据。<br>在 Shiro 中，会话管理器可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理</p>\n<h1 id=\"3、认证\"><a href=\"#3、认证\" class=\"headerlink\" title=\"3、认证\"></a>3、认证</h1><p>在shiro中,用户需要提供principlas(身份)和credentials(证明)给shiro，从而应用能验证用户身份</p>\n<h2 id=\"3-1、认证流程\"><a href=\"#3-1、认证流程\" class=\"headerlink\" title=\"3.1、认证流程\"></a>3.1、认证流程</h2><ol>\n<li>提交身份凭证：用户在应用程序的登录页面或其他身份验证入口提交身份和凭证，例如用户名和密码</li>\n<li>创建 Subject 对象：应用程序根据用户提交的身份凭证创建一个 Subject 对象，代表当前与应用程序交互的用户</li>\n<li>提交身份凭证给认证器：Subject 对象将身份凭证提交给 Shiro 的认证器（Authenticator）进行验证</li>\n<li>认证器验证身份凭证：认证器对身份凭证进行验证，通常是通过比对凭证与存储在数据源中的用户信息进行匹配。认证器可以使用一个或多个 Realm 来获取用户信息并进行验证。Realm 对获取到的用户信息与提交的身份凭证进行比对验证，判断凭证是否有效</li>\n<li>结果处理：如果身份验证成功，认证器将成功的身份信息存储在 Subject 对象中，以便后续使用</li>\n</ol>\n<h2 id=\"3-2、认证实现\"><a href=\"#3-2、认证实现\" class=\"headerlink\" title=\"3.2、认证实现\"></a>3.2、认证实现</h2><h3 id=\"3-2-1、自定义Realm\"><a href=\"#3-2-1、自定义Realm\" class=\"headerlink\" title=\"3.2.1、自定义Realm\"></a>3.2.1、自定义Realm</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义Realm</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomerRealm</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AuthorizingRealm</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//授权</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title function_\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;==================&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//认证</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title function_\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//在token中获取 用户名</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">principal</span> <span class=\"operator\">=</span> (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(principal);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//实际开发中应当 根据身份信息使用jdbc mybatis查询相关数据库</span></span><br><span class=\"line\">        <span class=\"comment\">//在这里只做简单的演示</span></span><br><span class=\"line\">        <span class=\"comment\">//假设username,password是从数据库获得的信息</span></span><br><span class=\"line\">        String username=<span class=\"string\">&quot;zhangsan&quot;</span>;</span><br><span class=\"line\">        String password=<span class=\"string\">&quot;123456&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(username.equals(principal))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//参数1:返回数据库中正确的用户名</span></span><br><span class=\"line\">            <span class=\"comment\">//参数2:返回数据库中正确密码</span></span><br><span class=\"line\">            <span class=\"comment\">//参数3:提供当前realm的名字 this.getName();</span></span><br><span class=\"line\">            <span class=\"type\">SimpleAuthenticationInfo</span> <span class=\"variable\">simpleAuthenticationInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleAuthenticationInfo</span>(principal,password,<span class=\"built_in\">this</span>.getName());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> simpleAuthenticationInfo;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2、用定义的Realm进行认证\"><a href=\"#3-2-2、用定义的Realm进行认证\" class=\"headerlink\" title=\"3.2.2、用定义的Realm进行认证\"></a>3.2.2、用定义的Realm进行认证</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试自定义的Realm</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestAuthenticatorCusttomerRealm</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建安全管理对象 securityManager</span></span><br><span class=\"line\">        <span class=\"type\">DefaultSecurityManager</span> <span class=\"variable\">defaultSecurityManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultSecurityManager</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.给安全管理器设置realm（设置为自定义realm获取认证数据）</span></span><br><span class=\"line\">        defaultSecurityManager.setRealm(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomerRealm</span>());</span><br><span class=\"line\">        <span class=\"comment\">//IniRealm realm = new IniRealm(&quot;classpath:shiro.ini&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//3.给安装工具类中设置默认安全管理器</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//4.获取主体对象subject</span></span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//5.创建token令牌</span></span><br><span class=\"line\">        <span class=\"type\">UsernamePasswordToken</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UsernamePasswordToken</span>(<span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            subject.login(token);<span class=\"comment\">//用户登录</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;登录成功~~&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (UnknownAccountException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;用户名错误!!&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;密码错误!!!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"4、授权\"><a href=\"#4、授权\" class=\"headerlink\" title=\"4、授权\"></a>4、授权</h1><h2 id=\"4-1、授权流程\"><a href=\"#4-1、授权流程\" class=\"headerlink\" title=\"4.1、授权流程\"></a>4.1、授权流程</h2><p>认证成功后，Shiro会将用户的身份信息保存在Subject对象中。一旦用户通过认证，就可以进行授权操作。授权是基于用户的身份和角色进行的，用于确定用户是否有权进行特定的操作或访问特定的资源。Shiro提供了基于角色的访问控制（Role-Based Access Control）和基于权限的访问控制（Permission-Based Access Control）两种授权方式。授权的核心是Realm。Realm是用于获取安全数据的组件</p>\n<ol>\n<li>用户发起访问请求。</li>\n<li>Shiro的Subject对象获取当前用户的身份信息，并创建相应的Principal对象。</li>\n<li>Subject将Principal对象传递给SecurityManager进行授权操作。</li>\n<li>SecurityManager委托Realm获取用户的角色和权限信息。</li>\n<li>Realm根据Principal对象从数据源（如数据库）中获取用户的角色和权限信息。</li>\n<li>Realm将获取的角色和权限信息返回给SecurityManager。</li>\n<li>SecurityManager根据获取的角色和权限信息进行授权判断，确定用户是否有权访问资源。</li>\n<li>根据授权结果，SecurityManager返回授权成功或失败的结果给Subject对象。</li>\n<li>Subject根据授权结果执行相应的操作，允许或拒绝用户访问受限资源。</li>\n</ol>\n<h2 id=\"4-2、授权方式\"><a href=\"#4-2、授权方式\" class=\"headerlink\" title=\"4.2、授权方式\"></a>4.2、授权方式</h2><h3 id=\"4-2-1、基于角色的访问控制\"><a href=\"#4-2-1、基于角色的访问控制\" class=\"headerlink\" title=\"4.2.1、基于角色的访问控制\"></a>4.2.1、基于角色的访问控制</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(subject.hasRole(<span class=\"string\">&quot;admin&quot;</span>))&#123;</span><br><span class=\"line\">   <span class=\"comment\">//操作什么资源</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-2、基于资源的访问控制\"><a href=\"#4-2-2、基于资源的访问控制\" class=\"headerlink\" title=\"4.2.2、基于资源的访问控制\"></a>4.2.2、基于资源的访问控制</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(subject.isPermission(<span class=\"string\">&quot;user:update:01&quot;</span>))&#123; <span class=\"comment\">//资源实例</span></span><br><span class=\"line\">  <span class=\"comment\">//对资源01用户具有修改的权限</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(subject.isPermission(<span class=\"string\">&quot;user:update:*&quot;</span>))&#123;  <span class=\"comment\">//资源类型</span></span><br><span class=\"line\">  <span class=\"comment\">//对 所有的资源 用户具有更新的权限</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>权限字符串的规则是：资源标识符：操作：资源实例标识符，意思是对哪个资源的哪个实例具有什么操作，“:”是资源&#x2F;操作&#x2F;实例的分割符，权限字符串也可以使用<em>通配符<br>用户创建权限：user:create，或user:create:</em><br> 用户修改实例001的权限：user:update:001<br> 用户实例001的所有权限：user:*：001</p>\n</blockquote>\n<h2 id=\"4-3、授权实现\"><a href=\"#4-3、授权实现\" class=\"headerlink\" title=\"4.3、授权实现\"></a>4.3、授权实现</h2><h3 id=\"4-3-1、定义Reaml\"><a href=\"#4-3-1、定义Reaml\" class=\"headerlink\" title=\"4.3.1、定义Reaml\"></a>4.3.1、定义Reaml</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用自定义realm</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现授权操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomerMd5Realm</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AuthorizingRealm</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//授权</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title function_\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">primaryPrincipal</span> <span class=\"operator\">=</span> (String)principals.getPrimaryPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;身份信息: &quot;</span>+primaryPrincipal); <span class=\"comment\">//用户名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//根据身份信息 用户名 获取当前用户的角色信息，以及权限信息</span></span><br><span class=\"line\">        <span class=\"type\">SimpleAuthorizationInfo</span> <span class=\"variable\">simpleAuthorizationInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleAuthorizationInfo</span>();</span><br><span class=\"line\">        <span class=\"comment\">//假设 admin,user 是从数据库查到的 角色信息</span></span><br><span class=\"line\">        simpleAuthorizationInfo.addRole(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        simpleAuthorizationInfo.addRole(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//假设 ... 是从数据库查到的 权限信息赋值给权限对象</span></span><br><span class=\"line\">        simpleAuthorizationInfo.addStringPermission(<span class=\"string\">&quot;user:*:01&quot;</span>);</span><br><span class=\"line\">        simpleAuthorizationInfo.addStringPermission(<span class=\"string\">&quot;prodect:*&quot;</span>);<span class=\"comment\">//第三个参数为*省略</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> simpleAuthorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//认证</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title function_\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-2、授权\"><a href=\"#4-3-2、授权\" class=\"headerlink\" title=\"4.3.2、授权\"></a>4.3.2、授权</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCustomerMd5RealmAuthenicator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//授权</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subject.isAuthenticated())&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//基于角色权限控制</span></span><br><span class=\"line\">            System.out.println(subject.hasRole(<span class=\"string\">&quot;admin&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//基于多角色的权限控制</span></span><br><span class=\"line\">            System.out.println(subject.hasAllRoles(Arrays.asList(<span class=\"string\">&quot;admin&quot;</span>, <span class=\"string\">&quot;user&quot;</span>)));<span class=\"comment\">//true</span></span><br><span class=\"line\">            System.out.println(subject.hasAllRoles(Arrays.asList(<span class=\"string\">&quot;admin&quot;</span>, <span class=\"string\">&quot;manager&quot;</span>)));<span class=\"comment\">//false</span></span><br><span class=\"line\">            <span class=\"comment\">//是否具有其中一个角色</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span>[] booleans = subject.hasRoles(Arrays.asList(<span class=\"string\">&quot;admin&quot;</span>, <span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;manager&quot;</span>));</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">boolean</span> aBoolean : booleans) &#123;</span><br><span class=\"line\">                System.out.println(aBoolean);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;====这是一个分隔符====&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//基于权限字符串的访问控制  资源标识符：操作：资源类型</span></span><br><span class=\"line\">            <span class=\"comment\">//用户具有的权限 user:*:01  prodect:*</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;权限:&quot;</span>+subject.isPermitted(<span class=\"string\">&quot;user:update:01&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;权限:&quot;</span>+subject.isPermitted(<span class=\"string\">&quot;prodect:update:02&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//分别具有哪些权限</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span>[] permitted = subject.isPermitted(<span class=\"string\">&quot;user:*:01&quot;</span>, <span class=\"string\">&quot;user:update:02&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">boolean</span> b : permitted) &#123;</span><br><span class=\"line\">                System.out.println(b);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//同时具有哪些权限</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">permittedAll</span> <span class=\"operator\">=</span> subject.isPermittedAll(<span class=\"string\">&quot;prodect:*:01&quot;</span>, <span class=\"string\">&quot;prodect:update:03&quot;</span>);</span><br><span class=\"line\">            System.out.println(permittedAll);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5、会话管理（cacheManager）\"><a href=\"#5、会话管理（cacheManager）\" class=\"headerlink\" title=\"5、会话管理（cacheManager）\"></a>5、会话管理（cacheManager）</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309141528819.png\" alt=\"shiro会话管理\"></p>\n<h2 id=\"5-1、shiro会话管理实现-EhCache\"><a href=\"#5-1、shiro会话管理实现-EhCache\" class=\"headerlink\" title=\"5.1、shiro会话管理实现(EhCache)\"></a>5.1、shiro会话管理实现(EhCache)</h2><h3 id=\"5-1-1、引入依赖\"><a href=\"#5-1-1、引入依赖\" class=\"headerlink\" title=\"5.1.1、引入依赖\"></a>5.1.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--引入shiro和ehcache--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-1-2、开启缓存\"><a href=\"#5-1-2、开启缓存\" class=\"headerlink\" title=\"5.1.2、开启缓存\"></a>5.1.2、开启缓存</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3.创建自定义realm</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Realm <span class=\"title function_\">getRealm</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">CustomerRealm</span> <span class=\"variable\">customerRealm</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomerRealm</span>();</span><br><span class=\"line\">    <span class=\"comment\">//修改凭证校验匹配器</span></span><br><span class=\"line\">    <span class=\"type\">HashedCredentialsMatcher</span> <span class=\"variable\">credentialsMatcher</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashedCredentialsMatcher</span>();</span><br><span class=\"line\">    <span class=\"comment\">//设置加密算法为md5</span></span><br><span class=\"line\">    credentialsMatcher.setHashAlgorithmName(<span class=\"string\">&quot;MD5&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置散列次数</span></span><br><span class=\"line\">    credentialsMatcher.setHashIterations(<span class=\"number\">1024</span>);</span><br><span class=\"line\">    customerRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//开启缓存管理器</span></span><br><span class=\"line\">    customerRealm.setCachingEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    customerRealm.setAuthorizationCachingEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    customerRealm.setAuthorizationCachingEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    customerRealm.setCacheManager(<span class=\"keyword\">new</span> <span class=\"title class_\">EhCacheManager</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customerRealm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6、springboot整合shiro\"><a href=\"#6、springboot整合shiro\" class=\"headerlink\" title=\"6、springboot整合shiro\"></a>6、springboot整合shiro</h1><h2 id=\"6-1、引入依赖\"><a href=\"#6-1、引入依赖\" class=\"headerlink\" title=\"6.1、引入依赖\"></a>6.1、引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--增加Shiro的配置--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--Thymeleaf模板引擎--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--在Thymeleaf中使用shiro标签--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.theborakompanioni<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>thymeleaf-extras-shiro<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-2、配置文件\"><a href=\"#6-2、配置文件\" class=\"headerlink\" title=\"6.2、配置文件\"></a>6.2、配置文件</h2><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#开启Shiro配置，默认为true</span></span><br><span class=\"line\"><span class=\"attr\">shiro.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\">#开启ShiroWeb配置，默认为true</span></span><br><span class=\"line\"><span class=\"attr\">shiro.web.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\">#登录地址</span></span><br><span class=\"line\"><span class=\"attr\">shiro.loginUrl</span>=<span class=\"string\">/login</span></span><br><span class=\"line\"><span class=\"comment\">#登录成功地址</span></span><br><span class=\"line\"><span class=\"attr\">shiro.successUrl</span>=<span class=\"string\">/index</span></span><br><span class=\"line\"><span class=\"comment\">#未获授权默认跳转地址</span></span><br><span class=\"line\"><span class=\"attr\">shiro.unauthorizedUrl</span>=<span class=\"string\">/unauthorized</span></span><br><span class=\"line\"><span class=\"comment\">#允许通过URL参数实现会话跟踪，如果网站支持Cookie，可以关闭这个选项。默认为true</span></span><br><span class=\"line\"><span class=\"attr\">shiro.sessionManager.sessionIdUrlRewritingEnabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\">#是否允许通过Cookie实现会话跟踪，默认为true</span></span><br><span class=\"line\"><span class=\"attr\">shiro.sessionManager.sessionIdCookieEnabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-3、配置类\"><a href=\"#6-3、配置类\" class=\"headerlink\" title=\"6.3、配置类\"></a>6.3、配置类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ShiroConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 自定义Realm</span></span><br><span class=\"line\"><span class=\"comment\">     * 直接配置了两个用户</span></span><br><span class=\"line\"><span class=\"comment\">     * nihiu=123</span></span><br><span class=\"line\"><span class=\"comment\">     * admin=123</span></span><br><span class=\"line\"><span class=\"comment\">     * 角色分别对应user和admin两个角色</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Realm <span class=\"title function_\">realm</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">TextConfigurationRealm</span> <span class=\"variable\">realm</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TextConfigurationRealm</span>();</span><br><span class=\"line\">        realm.setUserDefinitions(<span class=\"string\">&quot;nihui=123,user</span></span><br><span class=\"line\"><span class=\"string\"> admin=123,admin&quot;</span>);</span><br><span class=\"line\">        realm.setRoleDefinitions(<span class=\"string\">&quot;admin=read,write</span></span><br><span class=\"line\"><span class=\"string\"> user=read&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> realm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ShiroFilterChainDefinition</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ShiroFilterChainDefinition <span class=\"title function_\">shiroFilterChainDefinition</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">DefaultShiroFilterChainDefinition</span> <span class=\"variable\">chainDefinition</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultShiroFilterChainDefinition</span>();</span><br><span class=\"line\">        chainDefinition.addPathDefinition(<span class=\"string\">&quot;/login&quot;</span>,<span class=\"string\">&quot;anon&quot;</span>);</span><br><span class=\"line\">        chainDefinition.addPathDefinition(<span class=\"string\">&quot;/doLogin&quot;</span>,<span class=\"string\">&quot;anon&quot;</span>);</span><br><span class=\"line\">        chainDefinition.addPathDefinition(<span class=\"string\">&quot;logout&quot;</span>,<span class=\"string\">&quot;logout&quot;</span>);</span><br><span class=\"line\">        chainDefinition.addPathDefinition(<span class=\"string\">&quot;/**&quot;</span>,<span class=\"string\">&quot;authc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> chainDefinition;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个在Thymeleaf中支持Shiro标签。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ShiroDialect <span class=\"title function_\">shiroDialect</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ShiroDialect</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-4、登录接口控制类\"><a href=\"#6-4、登录接口控制类\" class=\"headerlink\" title=\"6.4、登录接口控制类\"></a>6.4、登录接口控制类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@PostMapping(&quot;/doLogin&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">doLogin</span><span class=\"params\">(String username, String password, Model model)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//构造一个UsernamePasswordToken实例获取</span></span><br><span class=\"line\">        <span class=\"type\">UsernamePasswordToken</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UsernamePasswordToken</span>(username,password);</span><br><span class=\"line\">        <span class=\"comment\">//获取Subject对象访问login方法当有异常的时候抛出异常</span></span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> SecurityUtils.getSubject();</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            subject.login(token);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (AuthenticationException e)&#123;</span><br><span class=\"line\">            model.addAttribute(<span class=\"string\">&quot;error&quot;</span>,<span class=\"string\">&quot;用户名密码输入错误&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;login&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;redirect:/index&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@RequiresRoles(&quot;admin&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/admin&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">admin</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;admin&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequiresRoles(value = &#123;&quot;admin&quot;,&quot;user&quot;&#125;,logical = Logical.OR)</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/user&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">user</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;user&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"6-5、编写页面代码\"><a href=\"#6-5、编写页面代码\" class=\"headerlink\" title=\"6.5、编写页面代码\"></a>6.5、编写页面代码</h2><p>在对应的目录下面建立五个页面分别表示用户登录页面、首页、用户页面、管理员页面、认证错误页面</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、shiro基本概念\"><a href=\"#1、shiro基本概念\" class=\"headerlink\" title=\"1、shiro基本概念\"></a>1、shiro基本概念</h1><p>Shiro是Apache组织下的一个开源的安全框架，常常用来做：安全认证、权限管理、会话管理、加密</p>\n<h2 id=\"1-1、安全认证\"><a href=\"#1-1、安全认证\" class=\"headerlink\" title=\"1.1、安全认证\"></a>1.1、安全认证</h2><p>可用于验证用户的身份凭证，如用户名和密码。通过配置 Shiro 的 Realm（领域）来自定义身份验证的逻辑，通过 Subject 对象进行身份验证，可以获取用户的身份信息和执行相关操作</p>\n<h2 id=\"1-2、权限管理\"><a href=\"#1-2、权限管理\" class=\"headerlink\" title=\"1.2、权限管理\"></a>1.2、权限管理</h2><p>可以通过配置 Shiro 的 Realm 来定义用户的角色和权限信息，或者使用注解方式进行权限控制。通过 Subject 对象进行权限检查，可以判断用户是否具有某个角色或权限，并根据结果进行相应的处理</p>\n<h2 id=\"1-3、会话管理\"><a href=\"#1-3、会话管理\" class=\"headerlink\" title=\"1.3、会话管理\"></a>1.3、会话管理</h2><p>shiro 提供了会话管理的功能，用于跟踪用户的登录状态和管理用户的会话信息。Shiro 的会话管理可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理（redis等）</p>\n<h2 id=\"1-4、加密\"><a href=\"#1-4、加密\" class=\"headerlink\" title=\"1.4、加密\"></a>1.4、加密</h2><p>对密码进行加密和解密操作，以保护用户的密码安全。Shiro 支持常用的加密算法，如MD5、SHA、AES等。你可以根据需求选择适当的加密算法进行使用</p>\n<h1 id=\"2、shiro架构\"><a href=\"#2、shiro架构\" class=\"headerlink\" title=\"2、shiro架构\"></a>2、shiro架构</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309131118959.jpg\" alt=\"shiro\"></p>\n<h2 id=\"2-1、主体（Subject）\"><a href=\"#2-1、主体（Subject）\" class=\"headerlink\" title=\"2.1、主体（Subject）\"></a>2.1、主体（Subject）</h2><p>Subject即主体，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权</p>\n<h2 id=\"2-2、安全管理器（Security-Manager）\"><a href=\"#2-2、安全管理器（Security-Manager）\" class=\"headerlink\" title=\"2.2、安全管理器（Security Manager）\"></a>2.2、安全管理器（Security Manager）</h2><p>SecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。<br>SecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口</p>\n<h2 id=\"2-3、认证器（Authenticator）\"><a href=\"#2-3、认证器（Authenticator）\" class=\"headerlink\" title=\"2.3、认证器（Authenticator）\"></a>2.3、认证器（Authenticator）</h2><p>Authenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器</p>\n<h2 id=\"2-4、授权器（Authorizer）\"><a href=\"#2-4、授权器（Authorizer）\" class=\"headerlink\" title=\"2.4、授权器（Authorizer）\"></a>2.4、授权器（Authorizer）</h2><p>Authorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限</p>\n<h2 id=\"2-5、领域（Realm）\"><a href=\"#2-5、领域（Realm）\" class=\"headerlink\" title=\"2.5、领域（Realm）\"></a>2.5、领域（Realm）</h2><p>Realm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。</p>\n<blockquote>\n<p>注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。</p>\n</blockquote>\n<h2 id=\"2-6、会话管理器（SessionManager）\"><a href=\"#2-6、会话管理器（SessionManager）\" class=\"headerlink\" title=\"2.6、会话管理器（SessionManager）\"></a>2.6、会话管理器（SessionManager）</h2><p>会话管理器负责管理主体的会话，跟踪用户的登录状态和管理会话数据。<br>在 Shiro 中，会话管理器可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理</p>\n<h1 id=\"3、认证\"><a href=\"#3、认证\" class=\"headerlink\" title=\"3、认证\"></a>3、认证</h1><p>在shiro中,用户需要提供principlas(身份)和credentials(证明)给shiro，从而应用能验证用户身份</p>\n<h2 id=\"3-1、认证流程\"><a href=\"#3-1、认证流程\" class=\"headerlink\" title=\"3.1、认证流程\"></a>3.1、认证流程</h2><ol>\n<li>提交身份凭证：用户在应用程序的登录页面或其他身份验证入口提交身份和凭证，例如用户名和密码</li>\n<li>创建 Subject 对象：应用程序根据用户提交的身份凭证创建一个 Subject 对象，代表当前与应用程序交互的用户</li>\n<li>提交身份凭证给认证器：Subject 对象将身份凭证提交给 Shiro 的认证器（Authenticator）进行验证</li>\n<li>认证器验证身份凭证：认证器对身份凭证进行验证，通常是通过比对凭证与存储在数据源中的用户信息进行匹配。认证器可以使用一个或多个 Realm 来获取用户信息并进行验证。Realm 对获取到的用户信息与提交的身份凭证进行比对验证，判断凭证是否有效</li>\n<li>结果处理：如果身份验证成功，认证器将成功的身份信息存储在 Subject 对象中，以便后续使用</li>\n</ol>\n<h2 id=\"3-2、认证实现\"><a href=\"#3-2、认证实现\" class=\"headerlink\" title=\"3.2、认证实现\"></a>3.2、认证实现</h2><h3 id=\"3-2-1、自定义Realm\"><a href=\"#3-2-1、自定义Realm\" class=\"headerlink\" title=\"3.2.1、自定义Realm\"></a>3.2.1、自定义Realm</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 自定义Realm</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomerRealm</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AuthorizingRealm</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//授权</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title function_\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;==================&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//认证</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title function_\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException &#123;</span><br><span class=\"line\">        <span class=\"comment\">//在token中获取 用户名</span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">principal</span> <span class=\"operator\">=</span> (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(principal);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//实际开发中应当 根据身份信息使用jdbc mybatis查询相关数据库</span></span><br><span class=\"line\">        <span class=\"comment\">//在这里只做简单的演示</span></span><br><span class=\"line\">        <span class=\"comment\">//假设username,password是从数据库获得的信息</span></span><br><span class=\"line\">        String username=<span class=\"string\">&quot;zhangsan&quot;</span>;</span><br><span class=\"line\">        String password=<span class=\"string\">&quot;123456&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(username.equals(principal))&#123;</span><br><span class=\"line\">            <span class=\"comment\">//参数1:返回数据库中正确的用户名</span></span><br><span class=\"line\">            <span class=\"comment\">//参数2:返回数据库中正确密码</span></span><br><span class=\"line\">            <span class=\"comment\">//参数3:提供当前realm的名字 this.getName();</span></span><br><span class=\"line\">            <span class=\"type\">SimpleAuthenticationInfo</span> <span class=\"variable\">simpleAuthenticationInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleAuthenticationInfo</span>(principal,password,<span class=\"built_in\">this</span>.getName());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> simpleAuthenticationInfo;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2、用定义的Realm进行认证\"><a href=\"#3-2-2、用定义的Realm进行认证\" class=\"headerlink\" title=\"3.2.2、用定义的Realm进行认证\"></a>3.2.2、用定义的Realm进行认证</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 测试自定义的Realm</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestAuthenticatorCusttomerRealm</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建安全管理对象 securityManager</span></span><br><span class=\"line\">        <span class=\"type\">DefaultSecurityManager</span> <span class=\"variable\">defaultSecurityManager</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultSecurityManager</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.给安全管理器设置realm（设置为自定义realm获取认证数据）</span></span><br><span class=\"line\">        defaultSecurityManager.setRealm(<span class=\"keyword\">new</span> <span class=\"title class_\">CustomerRealm</span>());</span><br><span class=\"line\">        <span class=\"comment\">//IniRealm realm = new IniRealm(&quot;classpath:shiro.ini&quot;);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//3.给安装工具类中设置默认安全管理器</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//4.获取主体对象subject</span></span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//5.创建token令牌</span></span><br><span class=\"line\">        <span class=\"type\">UsernamePasswordToken</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UsernamePasswordToken</span>(<span class=\"string\">&quot;zhangsan&quot;</span>, <span class=\"string\">&quot;123&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            subject.login(token);<span class=\"comment\">//用户登录</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;登录成功~~&quot;</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (UnknownAccountException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;用户名错误!!&quot;</span>);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;密码错误!!!&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"4、授权\"><a href=\"#4、授权\" class=\"headerlink\" title=\"4、授权\"></a>4、授权</h1><h2 id=\"4-1、授权流程\"><a href=\"#4-1、授权流程\" class=\"headerlink\" title=\"4.1、授权流程\"></a>4.1、授权流程</h2><p>认证成功后，Shiro会将用户的身份信息保存在Subject对象中。一旦用户通过认证，就可以进行授权操作。授权是基于用户的身份和角色进行的，用于确定用户是否有权进行特定的操作或访问特定的资源。Shiro提供了基于角色的访问控制（Role-Based Access Control）和基于权限的访问控制（Permission-Based Access Control）两种授权方式。授权的核心是Realm。Realm是用于获取安全数据的组件</p>\n<ol>\n<li>用户发起访问请求。</li>\n<li>Shiro的Subject对象获取当前用户的身份信息，并创建相应的Principal对象。</li>\n<li>Subject将Principal对象传递给SecurityManager进行授权操作。</li>\n<li>SecurityManager委托Realm获取用户的角色和权限信息。</li>\n<li>Realm根据Principal对象从数据源（如数据库）中获取用户的角色和权限信息。</li>\n<li>Realm将获取的角色和权限信息返回给SecurityManager。</li>\n<li>SecurityManager根据获取的角色和权限信息进行授权判断，确定用户是否有权访问资源。</li>\n<li>根据授权结果，SecurityManager返回授权成功或失败的结果给Subject对象。</li>\n<li>Subject根据授权结果执行相应的操作，允许或拒绝用户访问受限资源。</li>\n</ol>\n<h2 id=\"4-2、授权方式\"><a href=\"#4-2、授权方式\" class=\"headerlink\" title=\"4.2、授权方式\"></a>4.2、授权方式</h2><h3 id=\"4-2-1、基于角色的访问控制\"><a href=\"#4-2-1、基于角色的访问控制\" class=\"headerlink\" title=\"4.2.1、基于角色的访问控制\"></a>4.2.1、基于角色的访问控制</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(subject.hasRole(<span class=\"string\">&quot;admin&quot;</span>))&#123;</span><br><span class=\"line\">   <span class=\"comment\">//操作什么资源</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-2、基于资源的访问控制\"><a href=\"#4-2-2、基于资源的访问控制\" class=\"headerlink\" title=\"4.2.2、基于资源的访问控制\"></a>4.2.2、基于资源的访问控制</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(subject.isPermission(<span class=\"string\">&quot;user:update:01&quot;</span>))&#123; <span class=\"comment\">//资源实例</span></span><br><span class=\"line\">  <span class=\"comment\">//对资源01用户具有修改的权限</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(subject.isPermission(<span class=\"string\">&quot;user:update:*&quot;</span>))&#123;  <span class=\"comment\">//资源类型</span></span><br><span class=\"line\">  <span class=\"comment\">//对 所有的资源 用户具有更新的权限</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>权限字符串的规则是：资源标识符：操作：资源实例标识符，意思是对哪个资源的哪个实例具有什么操作，“:”是资源&#x2F;操作&#x2F;实例的分割符，权限字符串也可以使用<em>通配符<br>用户创建权限：user:create，或user:create:</em><br> 用户修改实例001的权限：user:update:001<br> 用户实例001的所有权限：user:*：001</p>\n</blockquote>\n<h2 id=\"4-3、授权实现\"><a href=\"#4-3、授权实现\" class=\"headerlink\" title=\"4.3、授权实现\"></a>4.3、授权实现</h2><h3 id=\"4-3-1、定义Reaml\"><a href=\"#4-3-1、定义Reaml\" class=\"headerlink\" title=\"4.3.1、定义Reaml\"></a>4.3.1、定义Reaml</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 使用自定义realm</span></span><br><span class=\"line\"><span class=\"comment\"> * 实现授权操作</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">CustomerMd5Realm</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">AuthorizingRealm</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//授权</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title function_\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">primaryPrincipal</span> <span class=\"operator\">=</span> (String)principals.getPrimaryPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;身份信息: &quot;</span>+primaryPrincipal); <span class=\"comment\">//用户名</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//根据身份信息 用户名 获取当前用户的角色信息，以及权限信息</span></span><br><span class=\"line\">        <span class=\"type\">SimpleAuthorizationInfo</span> <span class=\"variable\">simpleAuthorizationInfo</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleAuthorizationInfo</span>();</span><br><span class=\"line\">        <span class=\"comment\">//假设 admin,user 是从数据库查到的 角色信息</span></span><br><span class=\"line\">        simpleAuthorizationInfo.addRole(<span class=\"string\">&quot;admin&quot;</span>);</span><br><span class=\"line\">        simpleAuthorizationInfo.addRole(<span class=\"string\">&quot;user&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//假设 ... 是从数据库查到的 权限信息赋值给权限对象</span></span><br><span class=\"line\">        simpleAuthorizationInfo.addStringPermission(<span class=\"string\">&quot;user:*:01&quot;</span>);</span><br><span class=\"line\">        simpleAuthorizationInfo.addStringPermission(<span class=\"string\">&quot;prodect:*&quot;</span>);<span class=\"comment\">//第三个参数为*省略</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> simpleAuthorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//认证</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title function_\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-2、授权\"><a href=\"#4-3-2、授权\" class=\"headerlink\" title=\"4.3.2、授权\"></a>4.3.2、授权</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCustomerMd5RealmAuthenicator</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//授权</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (subject.isAuthenticated())&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//基于角色权限控制</span></span><br><span class=\"line\">            System.out.println(subject.hasRole(<span class=\"string\">&quot;admin&quot;</span>));</span><br><span class=\"line\">            <span class=\"comment\">//基于多角色的权限控制</span></span><br><span class=\"line\">            System.out.println(subject.hasAllRoles(Arrays.asList(<span class=\"string\">&quot;admin&quot;</span>, <span class=\"string\">&quot;user&quot;</span>)));<span class=\"comment\">//true</span></span><br><span class=\"line\">            System.out.println(subject.hasAllRoles(Arrays.asList(<span class=\"string\">&quot;admin&quot;</span>, <span class=\"string\">&quot;manager&quot;</span>)));<span class=\"comment\">//false</span></span><br><span class=\"line\">            <span class=\"comment\">//是否具有其中一个角色</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span>[] booleans = subject.hasRoles(Arrays.asList(<span class=\"string\">&quot;admin&quot;</span>, <span class=\"string\">&quot;user&quot;</span>, <span class=\"string\">&quot;manager&quot;</span>));</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">boolean</span> aBoolean : booleans) &#123;</span><br><span class=\"line\">                System.out.println(aBoolean);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;====这是一个分隔符====&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//基于权限字符串的访问控制  资源标识符：操作：资源类型</span></span><br><span class=\"line\">            <span class=\"comment\">//用户具有的权限 user:*:01  prodect:*</span></span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;权限:&quot;</span>+subject.isPermitted(<span class=\"string\">&quot;user:update:01&quot;</span>));</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;权限:&quot;</span>+subject.isPermitted(<span class=\"string\">&quot;prodect:update:02&quot;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//分别具有哪些权限</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span>[] permitted = subject.isPermitted(<span class=\"string\">&quot;user:*:01&quot;</span>, <span class=\"string\">&quot;user:update:02&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">boolean</span> b : permitted) &#123;</span><br><span class=\"line\">                System.out.println(b);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//同时具有哪些权限</span></span><br><span class=\"line\">            <span class=\"type\">boolean</span> <span class=\"variable\">permittedAll</span> <span class=\"operator\">=</span> subject.isPermittedAll(<span class=\"string\">&quot;prodect:*:01&quot;</span>, <span class=\"string\">&quot;prodect:update:03&quot;</span>);</span><br><span class=\"line\">            System.out.println(permittedAll);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"5、会话管理（cacheManager）\"><a href=\"#5、会话管理（cacheManager）\" class=\"headerlink\" title=\"5、会话管理（cacheManager）\"></a>5、会话管理（cacheManager）</h1><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309141528819.png\" alt=\"shiro会话管理\"></p>\n<h2 id=\"5-1、shiro会话管理实现-EhCache\"><a href=\"#5-1、shiro会话管理实现-EhCache\" class=\"headerlink\" title=\"5.1、shiro会话管理实现(EhCache)\"></a>5.1、shiro会话管理实现(EhCache)</h2><h3 id=\"5-1-1、引入依赖\"><a href=\"#5-1-1、引入依赖\" class=\"headerlink\" title=\"5.1.1、引入依赖\"></a>5.1.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--引入shiro和ehcache--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-ehcache<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.5.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"5-1-2、开启缓存\"><a href=\"#5-1-2、开启缓存\" class=\"headerlink\" title=\"5.1.2、开启缓存\"></a>5.1.2、开启缓存</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//3.创建自定义realm</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Realm <span class=\"title function_\">getRealm</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">CustomerRealm</span> <span class=\"variable\">customerRealm</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">CustomerRealm</span>();</span><br><span class=\"line\">    <span class=\"comment\">//修改凭证校验匹配器</span></span><br><span class=\"line\">    <span class=\"type\">HashedCredentialsMatcher</span> <span class=\"variable\">credentialsMatcher</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">HashedCredentialsMatcher</span>();</span><br><span class=\"line\">    <span class=\"comment\">//设置加密算法为md5</span></span><br><span class=\"line\">    credentialsMatcher.setHashAlgorithmName(<span class=\"string\">&quot;MD5&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//设置散列次数</span></span><br><span class=\"line\">    credentialsMatcher.setHashIterations(<span class=\"number\">1024</span>);</span><br><span class=\"line\">    customerRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//开启缓存管理器</span></span><br><span class=\"line\">    customerRealm.setCachingEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    customerRealm.setAuthorizationCachingEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    customerRealm.setAuthorizationCachingEnabled(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    customerRealm.setCacheManager(<span class=\"keyword\">new</span> <span class=\"title class_\">EhCacheManager</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customerRealm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"6、springboot整合shiro\"><a href=\"#6、springboot整合shiro\" class=\"headerlink\" title=\"6、springboot整合shiro\"></a>6、springboot整合shiro</h1><h2 id=\"6-1、引入依赖\"><a href=\"#6-1、引入依赖\" class=\"headerlink\" title=\"6.1、引入依赖\"></a>6.1、引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--增加Shiro的配置--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shiro<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.4.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--Thymeleaf模板引擎--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--在Thymeleaf中使用shiro标签--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.github.theborakompanioni<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>thymeleaf-extras-shiro<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-2、配置文件\"><a href=\"#6-2、配置文件\" class=\"headerlink\" title=\"6.2、配置文件\"></a>6.2、配置文件</h2><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#开启Shiro配置，默认为true</span></span><br><span class=\"line\"><span class=\"attr\">shiro.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\">#开启ShiroWeb配置，默认为true</span></span><br><span class=\"line\"><span class=\"attr\">shiro.web.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\">#登录地址</span></span><br><span class=\"line\"><span class=\"attr\">shiro.loginUrl</span>=<span class=\"string\">/login</span></span><br><span class=\"line\"><span class=\"comment\">#登录成功地址</span></span><br><span class=\"line\"><span class=\"attr\">shiro.successUrl</span>=<span class=\"string\">/index</span></span><br><span class=\"line\"><span class=\"comment\">#未获授权默认跳转地址</span></span><br><span class=\"line\"><span class=\"attr\">shiro.unauthorizedUrl</span>=<span class=\"string\">/unauthorized</span></span><br><span class=\"line\"><span class=\"comment\">#允许通过URL参数实现会话跟踪，如果网站支持Cookie，可以关闭这个选项。默认为true</span></span><br><span class=\"line\"><span class=\"attr\">shiro.sessionManager.sessionIdUrlRewritingEnabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\">#是否允许通过Cookie实现会话跟踪，默认为true</span></span><br><span class=\"line\"><span class=\"attr\">shiro.sessionManager.sessionIdCookieEnabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-3、配置类\"><a href=\"#6-3、配置类\" class=\"headerlink\" title=\"6.3、配置类\"></a>6.3、配置类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ShiroConfig</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 自定义Realm</span></span><br><span class=\"line\"><span class=\"comment\">     * 直接配置了两个用户</span></span><br><span class=\"line\"><span class=\"comment\">     * nihiu=123</span></span><br><span class=\"line\"><span class=\"comment\">     * admin=123</span></span><br><span class=\"line\"><span class=\"comment\">     * 角色分别对应user和admin两个角色</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Realm <span class=\"title function_\">realm</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">TextConfigurationRealm</span> <span class=\"variable\">realm</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">TextConfigurationRealm</span>();</span><br><span class=\"line\">        realm.setUserDefinitions(<span class=\"string\">&quot;nihui=123,user</span></span><br><span class=\"line\"><span class=\"string\"> admin=123,admin&quot;</span>);</span><br><span class=\"line\">        realm.setRoleDefinitions(<span class=\"string\">&quot;admin=read,write</span></span><br><span class=\"line\"><span class=\"string\"> user=read&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> realm;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * ShiroFilterChainDefinition</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ShiroFilterChainDefinition <span class=\"title function_\">shiroFilterChainDefinition</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">DefaultShiroFilterChainDefinition</span> <span class=\"variable\">chainDefinition</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">DefaultShiroFilterChainDefinition</span>();</span><br><span class=\"line\">        chainDefinition.addPathDefinition(<span class=\"string\">&quot;/login&quot;</span>,<span class=\"string\">&quot;anon&quot;</span>);</span><br><span class=\"line\">        chainDefinition.addPathDefinition(<span class=\"string\">&quot;/doLogin&quot;</span>,<span class=\"string\">&quot;anon&quot;</span>);</span><br><span class=\"line\">        chainDefinition.addPathDefinition(<span class=\"string\">&quot;logout&quot;</span>,<span class=\"string\">&quot;logout&quot;</span>);</span><br><span class=\"line\">        chainDefinition.addPathDefinition(<span class=\"string\">&quot;/**&quot;</span>,<span class=\"string\">&quot;authc&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> chainDefinition;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 定义一个在Thymeleaf中支持Shiro标签。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> ShiroDialect <span class=\"title function_\">shiroDialect</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ShiroDialect</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6-4、登录接口控制类\"><a href=\"#6-4、登录接口控制类\" class=\"headerlink\" title=\"6.4、登录接口控制类\"></a>6.4、登录接口控制类</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@PostMapping(&quot;/doLogin&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">doLogin</span><span class=\"params\">(String username, String password, Model model)</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//构造一个UsernamePasswordToken实例获取</span></span><br><span class=\"line\">        <span class=\"type\">UsernamePasswordToken</span> <span class=\"variable\">token</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UsernamePasswordToken</span>(username,password);</span><br><span class=\"line\">        <span class=\"comment\">//获取Subject对象访问login方法当有异常的时候抛出异常</span></span><br><span class=\"line\">        <span class=\"type\">Subject</span> <span class=\"variable\">subject</span> <span class=\"operator\">=</span> SecurityUtils.getSubject();</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">            subject.login(token);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">catch</span> (AuthenticationException e)&#123;</span><br><span class=\"line\">            model.addAttribute(<span class=\"string\">&quot;error&quot;</span>,<span class=\"string\">&quot;用户名密码输入错误&quot;</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;login&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;redirect:/index&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@RequiresRoles(&quot;admin&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/admin&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">admin</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;admin&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequiresRoles(value = &#123;&quot;admin&quot;,&quot;user&quot;&#125;,logical = Logical.OR)</span></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/user&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">user</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;user&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"6-5、编写页面代码\"><a href=\"#6-5、编写页面代码\" class=\"headerlink\" title=\"6.5、编写页面代码\"></a>6.5、编写页面代码</h2><p>在对应的目录下面建立五个页面分别表示用户登录页面、首页、用户页面、管理员页面、认证错误页面</p>\n"},{"title":"sharding-jdbc","date":"2023-09-12T16:00:00.000Z","updated":"2023-09-12T16:00:00.000Z","abbrlink":43456,"_content":"# 1、基本概念\n\n分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。分库分表分为分库和分表两部分，通常分为垂直分库、垂直分表、水平分库、水平分表\n\n## 1.1、垂直分库\n垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上。例如，将用户信息表和订单信息表分别存储在不同的数据库中，以减轻单个数据库的负载压力\n\n## 1.2、水平分库\n水平分库是将一个表的数据按照某个条件（例如，按照用户ID的范围或哈希值）分散存储在多个数据库中。每个数据库只存储部分数据。这样可以将数据库负载均衡，并提高查询性能。例如，将用户信息根据用户ID的哈希值分散存储在不同的数据库中\n\n## 1.3、垂直分表\n垂直分表是将一个表按照列的方式进行拆分，将不同的列存储在不同的表中。每个表负责存储特定的列数据。这样可以降低单个表的数据量和表的宽度，提高查询性能。例如，将用户表拆分为用户基本信息表和用户扩展信息表，分别存储基本信息和扩展信息\n\n## 1.4、水平分表\n水平分表是将一个表的数据按照某个条件（例如，按照时间范围或哈希值）分散存储在多个表中。每个表只存储部分数据。这样可以将表的数据量减小，提高查询性能。例如，将订单表按照订单创建时间的范围拆分为多个表，每个表存储一段时间内的订单数据。\n\n\n## 1.5、分库分表带来的问题\n\n1. 事务一致性问题：由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题\n2. 跨节点关联查询：但垂直分库后和不在一个数据库，甚至不在一台服务器，无法进行关联查询\n1. 跨节点分页，排序函数：跨节点多库进行查询时，limit分页、order by排序等问题，就变得比较复杂了\n2. 主键避重：在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题\n\n# 2、sharding-jdbc相关概念\n\nSharding-JDBC是ShardingSphere的第一个产品，也是ShardingSphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架\n\n```yml\nsharding:  \n    # 配置绑定表,分片键一致，关联查询时不会笛卡尔  \n    binding-tables[0]: ims_test_result,ims_test_sample_fetch \n    tables:  \n        ims_sample_base:  \n            actual-data-nodes: m1.ims_sample_base_202308,m1.ims_sample_base_202309 \n            key-generator:  \n                column: id  \n                type: SNOWFLAKE  \n            table-strategy:  \n                complex:  \n                    sharding-columns: submit_work_time,sample_uid  \n                    algorithm-class-name: com.chivd.common.algorithm.TableShardingSampleAlgorithm\n```\n## 2.1、逻辑表\n未参与分片（不带后缀等信息）的表，实际数据库中并不存在。如ims_sample_base\n\n## 2.2、真实表\n在分片的数据库中真实存在的物理表。如ims_sample_base_202308\n\n## 2.3、数据节点\n数据分片的最小单元。由数据源名称和数据表组成。如m1.ims_sample_base_202309\n\n## 2.4、绑定表\n\n指分片规则一致的主表和子表。例如: t_order表和t_order_item表，均按照order_id分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升\n\n```sql\nSELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\n\n在不配置绑定表关系时，假设分片键order_id将数值10路由至第0片，将数值11路第1片，那么路由后的SOL应该为4条，它们呈现为笛卡尔积:\nSELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\nSELECT i.* FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\nSELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\nSELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\n\n绑定表关系后，路由sql为两条：\nSELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\nSELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\n\n其中t_order在FROM的最左侧，ShardingSphere将会以它作为整个绑定表的主表。 所有路由计算将会只使用主表的策略，那么t_order_item表的分片计算将会使用t_order的条件。故绑定表之间的分区键要完全相同\n```\n\n## 2.5、五种分片策略\n\n1. none：不分片策略。对应NoneShardingStrategy ，不分片策略,SQL会被发给所有节点去执行,这个规则没有子项目可以配置。、\n2. inline：行表达式分片策略。对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持.只支持单分片键。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: t_user_$->{u_id % 8}表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7\n\n> 行表达式语法：\n> ${begin..end}表示范围区间\n> ${[unit1,unit2,unit3]}表示枚举值\n> 行表达式中如果出现连续多个$ { expression }或$->{expression}表达式，整个表达式最终结果将根据每个子表达式结果进行笛卡尔组合\n\n3. standard 标准分片策略\n\n对应StandardShardingStrategy。提供对SQL语句中的=,IN和BETWEENAND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理=和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND分片，如果不配置RangeShardingAlgorithm,SQL中的BETWEENAND将按照全库路由处理\n\n4. complex复合分片策略\n\n对应ComplexShardingStrategy。复合分片策略提供对SQL语句中的=,IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度\n\n5. hint分片策略\n\n对应HintShardingStrategy。通过Hint而非SQL解析的方式分片的策略。对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例:内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint支持通过JavaAPI和SQL注释(待实现)两种方式使用。\n\n## 2.6、主键生成策略\n\nshardingSphere提供灵活的配置分布式主键生成策略方式的主键生成策略，默认使用雪花算法 (snowflake) 生成64bit的长整型数据。当前提供了SNOWFLAKE、UUID 两种可用方式。\n\n## 2.7、事务处理\n有两种，一种是local，一种是XA（基于Atomikas来实现），还有一种未实现的柔性事务。其中如果不跨库，则选择local，否则则选择XA\n\n![sharding-jdbc事务处理](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161714644.png)\n\n\n# 3、基本原理\n\n当Sharding-JDBC接受到一条SQL语句时，会陆续执行 SQL解析 => 查询优化 => SQL路由 => SQL改写 => SQL执行 => 结果归并 ，最终返回执行结果\n\n## 3.1、sql解析\n\nSQL解析过程分为**词法解析**和**语法解析**。 \n词法解析器用于将SQL拆解为不可再分的原子符号，称为Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将SQL转换为抽象语法树。\n例如，以下SQL：\n```sql\nSELECT id, name FROM t_user WHERE status = 'ACTIVE' AND age > 18\n```\n\n解析之后的为抽象语法树见下图：\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161722674.png)\n\n\n为了便于理解，抽象语法树中的关键字的Token用绿色表示，变量的Token用红色表示，灰色表示需要进一步拆分\n\n## 3.2、sql路由\nSQL路由就是把针对逻辑表的数据操作映射到对数据结点操作的过程。根据解析上下文匹配数据库和表的分片策略，并生成路由路径\n\n1. 对于携带分片键的sql\n\n>1. 根据分片键操作符不同可以划分为单片路由(分片键的操作符是等号)、多片路由(分片键的操作符是IN)和范围路由(分片键的操作符是 BETWEEN)\n>2. 根据分片键进行路由的效果可分为直接路由、标准路由、笛卡尔路由等标准路由是Sharding-Jdbc最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的SQL。 当分片运算符是等于号时，路由结果将落入单库（表），当分片运算符是BETWEEN或IN时，则路由结果不一定落入唯一的库（表），因此一条逻辑SQL最终可能被拆分为多条用于执行的真实SQL.笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行\n\n2. 不携带分片键的sql则采用广播路由\n\n## 3.3、sql改写\n\n工程师面向逻辑表书写的SQL，并不能够直接在真实的数据库中执行，SQL改写用于将逻辑SQL改写为在真实数据库中可以正确执行的SQL\n\n```sql\n如一个简单的例子，若逻辑SQL为：\nSELECT order_id FROM t_order WHERE order_id=1;\n假设该SQL配置分片键order_id，并且order_id=1的情况，将路由至\n分片表1。那么改写之后的SQL应该为：\nSELECT order_id FROM t_order_1 WHERE order_id=1;\n```\n\n## 3.4、sql执行\n\nSharding-JDBC采用一套自动化的执行引擎，负责将路由和改写完成之后的真实SQL安全且高效发送到底层数据源执行。 \n\n它不是简单地将SQL通过JDBC直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题\n\n## 3.5、结果归并\n\n将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。\n\nSharding-JDBC支持的结果归并从功能上可分为遍历、排序、分组、分页和聚合5种类型","source":"_posts/sharding-jdbc.md","raw":"---\ntitle: sharding-jdbc\ndate: 2023/09/13\nupdated: 2023/09/13\ncategories:\n  - coding\ntags:\n  - sharding-jdbc\n  - 编程基础\nabbrlink: 43456\n---\n# 1、基本概念\n\n分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。分库分表分为分库和分表两部分，通常分为垂直分库、垂直分表、水平分库、水平分表\n\n## 1.1、垂直分库\n垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上。例如，将用户信息表和订单信息表分别存储在不同的数据库中，以减轻单个数据库的负载压力\n\n## 1.2、水平分库\n水平分库是将一个表的数据按照某个条件（例如，按照用户ID的范围或哈希值）分散存储在多个数据库中。每个数据库只存储部分数据。这样可以将数据库负载均衡，并提高查询性能。例如，将用户信息根据用户ID的哈希值分散存储在不同的数据库中\n\n## 1.3、垂直分表\n垂直分表是将一个表按照列的方式进行拆分，将不同的列存储在不同的表中。每个表负责存储特定的列数据。这样可以降低单个表的数据量和表的宽度，提高查询性能。例如，将用户表拆分为用户基本信息表和用户扩展信息表，分别存储基本信息和扩展信息\n\n## 1.4、水平分表\n水平分表是将一个表的数据按照某个条件（例如，按照时间范围或哈希值）分散存储在多个表中。每个表只存储部分数据。这样可以将表的数据量减小，提高查询性能。例如，将订单表按照订单创建时间的范围拆分为多个表，每个表存储一段时间内的订单数据。\n\n\n## 1.5、分库分表带来的问题\n\n1. 事务一致性问题：由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题\n2. 跨节点关联查询：但垂直分库后和不在一个数据库，甚至不在一台服务器，无法进行关联查询\n1. 跨节点分页，排序函数：跨节点多库进行查询时，limit分页、order by排序等问题，就变得比较复杂了\n2. 主键避重：在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题\n\n# 2、sharding-jdbc相关概念\n\nSharding-JDBC是ShardingSphere的第一个产品，也是ShardingSphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架\n\n```yml\nsharding:  \n    # 配置绑定表,分片键一致，关联查询时不会笛卡尔  \n    binding-tables[0]: ims_test_result,ims_test_sample_fetch \n    tables:  \n        ims_sample_base:  \n            actual-data-nodes: m1.ims_sample_base_202308,m1.ims_sample_base_202309 \n            key-generator:  \n                column: id  \n                type: SNOWFLAKE  \n            table-strategy:  \n                complex:  \n                    sharding-columns: submit_work_time,sample_uid  \n                    algorithm-class-name: com.chivd.common.algorithm.TableShardingSampleAlgorithm\n```\n## 2.1、逻辑表\n未参与分片（不带后缀等信息）的表，实际数据库中并不存在。如ims_sample_base\n\n## 2.2、真实表\n在分片的数据库中真实存在的物理表。如ims_sample_base_202308\n\n## 2.3、数据节点\n数据分片的最小单元。由数据源名称和数据表组成。如m1.ims_sample_base_202309\n\n## 2.4、绑定表\n\n指分片规则一致的主表和子表。例如: t_order表和t_order_item表，均按照order_id分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升\n\n```sql\nSELECT i.* FROM t_order o JOIN t_order_item i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\n\n在不配置绑定表关系时，假设分片键order_id将数值10路由至第0片，将数值11路第1片，那么路由后的SOL应该为4条，它们呈现为笛卡尔积:\nSELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\nSELECT i.* FROM t_order_0 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\nSELECT i.* FROM t_order_1 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\nSELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\n\n绑定表关系后，路由sql为两条：\nSELECT i.* FROM t_order_0 o JOIN t_order_item_0 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\nSELECT i.* FROM t_order_1 o JOIN t_order_item_1 i ON o.order_id=i.order_id WHERE o.order_id in (10, 11);\n\n其中t_order在FROM的最左侧，ShardingSphere将会以它作为整个绑定表的主表。 所有路由计算将会只使用主表的策略，那么t_order_item表的分片计算将会使用t_order的条件。故绑定表之间的分区键要完全相同\n```\n\n## 2.5、五种分片策略\n\n1. none：不分片策略。对应NoneShardingStrategy ，不分片策略,SQL会被发给所有节点去执行,这个规则没有子项目可以配置。、\n2. inline：行表达式分片策略。对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的=和IN的分片操作支持.只支持单分片键。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: t_user_$->{u_id % 8}表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7\n\n> 行表达式语法：\n> ${begin..end}表示范围区间\n> ${[unit1,unit2,unit3]}表示枚举值\n> 行表达式中如果出现连续多个$ { expression }或$->{expression}表达式，整个表达式最终结果将根据每个子表达式结果进行笛卡尔组合\n\n3. standard 标准分片策略\n\n对应StandardShardingStrategy。提供对SQL语句中的=,IN和BETWEENAND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理=和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND分片，如果不配置RangeShardingAlgorithm,SQL中的BETWEENAND将按照全库路由处理\n\n4. complex复合分片策略\n\n对应ComplexShardingStrategy。复合分片策略提供对SQL语句中的=,IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度\n\n5. hint分片策略\n\n对应HintShardingStrategy。通过Hint而非SQL解析的方式分片的策略。对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例:内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint支持通过JavaAPI和SQL注释(待实现)两种方式使用。\n\n## 2.6、主键生成策略\n\nshardingSphere提供灵活的配置分布式主键生成策略方式的主键生成策略，默认使用雪花算法 (snowflake) 生成64bit的长整型数据。当前提供了SNOWFLAKE、UUID 两种可用方式。\n\n## 2.7、事务处理\n有两种，一种是local，一种是XA（基于Atomikas来实现），还有一种未实现的柔性事务。其中如果不跨库，则选择local，否则则选择XA\n\n![sharding-jdbc事务处理](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161714644.png)\n\n\n# 3、基本原理\n\n当Sharding-JDBC接受到一条SQL语句时，会陆续执行 SQL解析 => 查询优化 => SQL路由 => SQL改写 => SQL执行 => 结果归并 ，最终返回执行结果\n\n## 3.1、sql解析\n\nSQL解析过程分为**词法解析**和**语法解析**。 \n词法解析器用于将SQL拆解为不可再分的原子符号，称为Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将SQL转换为抽象语法树。\n例如，以下SQL：\n```sql\nSELECT id, name FROM t_user WHERE status = 'ACTIVE' AND age > 18\n```\n\n解析之后的为抽象语法树见下图：\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161722674.png)\n\n\n为了便于理解，抽象语法树中的关键字的Token用绿色表示，变量的Token用红色表示，灰色表示需要进一步拆分\n\n## 3.2、sql路由\nSQL路由就是把针对逻辑表的数据操作映射到对数据结点操作的过程。根据解析上下文匹配数据库和表的分片策略，并生成路由路径\n\n1. 对于携带分片键的sql\n\n>1. 根据分片键操作符不同可以划分为单片路由(分片键的操作符是等号)、多片路由(分片键的操作符是IN)和范围路由(分片键的操作符是 BETWEEN)\n>2. 根据分片键进行路由的效果可分为直接路由、标准路由、笛卡尔路由等标准路由是Sharding-Jdbc最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的SQL。 当分片运算符是等于号时，路由结果将落入单库（表），当分片运算符是BETWEEN或IN时，则路由结果不一定落入唯一的库（表），因此一条逻辑SQL最终可能被拆分为多条用于执行的真实SQL.笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行\n\n2. 不携带分片键的sql则采用广播路由\n\n## 3.3、sql改写\n\n工程师面向逻辑表书写的SQL，并不能够直接在真实的数据库中执行，SQL改写用于将逻辑SQL改写为在真实数据库中可以正确执行的SQL\n\n```sql\n如一个简单的例子，若逻辑SQL为：\nSELECT order_id FROM t_order WHERE order_id=1;\n假设该SQL配置分片键order_id，并且order_id=1的情况，将路由至\n分片表1。那么改写之后的SQL应该为：\nSELECT order_id FROM t_order_1 WHERE order_id=1;\n```\n\n## 3.4、sql执行\n\nSharding-JDBC采用一套自动化的执行引擎，负责将路由和改写完成之后的真实SQL安全且高效发送到底层数据源执行。 \n\n它不是简单地将SQL通过JDBC直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题\n\n## 3.5、结果归并\n\n将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。\n\nSharding-JDBC支持的结果归并从功能上可分为遍历、排序、分组、分页和聚合5种类型","slug":"sharding-jdbc","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9p000r00uj7yvrgjyd","content":"<h1 id=\"1、基本概念\"><a href=\"#1、基本概念\" class=\"headerlink\" title=\"1、基本概念\"></a>1、基本概念</h1><p>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。分库分表分为分库和分表两部分，通常分为垂直分库、垂直分表、水平分库、水平分表</p>\n<h2 id=\"1-1、垂直分库\"><a href=\"#1-1、垂直分库\" class=\"headerlink\" title=\"1.1、垂直分库\"></a>1.1、垂直分库</h2><p>垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上。例如，将用户信息表和订单信息表分别存储在不同的数据库中，以减轻单个数据库的负载压力</p>\n<h2 id=\"1-2、水平分库\"><a href=\"#1-2、水平分库\" class=\"headerlink\" title=\"1.2、水平分库\"></a>1.2、水平分库</h2><p>水平分库是将一个表的数据按照某个条件（例如，按照用户ID的范围或哈希值）分散存储在多个数据库中。每个数据库只存储部分数据。这样可以将数据库负载均衡，并提高查询性能。例如，将用户信息根据用户ID的哈希值分散存储在不同的数据库中</p>\n<h2 id=\"1-3、垂直分表\"><a href=\"#1-3、垂直分表\" class=\"headerlink\" title=\"1.3、垂直分表\"></a>1.3、垂直分表</h2><p>垂直分表是将一个表按照列的方式进行拆分，将不同的列存储在不同的表中。每个表负责存储特定的列数据。这样可以降低单个表的数据量和表的宽度，提高查询性能。例如，将用户表拆分为用户基本信息表和用户扩展信息表，分别存储基本信息和扩展信息</p>\n<h2 id=\"1-4、水平分表\"><a href=\"#1-4、水平分表\" class=\"headerlink\" title=\"1.4、水平分表\"></a>1.4、水平分表</h2><p>水平分表是将一个表的数据按照某个条件（例如，按照时间范围或哈希值）分散存储在多个表中。每个表只存储部分数据。这样可以将表的数据量减小，提高查询性能。例如，将订单表按照订单创建时间的范围拆分为多个表，每个表存储一段时间内的订单数据。</p>\n<h2 id=\"1-5、分库分表带来的问题\"><a href=\"#1-5、分库分表带来的问题\" class=\"headerlink\" title=\"1.5、分库分表带来的问题\"></a>1.5、分库分表带来的问题</h2><ol>\n<li>事务一致性问题：由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题</li>\n<li>跨节点关联查询：但垂直分库后和不在一个数据库，甚至不在一台服务器，无法进行关联查询</li>\n<li>跨节点分页，排序函数：跨节点多库进行查询时，limit分页、order by排序等问题，就变得比较复杂了</li>\n<li>主键避重：在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题</li>\n</ol>\n<h1 id=\"2、sharding-jdbc相关概念\"><a href=\"#2、sharding-jdbc相关概念\" class=\"headerlink\" title=\"2、sharding-jdbc相关概念\"></a>2、sharding-jdbc相关概念</h1><p>Sharding-JDBC是ShardingSphere的第一个产品，也是ShardingSphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sharding:</span>  </span><br><span class=\"line\">    <span class=\"comment\"># 配置绑定表,分片键一致，关联查询时不会笛卡尔  </span></span><br><span class=\"line\">    <span class=\"string\">binding-tables[0]:</span> <span class=\"string\">ims_test_result,ims_test_sample_fetch</span> </span><br><span class=\"line\">    <span class=\"attr\">tables:</span>  </span><br><span class=\"line\">        <span class=\"attr\">ims_sample_base:</span>  </span><br><span class=\"line\">            <span class=\"attr\">actual-data-nodes:</span> <span class=\"string\">m1.ims_sample_base_202308,m1.ims_sample_base_202309</span> </span><br><span class=\"line\">            <span class=\"attr\">key-generator:</span>  </span><br><span class=\"line\">                <span class=\"attr\">column:</span> <span class=\"string\">id</span>  </span><br><span class=\"line\">                <span class=\"attr\">type:</span> <span class=\"string\">SNOWFLAKE</span>  </span><br><span class=\"line\">            <span class=\"attr\">table-strategy:</span>  </span><br><span class=\"line\">                <span class=\"attr\">complex:</span>  </span><br><span class=\"line\">                    <span class=\"attr\">sharding-columns:</span> <span class=\"string\">submit_work_time,sample_uid</span>  </span><br><span class=\"line\">                    <span class=\"attr\">algorithm-class-name:</span> <span class=\"string\">com.chivd.common.algorithm.TableShardingSampleAlgorithm</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1、逻辑表\"><a href=\"#2-1、逻辑表\" class=\"headerlink\" title=\"2.1、逻辑表\"></a>2.1、逻辑表</h2><p>未参与分片（不带后缀等信息）的表，实际数据库中并不存在。如ims_sample_base</p>\n<h2 id=\"2-2、真实表\"><a href=\"#2-2、真实表\" class=\"headerlink\" title=\"2.2、真实表\"></a>2.2、真实表</h2><p>在分片的数据库中真实存在的物理表。如ims_sample_base_202308</p>\n<h2 id=\"2-3、数据节点\"><a href=\"#2-3、数据节点\" class=\"headerlink\" title=\"2.3、数据节点\"></a>2.3、数据节点</h2><p>数据分片的最小单元。由数据源名称和数据表组成。如m1.ims_sample_base_202309</p>\n<h2 id=\"2-4、绑定表\"><a href=\"#2-4、绑定表\" class=\"headerlink\" title=\"2.4、绑定表\"></a>2.4、绑定表</h2><p>指分片规则一致的主表和子表。例如: t_order表和t_order_item表，均按照order_id分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order o <span class=\"keyword\">JOIN</span> t_order_item i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">在不配置绑定表关系时，假设分片键order_id将数值<span class=\"number\">10</span>路由至第<span class=\"number\">0</span>片，将数值<span class=\"number\">11</span>路第<span class=\"number\">1</span>片，那么路由后的SOL应该为<span class=\"number\">4</span>条，它们呈现为笛卡尔积:</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_0 o <span class=\"keyword\">JOIN</span> t_order_item_0 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_0 o <span class=\"keyword\">JOIN</span> t_order_item_1 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_1 o <span class=\"keyword\">JOIN</span> t_order_item_0 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_1 o <span class=\"keyword\">JOIN</span> t_order_item_1 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">绑定表关系后，路由<span class=\"keyword\">sql</span>为两条：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_0 o <span class=\"keyword\">JOIN</span> t_order_item_0 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_1 o <span class=\"keyword\">JOIN</span> t_order_item_1 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">其中t_order在<span class=\"keyword\">FROM</span>的最左侧，ShardingSphere将会以它作为整个绑定表的主表。 所有路由计算将会只使用主表的策略，那么t_order_item表的分片计算将会使用t_order的条件。故绑定表之间的分区键要完全相同</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5、五种分片策略\"><a href=\"#2-5、五种分片策略\" class=\"headerlink\" title=\"2.5、五种分片策略\"></a>2.5、五种分片策略</h2><ol>\n<li>none：不分片策略。对应NoneShardingStrategy ，不分片策略,SQL会被发给所有节点去执行,这个规则没有子项目可以配置。、</li>\n<li>inline：行表达式分片策略。对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的&#x3D;和IN的分片操作支持.只支持单分片键。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: t_user_$-&gt;{u_id % 8}表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7</li>\n</ol>\n<blockquote>\n<p>行表达式语法：<br>${begin..end}表示范围区间<br>${[unit1,unit2,unit3]}表示枚举值<br>行表达式中如果出现连续多个$ { expression }或$-&gt;{expression}表达式，整个表达式最终结果将根据每个子表达式结果进行笛卡尔组合</p>\n</blockquote>\n<ol start=\"3\">\n<li>standard 标准分片策略</li>\n</ol>\n<p>对应StandardShardingStrategy。提供对SQL语句中的&#x3D;,IN和BETWEENAND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理&#x3D;和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND分片，如果不配置RangeShardingAlgorithm,SQL中的BETWEENAND将按照全库路由处理</p>\n<ol start=\"4\">\n<li>complex复合分片策略</li>\n</ol>\n<p>对应ComplexShardingStrategy。复合分片策略提供对SQL语句中的&#x3D;,IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度</p>\n<ol start=\"5\">\n<li>hint分片策略</li>\n</ol>\n<p>对应HintShardingStrategy。通过Hint而非SQL解析的方式分片的策略。对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例:内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint支持通过JavaAPI和SQL注释(待实现)两种方式使用。</p>\n<h2 id=\"2-6、主键生成策略\"><a href=\"#2-6、主键生成策略\" class=\"headerlink\" title=\"2.6、主键生成策略\"></a>2.6、主键生成策略</h2><p>shardingSphere提供灵活的配置分布式主键生成策略方式的主键生成策略，默认使用雪花算法 (snowflake) 生成64bit的长整型数据。当前提供了SNOWFLAKE、UUID 两种可用方式。</p>\n<h2 id=\"2-7、事务处理\"><a href=\"#2-7、事务处理\" class=\"headerlink\" title=\"2.7、事务处理\"></a>2.7、事务处理</h2><p>有两种，一种是local，一种是XA（基于Atomikas来实现），还有一种未实现的柔性事务。其中如果不跨库，则选择local，否则则选择XA</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161714644.png\" alt=\"sharding-jdbc事务处理\"></p>\n<h1 id=\"3、基本原理\"><a href=\"#3、基本原理\" class=\"headerlink\" title=\"3、基本原理\"></a>3、基本原理</h1><p>当Sharding-JDBC接受到一条SQL语句时，会陆续执行 SQL解析 &#x3D;&gt; 查询优化 &#x3D;&gt; SQL路由 &#x3D;&gt; SQL改写 &#x3D;&gt; SQL执行 &#x3D;&gt; 结果归并 ，最终返回执行结果</p>\n<h2 id=\"3-1、sql解析\"><a href=\"#3-1、sql解析\" class=\"headerlink\" title=\"3.1、sql解析\"></a>3.1、sql解析</h2><p>SQL解析过程分为<strong>词法解析</strong>和<strong>语法解析</strong>。<br>词法解析器用于将SQL拆解为不可再分的原子符号，称为Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将SQL转换为抽象语法树。<br>例如，以下SQL：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> id, name <span class=\"keyword\">FROM</span> t_user <span class=\"keyword\">WHERE</span> status <span class=\"operator\">=</span> <span class=\"string\">&#x27;ACTIVE&#x27;</span> <span class=\"keyword\">AND</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n<p>解析之后的为抽象语法树见下图：</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161722674.png\" alt=\"image.png\"></p>\n<p>为了便于理解，抽象语法树中的关键字的Token用绿色表示，变量的Token用红色表示，灰色表示需要进一步拆分</p>\n<h2 id=\"3-2、sql路由\"><a href=\"#3-2、sql路由\" class=\"headerlink\" title=\"3.2、sql路由\"></a>3.2、sql路由</h2><p>SQL路由就是把针对逻辑表的数据操作映射到对数据结点操作的过程。根据解析上下文匹配数据库和表的分片策略，并生成路由路径</p>\n<ol>\n<li>对于携带分片键的sql</li>\n</ol>\n<blockquote>\n<ol>\n<li>根据分片键操作符不同可以划分为单片路由(分片键的操作符是等号)、多片路由(分片键的操作符是IN)和范围路由(分片键的操作符是 BETWEEN)</li>\n<li>根据分片键进行路由的效果可分为直接路由、标准路由、笛卡尔路由等标准路由是Sharding-Jdbc最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的SQL。 当分片运算符是等于号时，路由结果将落入单库（表），当分片运算符是BETWEEN或IN时，则路由结果不一定落入唯一的库（表），因此一条逻辑SQL最终可能被拆分为多条用于执行的真实SQL.笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>不携带分片键的sql则采用广播路由</li>\n</ol>\n<h2 id=\"3-3、sql改写\"><a href=\"#3-3、sql改写\" class=\"headerlink\" title=\"3.3、sql改写\"></a>3.3、sql改写</h2><p>工程师面向逻辑表书写的SQL，并不能够直接在真实的数据库中执行，SQL改写用于将逻辑SQL改写为在真实数据库中可以正确执行的SQL</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如一个简单的例子，若逻辑<span class=\"keyword\">SQL</span>为：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> order_id <span class=\"keyword\">FROM</span> t_order <span class=\"keyword\">WHERE</span> order_id<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br><span class=\"line\">假设该<span class=\"keyword\">SQL</span>配置分片键order_id，并且order_id<span class=\"operator\">=</span><span class=\"number\">1</span>的情况，将路由至</span><br><span class=\"line\">分片表<span class=\"number\">1</span>。那么改写之后的<span class=\"keyword\">SQL</span>应该为：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> order_id <span class=\"keyword\">FROM</span> t_order_1 <span class=\"keyword\">WHERE</span> order_id<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4、sql执行\"><a href=\"#3-4、sql执行\" class=\"headerlink\" title=\"3.4、sql执行\"></a>3.4、sql执行</h2><p>Sharding-JDBC采用一套自动化的执行引擎，负责将路由和改写完成之后的真实SQL安全且高效发送到底层数据源执行。 </p>\n<p>它不是简单地将SQL通过JDBC直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题</p>\n<h2 id=\"3-5、结果归并\"><a href=\"#3-5、结果归并\" class=\"headerlink\" title=\"3.5、结果归并\"></a>3.5、结果归并</h2><p>将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。</p>\n<p>Sharding-JDBC支持的结果归并从功能上可分为遍历、排序、分组、分页和聚合5种类型</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、基本概念\"><a href=\"#1、基本概念\" class=\"headerlink\" title=\"1、基本概念\"></a>1、基本概念</h1><p>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。分库分表分为分库和分表两部分，通常分为垂直分库、垂直分表、水平分库、水平分表</p>\n<h2 id=\"1-1、垂直分库\"><a href=\"#1-1、垂直分库\" class=\"headerlink\" title=\"1.1、垂直分库\"></a>1.1、垂直分库</h2><p>垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上。例如，将用户信息表和订单信息表分别存储在不同的数据库中，以减轻单个数据库的负载压力</p>\n<h2 id=\"1-2、水平分库\"><a href=\"#1-2、水平分库\" class=\"headerlink\" title=\"1.2、水平分库\"></a>1.2、水平分库</h2><p>水平分库是将一个表的数据按照某个条件（例如，按照用户ID的范围或哈希值）分散存储在多个数据库中。每个数据库只存储部分数据。这样可以将数据库负载均衡，并提高查询性能。例如，将用户信息根据用户ID的哈希值分散存储在不同的数据库中</p>\n<h2 id=\"1-3、垂直分表\"><a href=\"#1-3、垂直分表\" class=\"headerlink\" title=\"1.3、垂直分表\"></a>1.3、垂直分表</h2><p>垂直分表是将一个表按照列的方式进行拆分，将不同的列存储在不同的表中。每个表负责存储特定的列数据。这样可以降低单个表的数据量和表的宽度，提高查询性能。例如，将用户表拆分为用户基本信息表和用户扩展信息表，分别存储基本信息和扩展信息</p>\n<h2 id=\"1-4、水平分表\"><a href=\"#1-4、水平分表\" class=\"headerlink\" title=\"1.4、水平分表\"></a>1.4、水平分表</h2><p>水平分表是将一个表的数据按照某个条件（例如，按照时间范围或哈希值）分散存储在多个表中。每个表只存储部分数据。这样可以将表的数据量减小，提高查询性能。例如，将订单表按照订单创建时间的范围拆分为多个表，每个表存储一段时间内的订单数据。</p>\n<h2 id=\"1-5、分库分表带来的问题\"><a href=\"#1-5、分库分表带来的问题\" class=\"headerlink\" title=\"1.5、分库分表带来的问题\"></a>1.5、分库分表带来的问题</h2><ol>\n<li>事务一致性问题：由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题</li>\n<li>跨节点关联查询：但垂直分库后和不在一个数据库，甚至不在一台服务器，无法进行关联查询</li>\n<li>跨节点分页，排序函数：跨节点多库进行查询时，limit分页、order by排序等问题，就变得比较复杂了</li>\n<li>主键避重：在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题</li>\n</ol>\n<h1 id=\"2、sharding-jdbc相关概念\"><a href=\"#2、sharding-jdbc相关概念\" class=\"headerlink\" title=\"2、sharding-jdbc相关概念\"></a>2、sharding-jdbc相关概念</h1><p>Sharding-JDBC是ShardingSphere的第一个产品，也是ShardingSphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sharding:</span>  </span><br><span class=\"line\">    <span class=\"comment\"># 配置绑定表,分片键一致，关联查询时不会笛卡尔  </span></span><br><span class=\"line\">    <span class=\"string\">binding-tables[0]:</span> <span class=\"string\">ims_test_result,ims_test_sample_fetch</span> </span><br><span class=\"line\">    <span class=\"attr\">tables:</span>  </span><br><span class=\"line\">        <span class=\"attr\">ims_sample_base:</span>  </span><br><span class=\"line\">            <span class=\"attr\">actual-data-nodes:</span> <span class=\"string\">m1.ims_sample_base_202308,m1.ims_sample_base_202309</span> </span><br><span class=\"line\">            <span class=\"attr\">key-generator:</span>  </span><br><span class=\"line\">                <span class=\"attr\">column:</span> <span class=\"string\">id</span>  </span><br><span class=\"line\">                <span class=\"attr\">type:</span> <span class=\"string\">SNOWFLAKE</span>  </span><br><span class=\"line\">            <span class=\"attr\">table-strategy:</span>  </span><br><span class=\"line\">                <span class=\"attr\">complex:</span>  </span><br><span class=\"line\">                    <span class=\"attr\">sharding-columns:</span> <span class=\"string\">submit_work_time,sample_uid</span>  </span><br><span class=\"line\">                    <span class=\"attr\">algorithm-class-name:</span> <span class=\"string\">com.chivd.common.algorithm.TableShardingSampleAlgorithm</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-1、逻辑表\"><a href=\"#2-1、逻辑表\" class=\"headerlink\" title=\"2.1、逻辑表\"></a>2.1、逻辑表</h2><p>未参与分片（不带后缀等信息）的表，实际数据库中并不存在。如ims_sample_base</p>\n<h2 id=\"2-2、真实表\"><a href=\"#2-2、真实表\" class=\"headerlink\" title=\"2.2、真实表\"></a>2.2、真实表</h2><p>在分片的数据库中真实存在的物理表。如ims_sample_base_202308</p>\n<h2 id=\"2-3、数据节点\"><a href=\"#2-3、数据节点\" class=\"headerlink\" title=\"2.3、数据节点\"></a>2.3、数据节点</h2><p>数据分片的最小单元。由数据源名称和数据表组成。如m1.ims_sample_base_202309</p>\n<h2 id=\"2-4、绑定表\"><a href=\"#2-4、绑定表\" class=\"headerlink\" title=\"2.4、绑定表\"></a>2.4、绑定表</h2><p>指分片规则一致的主表和子表。例如: t_order表和t_order_item表，均按照order_id分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order o <span class=\"keyword\">JOIN</span> t_order_item i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">在不配置绑定表关系时，假设分片键order_id将数值<span class=\"number\">10</span>路由至第<span class=\"number\">0</span>片，将数值<span class=\"number\">11</span>路第<span class=\"number\">1</span>片，那么路由后的SOL应该为<span class=\"number\">4</span>条，它们呈现为笛卡尔积:</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_0 o <span class=\"keyword\">JOIN</span> t_order_item_0 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_0 o <span class=\"keyword\">JOIN</span> t_order_item_1 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_1 o <span class=\"keyword\">JOIN</span> t_order_item_0 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_1 o <span class=\"keyword\">JOIN</span> t_order_item_1 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">绑定表关系后，路由<span class=\"keyword\">sql</span>为两条：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_0 o <span class=\"keyword\">JOIN</span> t_order_item_0 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> i.<span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> t_order_1 o <span class=\"keyword\">JOIN</span> t_order_item_1 i <span class=\"keyword\">ON</span> o.order_id<span class=\"operator\">=</span>i.order_id <span class=\"keyword\">WHERE</span> o.order_id <span class=\"keyword\">in</span> (<span class=\"number\">10</span>, <span class=\"number\">11</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">其中t_order在<span class=\"keyword\">FROM</span>的最左侧，ShardingSphere将会以它作为整个绑定表的主表。 所有路由计算将会只使用主表的策略，那么t_order_item表的分片计算将会使用t_order的条件。故绑定表之间的分区键要完全相同</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5、五种分片策略\"><a href=\"#2-5、五种分片策略\" class=\"headerlink\" title=\"2.5、五种分片策略\"></a>2.5、五种分片策略</h2><ol>\n<li>none：不分片策略。对应NoneShardingStrategy ，不分片策略,SQL会被发给所有节点去执行,这个规则没有子项目可以配置。、</li>\n<li>inline：行表达式分片策略。对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的&#x3D;和IN的分片操作支持.只支持单分片键。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: t_user_$-&gt;{u_id % 8}表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7</li>\n</ol>\n<blockquote>\n<p>行表达式语法：<br>${begin..end}表示范围区间<br>${[unit1,unit2,unit3]}表示枚举值<br>行表达式中如果出现连续多个$ { expression }或$-&gt;{expression}表达式，整个表达式最终结果将根据每个子表达式结果进行笛卡尔组合</p>\n</blockquote>\n<ol start=\"3\">\n<li>standard 标准分片策略</li>\n</ol>\n<p>对应StandardShardingStrategy。提供对SQL语句中的&#x3D;,IN和BETWEENAND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理&#x3D;和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND分片，如果不配置RangeShardingAlgorithm,SQL中的BETWEENAND将按照全库路由处理</p>\n<ol start=\"4\">\n<li>complex复合分片策略</li>\n</ol>\n<p>对应ComplexShardingStrategy。复合分片策略提供对SQL语句中的&#x3D;,IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度</p>\n<ol start=\"5\">\n<li>hint分片策略</li>\n</ol>\n<p>对应HintShardingStrategy。通过Hint而非SQL解析的方式分片的策略。对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例:内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint支持通过JavaAPI和SQL注释(待实现)两种方式使用。</p>\n<h2 id=\"2-6、主键生成策略\"><a href=\"#2-6、主键生成策略\" class=\"headerlink\" title=\"2.6、主键生成策略\"></a>2.6、主键生成策略</h2><p>shardingSphere提供灵活的配置分布式主键生成策略方式的主键生成策略，默认使用雪花算法 (snowflake) 生成64bit的长整型数据。当前提供了SNOWFLAKE、UUID 两种可用方式。</p>\n<h2 id=\"2-7、事务处理\"><a href=\"#2-7、事务处理\" class=\"headerlink\" title=\"2.7、事务处理\"></a>2.7、事务处理</h2><p>有两种，一种是local，一种是XA（基于Atomikas来实现），还有一种未实现的柔性事务。其中如果不跨库，则选择local，否则则选择XA</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161714644.png\" alt=\"sharding-jdbc事务处理\"></p>\n<h1 id=\"3、基本原理\"><a href=\"#3、基本原理\" class=\"headerlink\" title=\"3、基本原理\"></a>3、基本原理</h1><p>当Sharding-JDBC接受到一条SQL语句时，会陆续执行 SQL解析 &#x3D;&gt; 查询优化 &#x3D;&gt; SQL路由 &#x3D;&gt; SQL改写 &#x3D;&gt; SQL执行 &#x3D;&gt; 结果归并 ，最终返回执行结果</p>\n<h2 id=\"3-1、sql解析\"><a href=\"#3-1、sql解析\" class=\"headerlink\" title=\"3.1、sql解析\"></a>3.1、sql解析</h2><p>SQL解析过程分为<strong>词法解析</strong>和<strong>语法解析</strong>。<br>词法解析器用于将SQL拆解为不可再分的原子符号，称为Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将SQL转换为抽象语法树。<br>例如，以下SQL：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> id, name <span class=\"keyword\">FROM</span> t_user <span class=\"keyword\">WHERE</span> status <span class=\"operator\">=</span> <span class=\"string\">&#x27;ACTIVE&#x27;</span> <span class=\"keyword\">AND</span> age <span class=\"operator\">&gt;</span> <span class=\"number\">18</span></span><br></pre></td></tr></table></figure>\n\n<p>解析之后的为抽象语法树见下图：</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161722674.png\" alt=\"image.png\"></p>\n<p>为了便于理解，抽象语法树中的关键字的Token用绿色表示，变量的Token用红色表示，灰色表示需要进一步拆分</p>\n<h2 id=\"3-2、sql路由\"><a href=\"#3-2、sql路由\" class=\"headerlink\" title=\"3.2、sql路由\"></a>3.2、sql路由</h2><p>SQL路由就是把针对逻辑表的数据操作映射到对数据结点操作的过程。根据解析上下文匹配数据库和表的分片策略，并生成路由路径</p>\n<ol>\n<li>对于携带分片键的sql</li>\n</ol>\n<blockquote>\n<ol>\n<li>根据分片键操作符不同可以划分为单片路由(分片键的操作符是等号)、多片路由(分片键的操作符是IN)和范围路由(分片键的操作符是 BETWEEN)</li>\n<li>根据分片键进行路由的效果可分为直接路由、标准路由、笛卡尔路由等标准路由是Sharding-Jdbc最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的SQL。 当分片运算符是等于号时，路由结果将落入单库（表），当分片运算符是BETWEEN或IN时，则路由结果不一定落入唯一的库（表），因此一条逻辑SQL最终可能被拆分为多条用于执行的真实SQL.笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行</li>\n</ol>\n</blockquote>\n<ol start=\"2\">\n<li>不携带分片键的sql则采用广播路由</li>\n</ol>\n<h2 id=\"3-3、sql改写\"><a href=\"#3-3、sql改写\" class=\"headerlink\" title=\"3.3、sql改写\"></a>3.3、sql改写</h2><p>工程师面向逻辑表书写的SQL，并不能够直接在真实的数据库中执行，SQL改写用于将逻辑SQL改写为在真实数据库中可以正确执行的SQL</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如一个简单的例子，若逻辑<span class=\"keyword\">SQL</span>为：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> order_id <span class=\"keyword\">FROM</span> t_order <span class=\"keyword\">WHERE</span> order_id<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br><span class=\"line\">假设该<span class=\"keyword\">SQL</span>配置分片键order_id，并且order_id<span class=\"operator\">=</span><span class=\"number\">1</span>的情况，将路由至</span><br><span class=\"line\">分片表<span class=\"number\">1</span>。那么改写之后的<span class=\"keyword\">SQL</span>应该为：</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> order_id <span class=\"keyword\">FROM</span> t_order_1 <span class=\"keyword\">WHERE</span> order_id<span class=\"operator\">=</span><span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4、sql执行\"><a href=\"#3-4、sql执行\" class=\"headerlink\" title=\"3.4、sql执行\"></a>3.4、sql执行</h2><p>Sharding-JDBC采用一套自动化的执行引擎，负责将路由和改写完成之后的真实SQL安全且高效发送到底层数据源执行。 </p>\n<p>它不是简单地将SQL通过JDBC直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题</p>\n<h2 id=\"3-5、结果归并\"><a href=\"#3-5、结果归并\" class=\"headerlink\" title=\"3.5、结果归并\"></a>3.5、结果归并</h2><p>将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。</p>\n<p>Sharding-JDBC支持的结果归并从功能上可分为遍历、排序、分组、分页和聚合5种类型</p>\n"},{"title":"sharding-jdbc实现自动按月分表","date":"2023-10-15T16:00:00.000Z","abbrlink":53776,"_content":"\n# 1、基本需求\n\n1、 项目中我们希望 能够按照时间、类别来添加表。但是sharding-jdbc 是固定配置 的 actual-data-nodes 参数。也就是说我们需要提前创建好分表或者分库。那么我们需要如何来实现动态创建表，并且动态刷新 actual-data-nodes 呢。\n\n2、思路就是写个定时器来动态创建表 ，在创建表的时候 动态刷新 actual-data-nodes 实现动态创建表被shard加载。\n\n# 2、功能实现\n\n## 2.1、添加依赖\n```xml\n<dependency>\n    <groupId>org.apache.shardingsphere</groupId>\n    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>\n    <version>4.0.0-RC1</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.shardingsphere</groupId>\n    <artifactId>sharding-jdbc-spring-namespace</artifactId>\n    <version>4.0.0-RC1</version>\n</dependency>\n```\n\n\n## 2.2、yml配置\n\n```yml\nsharding:  \n    # 配置绑定表  \n    binding-tables[0]: ims_test_result,ims_test_sample_fetch,ims_test_sample_diluent,ims_test_reagent_add,ims_test_ls_add,ims_test_incubate,ims_test_read  \n    tables:  \n\t\tims_sample_base:  \n\t\t    actual-data-nodes: m1.sharding_data_nodes_2022  \n\t\t    key-generator:  \n\t\t        column: id  \n\t\t        type: SNOWFLAKE  \n\t\t        props:  \n\t\t            worker.id: ${workerId}  \n\t\t    table-strategy:  \n\t\t        complex:  \n\t\t            sharding-columns: submit_work_time,sample_uid  \n\t\t\t            algorithm-class-name: com.chivd.common.algorithm.TableShardingSampleAlgorithm\n```\n\n## 2.3、具体分片算法\n\n```java\npublic class TableShardingSampleAlgorithm implements ComplexKeysShardingAlgorithm<String> {  \n  \n    private static final String COLUMN_SAMPLE_UID = \"sample_uid\";  \n  \n    private static final String COLUMN_SUBMIT_TIME = \"submit_work_time\";  \n  \n    @Override  \n    public Collection<String> doSharding(Collection<String> collection, ComplexKeysShardingValue<String> complexKeysShardingValue) {  \n        // 逻辑表名  \n        String logicTableName = complexKeysShardingValue.getLogicTableName();  \n  \n        // 精准工单提交时间  \n        Collection<String> submitWorkTimeCollection = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SUBMIT_TIME, new ArrayList<>());  \n        ArrayList<String> submitWorkTimeList = new ArrayList<>(submitWorkTimeCollection);  \n        if (CollectionUtils.isNotEmpty(submitWorkTimeList)) {  \n            Set<String> set = new HashSet<>();  \n            for (int i = 0; i < submitWorkTimeList.size(); i++) {  \n                Date date = DateUtils.parseDate(submitWorkTimeList.get(i));  \n                StringBuffer tableName = new StringBuffer();  \n                tableName.append(logicTableName).append(\"_\").append(DateUtils.parseDateToStr(DateUtils.YYYYMM, date));  \n                set.add(tableName.toString());  \n            }  \n            return set;  \n        }  \n  \n        // 工单提交时间范围  \n        Range<String> submitWorkTimeRange = complexKeysShardingValue.getColumnNameAndRangeValuesMap().get(COLUMN_SUBMIT_TIME);  \n        if (submitWorkTimeRange != null) {  \n            // 实体表名集合  \n            Set<String> result = new HashSet<>();  \n            Date lowerDate = DateUtils.parseDate(submitWorkTimeRange.lowerEndpoint());  \n            Date upperDate = DateUtils.parseDate(submitWorkTimeRange.upperEndpoint());  \n            // 获取月份间隔  \n            int monthSpace = DateUtils.getMonthSpace(lowerDate, upperDate);  \n            // 获取所有的实体表名  \n            for (int i = 0; i < monthSpace; i++) {  \n                result.add(logicTableName + \"_\" + DateUtils.parseDateToStr(DateUtils.YYYYMM, lowerDate));  \n                lowerDate = DateUtils.addMonths(lowerDate, 1);  \n            }  \n            return result;  \n        }  \n  \n        // 样本uid  \n        Collection<String> testUids = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SAMPLE_UID, new ArrayList<>());  \n        if (CollectionUtils.isNotEmpty(testUids)) {  \n            return testUids.stream().map(uid -> {  \n                String[] split = uid.split(\"-\");  \n                StringBuffer tableName = new StringBuffer();  \n                tableName.append(logicTableName)  \n                        .append(\"_\")  \n                        .append(split[split.length - 1].substring(0,6));  \n                return tableName.toString();  \n            }).collect(Collectors.toSet());  \n        }  \n        return null;  \n    }  \n}\n```\n## 2.4、创建配置表\n\n配置表包含所有需要分表的逻辑表表名，分表开始年月等信息\n\n```sql\nCREATE TABLE `ims_sharding_config` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `table_name` varchar(100) DEFAULT NULL COMMENT '表名',\n  `start_year_month` varchar(20) DEFAULT NULL COMMENT '分表开始年月',\n  `comment` varchar(100) DEFAULT NULL COMMENT '备注',\n  `is_deleted` tinyint(4) DEFAULT '0' COMMENT '(0-未删除 1-删除)',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4;\n```\n\n## 2.5、创建定时任务\n\n1. 启动时自动刷新actual-data-nodes节点\n2. 自动创建下月分表\n\n```java\n@Slf4j  \n@Component  \npublic class ShardingTableUtils {  \n    @Autowired  \n    DataSource dataSource;  \n  \n    @Autowired  \n    IShardingConfigService shardingConfigService;  \n  \n    /**  \n     * @Description 项目启动时刷新节点配置  \n     **/    \n     @PostConstruct  \n    public void startRefresh() {  \n        AutoCreateTable();  \n    }  \n  \n    /**  \n     * @Description 刷新actual-data-nodes节点配置  \n     **/    \n     public void actualTablesRefresh() {  \n        log.info(\"-------------- 开始刷新sharding配置 ---------------\");  \n        try {  \n            List<ShardingConfig> shardingConfigList = shardingConfigService.listShardingConfig();  \n            ShardingDataSource dataSource = (ShardingDataSource) this.dataSource;  \n            if (shardingConfigList == null || shardingConfigList.isEmpty()) {  \n                log.info(\"【sharding自动配置】配置表为空\");  \n                return;            }  \n            String curYearAndMonth = DateUtils.getYearAndMonth(DateUtils.monthAdd(new Date(),1).getTime());  \n            Field modifiersField = Field.class.getDeclaredField(\"modifiers\");  \n            modifiersField.setAccessible(true);  \n            for (ShardingConfig item : shardingConfigList) {  \n                TableRule tableRule = null;  \n                tableRule = dataSource.getRuntimeContext().getRule().getTableRule(item.getTableName());  \n                List<DataNode> dataNodes = tableRule.getActualDataNodes();  \n                String dataSourceName = dataNodes.get(0).getDataSourceName();  \n                List<String> monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  \n                List<DataNode> newDataNodes = monthBetween.stream()  \n                        .map(yearMonth -> new DataNode(dataSourceName + \".\" + item.getTableName()  \n                                + \"_\" + yearMonth)).collect(Collectors.toList());  \n                // 修改actualDataNodesField  \n                Field actualDataNodesField = TableRule.class.getDeclaredField(\"actualDataNodes\");  \n                actualDataNodesField.setAccessible(true);  \n                modifiersField.setInt(actualDataNodesField, actualDataNodesField.getModifiers() & ~Modifier.FINAL);  \n                actualDataNodesField.set(tableRule, newDataNodes);  \n                // 修改actualTablesField  \n                Set<String> actualTables = Sets.newHashSet();  \n                Map<DataNode, Integer> dataNodeIndexMap = Maps.newHashMap();  \n                AtomicInteger index = new AtomicInteger(0);  \n                newDataNodes.forEach(dataNode -> {  \n                    actualTables.add(dataNode.getTableName());  \n                    if (index.intValue() == 0) {  \n                        dataNodeIndexMap.put(dataNode, 0);  \n                    } else {  \n                        dataNodeIndexMap.put(dataNode, index.intValue());  \n                    }  \n                    index.incrementAndGet();  \n                });  \n                Field actualTablesField = TableRule.class.getDeclaredField(\"actualTables\");  \n                actualTablesField.setAccessible(true);  \n                actualTablesField.set(tableRule, actualTables);  \n                // 动态刷新 dataNodeIndexMapField                Field dataNodeIndexMapField = TableRule.class.getDeclaredField(\"dataNodeIndexMap\");  \n                dataNodeIndexMapField.setAccessible(true);  \n                dataNodeIndexMapField.set(tableRule, dataNodeIndexMap);  \n                // 动态刷新 datasourceToTablesMapField                Map<String, Collection<String>> datasourceToTablesMap = Maps.newHashMap();  \n                datasourceToTablesMap.put(dataSourceName, actualTables);  \n                Field datasourceToTablesMapField = TableRule.class.getDeclaredField(\"datasourceToTablesMap\");  \n                datasourceToTablesMapField.setAccessible(true);  \n                datasourceToTablesMapField.set(tableRule, datasourceToTablesMap);  \n            }  \n        } catch (Exception e) {  \n            e.printStackTrace();  \n            log.info(\"【sharding自动配置】异常\" + e.getMessage());  \n        }  \n    }  \n  \n    /**  \n     * @Description 自动创建不存在的表  \n     **/    \n     private void AutoCreateTable() {  \n        log.info(\"-------------- 开始创建分表 ---------------\");  \n        List<ShardingConfig> shardingConfigList = shardingConfigService.listShardingConfig();  \n        if (shardingConfigList == null || shardingConfigList.isEmpty()) {  \n            log.info(\"【sharding自动配置】配置表为空\");  \n            return;        }  \n        String curYearAndMonth = DateUtils.getYearAndMonth(DateUtils.monthAdd(new Date(),2).getTime());  \n        for (ShardingConfig item : shardingConfigList) {  \n            List<String> monthBetween = new ArrayList<>();  \n            try {  \n                monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  \n            } catch (ParseException e) {  \n                log.info(\"【sharding自动配置】日期转化失败\" + e.getMessage());  \n                e.printStackTrace();  \n            }  \n            // todo (CREATE TABLE if not exists xx like xxx 表存在会抛异常。为啥呢 这里先catch住让代码继续运行)  \n            monthBetween.forEach(yearMonth -> {  \n                try {  \n                    shardingConfigService.createTable(item.getTableName(), item.getTableName() + \"_\" + yearMonth);  \n                }catch (Exception ignored){}  \n            });  \n        }  \n        // 刷新配置  \n        actualTablesRefresh();  \n    }  \n  \n    /**  \n     * 获取两个月份之间的所有月份  \n     * @param minDate  \n     * @param maxDate  \n     * @return  \n     * @throws ParseException  \n     */    private static List<String> getMonthBetween(String minDate, String maxDate) throws ParseException {  \n        ArrayList<String> result = new ArrayList<>();  \n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMM\");//格式化为年月  \n  \n        Calendar min = Calendar.getInstance();  \n        Calendar max = Calendar.getInstance();  \n  \n        min.setTime(sdf.parse(minDate));  \n        min.set(min.get(Calendar.YEAR), min.get(Calendar.MONTH), 1);  \n  \n        max.setTime(sdf.parse(maxDate));  \n        max.set(max.get(Calendar.YEAR), max.get(Calendar.MONTH), 2);  \n  \n        Calendar curr = min;  \n        while (curr.before(max)) {  \n            result.add(sdf.format(curr.getTime()));  \n            curr.add(Calendar.MONTH, 1);  \n        }  \n        return result;  \n    }  \n  \n    /**  \n     * 每月27号1点自动刷新配置节点  \n     */  \n    @Scheduled(cron = \"0 0 1 27 * ?\")  \n    public void refreshScheduled() {  \n        AutoCreateTable();  \n    }  \n}\n```","source":"_posts/sharding-jdbc实现自动按月分表.md","raw":"---\ntitle: sharding-jdbc实现自动按月分表\ndate: 2023/10/16\ncategories:\n  - coding\ntags:\n  - sharding-jdbc\n  - 分库分表\n  - 技术文章\nabbrlink: 53776\n---\n\n# 1、基本需求\n\n1、 项目中我们希望 能够按照时间、类别来添加表。但是sharding-jdbc 是固定配置 的 actual-data-nodes 参数。也就是说我们需要提前创建好分表或者分库。那么我们需要如何来实现动态创建表，并且动态刷新 actual-data-nodes 呢。\n\n2、思路就是写个定时器来动态创建表 ，在创建表的时候 动态刷新 actual-data-nodes 实现动态创建表被shard加载。\n\n# 2、功能实现\n\n## 2.1、添加依赖\n```xml\n<dependency>\n    <groupId>org.apache.shardingsphere</groupId>\n    <artifactId>sharding-jdbc-spring-boot-starter</artifactId>\n    <version>4.0.0-RC1</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.shardingsphere</groupId>\n    <artifactId>sharding-jdbc-spring-namespace</artifactId>\n    <version>4.0.0-RC1</version>\n</dependency>\n```\n\n\n## 2.2、yml配置\n\n```yml\nsharding:  \n    # 配置绑定表  \n    binding-tables[0]: ims_test_result,ims_test_sample_fetch,ims_test_sample_diluent,ims_test_reagent_add,ims_test_ls_add,ims_test_incubate,ims_test_read  \n    tables:  \n\t\tims_sample_base:  \n\t\t    actual-data-nodes: m1.sharding_data_nodes_2022  \n\t\t    key-generator:  \n\t\t        column: id  \n\t\t        type: SNOWFLAKE  \n\t\t        props:  \n\t\t            worker.id: ${workerId}  \n\t\t    table-strategy:  \n\t\t        complex:  \n\t\t            sharding-columns: submit_work_time,sample_uid  \n\t\t\t            algorithm-class-name: com.chivd.common.algorithm.TableShardingSampleAlgorithm\n```\n\n## 2.3、具体分片算法\n\n```java\npublic class TableShardingSampleAlgorithm implements ComplexKeysShardingAlgorithm<String> {  \n  \n    private static final String COLUMN_SAMPLE_UID = \"sample_uid\";  \n  \n    private static final String COLUMN_SUBMIT_TIME = \"submit_work_time\";  \n  \n    @Override  \n    public Collection<String> doSharding(Collection<String> collection, ComplexKeysShardingValue<String> complexKeysShardingValue) {  \n        // 逻辑表名  \n        String logicTableName = complexKeysShardingValue.getLogicTableName();  \n  \n        // 精准工单提交时间  \n        Collection<String> submitWorkTimeCollection = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SUBMIT_TIME, new ArrayList<>());  \n        ArrayList<String> submitWorkTimeList = new ArrayList<>(submitWorkTimeCollection);  \n        if (CollectionUtils.isNotEmpty(submitWorkTimeList)) {  \n            Set<String> set = new HashSet<>();  \n            for (int i = 0; i < submitWorkTimeList.size(); i++) {  \n                Date date = DateUtils.parseDate(submitWorkTimeList.get(i));  \n                StringBuffer tableName = new StringBuffer();  \n                tableName.append(logicTableName).append(\"_\").append(DateUtils.parseDateToStr(DateUtils.YYYYMM, date));  \n                set.add(tableName.toString());  \n            }  \n            return set;  \n        }  \n  \n        // 工单提交时间范围  \n        Range<String> submitWorkTimeRange = complexKeysShardingValue.getColumnNameAndRangeValuesMap().get(COLUMN_SUBMIT_TIME);  \n        if (submitWorkTimeRange != null) {  \n            // 实体表名集合  \n            Set<String> result = new HashSet<>();  \n            Date lowerDate = DateUtils.parseDate(submitWorkTimeRange.lowerEndpoint());  \n            Date upperDate = DateUtils.parseDate(submitWorkTimeRange.upperEndpoint());  \n            // 获取月份间隔  \n            int monthSpace = DateUtils.getMonthSpace(lowerDate, upperDate);  \n            // 获取所有的实体表名  \n            for (int i = 0; i < monthSpace; i++) {  \n                result.add(logicTableName + \"_\" + DateUtils.parseDateToStr(DateUtils.YYYYMM, lowerDate));  \n                lowerDate = DateUtils.addMonths(lowerDate, 1);  \n            }  \n            return result;  \n        }  \n  \n        // 样本uid  \n        Collection<String> testUids = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SAMPLE_UID, new ArrayList<>());  \n        if (CollectionUtils.isNotEmpty(testUids)) {  \n            return testUids.stream().map(uid -> {  \n                String[] split = uid.split(\"-\");  \n                StringBuffer tableName = new StringBuffer();  \n                tableName.append(logicTableName)  \n                        .append(\"_\")  \n                        .append(split[split.length - 1].substring(0,6));  \n                return tableName.toString();  \n            }).collect(Collectors.toSet());  \n        }  \n        return null;  \n    }  \n}\n```\n## 2.4、创建配置表\n\n配置表包含所有需要分表的逻辑表表名，分表开始年月等信息\n\n```sql\nCREATE TABLE `ims_sharding_config` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `table_name` varchar(100) DEFAULT NULL COMMENT '表名',\n  `start_year_month` varchar(20) DEFAULT NULL COMMENT '分表开始年月',\n  `comment` varchar(100) DEFAULT NULL COMMENT '备注',\n  `is_deleted` tinyint(4) DEFAULT '0' COMMENT '(0-未删除 1-删除)',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8mb4;\n```\n\n## 2.5、创建定时任务\n\n1. 启动时自动刷新actual-data-nodes节点\n2. 自动创建下月分表\n\n```java\n@Slf4j  \n@Component  \npublic class ShardingTableUtils {  \n    @Autowired  \n    DataSource dataSource;  \n  \n    @Autowired  \n    IShardingConfigService shardingConfigService;  \n  \n    /**  \n     * @Description 项目启动时刷新节点配置  \n     **/    \n     @PostConstruct  \n    public void startRefresh() {  \n        AutoCreateTable();  \n    }  \n  \n    /**  \n     * @Description 刷新actual-data-nodes节点配置  \n     **/    \n     public void actualTablesRefresh() {  \n        log.info(\"-------------- 开始刷新sharding配置 ---------------\");  \n        try {  \n            List<ShardingConfig> shardingConfigList = shardingConfigService.listShardingConfig();  \n            ShardingDataSource dataSource = (ShardingDataSource) this.dataSource;  \n            if (shardingConfigList == null || shardingConfigList.isEmpty()) {  \n                log.info(\"【sharding自动配置】配置表为空\");  \n                return;            }  \n            String curYearAndMonth = DateUtils.getYearAndMonth(DateUtils.monthAdd(new Date(),1).getTime());  \n            Field modifiersField = Field.class.getDeclaredField(\"modifiers\");  \n            modifiersField.setAccessible(true);  \n            for (ShardingConfig item : shardingConfigList) {  \n                TableRule tableRule = null;  \n                tableRule = dataSource.getRuntimeContext().getRule().getTableRule(item.getTableName());  \n                List<DataNode> dataNodes = tableRule.getActualDataNodes();  \n                String dataSourceName = dataNodes.get(0).getDataSourceName();  \n                List<String> monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  \n                List<DataNode> newDataNodes = monthBetween.stream()  \n                        .map(yearMonth -> new DataNode(dataSourceName + \".\" + item.getTableName()  \n                                + \"_\" + yearMonth)).collect(Collectors.toList());  \n                // 修改actualDataNodesField  \n                Field actualDataNodesField = TableRule.class.getDeclaredField(\"actualDataNodes\");  \n                actualDataNodesField.setAccessible(true);  \n                modifiersField.setInt(actualDataNodesField, actualDataNodesField.getModifiers() & ~Modifier.FINAL);  \n                actualDataNodesField.set(tableRule, newDataNodes);  \n                // 修改actualTablesField  \n                Set<String> actualTables = Sets.newHashSet();  \n                Map<DataNode, Integer> dataNodeIndexMap = Maps.newHashMap();  \n                AtomicInteger index = new AtomicInteger(0);  \n                newDataNodes.forEach(dataNode -> {  \n                    actualTables.add(dataNode.getTableName());  \n                    if (index.intValue() == 0) {  \n                        dataNodeIndexMap.put(dataNode, 0);  \n                    } else {  \n                        dataNodeIndexMap.put(dataNode, index.intValue());  \n                    }  \n                    index.incrementAndGet();  \n                });  \n                Field actualTablesField = TableRule.class.getDeclaredField(\"actualTables\");  \n                actualTablesField.setAccessible(true);  \n                actualTablesField.set(tableRule, actualTables);  \n                // 动态刷新 dataNodeIndexMapField                Field dataNodeIndexMapField = TableRule.class.getDeclaredField(\"dataNodeIndexMap\");  \n                dataNodeIndexMapField.setAccessible(true);  \n                dataNodeIndexMapField.set(tableRule, dataNodeIndexMap);  \n                // 动态刷新 datasourceToTablesMapField                Map<String, Collection<String>> datasourceToTablesMap = Maps.newHashMap();  \n                datasourceToTablesMap.put(dataSourceName, actualTables);  \n                Field datasourceToTablesMapField = TableRule.class.getDeclaredField(\"datasourceToTablesMap\");  \n                datasourceToTablesMapField.setAccessible(true);  \n                datasourceToTablesMapField.set(tableRule, datasourceToTablesMap);  \n            }  \n        } catch (Exception e) {  \n            e.printStackTrace();  \n            log.info(\"【sharding自动配置】异常\" + e.getMessage());  \n        }  \n    }  \n  \n    /**  \n     * @Description 自动创建不存在的表  \n     **/    \n     private void AutoCreateTable() {  \n        log.info(\"-------------- 开始创建分表 ---------------\");  \n        List<ShardingConfig> shardingConfigList = shardingConfigService.listShardingConfig();  \n        if (shardingConfigList == null || shardingConfigList.isEmpty()) {  \n            log.info(\"【sharding自动配置】配置表为空\");  \n            return;        }  \n        String curYearAndMonth = DateUtils.getYearAndMonth(DateUtils.monthAdd(new Date(),2).getTime());  \n        for (ShardingConfig item : shardingConfigList) {  \n            List<String> monthBetween = new ArrayList<>();  \n            try {  \n                monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  \n            } catch (ParseException e) {  \n                log.info(\"【sharding自动配置】日期转化失败\" + e.getMessage());  \n                e.printStackTrace();  \n            }  \n            // todo (CREATE TABLE if not exists xx like xxx 表存在会抛异常。为啥呢 这里先catch住让代码继续运行)  \n            monthBetween.forEach(yearMonth -> {  \n                try {  \n                    shardingConfigService.createTable(item.getTableName(), item.getTableName() + \"_\" + yearMonth);  \n                }catch (Exception ignored){}  \n            });  \n        }  \n        // 刷新配置  \n        actualTablesRefresh();  \n    }  \n  \n    /**  \n     * 获取两个月份之间的所有月份  \n     * @param minDate  \n     * @param maxDate  \n     * @return  \n     * @throws ParseException  \n     */    private static List<String> getMonthBetween(String minDate, String maxDate) throws ParseException {  \n        ArrayList<String> result = new ArrayList<>();  \n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyyMM\");//格式化为年月  \n  \n        Calendar min = Calendar.getInstance();  \n        Calendar max = Calendar.getInstance();  \n  \n        min.setTime(sdf.parse(minDate));  \n        min.set(min.get(Calendar.YEAR), min.get(Calendar.MONTH), 1);  \n  \n        max.setTime(sdf.parse(maxDate));  \n        max.set(max.get(Calendar.YEAR), max.get(Calendar.MONTH), 2);  \n  \n        Calendar curr = min;  \n        while (curr.before(max)) {  \n            result.add(sdf.format(curr.getTime()));  \n            curr.add(Calendar.MONTH, 1);  \n        }  \n        return result;  \n    }  \n  \n    /**  \n     * 每月27号1点自动刷新配置节点  \n     */  \n    @Scheduled(cron = \"0 0 1 27 * ?\")  \n    public void refreshScheduled() {  \n        AutoCreateTable();  \n    }  \n}\n```","slug":"sharding-jdbc实现自动按月分表","published":1,"updated":"2023-10-19T12:57:37.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9q000v00uj153x394f","content":"<h1 id=\"1、基本需求\"><a href=\"#1、基本需求\" class=\"headerlink\" title=\"1、基本需求\"></a>1、基本需求</h1><p>1、 项目中我们希望 能够按照时间、类别来添加表。但是sharding-jdbc 是固定配置 的 actual-data-nodes 参数。也就是说我们需要提前创建好分表或者分库。那么我们需要如何来实现动态创建表，并且动态刷新 actual-data-nodes 呢。</p>\n<p>2、思路就是写个定时器来动态创建表 ，在创建表的时候 动态刷新 actual-data-nodes 实现动态创建表被shard加载。</p>\n<h1 id=\"2、功能实现\"><a href=\"#2、功能实现\" class=\"headerlink\" title=\"2、功能实现\"></a>2、功能实现</h1><h2 id=\"2-1、添加依赖\"><a href=\"#2-1、添加依赖\" class=\"headerlink\" title=\"2.1、添加依赖\"></a>2.1、添加依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shardingsphere<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0-RC1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shardingsphere<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sharding-jdbc-spring-namespace<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0-RC1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-2、yml配置\"><a href=\"#2-2、yml配置\" class=\"headerlink\" title=\"2.2、yml配置\"></a>2.2、yml配置</h2><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sharding:</span>  </span><br><span class=\"line\">    <span class=\"comment\"># 配置绑定表  </span></span><br><span class=\"line\">    <span class=\"string\">binding-tables[0]:</span> <span class=\"string\">ims_test_result,ims_test_sample_fetch,ims_test_sample_diluent,ims_test_reagent_add,ims_test_ls_add,ims_test_incubate,ims_test_read</span>  </span><br><span class=\"line\">    <span class=\"attr\">tables:</span>  </span><br><span class=\"line\">\t\t<span class=\"attr\">ims_sample_base:</span>  </span><br><span class=\"line\">\t\t    <span class=\"attr\">actual-data-nodes:</span> <span class=\"string\">m1.sharding_data_nodes_2022</span>  </span><br><span class=\"line\">\t\t    <span class=\"attr\">key-generator:</span>  </span><br><span class=\"line\">\t\t        <span class=\"attr\">column:</span> <span class=\"string\">id</span>  </span><br><span class=\"line\">\t\t        <span class=\"attr\">type:</span> <span class=\"string\">SNOWFLAKE</span>  </span><br><span class=\"line\">\t\t        <span class=\"attr\">props:</span>  </span><br><span class=\"line\">\t\t            <span class=\"attr\">worker.id:</span> <span class=\"string\">$&#123;workerId&#125;</span>  </span><br><span class=\"line\">\t\t    <span class=\"attr\">table-strategy:</span>  </span><br><span class=\"line\">\t\t        <span class=\"attr\">complex:</span>  </span><br><span class=\"line\">\t\t            <span class=\"attr\">sharding-columns:</span> <span class=\"string\">submit_work_time,sample_uid</span>  </span><br><span class=\"line\">\t\t\t            <span class=\"attr\">algorithm-class-name:</span> <span class=\"string\">com.chivd.common.algorithm.TableShardingSampleAlgorithm</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3、具体分片算法\"><a href=\"#2-3、具体分片算法\" class=\"headerlink\" title=\"2.3、具体分片算法\"></a>2.3、具体分片算法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TableShardingSampleAlgorithm</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ComplexKeysShardingAlgorithm</span>&lt;String&gt; &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">COLUMN_SAMPLE_UID</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_uid&quot;</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">COLUMN_SUBMIT_TIME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;submit_work_time&quot;</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Collection&lt;String&gt; <span class=\"title function_\">doSharding</span><span class=\"params\">(Collection&lt;String&gt; collection, ComplexKeysShardingValue&lt;String&gt; complexKeysShardingValue)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 逻辑表名  </span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">logicTableName</span> <span class=\"operator\">=</span> complexKeysShardingValue.getLogicTableName();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 精准工单提交时间  </span></span><br><span class=\"line\">        Collection&lt;String&gt; submitWorkTimeCollection = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SUBMIT_TIME, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());  </span><br><span class=\"line\">        ArrayList&lt;String&gt; submitWorkTimeList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(submitWorkTimeCollection);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CollectionUtils.isNotEmpty(submitWorkTimeList)) &#123;  </span><br><span class=\"line\">            Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; submitWorkTimeList.size(); i++) &#123;  </span><br><span class=\"line\">                <span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> DateUtils.parseDate(submitWorkTimeList.get(i));  </span><br><span class=\"line\">                <span class=\"type\">StringBuffer</span> <span class=\"variable\">tableName</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();  </span><br><span class=\"line\">                tableName.append(logicTableName).append(<span class=\"string\">&quot;_&quot;</span>).append(DateUtils.parseDateToStr(DateUtils.YYYYMM, date));  </span><br><span class=\"line\">                set.add(tableName.toString());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> set;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 工单提交时间范围  </span></span><br><span class=\"line\">        Range&lt;String&gt; submitWorkTimeRange = complexKeysShardingValue.getColumnNameAndRangeValuesMap().get(COLUMN_SUBMIT_TIME);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (submitWorkTimeRange != <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 实体表名集合  </span></span><br><span class=\"line\">            Set&lt;String&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"type\">Date</span> <span class=\"variable\">lowerDate</span> <span class=\"operator\">=</span> DateUtils.parseDate(submitWorkTimeRange.lowerEndpoint());  </span><br><span class=\"line\">            <span class=\"type\">Date</span> <span class=\"variable\">upperDate</span> <span class=\"operator\">=</span> DateUtils.parseDate(submitWorkTimeRange.upperEndpoint());  </span><br><span class=\"line\">            <span class=\"comment\">// 获取月份间隔  </span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">monthSpace</span> <span class=\"operator\">=</span> DateUtils.getMonthSpace(lowerDate, upperDate);  </span><br><span class=\"line\">            <span class=\"comment\">// 获取所有的实体表名  </span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; monthSpace; i++) &#123;  </span><br><span class=\"line\">                result.add(logicTableName + <span class=\"string\">&quot;_&quot;</span> + DateUtils.parseDateToStr(DateUtils.YYYYMM, lowerDate));  </span><br><span class=\"line\">                lowerDate = DateUtils.addMonths(lowerDate, <span class=\"number\">1</span>);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 样本uid  </span></span><br><span class=\"line\">        Collection&lt;String&gt; testUids = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SAMPLE_UID, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CollectionUtils.isNotEmpty(testUids)) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> testUids.stream().map(uid -&gt; &#123;  </span><br><span class=\"line\">                String[] split = uid.split(<span class=\"string\">&quot;-&quot;</span>);  </span><br><span class=\"line\">                <span class=\"type\">StringBuffer</span> <span class=\"variable\">tableName</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();  </span><br><span class=\"line\">                tableName.append(logicTableName)  </span><br><span class=\"line\">                        .append(<span class=\"string\">&quot;_&quot;</span>)  </span><br><span class=\"line\">                        .append(split[split.length - <span class=\"number\">1</span>].substring(<span class=\"number\">0</span>,<span class=\"number\">6</span>));  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> tableName.toString();  </span><br><span class=\"line\">            &#125;).collect(Collectors.toSet());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4、创建配置表\"><a href=\"#2-4、创建配置表\" class=\"headerlink\" title=\"2.4、创建配置表\"></a>2.4、创建配置表</h2><p>配置表包含所有需要分表的逻辑表表名，分表开始年月等信息</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `ims_sharding_config` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  `table_name` <span class=\"type\">varchar</span>(<span class=\"number\">100</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;表名&#x27;</span>,</span><br><span class=\"line\">  `start_year_month` <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;分表开始年月&#x27;</span>,</span><br><span class=\"line\">  `comment` <span class=\"type\">varchar</span>(<span class=\"number\">100</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;备注&#x27;</span>,</span><br><span class=\"line\">  `is_deleted` tinyint(<span class=\"number\">4</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;(0-未删除 1-删除)&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">21</span> <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5、创建定时任务\"><a href=\"#2-5、创建定时任务\" class=\"headerlink\" title=\"2.5、创建定时任务\"></a>2.5、创建定时任务</h2><ol>\n<li>启动时自动刷新actual-data-nodes节点</li>\n<li>自动创建下月分表</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span>  </span><br><span class=\"line\"><span class=\"meta\">@Component</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ShardingTableUtils</span> &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    DataSource dataSource;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    IShardingConfigService shardingConfigService;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 项目启动时刷新节点配置  </span></span><br><span class=\"line\"><span class=\"comment\">     **/</span>    </span><br><span class=\"line\">     <span class=\"meta\">@PostConstruct</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startRefresh</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        AutoCreateTable();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 刷新actual-data-nodes节点配置  </span></span><br><span class=\"line\"><span class=\"comment\">     **/</span>    </span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">actualTablesRefresh</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;-------------- 开始刷新sharding配置 ---------------&quot;</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            List&lt;ShardingConfig&gt; shardingConfigList = shardingConfigService.listShardingConfig();  </span><br><span class=\"line\">            <span class=\"type\">ShardingDataSource</span> <span class=\"variable\">dataSource</span> <span class=\"operator\">=</span> (ShardingDataSource) <span class=\"built_in\">this</span>.dataSource;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shardingConfigList == <span class=\"literal\">null</span> || shardingConfigList.isEmpty()) &#123;  </span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;【sharding自动配置】配置表为空&quot;</span>);  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;            &#125;  </span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">curYearAndMonth</span> <span class=\"operator\">=</span> DateUtils.getYearAndMonth(DateUtils.monthAdd(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(),<span class=\"number\">1</span>).getTime());  </span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">modifiersField</span> <span class=\"operator\">=</span> Field.class.getDeclaredField(<span class=\"string\">&quot;modifiers&quot;</span>);  </span><br><span class=\"line\">            modifiersField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ShardingConfig item : shardingConfigList) &#123;  </span><br><span class=\"line\">                <span class=\"type\">TableRule</span> <span class=\"variable\">tableRule</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">                tableRule = dataSource.getRuntimeContext().getRule().getTableRule(item.getTableName());  </span><br><span class=\"line\">                List&lt;DataNode&gt; dataNodes = tableRule.getActualDataNodes();  </span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">dataSourceName</span> <span class=\"operator\">=</span> dataNodes.get(<span class=\"number\">0</span>).getDataSourceName();  </span><br><span class=\"line\">                List&lt;String&gt; monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  </span><br><span class=\"line\">                List&lt;DataNode&gt; newDataNodes = monthBetween.stream()  </span><br><span class=\"line\">                        .map(yearMonth -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">DataNode</span>(dataSourceName + <span class=\"string\">&quot;.&quot;</span> + item.getTableName()  </span><br><span class=\"line\">                                + <span class=\"string\">&quot;_&quot;</span> + yearMonth)).collect(Collectors.toList());  </span><br><span class=\"line\">                <span class=\"comment\">// 修改actualDataNodesField  </span></span><br><span class=\"line\">                <span class=\"type\">Field</span> <span class=\"variable\">actualDataNodesField</span> <span class=\"operator\">=</span> TableRule.class.getDeclaredField(<span class=\"string\">&quot;actualDataNodes&quot;</span>);  </span><br><span class=\"line\">                actualDataNodesField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">                modifiersField.setInt(actualDataNodesField, actualDataNodesField.getModifiers() &amp; ~Modifier.FINAL);  </span><br><span class=\"line\">                actualDataNodesField.set(tableRule, newDataNodes);  </span><br><span class=\"line\">                <span class=\"comment\">// 修改actualTablesField  </span></span><br><span class=\"line\">                Set&lt;String&gt; actualTables = Sets.newHashSet();  </span><br><span class=\"line\">                Map&lt;DataNode, Integer&gt; dataNodeIndexMap = Maps.newHashMap();  </span><br><span class=\"line\">                <span class=\"type\">AtomicInteger</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);  </span><br><span class=\"line\">                newDataNodes.forEach(dataNode -&gt; &#123;  </span><br><span class=\"line\">                    actualTables.add(dataNode.getTableName());  </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (index.intValue() == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">                        dataNodeIndexMap.put(dataNode, <span class=\"number\">0</span>);  </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                        dataNodeIndexMap.put(dataNode, index.intValue());  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    index.incrementAndGet();  </span><br><span class=\"line\">                &#125;);  </span><br><span class=\"line\">                <span class=\"type\">Field</span> <span class=\"variable\">actualTablesField</span> <span class=\"operator\">=</span> TableRule.class.getDeclaredField(<span class=\"string\">&quot;actualTables&quot;</span>);  </span><br><span class=\"line\">                actualTablesField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">                actualTablesField.set(tableRule, actualTables);  </span><br><span class=\"line\">                <span class=\"comment\">// 动态刷新 dataNodeIndexMapField                Field dataNodeIndexMapField = TableRule.class.getDeclaredField(&quot;dataNodeIndexMap&quot;);  </span></span><br><span class=\"line\">                dataNodeIndexMapField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">                dataNodeIndexMapField.set(tableRule, dataNodeIndexMap);  </span><br><span class=\"line\">                <span class=\"comment\">// 动态刷新 datasourceToTablesMapField                Map&lt;String, Collection&lt;String&gt;&gt; datasourceToTablesMap = Maps.newHashMap();  </span></span><br><span class=\"line\">                datasourceToTablesMap.put(dataSourceName, actualTables);  </span><br><span class=\"line\">                <span class=\"type\">Field</span> <span class=\"variable\">datasourceToTablesMapField</span> <span class=\"operator\">=</span> TableRule.class.getDeclaredField(<span class=\"string\">&quot;datasourceToTablesMap&quot;</span>);  </span><br><span class=\"line\">                datasourceToTablesMapField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">                datasourceToTablesMapField.set(tableRule, datasourceToTablesMap);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;【sharding自动配置】异常&quot;</span> + e.getMessage());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 自动创建不存在的表  </span></span><br><span class=\"line\"><span class=\"comment\">     **/</span>    </span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">AutoCreateTable</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;-------------- 开始创建分表 ---------------&quot;</span>);  </span><br><span class=\"line\">        List&lt;ShardingConfig&gt; shardingConfigList = shardingConfigService.listShardingConfig();  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shardingConfigList == <span class=\"literal\">null</span> || shardingConfigList.isEmpty()) &#123;  </span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;【sharding自动配置】配置表为空&quot;</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;        &#125;  </span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">curYearAndMonth</span> <span class=\"operator\">=</span> DateUtils.getYearAndMonth(DateUtils.monthAdd(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(),<span class=\"number\">2</span>).getTime());  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ShardingConfig item : shardingConfigList) &#123;  </span><br><span class=\"line\">            List&lt;String&gt; monthBetween = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">                monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ParseException e) &#123;  </span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;【sharding自动配置】日期转化失败&quot;</span> + e.getMessage());  </span><br><span class=\"line\">                e.printStackTrace();  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// todo (CREATE TABLE if not exists xx like xxx 表存在会抛异常。为啥呢 这里先catch住让代码继续运行)  </span></span><br><span class=\"line\">            monthBetween.forEach(yearMonth -&gt; &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">                    shardingConfigService.createTable(item.getTableName(), item.getTableName() + <span class=\"string\">&quot;_&quot;</span> + yearMonth);  </span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span> (Exception ignored)&#123;&#125;  </span><br><span class=\"line\">            &#125;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 刷新配置  </span></span><br><span class=\"line\">        actualTablesRefresh();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 获取两个月份之间的所有月份  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minDate  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maxDate  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> ParseException  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title function_\">getMonthBetween</span><span class=\"params\">(String minDate, String maxDate)</span> <span class=\"keyword\">throws</span> ParseException &#123;  </span><br><span class=\"line\">        ArrayList&lt;String&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">        <span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">sdf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;yyyyMM&quot;</span>);<span class=\"comment\">//格式化为年月  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"type\">Calendar</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Calendar.getInstance();  </span><br><span class=\"line\">        <span class=\"type\">Calendar</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Calendar.getInstance();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        min.setTime(sdf.parse(minDate));  </span><br><span class=\"line\">        min.set(min.get(Calendar.YEAR), min.get(Calendar.MONTH), <span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        max.setTime(sdf.parse(maxDate));  </span><br><span class=\"line\">        max.set(max.get(Calendar.YEAR), max.get(Calendar.MONTH), <span class=\"number\">2</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"type\">Calendar</span> <span class=\"variable\">curr</span> <span class=\"operator\">=</span> min;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curr.before(max)) &#123;  </span><br><span class=\"line\">            result.add(sdf.format(curr.getTime()));  </span><br><span class=\"line\">            curr.add(Calendar.MONTH, <span class=\"number\">1</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 每月27号1点自动刷新配置节点  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(cron = &quot;0 0 1 27 * ?&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refreshScheduled</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        AutoCreateTable();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、基本需求\"><a href=\"#1、基本需求\" class=\"headerlink\" title=\"1、基本需求\"></a>1、基本需求</h1><p>1、 项目中我们希望 能够按照时间、类别来添加表。但是sharding-jdbc 是固定配置 的 actual-data-nodes 参数。也就是说我们需要提前创建好分表或者分库。那么我们需要如何来实现动态创建表，并且动态刷新 actual-data-nodes 呢。</p>\n<p>2、思路就是写个定时器来动态创建表 ，在创建表的时候 动态刷新 actual-data-nodes 实现动态创建表被shard加载。</p>\n<h1 id=\"2、功能实现\"><a href=\"#2、功能实现\" class=\"headerlink\" title=\"2、功能实现\"></a>2、功能实现</h1><h2 id=\"2-1、添加依赖\"><a href=\"#2-1、添加依赖\" class=\"headerlink\" title=\"2.1、添加依赖\"></a>2.1、添加依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shardingsphere<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0-RC1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.shardingsphere<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>sharding-jdbc-spring-namespace<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>4.0.0-RC1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"2-2、yml配置\"><a href=\"#2-2、yml配置\" class=\"headerlink\" title=\"2.2、yml配置\"></a>2.2、yml配置</h2><figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">sharding:</span>  </span><br><span class=\"line\">    <span class=\"comment\"># 配置绑定表  </span></span><br><span class=\"line\">    <span class=\"string\">binding-tables[0]:</span> <span class=\"string\">ims_test_result,ims_test_sample_fetch,ims_test_sample_diluent,ims_test_reagent_add,ims_test_ls_add,ims_test_incubate,ims_test_read</span>  </span><br><span class=\"line\">    <span class=\"attr\">tables:</span>  </span><br><span class=\"line\">\t\t<span class=\"attr\">ims_sample_base:</span>  </span><br><span class=\"line\">\t\t    <span class=\"attr\">actual-data-nodes:</span> <span class=\"string\">m1.sharding_data_nodes_2022</span>  </span><br><span class=\"line\">\t\t    <span class=\"attr\">key-generator:</span>  </span><br><span class=\"line\">\t\t        <span class=\"attr\">column:</span> <span class=\"string\">id</span>  </span><br><span class=\"line\">\t\t        <span class=\"attr\">type:</span> <span class=\"string\">SNOWFLAKE</span>  </span><br><span class=\"line\">\t\t        <span class=\"attr\">props:</span>  </span><br><span class=\"line\">\t\t            <span class=\"attr\">worker.id:</span> <span class=\"string\">$&#123;workerId&#125;</span>  </span><br><span class=\"line\">\t\t    <span class=\"attr\">table-strategy:</span>  </span><br><span class=\"line\">\t\t        <span class=\"attr\">complex:</span>  </span><br><span class=\"line\">\t\t            <span class=\"attr\">sharding-columns:</span> <span class=\"string\">submit_work_time,sample_uid</span>  </span><br><span class=\"line\">\t\t\t            <span class=\"attr\">algorithm-class-name:</span> <span class=\"string\">com.chivd.common.algorithm.TableShardingSampleAlgorithm</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-3、具体分片算法\"><a href=\"#2-3、具体分片算法\" class=\"headerlink\" title=\"2.3、具体分片算法\"></a>2.3、具体分片算法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TableShardingSampleAlgorithm</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">ComplexKeysShardingAlgorithm</span>&lt;String&gt; &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">COLUMN_SAMPLE_UID</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;sample_uid&quot;</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"type\">String</span> <span class=\"variable\">COLUMN_SUBMIT_TIME</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;submit_work_time&quot;</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Collection&lt;String&gt; <span class=\"title function_\">doSharding</span><span class=\"params\">(Collection&lt;String&gt; collection, ComplexKeysShardingValue&lt;String&gt; complexKeysShardingValue)</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// 逻辑表名  </span></span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">logicTableName</span> <span class=\"operator\">=</span> complexKeysShardingValue.getLogicTableName();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 精准工单提交时间  </span></span><br><span class=\"line\">        Collection&lt;String&gt; submitWorkTimeCollection = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SUBMIT_TIME, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());  </span><br><span class=\"line\">        ArrayList&lt;String&gt; submitWorkTimeList = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;(submitWorkTimeCollection);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CollectionUtils.isNotEmpty(submitWorkTimeList)) &#123;  </span><br><span class=\"line\">            Set&lt;String&gt; set = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; submitWorkTimeList.size(); i++) &#123;  </span><br><span class=\"line\">                <span class=\"type\">Date</span> <span class=\"variable\">date</span> <span class=\"operator\">=</span> DateUtils.parseDate(submitWorkTimeList.get(i));  </span><br><span class=\"line\">                <span class=\"type\">StringBuffer</span> <span class=\"variable\">tableName</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();  </span><br><span class=\"line\">                tableName.append(logicTableName).append(<span class=\"string\">&quot;_&quot;</span>).append(DateUtils.parseDateToStr(DateUtils.YYYYMM, date));  </span><br><span class=\"line\">                set.add(tableName.toString());  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> set;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 工单提交时间范围  </span></span><br><span class=\"line\">        Range&lt;String&gt; submitWorkTimeRange = complexKeysShardingValue.getColumnNameAndRangeValuesMap().get(COLUMN_SUBMIT_TIME);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (submitWorkTimeRange != <span class=\"literal\">null</span>) &#123;  </span><br><span class=\"line\">            <span class=\"comment\">// 实体表名集合  </span></span><br><span class=\"line\">            Set&lt;String&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">HashSet</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"type\">Date</span> <span class=\"variable\">lowerDate</span> <span class=\"operator\">=</span> DateUtils.parseDate(submitWorkTimeRange.lowerEndpoint());  </span><br><span class=\"line\">            <span class=\"type\">Date</span> <span class=\"variable\">upperDate</span> <span class=\"operator\">=</span> DateUtils.parseDate(submitWorkTimeRange.upperEndpoint());  </span><br><span class=\"line\">            <span class=\"comment\">// 获取月份间隔  </span></span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">monthSpace</span> <span class=\"operator\">=</span> DateUtils.getMonthSpace(lowerDate, upperDate);  </span><br><span class=\"line\">            <span class=\"comment\">// 获取所有的实体表名  </span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; monthSpace; i++) &#123;  </span><br><span class=\"line\">                result.add(logicTableName + <span class=\"string\">&quot;_&quot;</span> + DateUtils.parseDateToStr(DateUtils.YYYYMM, lowerDate));  </span><br><span class=\"line\">                lowerDate = DateUtils.addMonths(lowerDate, <span class=\"number\">1</span>);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"comment\">// 样本uid  </span></span><br><span class=\"line\">        Collection&lt;String&gt; testUids = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SAMPLE_UID, <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;());  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CollectionUtils.isNotEmpty(testUids)) &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">return</span> testUids.stream().map(uid -&gt; &#123;  </span><br><span class=\"line\">                String[] split = uid.split(<span class=\"string\">&quot;-&quot;</span>);  </span><br><span class=\"line\">                <span class=\"type\">StringBuffer</span> <span class=\"variable\">tableName</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">StringBuffer</span>();  </span><br><span class=\"line\">                tableName.append(logicTableName)  </span><br><span class=\"line\">                        .append(<span class=\"string\">&quot;_&quot;</span>)  </span><br><span class=\"line\">                        .append(split[split.length - <span class=\"number\">1</span>].substring(<span class=\"number\">0</span>,<span class=\"number\">6</span>));  </span><br><span class=\"line\">                <span class=\"keyword\">return</span> tableName.toString();  </span><br><span class=\"line\">            &#125;).collect(Collectors.toSet());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"2-4、创建配置表\"><a href=\"#2-4、创建配置表\" class=\"headerlink\" title=\"2.4、创建配置表\"></a>2.4、创建配置表</h2><p>配置表包含所有需要分表的逻辑表表名，分表开始年月等信息</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `ims_sharding_config` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  `table_name` <span class=\"type\">varchar</span>(<span class=\"number\">100</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;表名&#x27;</span>,</span><br><span class=\"line\">  `start_year_month` <span class=\"type\">varchar</span>(<span class=\"number\">20</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;分表开始年月&#x27;</span>,</span><br><span class=\"line\">  `comment` <span class=\"type\">varchar</span>(<span class=\"number\">100</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;备注&#x27;</span>,</span><br><span class=\"line\">  `is_deleted` tinyint(<span class=\"number\">4</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;(0-未删除 1-删除)&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">21</span> <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-5、创建定时任务\"><a href=\"#2-5、创建定时任务\" class=\"headerlink\" title=\"2.5、创建定时任务\"></a>2.5、创建定时任务</h2><ol>\n<li>启动时自动刷新actual-data-nodes节点</li>\n<li>自动创建下月分表</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Slf4j</span>  </span><br><span class=\"line\"><span class=\"meta\">@Component</span>  </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ShardingTableUtils</span> &#123;  </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    DataSource dataSource;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span>  </span><br><span class=\"line\">    IShardingConfigService shardingConfigService;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 项目启动时刷新节点配置  </span></span><br><span class=\"line\"><span class=\"comment\">     **/</span>    </span><br><span class=\"line\">     <span class=\"meta\">@PostConstruct</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">startRefresh</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        AutoCreateTable();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 刷新actual-data-nodes节点配置  </span></span><br><span class=\"line\"><span class=\"comment\">     **/</span>    </span><br><span class=\"line\">     <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">actualTablesRefresh</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;-------------- 开始刷新sharding配置 ---------------&quot;</span>);  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            List&lt;ShardingConfig&gt; shardingConfigList = shardingConfigService.listShardingConfig();  </span><br><span class=\"line\">            <span class=\"type\">ShardingDataSource</span> <span class=\"variable\">dataSource</span> <span class=\"operator\">=</span> (ShardingDataSource) <span class=\"built_in\">this</span>.dataSource;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (shardingConfigList == <span class=\"literal\">null</span> || shardingConfigList.isEmpty()) &#123;  </span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;【sharding自动配置】配置表为空&quot;</span>);  </span><br><span class=\"line\">                <span class=\"keyword\">return</span>;            &#125;  </span><br><span class=\"line\">            <span class=\"type\">String</span> <span class=\"variable\">curYearAndMonth</span> <span class=\"operator\">=</span> DateUtils.getYearAndMonth(DateUtils.monthAdd(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(),<span class=\"number\">1</span>).getTime());  </span><br><span class=\"line\">            <span class=\"type\">Field</span> <span class=\"variable\">modifiersField</span> <span class=\"operator\">=</span> Field.class.getDeclaredField(<span class=\"string\">&quot;modifiers&quot;</span>);  </span><br><span class=\"line\">            modifiersField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (ShardingConfig item : shardingConfigList) &#123;  </span><br><span class=\"line\">                <span class=\"type\">TableRule</span> <span class=\"variable\">tableRule</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;  </span><br><span class=\"line\">                tableRule = dataSource.getRuntimeContext().getRule().getTableRule(item.getTableName());  </span><br><span class=\"line\">                List&lt;DataNode&gt; dataNodes = tableRule.getActualDataNodes();  </span><br><span class=\"line\">                <span class=\"type\">String</span> <span class=\"variable\">dataSourceName</span> <span class=\"operator\">=</span> dataNodes.get(<span class=\"number\">0</span>).getDataSourceName();  </span><br><span class=\"line\">                List&lt;String&gt; monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  </span><br><span class=\"line\">                List&lt;DataNode&gt; newDataNodes = monthBetween.stream()  </span><br><span class=\"line\">                        .map(yearMonth -&gt; <span class=\"keyword\">new</span> <span class=\"title class_\">DataNode</span>(dataSourceName + <span class=\"string\">&quot;.&quot;</span> + item.getTableName()  </span><br><span class=\"line\">                                + <span class=\"string\">&quot;_&quot;</span> + yearMonth)).collect(Collectors.toList());  </span><br><span class=\"line\">                <span class=\"comment\">// 修改actualDataNodesField  </span></span><br><span class=\"line\">                <span class=\"type\">Field</span> <span class=\"variable\">actualDataNodesField</span> <span class=\"operator\">=</span> TableRule.class.getDeclaredField(<span class=\"string\">&quot;actualDataNodes&quot;</span>);  </span><br><span class=\"line\">                actualDataNodesField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">                modifiersField.setInt(actualDataNodesField, actualDataNodesField.getModifiers() &amp; ~Modifier.FINAL);  </span><br><span class=\"line\">                actualDataNodesField.set(tableRule, newDataNodes);  </span><br><span class=\"line\">                <span class=\"comment\">// 修改actualTablesField  </span></span><br><span class=\"line\">                Set&lt;String&gt; actualTables = Sets.newHashSet();  </span><br><span class=\"line\">                Map&lt;DataNode, Integer&gt; dataNodeIndexMap = Maps.newHashMap();  </span><br><span class=\"line\">                <span class=\"type\">AtomicInteger</span> <span class=\"variable\">index</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">AtomicInteger</span>(<span class=\"number\">0</span>);  </span><br><span class=\"line\">                newDataNodes.forEach(dataNode -&gt; &#123;  </span><br><span class=\"line\">                    actualTables.add(dataNode.getTableName());  </span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (index.intValue() == <span class=\"number\">0</span>) &#123;  </span><br><span class=\"line\">                        dataNodeIndexMap.put(dataNode, <span class=\"number\">0</span>);  </span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">                        dataNodeIndexMap.put(dataNode, index.intValue());  </span><br><span class=\"line\">                    &#125;  </span><br><span class=\"line\">                    index.incrementAndGet();  </span><br><span class=\"line\">                &#125;);  </span><br><span class=\"line\">                <span class=\"type\">Field</span> <span class=\"variable\">actualTablesField</span> <span class=\"operator\">=</span> TableRule.class.getDeclaredField(<span class=\"string\">&quot;actualTables&quot;</span>);  </span><br><span class=\"line\">                actualTablesField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">                actualTablesField.set(tableRule, actualTables);  </span><br><span class=\"line\">                <span class=\"comment\">// 动态刷新 dataNodeIndexMapField                Field dataNodeIndexMapField = TableRule.class.getDeclaredField(&quot;dataNodeIndexMap&quot;);  </span></span><br><span class=\"line\">                dataNodeIndexMapField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">                dataNodeIndexMapField.set(tableRule, dataNodeIndexMap);  </span><br><span class=\"line\">                <span class=\"comment\">// 动态刷新 datasourceToTablesMapField                Map&lt;String, Collection&lt;String&gt;&gt; datasourceToTablesMap = Maps.newHashMap();  </span></span><br><span class=\"line\">                datasourceToTablesMap.put(dataSourceName, actualTables);  </span><br><span class=\"line\">                <span class=\"type\">Field</span> <span class=\"variable\">datasourceToTablesMapField</span> <span class=\"operator\">=</span> TableRule.class.getDeclaredField(<span class=\"string\">&quot;datasourceToTablesMap&quot;</span>);  </span><br><span class=\"line\">                datasourceToTablesMapField.setAccessible(<span class=\"literal\">true</span>);  </span><br><span class=\"line\">                datasourceToTablesMapField.set(tableRule, datasourceToTablesMap);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;【sharding自动配置】异常&quot;</span> + e.getMessage());  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@Description</span> 自动创建不存在的表  </span></span><br><span class=\"line\"><span class=\"comment\">     **/</span>    </span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title function_\">AutoCreateTable</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;-------------- 开始创建分表 ---------------&quot;</span>);  </span><br><span class=\"line\">        List&lt;ShardingConfig&gt; shardingConfigList = shardingConfigService.listShardingConfig();  </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (shardingConfigList == <span class=\"literal\">null</span> || shardingConfigList.isEmpty()) &#123;  </span><br><span class=\"line\">            log.info(<span class=\"string\">&quot;【sharding自动配置】配置表为空&quot;</span>);  </span><br><span class=\"line\">            <span class=\"keyword\">return</span>;        &#125;  </span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">curYearAndMonth</span> <span class=\"operator\">=</span> DateUtils.getYearAndMonth(DateUtils.monthAdd(<span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>(),<span class=\"number\">2</span>).getTime());  </span><br><span class=\"line\">        <span class=\"keyword\">for</span> (ShardingConfig item : shardingConfigList) &#123;  </span><br><span class=\"line\">            List&lt;String&gt; monthBetween = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">                monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (ParseException e) &#123;  </span><br><span class=\"line\">                log.info(<span class=\"string\">&quot;【sharding自动配置】日期转化失败&quot;</span> + e.getMessage());  </span><br><span class=\"line\">                e.printStackTrace();  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"comment\">// todo (CREATE TABLE if not exists xx like xxx 表存在会抛异常。为啥呢 这里先catch住让代码继续运行)  </span></span><br><span class=\"line\">            monthBetween.forEach(yearMonth -&gt; &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">                    shardingConfigService.createTable(item.getTableName(), item.getTableName() + <span class=\"string\">&quot;_&quot;</span> + yearMonth);  </span><br><span class=\"line\">                &#125;<span class=\"keyword\">catch</span> (Exception ignored)&#123;&#125;  </span><br><span class=\"line\">            &#125;);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"comment\">// 刷新配置  </span></span><br><span class=\"line\">        actualTablesRefresh();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 获取两个月份之间的所有月份  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> minDate  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> maxDate  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span>  </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> ParseException  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; <span class=\"title function_\">getMonthBetween</span><span class=\"params\">(String minDate, String maxDate)</span> <span class=\"keyword\">throws</span> ParseException &#123;  </span><br><span class=\"line\">        ArrayList&lt;String&gt; result = <span class=\"keyword\">new</span> <span class=\"title class_\">ArrayList</span>&lt;&gt;();  </span><br><span class=\"line\">        <span class=\"type\">SimpleDateFormat</span> <span class=\"variable\">sdf</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SimpleDateFormat</span>(<span class=\"string\">&quot;yyyyMM&quot;</span>);<span class=\"comment\">//格式化为年月  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"type\">Calendar</span> <span class=\"variable\">min</span> <span class=\"operator\">=</span> Calendar.getInstance();  </span><br><span class=\"line\">        <span class=\"type\">Calendar</span> <span class=\"variable\">max</span> <span class=\"operator\">=</span> Calendar.getInstance();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        min.setTime(sdf.parse(minDate));  </span><br><span class=\"line\">        min.set(min.get(Calendar.YEAR), min.get(Calendar.MONTH), <span class=\"number\">1</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        max.setTime(sdf.parse(maxDate));  </span><br><span class=\"line\">        max.set(max.get(Calendar.YEAR), max.get(Calendar.MONTH), <span class=\"number\">2</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"type\">Calendar</span> <span class=\"variable\">curr</span> <span class=\"operator\">=</span> min;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curr.before(max)) &#123;  </span><br><span class=\"line\">            result.add(sdf.format(curr.getTime()));  </span><br><span class=\"line\">            curr.add(Calendar.MONTH, <span class=\"number\">1</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/**  </span></span><br><span class=\"line\"><span class=\"comment\">     * 每月27号1点自动刷新配置节点  </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(cron = &quot;0 0 1 27 * ?&quot;)</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">refreshScheduled</span><span class=\"params\">()</span> &#123;  </span><br><span class=\"line\">        AutoCreateTable();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"springCloud","date":"2023-07-28T16:00:00.000Z","abbrlink":26325,"_content":"#  1、微服务架构\n## 1.1、基本概念\n微服务是一种架构，这种架构是将单个整体应用程序分割成更小的项目关联的独立服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现，这些独立的微服务\n\n## 1.2、为什么要用微服务？\n### 1.2.1、优点\n\n1. 将服务拆分成单一职责的小服务，进行单独部署，服务之间通过网络进行通信\n2. 每个服务应该有自己的管理团队，高度自治\n3. 服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃\n\n### 1.2.2、缺点\n\n1. 开发人员需要处理分布式系统的复杂性\n2. 随着服务的增加，运维的压力也在增大\n3. 服务治理（负载均衡，服务熔断，服务配置管理）和服务监控\n\n## 1.3、架构的演变\n\n### 1.3.1、单一架构（all in one）\n一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(**ORM**)是影响项目开发的关键（mybatis，hibernate）\n\n> 缺点：随着应用功能的增多，代码量越来越大，越来越难维护\n\n\n### 1.3.2、垂直架构（vertical application）\n当访问量逐渐增大，单一应用无法满足需求，我们就需要增加节点来提供系统的访问能力，但是并不是所有的模块都需要进行性能的提高，这时候单体应用架构无法满足我们的需求；我们需要将系统里面的模块进行拆分，这样对于后面的水平扩容是非常友好的；\n![垂直架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307290956007.jpg)\n\n> 优点：系统拆分实现了流量分担，提高了系统并发量\n>    垂直架构中可以针对不同模块进行针对性优化\n>    方便水平扩展，负载均衡，系统容错率提高\n\n> 缺点：垂直架构中相同逻辑代码需要不断的复制，不能复用。每个垂直模块都相当于一个独立的系统\n\n\n### 1.3.3、分布式服务架构（distributed service）\n当垂直应用越来越多，重复的业务代码就会越来越多，并且在垂直架构中应用之间的交互不可避免，此时，为了解决基础代码重复太多、应用之间的调用等问题；我们将重复的代码抽取出来作为独立的服务，对外提供服务；\n> rpc是传输层传输协议，效率比应用层传输要高\n> dubbo采用rpc\n> springcloud采用http，属于应用层传输\n\n> 优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率\n\n> 缺点：服务越来越多，需要管理每个服务的地址，调用关系错综复杂，难以理清依赖关系，服务状态难以管理，无法根据服务情况动态管理\n\n![分布式架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291006525.jpg)\n\n### 1.3.4、SOA架构\n在分布式架构下，当服务越来越多，容量的评估，小服务资源等浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理（根据请求量动态的分配资源）。它一般使用中心化的思想实现，服务的管理和调度都由中央的服务总线（ESB）来负责\n\n### 1.3.4、微服务架构\n微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中每个服务独立，互不影响；（怎么理解粒度更细？：微服务采用去中心化的思想来治理，注册中心只是服务发现的工具，而服务之间的调用，熔断，负载均衡等都是都是由服务自己控制的）\n\n![微服务架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291013480.png)\n\n\n## 1.4、微服务架构解决方案\n\n- **国内阿里系**\n\nspringboot + dubbo + zookeeper\n\n- **spring cloud技术栈**\n\nspring cloud netflix\nspring cloud spring （spring自己封装的微服务解决方案）\nspring cloud alibaba（阿里巴巴解决方案）\n\n## 1.5、SpringCloud概念\n### 1.5.1、基本概念\nSpring Cloud是一个含概多个子项目的微服务开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.Spring Cloud在整合过程中主要是针对Netflix(耐非),alibaba开源组件的封装\n\n### 1.5.2、版本\nspringcloud版本采用伦敦地铁站命名，根据首字母顺序排序 这样设计的目的是为了更好的管理每个springcloud子项目清单，避免了总版本号与子项目版本号混淆\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291014046.png)\n\n\n### 1.5.3、组件\n|  | spring cloud官方 | spring cloud netflix | spring cloud alibaba |\n| --- | --- | --- | --- |\n| 服务注册发现 | - | Eureka | nacos |\n| 分布式配置 | spring cloud config | Archaius | nacos |\n| 服务熔断 | - | Hystrix | Sentinel |\n| 服务调用 | Open Fegin | Fegin | Dubbo RPC |\n| 服务路由 | spring cloud gateway | zuul | dubbo proxy |\n| 分布式消息 | rabbitmq | - | rocketmq |\n| 负载均衡 | - | ribbon | dubbo LB |\n| 分布式事务 | - | - | Seata |\n\n# 2、项目搭建（父工程）\n## 2.1、引入依赖\n\n```xml\n<!--springBoot父项目-->\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>2.2.5.RELEASE</version>\n</parent>\n    <dependencyManagement>\n        <dependencies>\n            <!--springBoot-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter</artifactId>\n            </dependency>\n            <!--springCloud-->\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Hoxton.SR6</version>\n                <!--maven只能有一个parent 所以这里以pom引入父项目-->\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n# 3、eureka（注册中心）\n## 3.1、基本概念\n注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。两个重要的功能：**服务注册**和**服务发现**\n\n## 3.2、常用的注册中心\n\n![常用的注册中心](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291044882.png)\n\n\n## 3.3、eureka角色\n\n- **服务注册中心（server**）：Eureka的服务端应用，提供服务注册和发现功能.\n- **服务提供者（client）**： 启动后向Eureka注册自己信息（地址，提供什么服务）\n\n> 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态\n\n- **服务消费者（client）**：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新\n\n## 3.4、eureka server开发\n搭建eureka server子项目\n### 3.4.1、引入依赖\n\n```xml\n        <!--springBoot-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--eurekaServer-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n```\n### 3.4.2、配置文件\n\n```properties\n# eureka server端口号 （默认就是8761）\nserver.port=8761\n# 指定服务名称\nspring.application.name=EUREKASERVER\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n```\n### 3.4.3、入口类加注解\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n\n```\n## 3.5、eureka client开发\n### 3.5.1、引入依赖\n\n```xml\n<dependencies>\n  <!--eureka client依赖-->\n  <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n  </dependency>\n  <!--springboot依赖-->\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n</dependencies>\n\n```\n### 3.5.2、配置文件\n\n```properties\nserver.port=8989\n# 应用名称\nspring.application.name=EUREKACLIENT\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n### 3.5.3、启动类\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class EurekaClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaClientApplication.class, args);\n    }\n}\n```\n\n## 3.6、eureka自我保护机制 \n### 3.6.1、自我保护机制\n默认情况下，如果eureka server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，eureka server将会移除掉该实例（eureka客户端每隔60秒会发送一次心跳包）\n\n但是当网络分区发生故障，微服务和eureka server之间无法通信，但是微服务本身是正常的，此时不应该移除这个服务，所以就引入了自我保护机制\n\nEureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期\n\n> 自我保护机制清除：\n> （1）心跳次数高于预期值\n> （2）自我保护机制被禁用\n\n### 3.6.2、如何关闭自我保护机制\n\n```properties\neureka:\n  server:\n    #服务端是否开启自我保护机制 （默认true）\n    enable-self-preservation: false\n    # eureka客户端每隔多长时间发一次心跳（单位毫秒，默认是60*1000）即60秒\n    eviction-interval-timer-in-ms: 60000\n```\n## 3.7、eureka server集群\n\n多个注册中心之间相互注册就可搭建eureka server集群\n\n> 服务端：eureka.client.service-url.defaultZone 配置其它的注册中心地址即可\n\n```properties\n# eureka server端口号 （默认就是8761）\nserver.port=8761\n# 指定服务名称\nspring.application.name=EUREKASERVER01\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8762/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n\n# eureka server端口号 \nserver.port=8762\n# 指定服务名称\nspring.application.name=EUREKASERVER02\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n```\n \n> 客户端：所有的注册中心地址都需要指明\n\n```properties\nserver.port=8989\n# 应用名称\nspring.application.name=EUREKACLIENT\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka\n```\n# 4、consul（注册中心）\n## 4.1、简介\nconsul是基于go语言进行开发的服务注册中心，是一个可以直接运行的注册中心工具，不需要像eureka注册中心一样再进行编码。使用起来较为简单\n\n## 4.2、安装\n\n1. 下载 [https://www.consul.io/downloads](https://www.consul.io/downloads)\n2. 解压\n3. 启动服务注册中心（cmd）\n```properties\nconsul agent -dev\n```\n\n4. 访问管理界面：[http://localhost:8500/](http://localhost:8500/)\n\n## 4.3、consul client开发\n\n1. 引入依赖\n\n```xml\n<dependencies>\n        <!--springboot依赖-->\n        <dependency>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--consul客户端组件-->\n        <dependency>\n          <groupId>org.springframework.cloud</groupId>\n          <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n          <!--健康检查依赖 actuator-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n</dependencies>\n\n```\n\n2. 编写配置文件\n\n```properties\nserver.port=8082\nspring.application.name=CONSULCLIENT\n# 向consul server服务注册地址\nspring.cloud.consul.host=localhost\nspring.cloud.consul.port=8500\n# 默认为${spring.application.name}\nspring.cloud.consul.discovery.service-name=CONSULCLIENT\n```\n\n3. 启动类添加注解\n\n```java\n@SpringBootApplication\n// 除了eureka，其它注册中心客户端都可以用该注解\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n\n```\n## 4.4、consul健康检查\n\n![image (10).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291356805.png)\n\n\n1. 默认情况下consul监控健康是开启的，但必须依赖健康监控依赖才能正常响应客户端发来的心跳，否则界面会显示错误，引入健康依赖之后服务正常\n```xml\n<!--健康检查依赖 actuator-->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n# 5、openFeign（服务间通信）\n## 5.1、基于RestTemplate实现调用\n```java\n@RestController\npublic class Client2Controller {\n    @RequestMapping(\"/test\")\n    public String test(){\n        return \"client 2 OK!\";\n    }\n}\n\n@RestController\npublic class ClientController {\n    @RequestMapping(\"/test\")\n    public String test(){\n        RestTemplate restTemplate = new RestTemplate();\n        String result = restTemplate.getForObject(\"http://localhost:8088/test\", String.class);\n        return \"调用client2成功：\"+result;\n    }\n}\n```\n\n## 5.2、基于RestTemplate+Ribbon实现负载均衡调用\nspring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现，通过spring cloud封装，可以让我们轻松的进行客户端负载均衡调用。Ribbon可从注册中心中获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例\n\n1. **编码形式**\n\n```java\n@RestController\npublic class ClientController {\n    @Autowired // 服务注册与发现客户端对象（获取服务列表后需要手动选取）\n    private DiscoveryClient discoveryClient;\n    @Autowired // 具有负载均衡的服务注册与发现客户端对象（根据负载均衡策略自动选取一个）\n    private LoadBalancerClient loadBalancerClient;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        // （1）DiscoveryClient\n        List<ServiceInstance> serviceInstances = discoveryClient.getInstances(\"CONSULCLIENT2\");\n        String result = new RestTemplate().getForObject(serviceInstances.get(0).getUri() + \"/test\", String.class);\n        // （2）LoadBalanceClient\n        ServiceInstance serviceInstances2 = loadBalancerClient.choose(\"CONSULCLIENT2\");\n        String result2 = new RestTemplate().getForObject(serviceInstances2.getUri() + \"/test\", String.class);\n        return \"调用client2成功：\" + result2;\n    }\n}\n```\n\n2. **@LoadBalance注解实现负载均衡**\n\n```java\n@Configuration\npublic class BeanConfig {\n    @Bean\n    @LoadBalanced // 使RestTemplate对象具有ribbon负载均衡特性\n    public RestTemplate restTemplate(){\n        return new RestTemplate();\n    }\n}\n\n@RestController\npublic class ClientController {\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        String result3 = restTemplate.getForObject(\"http://CONSULCLIENT2/test\", String.class);\n        return \"调用client2成功：\" + result3;\n    }\n}\n```\n\n3. **Ribbon负载均衡策略**\n\n| 策略类 | 命名 | 描述 |\n| --- | --- | --- |\n| RoundRobinRule | 轮询策略 | 轮询选择，轮询index，选择index对应位置的Server |\n| RandomRule | 随机策略 | 随机选择server |\n| BestAvailableRule | 最低并发策略 | 选择其中并发链接最低的server |\n| RetryRule | 重试策略 | 其实就是轮询策略的加强版，轮询策略服务不可用时不处理，重试策略会尝试其它节点 |\n| AvailabilityFilteringRule | 可用过滤策略 | 过滤掉一直连接失败的provider和繁忙的provider |\n| ZoneAvoidanceRule | 区域权重策略 | 如果某个ip区域内有一个或多个示例不可达或响应慢，都会降低该ip区域内其它ip被选中的权重 |\n\n4. **负载均衡策略设置**\n\n（1）局部修改\n\n```java\n# 负载均衡策略 provider为调用的服务的名称\n# 格式：服务应用名.ribbon.负载均衡策略名字\nprovider:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\n```\n（2）全局修改\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n\n    // 所有被调用服务均使用该策略\n    @Bean\n    public RandomRule randomRule(){\n        return new RandomRule();\n    }\n}\n```\n## 5.3、基于openFeign实现调用\n### 5.3.1、Feign\n\n\n> Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务\n\n### 5.3.2、openFeign\n\n> OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。\n> OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，\n> 并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务\n\n\n### 5.3.3、openFeign调用\n#### 5.3.3.1、编码\n（1）引入依赖\n\n```xml\n<!--openFeign-->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n（2）启动类开启openFeign的调用\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n```\n（3）创建业务层接口，添加@FeginClient注解声明需要调用的服务\n\n```java\n@FeignClient(\"CONSULCLIENT2\")\npublic interface Client2 {\n    @RequestMapping(\"/test\")\n    String test2();\n}\n```\n（4）调用\n\n```java\n@RestController\npublic class ClientController {\n    @Autowired\n    private Client2 client2;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        String result = client2.test2();\n        return \"调用client2成功：\" + result;\n    }\n}\n```\n#### 5.3.3.2、接口参数传递详解\n> （1）test？name=xxx&age=10  —— @RequestParam(\"name\")\n> （2）test/{id}   ——  @PathVarible(\"id\")\n> （3）test(@RequestBody User user)\n> （4）集合和数组作为参数时封装到VO对象中\n\n#### 5.3.3.3、超时处理\n\n1. 默认超时时间：1s\n2. 修改某个服务的超时时间\n\n```properties\nfeign.client.config.PRODUCTS.connecTimeOut=5000 # 配置指定服务连接超时\nfeign.client.config.PRODUCTS.readTimeOut=5000 # 配置指定服务等待超时\n```\n\n3. 修改所有服务超时时间\n\n```properties\nfeign.client.config.default.connecTimeOut=5000 # 配置服务连接超时\nfeign.client.config.default.readTimeOut=5000 # 配置服务等待超时\n```\n# 6、Hystrix（服务熔断）\n## 6.1、什么是服务雪崩？\n因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象\n\n> （1）程序bug导致服务不可用，或者运行缓慢 \n> （2）缓存击穿，导致调用全部访问某服务，导致down掉 \n> （3）访问量的突然激增\n\n## 6.2、解决服务雪崩（ 熔断 + 降级）\n\n1. **服务熔断**\n\n一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，向调用方返回一个符合预期的的备选响应，而不是长时间等待或抛出异常。所以很多地方把熔断亦称为过载保护\n\n2. **服务降级**\n\n当网站或服务流量突然增加时，为了保证系统核心服务正常运行，有策略的关闭系统中的边缘服务，以保证核心服务的正常运行\n\n3. **熔断降级的关系**\n\n熔断必会出发降级，所以熔断也是降级的一种，区别在于熔断是对调用链路的保护，降级是对系统过载的一种保护\n## 6.3、Hystrix概念\nHystrix是处理分布式系统延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时，异常等。Hystrix能够保证在一个依赖出现问题时，不会导致整体服务失败，避免雪崩效应，提高分布式系统的弹性\n\n## 6.4、编码\n\n1. 所有服务引入Hystrix依赖\n\n```xml\n<!--hystrix-->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n2. 服务提供者\n\n（直接调用服务提供者的方案，是一种服务降级的思想）\n\n```java\n\n// 开启熔断功能\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableHystrix //开启hystrix熔断功能\npublic class ConsulClient2Application {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClient2Application.class,args);\n    }\n}\n\n\n@RestController\npublic class Client2Controller {\n    @RequestMapping(\"/test2\")\n    @HystrixCommand(fallbackMethod = \"demoFallBack\",defaultFallback = \"defaultFallBack\") //熔断之后的处理\n    public String test(Integer id){\n        if (id <= 0){\n            throw new RuntimeException(\"发生异常！\");\n        }\n        return \"client 2:8088 OK!\";\n    }\n\n    public String demoFallBack(Integer id){\n        return \"服务被熔断\";\n    }\n\n    public String defaultFallBack(){\n        return \"服务被熔断(默认)\";\n    }\n}\n\n```\n\n3. 服务消费者\n\n（通过服务消费者调用的方案，服务者完全挂掉时的处理，是一种服务熔断的思想）\n```java\n# 开启openFeign支持服务降级\nfeign.hystrix.enabled=true\n\n@SpringBootApplication\n@EnableDiscoveryClient  // 开启服务注册客户端\n@EnableFeignClients  // 开启openFeign调用\n@EnableHystrix // 开启hystrix熔断功能\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n\n// fallback:指定当服务不可用时，默认的备选处理\n@FeignClient(value = \"CONSULCLIENT2\",fallback = Client2FallBack.class)\npublic interface Client2 {\n    @RequestMapping(\"/test2\")\n    String test2(@RequestParam(\"id\") Integer id);\n}\n\n// \n@Component\npublic class Client2FallBack implements Client2{\n    @Override\n    public String test2(Integer id) {\n        return \"当前服务不可达\";\n    }\n}\n\n\n@RestController\npublic class ClientController {\n    @Autowired\n    private Client2 client2;\n    @RequestMapping(\"/test\")\n    public String test(Integer id) {\n        String result = client2.test2(id);\n        return \"调用client2成功：\" + result;\n    }\n}\n```\n## 6.5、Hystrix服务熔断机制\n### 6.5.1、Hystrix断路器打开的条件\na. 当满足一定阈值的时候（默认10秒内超过20个请求次数）\nb. 当失败率达到一定的时候（默认10秒内超过50%的请求失败）\n\n> 注意：一旦断路开启之后，所有到这个服务请求均不可用，只有在断路关闭之后才可用\n\n### 6.5.2、Hystrix监控流程\n![Hystrix监控流程](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291357597.png)\n\n当服务调用达到两个阈值，会自动开启断路器，在熔断器打开期间，任何到该接口的请求均不可用，同时在断路器打开5s后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果执行成功，断路器彻底关闭，执行失败则重新打开\n\n## 6.6、Hystrix Dashboard（仪表盘）\n\n1. 基本概念\n\nHystrix Dashboard主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题\n\n2. 编码\n\n（1）新建一个 Hystrix Dashboard 工程\n（2）引入依赖\n\n```xml\n<!-- Spring Cloud Hystrix Dashboard -->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n\n```\n（3）启动类开启监控功能\n\n```java\n/** 开启 Hystrix Dashboard 监控功能 */\n@EnableHystrixDashboard\n```\n（4）访问仪表盘界面\n\n> [http://localhost:9000/hystrix](http://localhost:9000/hystrix)\n> 端口为项目的端口号\n\n# 7、zuul（网关）\nZuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。zuul 包含了对请求的**路由**和**过滤**两个最主要的功能。\n\nZuul是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能:\n\n（1）聚合接口使得服务对调用者透明，客户端与后端的耦合度降低\n（2）聚合后台服务，节省流量，提高性能，提升用户体验\n（3）提供安全、流控、过滤、缓存、计费、监控等 API 管理功能\n## 7.1、搭建环境\n创建一个应用，在启动类中添加注解@EnableZuulProxy，声明这是一个网关服务提供者\n\n## 7.2、路由规则配置\n### 7.2.1、URL地址路由\n\n```java\n# 路由规则\nzuul:\n\troutes :\n        # 路由 id 自定义\n        product-service :\n\t\t\tpath: /product-service/**配请求 ur1 的映射路径#\n    \t\turl: http://localhost:7070/ # 映射路径对应的微服务地址\n```\n通配符含义：\n\n| 通配符 | 含义 | 举例 |\n| --- | --- | --- |\n| ？ | 匹配任意单个字符 | /product-service/? |\n| * | 匹配任意数量字符不包括子路径 | /product-service/* |\n| ** | 匹配任意数量字符包括所有子路径 | /product-service/** |\n\n### 7.2.2、服务名称路由\n微服务一般是由几十、上百个服务组成，对于 URL 地址路由的方式，如果对每个服务实例手动指定一个唯一访问地址，这样做显然是不合理的。\nZuul 支持与 Eureka 整合开发，根据 serviceld 自动从注册中心获取服务地并转发清求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而目在添加或移除服务实例时不用修改 Zuul 的路由配置\n\n```java\n路由规则\nZuul\n\troutes:\n\t# 路由 id 自定义\n\t\tproduct-service:\n\t\tpath: /product-service/**#配置请 url 的映射路径\n\t\tserviceId: product-service # 根据 serviceId 自动从注册中心获取服务地址并转发请求\n```\n### 7.2.3、简化路由配置\nZuul 为了方便大家使用，提供了默认路由配置: 路由 id 和 微服务名称 一致，path 默认对应 微服务名称/* ，所以以下配置就没必要再写了。\n\n## 7.3、路由排除\n我们可以通过路由排除设置不允许被访问的资源。允许被访问的资源可以通过路由规则进行设置。\n```java\n# 路由规则\nZuul:\n\t#ignored-patterns: /**/order/** # URL 地址排除，排除所有包含 /order/ 的路径\n\tignored-services: order-service # 服务名称排除，多个服务逗号分隔，'*’排除所有\n```\n## 7.4、路由前缀\n```java\nZuul:\n\tprefix: /api\n```\n## 7.5、网关过滤器\n### 7.5.1、关键名词\n类型: 定义路由流程中应用过滤器的阶段。共 pre、routing、 post、error 4 个类型\n执行顺序: 在同类型中，定义过滤器执行的顺序。比如多个 pre 类型的执行顺序.\n条件: 执行过滤器所需的条件。true 开启，false 关闭.\n动作: 如果符合条件，将执行的动作。具体操作。\n\n### 7.5.2、过滤器类型\n **pre**: 请求被路由到源服务器之前执行的过滤器\n> 身份认证\n> 选路由\n> 请求日志\n\n**routing**: 处理将请求发送到源服务器的过滤器。 \n**post**: 响应从源服务器返回时执行的过滤器\n> 对响应增加 HTTP 头\n> 收集统计和度量指标\n> 将响应以流的方式发送回客户端\n\n**error**:上述阶段中出现错误时执行的过滤器\n\n```java\n@Component \npublic class LoginFilter extends ZuulFilter{ \n    @Override \n    public String filterType() { \n        // 登录校验，肯定是在前置拦截 \n        return \"pre\"; \n    }\n \n    @Override \n    public int filterOrder() { \n        // 顺序设置为1 \n        return 1; \n    }\n \n    @Override \n    public boolean shouldFilter() { \n        // 返回true，代表过滤器生效。 \n        return true; \n    }\n \n    @Override \n    public Object run() throws ZuulException {\n    //处理业务逻辑\n    return null;\n    }    \n}\n```\n## 7.6、网关限流\n这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的\n\n**计数器**：计算单元时间内访问接口的次数，如果达到次数，则限制访问\n\n**漏桶算法**：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃\n\n**令牌桶算法：**\n（1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理;\n（2）根据限流大小，设置按照一定的速率往桶里添加令牌;\n（3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝;\n（4）请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除:\n（5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。\n\n> 令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放回定数量的令牌\n\n### 7.6.1、网关限流\n\n1. 全局限流配置\n\n使用全局限流配置，zuul会对代理的所有服务提供限流保护\n```properties\n# 开启限流保护\nzuul.ratelimit.enabled=true\n# 60s内请求超过3次，服务端就抛出异常，60s后可以恢复正常请求\nzuul.ratelimit.default-policy.limit=3\nzuul.ratelimit.default-policy.refresh-interval=60\n# 针对IP进行限流，不影响其他IP\nzuul.ratelimit.default-policy.type=origin\n```\n\n2. 局部限流配置\n\n使用局部限流配置，zuul仅针对配置的服务提供限流保护\n```properties\n# 开启限流保护\nzuul.ratelimit.enabled=true\n# hystrix-application-client服务60s内请求超过3次，服务抛出异常。\nzuul.ratelimit.policies.hystrix-application-client.limit=3\nzuul.ratelimit.policies.hystrix-application-client.refresh-interval=60\n# 针对IP限流。\nzuul.ratelimit.policies.hystrix-application-client.type=origin\n```\n# 8、sleuth（链路追踪）\n## 8.1、链路追踪\n单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整记录下来.\n## 8.2、sleuth\nSpring Cloud sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，和其他基于日志的追踪系统，例如ELK (Elasticsearch 、 Logstash、Kibana)\nSpring cloud sleuth 提供了以下功能:\n\n- 辩路追踪: 通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。\n- 性能分析 :通过 sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。\n- 数据分析，优化链路 : 对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施.\n- 可视化错误 : 对于程序未捕获的异常，可以配合 Zipkin 查看。\n\n## 8.3、专业术语\n### 8.3.1、span\n基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父ID，以重建在一次追踪过程中不同 Span 之间的关系\n","source":"_posts/springCloud.md","raw":"---\ntitle: springCloud\ndate: 2023/07/29\ncategories:\n  - coding\ntags:\n  - springCloud\n  - 编程基础\nabbrlink: 26325\n---\n#  1、微服务架构\n## 1.1、基本概念\n微服务是一种架构，这种架构是将单个整体应用程序分割成更小的项目关联的独立服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现，这些独立的微服务\n\n## 1.2、为什么要用微服务？\n### 1.2.1、优点\n\n1. 将服务拆分成单一职责的小服务，进行单独部署，服务之间通过网络进行通信\n2. 每个服务应该有自己的管理团队，高度自治\n3. 服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃\n\n### 1.2.2、缺点\n\n1. 开发人员需要处理分布式系统的复杂性\n2. 随着服务的增加，运维的压力也在增大\n3. 服务治理（负载均衡，服务熔断，服务配置管理）和服务监控\n\n## 1.3、架构的演变\n\n### 1.3.1、单一架构（all in one）\n一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(**ORM**)是影响项目开发的关键（mybatis，hibernate）\n\n> 缺点：随着应用功能的增多，代码量越来越大，越来越难维护\n\n\n### 1.3.2、垂直架构（vertical application）\n当访问量逐渐增大，单一应用无法满足需求，我们就需要增加节点来提供系统的访问能力，但是并不是所有的模块都需要进行性能的提高，这时候单体应用架构无法满足我们的需求；我们需要将系统里面的模块进行拆分，这样对于后面的水平扩容是非常友好的；\n![垂直架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307290956007.jpg)\n\n> 优点：系统拆分实现了流量分担，提高了系统并发量\n>    垂直架构中可以针对不同模块进行针对性优化\n>    方便水平扩展，负载均衡，系统容错率提高\n\n> 缺点：垂直架构中相同逻辑代码需要不断的复制，不能复用。每个垂直模块都相当于一个独立的系统\n\n\n### 1.3.3、分布式服务架构（distributed service）\n当垂直应用越来越多，重复的业务代码就会越来越多，并且在垂直架构中应用之间的交互不可避免，此时，为了解决基础代码重复太多、应用之间的调用等问题；我们将重复的代码抽取出来作为独立的服务，对外提供服务；\n> rpc是传输层传输协议，效率比应用层传输要高\n> dubbo采用rpc\n> springcloud采用http，属于应用层传输\n\n> 优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率\n\n> 缺点：服务越来越多，需要管理每个服务的地址，调用关系错综复杂，难以理清依赖关系，服务状态难以管理，无法根据服务情况动态管理\n\n![分布式架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291006525.jpg)\n\n### 1.3.4、SOA架构\n在分布式架构下，当服务越来越多，容量的评估，小服务资源等浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理（根据请求量动态的分配资源）。它一般使用中心化的思想实现，服务的管理和调度都由中央的服务总线（ESB）来负责\n\n### 1.3.4、微服务架构\n微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中每个服务独立，互不影响；（怎么理解粒度更细？：微服务采用去中心化的思想来治理，注册中心只是服务发现的工具，而服务之间的调用，熔断，负载均衡等都是都是由服务自己控制的）\n\n![微服务架构](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291013480.png)\n\n\n## 1.4、微服务架构解决方案\n\n- **国内阿里系**\n\nspringboot + dubbo + zookeeper\n\n- **spring cloud技术栈**\n\nspring cloud netflix\nspring cloud spring （spring自己封装的微服务解决方案）\nspring cloud alibaba（阿里巴巴解决方案）\n\n## 1.5、SpringCloud概念\n### 1.5.1、基本概念\nSpring Cloud是一个含概多个子项目的微服务开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.Spring Cloud在整合过程中主要是针对Netflix(耐非),alibaba开源组件的封装\n\n### 1.5.2、版本\nspringcloud版本采用伦敦地铁站命名，根据首字母顺序排序 这样设计的目的是为了更好的管理每个springcloud子项目清单，避免了总版本号与子项目版本号混淆\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291014046.png)\n\n\n### 1.5.3、组件\n|  | spring cloud官方 | spring cloud netflix | spring cloud alibaba |\n| --- | --- | --- | --- |\n| 服务注册发现 | - | Eureka | nacos |\n| 分布式配置 | spring cloud config | Archaius | nacos |\n| 服务熔断 | - | Hystrix | Sentinel |\n| 服务调用 | Open Fegin | Fegin | Dubbo RPC |\n| 服务路由 | spring cloud gateway | zuul | dubbo proxy |\n| 分布式消息 | rabbitmq | - | rocketmq |\n| 负载均衡 | - | ribbon | dubbo LB |\n| 分布式事务 | - | - | Seata |\n\n# 2、项目搭建（父工程）\n## 2.1、引入依赖\n\n```xml\n<!--springBoot父项目-->\n<parent>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-parent</artifactId>\n  <version>2.2.5.RELEASE</version>\n</parent>\n    <dependencyManagement>\n        <dependencies>\n            <!--springBoot-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter</artifactId>\n            </dependency>\n            <!--springCloud-->\n            <dependency>\n                <groupId>org.springframework.cloud</groupId>\n                <artifactId>spring-cloud-dependencies</artifactId>\n                <version>Hoxton.SR6</version>\n                <!--maven只能有一个parent 所以这里以pom引入父项目-->\n                <type>pom</type>\n                <scope>import</scope>\n            </dependency>\n        </dependencies>\n    </dependencyManagement>\n```\n# 3、eureka（注册中心）\n## 3.1、基本概念\n注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。两个重要的功能：**服务注册**和**服务发现**\n\n## 3.2、常用的注册中心\n\n![常用的注册中心](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291044882.png)\n\n\n## 3.3、eureka角色\n\n- **服务注册中心（server**）：Eureka的服务端应用，提供服务注册和发现功能.\n- **服务提供者（client）**： 启动后向Eureka注册自己信息（地址，提供什么服务）\n\n> 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态\n\n- **服务消费者（client）**：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新\n\n## 3.4、eureka server开发\n搭建eureka server子项目\n### 3.4.1、引入依赖\n\n```xml\n        <!--springBoot-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--eurekaServer-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n        </dependency>\n```\n### 3.4.2、配置文件\n\n```properties\n# eureka server端口号 （默认就是8761）\nserver.port=8761\n# 指定服务名称\nspring.application.name=EUREKASERVER\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n```\n### 3.4.3、入口类加注解\n\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaServerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaServerApplication.class, args);\n    }\n}\n\n```\n## 3.5、eureka client开发\n### 3.5.1、引入依赖\n\n```xml\n<dependencies>\n  <!--eureka client依赖-->\n  <dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n  </dependency>\n  <!--springboot依赖-->\n  <dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-web</artifactId>\n  </dependency>\n</dependencies>\n\n```\n### 3.5.2、配置文件\n\n```properties\nserver.port=8989\n# 应用名称\nspring.application.name=EUREKACLIENT\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n```\n### 3.5.3、启动类\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class EurekaClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaClientApplication.class, args);\n    }\n}\n```\n\n## 3.6、eureka自我保护机制 \n### 3.6.1、自我保护机制\n默认情况下，如果eureka server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，eureka server将会移除掉该实例（eureka客户端每隔60秒会发送一次心跳包）\n\n但是当网络分区发生故障，微服务和eureka server之间无法通信，但是微服务本身是正常的，此时不应该移除这个服务，所以就引入了自我保护机制\n\nEureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期\n\n> 自我保护机制清除：\n> （1）心跳次数高于预期值\n> （2）自我保护机制被禁用\n\n### 3.6.2、如何关闭自我保护机制\n\n```properties\neureka:\n  server:\n    #服务端是否开启自我保护机制 （默认true）\n    enable-self-preservation: false\n    # eureka客户端每隔多长时间发一次心跳（单位毫秒，默认是60*1000）即60秒\n    eviction-interval-timer-in-ms: 60000\n```\n## 3.7、eureka server集群\n\n多个注册中心之间相互注册就可搭建eureka server集群\n\n> 服务端：eureka.client.service-url.defaultZone 配置其它的注册中心地址即可\n\n```properties\n# eureka server端口号 （默认就是8761）\nserver.port=8761\n# 指定服务名称\nspring.application.name=EUREKASERVER01\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8762/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n\n# eureka server端口号 \nserver.port=8762\n# 指定服务名称\nspring.application.name=EUREKASERVER02\n# eureka server服务注册中心地址 暴露服务地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka\n# 关闭立即注册（避免控制台报错）\neureka.client.fetch-registry=false\n# 让当前应用仅仅是服务注册中心\neureka.client.register-with-eureka=false\n```\n \n> 客户端：所有的注册中心地址都需要指明\n\n```properties\nserver.port=8989\n# 应用名称\nspring.application.name=EUREKACLIENT\n# 注册中心地址\neureka.client.service-url.defaultZone=http://localhost:8761/eureka,http://localhost:8762/eureka\n```\n# 4、consul（注册中心）\n## 4.1、简介\nconsul是基于go语言进行开发的服务注册中心，是一个可以直接运行的注册中心工具，不需要像eureka注册中心一样再进行编码。使用起来较为简单\n\n## 4.2、安装\n\n1. 下载 [https://www.consul.io/downloads](https://www.consul.io/downloads)\n2. 解压\n3. 启动服务注册中心（cmd）\n```properties\nconsul agent -dev\n```\n\n4. 访问管理界面：[http://localhost:8500/](http://localhost:8500/)\n\n## 4.3、consul client开发\n\n1. 引入依赖\n\n```xml\n<dependencies>\n        <!--springboot依赖-->\n        <dependency>\n          <groupId>org.springframework.boot</groupId>\n          <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--consul客户端组件-->\n        <dependency>\n          <groupId>org.springframework.cloud</groupId>\n          <artifactId>spring-cloud-starter-consul-discovery</artifactId>\n        </dependency>\n          <!--健康检查依赖 actuator-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-actuator</artifactId>\n        </dependency>\n</dependencies>\n\n```\n\n2. 编写配置文件\n\n```properties\nserver.port=8082\nspring.application.name=CONSULCLIENT\n# 向consul server服务注册地址\nspring.cloud.consul.host=localhost\nspring.cloud.consul.port=8500\n# 默认为${spring.application.name}\nspring.cloud.consul.discovery.service-name=CONSULCLIENT\n```\n\n3. 启动类添加注解\n\n```java\n@SpringBootApplication\n// 除了eureka，其它注册中心客户端都可以用该注解\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n\n```\n## 4.4、consul健康检查\n\n![image (10).png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291356805.png)\n\n\n1. 默认情况下consul监控健康是开启的，但必须依赖健康监控依赖才能正常响应客户端发来的心跳，否则界面会显示错误，引入健康依赖之后服务正常\n```xml\n<!--健康检查依赖 actuator-->\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\n# 5、openFeign（服务间通信）\n## 5.1、基于RestTemplate实现调用\n```java\n@RestController\npublic class Client2Controller {\n    @RequestMapping(\"/test\")\n    public String test(){\n        return \"client 2 OK!\";\n    }\n}\n\n@RestController\npublic class ClientController {\n    @RequestMapping(\"/test\")\n    public String test(){\n        RestTemplate restTemplate = new RestTemplate();\n        String result = restTemplate.getForObject(\"http://localhost:8088/test\", String.class);\n        return \"调用client2成功：\"+result;\n    }\n}\n```\n\n## 5.2、基于RestTemplate+Ribbon实现负载均衡调用\nspring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现，通过spring cloud封装，可以让我们轻松的进行客户端负载均衡调用。Ribbon可从注册中心中获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例\n\n1. **编码形式**\n\n```java\n@RestController\npublic class ClientController {\n    @Autowired // 服务注册与发现客户端对象（获取服务列表后需要手动选取）\n    private DiscoveryClient discoveryClient;\n    @Autowired // 具有负载均衡的服务注册与发现客户端对象（根据负载均衡策略自动选取一个）\n    private LoadBalancerClient loadBalancerClient;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        // （1）DiscoveryClient\n        List<ServiceInstance> serviceInstances = discoveryClient.getInstances(\"CONSULCLIENT2\");\n        String result = new RestTemplate().getForObject(serviceInstances.get(0).getUri() + \"/test\", String.class);\n        // （2）LoadBalanceClient\n        ServiceInstance serviceInstances2 = loadBalancerClient.choose(\"CONSULCLIENT2\");\n        String result2 = new RestTemplate().getForObject(serviceInstances2.getUri() + \"/test\", String.class);\n        return \"调用client2成功：\" + result2;\n    }\n}\n```\n\n2. **@LoadBalance注解实现负载均衡**\n\n```java\n@Configuration\npublic class BeanConfig {\n    @Bean\n    @LoadBalanced // 使RestTemplate对象具有ribbon负载均衡特性\n    public RestTemplate restTemplate(){\n        return new RestTemplate();\n    }\n}\n\n@RestController\npublic class ClientController {\n    @Autowired\n    private RestTemplate restTemplate;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        String result3 = restTemplate.getForObject(\"http://CONSULCLIENT2/test\", String.class);\n        return \"调用client2成功：\" + result3;\n    }\n}\n```\n\n3. **Ribbon负载均衡策略**\n\n| 策略类 | 命名 | 描述 |\n| --- | --- | --- |\n| RoundRobinRule | 轮询策略 | 轮询选择，轮询index，选择index对应位置的Server |\n| RandomRule | 随机策略 | 随机选择server |\n| BestAvailableRule | 最低并发策略 | 选择其中并发链接最低的server |\n| RetryRule | 重试策略 | 其实就是轮询策略的加强版，轮询策略服务不可用时不处理，重试策略会尝试其它节点 |\n| AvailabilityFilteringRule | 可用过滤策略 | 过滤掉一直连接失败的provider和繁忙的provider |\n| ZoneAvoidanceRule | 区域权重策略 | 如果某个ip区域内有一个或多个示例不可达或响应慢，都会降低该ip区域内其它ip被选中的权重 |\n\n4. **负载均衡策略设置**\n\n（1）局部修改\n\n```java\n# 负载均衡策略 provider为调用的服务的名称\n# 格式：服务应用名.ribbon.负载均衡策略名字\nprovider:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule\n```\n（2）全局修改\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n\n    // 所有被调用服务均使用该策略\n    @Bean\n    public RandomRule randomRule(){\n        return new RandomRule();\n    }\n}\n```\n## 5.3、基于openFeign实现调用\n### 5.3.1、Feign\n\n\n> Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务\n\n### 5.3.2、openFeign\n\n> OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。\n> OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，\n> 并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务\n\n\n### 5.3.3、openFeign调用\n#### 5.3.3.1、编码\n（1）引入依赖\n\n```xml\n<!--openFeign-->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n（2）启动类开启openFeign的调用\n\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableFeignClients\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n```\n（3）创建业务层接口，添加@FeginClient注解声明需要调用的服务\n\n```java\n@FeignClient(\"CONSULCLIENT2\")\npublic interface Client2 {\n    @RequestMapping(\"/test\")\n    String test2();\n}\n```\n（4）调用\n\n```java\n@RestController\npublic class ClientController {\n    @Autowired\n    private Client2 client2;\n\n    @RequestMapping(\"/test\")\n    public String test() {\n        String result = client2.test2();\n        return \"调用client2成功：\" + result;\n    }\n}\n```\n#### 5.3.3.2、接口参数传递详解\n> （1）test？name=xxx&age=10  —— @RequestParam(\"name\")\n> （2）test/{id}   ——  @PathVarible(\"id\")\n> （3）test(@RequestBody User user)\n> （4）集合和数组作为参数时封装到VO对象中\n\n#### 5.3.3.3、超时处理\n\n1. 默认超时时间：1s\n2. 修改某个服务的超时时间\n\n```properties\nfeign.client.config.PRODUCTS.connecTimeOut=5000 # 配置指定服务连接超时\nfeign.client.config.PRODUCTS.readTimeOut=5000 # 配置指定服务等待超时\n```\n\n3. 修改所有服务超时时间\n\n```properties\nfeign.client.config.default.connecTimeOut=5000 # 配置服务连接超时\nfeign.client.config.default.readTimeOut=5000 # 配置服务等待超时\n```\n# 6、Hystrix（服务熔断）\n## 6.1、什么是服务雪崩？\n因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象\n\n> （1）程序bug导致服务不可用，或者运行缓慢 \n> （2）缓存击穿，导致调用全部访问某服务，导致down掉 \n> （3）访问量的突然激增\n\n## 6.2、解决服务雪崩（ 熔断 + 降级）\n\n1. **服务熔断**\n\n一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，向调用方返回一个符合预期的的备选响应，而不是长时间等待或抛出异常。所以很多地方把熔断亦称为过载保护\n\n2. **服务降级**\n\n当网站或服务流量突然增加时，为了保证系统核心服务正常运行，有策略的关闭系统中的边缘服务，以保证核心服务的正常运行\n\n3. **熔断降级的关系**\n\n熔断必会出发降级，所以熔断也是降级的一种，区别在于熔断是对调用链路的保护，降级是对系统过载的一种保护\n## 6.3、Hystrix概念\nHystrix是处理分布式系统延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时，异常等。Hystrix能够保证在一个依赖出现问题时，不会导致整体服务失败，避免雪崩效应，提高分布式系统的弹性\n\n## 6.4、编码\n\n1. 所有服务引入Hystrix依赖\n\n```xml\n<!--hystrix-->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n\n2. 服务提供者\n\n（直接调用服务提供者的方案，是一种服务降级的思想）\n\n```java\n\n// 开启熔断功能\n@SpringBootApplication\n@EnableDiscoveryClient\n@EnableHystrix //开启hystrix熔断功能\npublic class ConsulClient2Application {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClient2Application.class,args);\n    }\n}\n\n\n@RestController\npublic class Client2Controller {\n    @RequestMapping(\"/test2\")\n    @HystrixCommand(fallbackMethod = \"demoFallBack\",defaultFallback = \"defaultFallBack\") //熔断之后的处理\n    public String test(Integer id){\n        if (id <= 0){\n            throw new RuntimeException(\"发生异常！\");\n        }\n        return \"client 2:8088 OK!\";\n    }\n\n    public String demoFallBack(Integer id){\n        return \"服务被熔断\";\n    }\n\n    public String defaultFallBack(){\n        return \"服务被熔断(默认)\";\n    }\n}\n\n```\n\n3. 服务消费者\n\n（通过服务消费者调用的方案，服务者完全挂掉时的处理，是一种服务熔断的思想）\n```java\n# 开启openFeign支持服务降级\nfeign.hystrix.enabled=true\n\n@SpringBootApplication\n@EnableDiscoveryClient  // 开启服务注册客户端\n@EnableFeignClients  // 开启openFeign调用\n@EnableHystrix // 开启hystrix熔断功能\npublic class ConsulClientApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsulClientApplication.class, args);\n    }\n}\n\n// fallback:指定当服务不可用时，默认的备选处理\n@FeignClient(value = \"CONSULCLIENT2\",fallback = Client2FallBack.class)\npublic interface Client2 {\n    @RequestMapping(\"/test2\")\n    String test2(@RequestParam(\"id\") Integer id);\n}\n\n// \n@Component\npublic class Client2FallBack implements Client2{\n    @Override\n    public String test2(Integer id) {\n        return \"当前服务不可达\";\n    }\n}\n\n\n@RestController\npublic class ClientController {\n    @Autowired\n    private Client2 client2;\n    @RequestMapping(\"/test\")\n    public String test(Integer id) {\n        String result = client2.test2(id);\n        return \"调用client2成功：\" + result;\n    }\n}\n```\n## 6.5、Hystrix服务熔断机制\n### 6.5.1、Hystrix断路器打开的条件\na. 当满足一定阈值的时候（默认10秒内超过20个请求次数）\nb. 当失败率达到一定的时候（默认10秒内超过50%的请求失败）\n\n> 注意：一旦断路开启之后，所有到这个服务请求均不可用，只有在断路关闭之后才可用\n\n### 6.5.2、Hystrix监控流程\n![Hystrix监控流程](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291357597.png)\n\n当服务调用达到两个阈值，会自动开启断路器，在熔断器打开期间，任何到该接口的请求均不可用，同时在断路器打开5s后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果执行成功，断路器彻底关闭，执行失败则重新打开\n\n## 6.6、Hystrix Dashboard（仪表盘）\n\n1. 基本概念\n\nHystrix Dashboard主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题\n\n2. 编码\n\n（1）新建一个 Hystrix Dashboard 工程\n（2）引入依赖\n\n```xml\n<!-- Spring Cloud Hystrix Dashboard -->\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n\n```\n（3）启动类开启监控功能\n\n```java\n/** 开启 Hystrix Dashboard 监控功能 */\n@EnableHystrixDashboard\n```\n（4）访问仪表盘界面\n\n> [http://localhost:9000/hystrix](http://localhost:9000/hystrix)\n> 端口为项目的端口号\n\n# 7、zuul（网关）\nZuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。zuul 包含了对请求的**路由**和**过滤**两个最主要的功能。\n\nZuul是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能:\n\n（1）聚合接口使得服务对调用者透明，客户端与后端的耦合度降低\n（2）聚合后台服务，节省流量，提高性能，提升用户体验\n（3）提供安全、流控、过滤、缓存、计费、监控等 API 管理功能\n## 7.1、搭建环境\n创建一个应用，在启动类中添加注解@EnableZuulProxy，声明这是一个网关服务提供者\n\n## 7.2、路由规则配置\n### 7.2.1、URL地址路由\n\n```java\n# 路由规则\nzuul:\n\troutes :\n        # 路由 id 自定义\n        product-service :\n\t\t\tpath: /product-service/**配请求 ur1 的映射路径#\n    \t\turl: http://localhost:7070/ # 映射路径对应的微服务地址\n```\n通配符含义：\n\n| 通配符 | 含义 | 举例 |\n| --- | --- | --- |\n| ？ | 匹配任意单个字符 | /product-service/? |\n| * | 匹配任意数量字符不包括子路径 | /product-service/* |\n| ** | 匹配任意数量字符包括所有子路径 | /product-service/** |\n\n### 7.2.2、服务名称路由\n微服务一般是由几十、上百个服务组成，对于 URL 地址路由的方式，如果对每个服务实例手动指定一个唯一访问地址，这样做显然是不合理的。\nZuul 支持与 Eureka 整合开发，根据 serviceld 自动从注册中心获取服务地并转发清求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而目在添加或移除服务实例时不用修改 Zuul 的路由配置\n\n```java\n路由规则\nZuul\n\troutes:\n\t# 路由 id 自定义\n\t\tproduct-service:\n\t\tpath: /product-service/**#配置请 url 的映射路径\n\t\tserviceId: product-service # 根据 serviceId 自动从注册中心获取服务地址并转发请求\n```\n### 7.2.3、简化路由配置\nZuul 为了方便大家使用，提供了默认路由配置: 路由 id 和 微服务名称 一致，path 默认对应 微服务名称/* ，所以以下配置就没必要再写了。\n\n## 7.3、路由排除\n我们可以通过路由排除设置不允许被访问的资源。允许被访问的资源可以通过路由规则进行设置。\n```java\n# 路由规则\nZuul:\n\t#ignored-patterns: /**/order/** # URL 地址排除，排除所有包含 /order/ 的路径\n\tignored-services: order-service # 服务名称排除，多个服务逗号分隔，'*’排除所有\n```\n## 7.4、路由前缀\n```java\nZuul:\n\tprefix: /api\n```\n## 7.5、网关过滤器\n### 7.5.1、关键名词\n类型: 定义路由流程中应用过滤器的阶段。共 pre、routing、 post、error 4 个类型\n执行顺序: 在同类型中，定义过滤器执行的顺序。比如多个 pre 类型的执行顺序.\n条件: 执行过滤器所需的条件。true 开启，false 关闭.\n动作: 如果符合条件，将执行的动作。具体操作。\n\n### 7.5.2、过滤器类型\n **pre**: 请求被路由到源服务器之前执行的过滤器\n> 身份认证\n> 选路由\n> 请求日志\n\n**routing**: 处理将请求发送到源服务器的过滤器。 \n**post**: 响应从源服务器返回时执行的过滤器\n> 对响应增加 HTTP 头\n> 收集统计和度量指标\n> 将响应以流的方式发送回客户端\n\n**error**:上述阶段中出现错误时执行的过滤器\n\n```java\n@Component \npublic class LoginFilter extends ZuulFilter{ \n    @Override \n    public String filterType() { \n        // 登录校验，肯定是在前置拦截 \n        return \"pre\"; \n    }\n \n    @Override \n    public int filterOrder() { \n        // 顺序设置为1 \n        return 1; \n    }\n \n    @Override \n    public boolean shouldFilter() { \n        // 返回true，代表过滤器生效。 \n        return true; \n    }\n \n    @Override \n    public Object run() throws ZuulException {\n    //处理业务逻辑\n    return null;\n    }    \n}\n```\n## 7.6、网关限流\n这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的\n\n**计数器**：计算单元时间内访问接口的次数，如果达到次数，则限制访问\n\n**漏桶算法**：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃\n\n**令牌桶算法：**\n（1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理;\n（2）根据限流大小，设置按照一定的速率往桶里添加令牌;\n（3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝;\n（4）请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除:\n（5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。\n\n> 令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放回定数量的令牌\n\n### 7.6.1、网关限流\n\n1. 全局限流配置\n\n使用全局限流配置，zuul会对代理的所有服务提供限流保护\n```properties\n# 开启限流保护\nzuul.ratelimit.enabled=true\n# 60s内请求超过3次，服务端就抛出异常，60s后可以恢复正常请求\nzuul.ratelimit.default-policy.limit=3\nzuul.ratelimit.default-policy.refresh-interval=60\n# 针对IP进行限流，不影响其他IP\nzuul.ratelimit.default-policy.type=origin\n```\n\n2. 局部限流配置\n\n使用局部限流配置，zuul仅针对配置的服务提供限流保护\n```properties\n# 开启限流保护\nzuul.ratelimit.enabled=true\n# hystrix-application-client服务60s内请求超过3次，服务抛出异常。\nzuul.ratelimit.policies.hystrix-application-client.limit=3\nzuul.ratelimit.policies.hystrix-application-client.refresh-interval=60\n# 针对IP限流。\nzuul.ratelimit.policies.hystrix-application-client.type=origin\n```\n# 8、sleuth（链路追踪）\n## 8.1、链路追踪\n单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整记录下来.\n## 8.2、sleuth\nSpring Cloud sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，和其他基于日志的追踪系统，例如ELK (Elasticsearch 、 Logstash、Kibana)\nSpring cloud sleuth 提供了以下功能:\n\n- 辩路追踪: 通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。\n- 性能分析 :通过 sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。\n- 数据分析，优化链路 : 对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施.\n- 可视化错误 : 对于程序未捕获的异常，可以配合 Zipkin 查看。\n\n## 8.3、专业术语\n### 8.3.1、span\n基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父ID，以重建在一次追踪过程中不同 Span 之间的关系\n","slug":"springCloud","published":1,"updated":"2023-07-29T06:09:16.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9r000y00ujaawtdh8o","content":"<h1 id=\"1、微服务架构\"><a href=\"#1、微服务架构\" class=\"headerlink\" title=\"1、微服务架构\"></a>1、微服务架构</h1><h2 id=\"1-1、基本概念\"><a href=\"#1-1、基本概念\" class=\"headerlink\" title=\"1.1、基本概念\"></a>1.1、基本概念</h2><p>微服务是一种架构，这种架构是将单个整体应用程序分割成更小的项目关联的独立服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现，这些独立的微服务</p>\n<h2 id=\"1-2、为什么要用微服务？\"><a href=\"#1-2、为什么要用微服务？\" class=\"headerlink\" title=\"1.2、为什么要用微服务？\"></a>1.2、为什么要用微服务？</h2><h3 id=\"1-2-1、优点\"><a href=\"#1-2-1、优点\" class=\"headerlink\" title=\"1.2.1、优点\"></a>1.2.1、优点</h3><ol>\n<li>将服务拆分成单一职责的小服务，进行单独部署，服务之间通过网络进行通信</li>\n<li>每个服务应该有自己的管理团队，高度自治</li>\n<li>服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃</li>\n</ol>\n<h3 id=\"1-2-2、缺点\"><a href=\"#1-2-2、缺点\" class=\"headerlink\" title=\"1.2.2、缺点\"></a>1.2.2、缺点</h3><ol>\n<li>开发人员需要处理分布式系统的复杂性</li>\n<li>随着服务的增加，运维的压力也在增大</li>\n<li>服务治理（负载均衡，服务熔断，服务配置管理）和服务监控</li>\n</ol>\n<h2 id=\"1-3、架构的演变\"><a href=\"#1-3、架构的演变\" class=\"headerlink\" title=\"1.3、架构的演变\"></a>1.3、架构的演变</h2><h3 id=\"1-3-1、单一架构（all-in-one）\"><a href=\"#1-3-1、单一架构（all-in-one）\" class=\"headerlink\" title=\"1.3.1、单一架构（all in one）\"></a>1.3.1、单一架构（all in one）</h3><p>一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(<strong>ORM</strong>)是影响项目开发的关键（mybatis，hibernate）</p>\n<blockquote>\n<p>缺点：随着应用功能的增多，代码量越来越大，越来越难维护</p>\n</blockquote>\n<h3 id=\"1-3-2、垂直架构（vertical-application）\"><a href=\"#1-3-2、垂直架构（vertical-application）\" class=\"headerlink\" title=\"1.3.2、垂直架构（vertical application）\"></a>1.3.2、垂直架构（vertical application）</h3><p>当访问量逐渐增大，单一应用无法满足需求，我们就需要增加节点来提供系统的访问能力，但是并不是所有的模块都需要进行性能的提高，这时候单体应用架构无法满足我们的需求；我们需要将系统里面的模块进行拆分，这样对于后面的水平扩容是非常友好的；<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307290956007.jpg\" alt=\"垂直架构\"></p>\n<blockquote>\n<p>优点：系统拆分实现了流量分担，提高了系统并发量<br>   垂直架构中可以针对不同模块进行针对性优化<br>   方便水平扩展，负载均衡，系统容错率提高</p>\n</blockquote>\n<blockquote>\n<p>缺点：垂直架构中相同逻辑代码需要不断的复制，不能复用。每个垂直模块都相当于一个独立的系统</p>\n</blockquote>\n<h3 id=\"1-3-3、分布式服务架构（distributed-service）\"><a href=\"#1-3-3、分布式服务架构（distributed-service）\" class=\"headerlink\" title=\"1.3.3、分布式服务架构（distributed service）\"></a>1.3.3、分布式服务架构（distributed service）</h3><p>当垂直应用越来越多，重复的业务代码就会越来越多，并且在垂直架构中应用之间的交互不可避免，此时，为了解决基础代码重复太多、应用之间的调用等问题；我们将重复的代码抽取出来作为独立的服务，对外提供服务；</p>\n<blockquote>\n<p>rpc是传输层传输协议，效率比应用层传输要高<br>dubbo采用rpc<br>springcloud采用http，属于应用层传输</p>\n</blockquote>\n<blockquote>\n<p>优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</p>\n</blockquote>\n<blockquote>\n<p>缺点：服务越来越多，需要管理每个服务的地址，调用关系错综复杂，难以理清依赖关系，服务状态难以管理，无法根据服务情况动态管理</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291006525.jpg\" alt=\"分布式架构\"></p>\n<h3 id=\"1-3-4、SOA架构\"><a href=\"#1-3-4、SOA架构\" class=\"headerlink\" title=\"1.3.4、SOA架构\"></a>1.3.4、SOA架构</h3><p>在分布式架构下，当服务越来越多，容量的评估，小服务资源等浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理（根据请求量动态的分配资源）。它一般使用中心化的思想实现，服务的管理和调度都由中央的服务总线（ESB）来负责</p>\n<h3 id=\"1-3-4、微服务架构\"><a href=\"#1-3-4、微服务架构\" class=\"headerlink\" title=\"1.3.4、微服务架构\"></a>1.3.4、微服务架构</h3><p>微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中每个服务独立，互不影响；（怎么理解粒度更细？：微服务采用去中心化的思想来治理，注册中心只是服务发现的工具，而服务之间的调用，熔断，负载均衡等都是都是由服务自己控制的）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291013480.png\" alt=\"微服务架构\"></p>\n<h2 id=\"1-4、微服务架构解决方案\"><a href=\"#1-4、微服务架构解决方案\" class=\"headerlink\" title=\"1.4、微服务架构解决方案\"></a>1.4、微服务架构解决方案</h2><ul>\n<li><strong>国内阿里系</strong></li>\n</ul>\n<p>springboot + dubbo + zookeeper</p>\n<ul>\n<li><strong>spring cloud技术栈</strong></li>\n</ul>\n<p>spring cloud netflix<br>spring cloud spring （spring自己封装的微服务解决方案）<br>spring cloud alibaba（阿里巴巴解决方案）</p>\n<h2 id=\"1-5、SpringCloud概念\"><a href=\"#1-5、SpringCloud概念\" class=\"headerlink\" title=\"1.5、SpringCloud概念\"></a>1.5、SpringCloud概念</h2><h3 id=\"1-5-1、基本概念\"><a href=\"#1-5-1、基本概念\" class=\"headerlink\" title=\"1.5.1、基本概念\"></a>1.5.1、基本概念</h3><p>Spring Cloud是一个含概多个子项目的微服务开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.Spring Cloud在整合过程中主要是针对Netflix(耐非),alibaba开源组件的封装</p>\n<h3 id=\"1-5-2、版本\"><a href=\"#1-5-2、版本\" class=\"headerlink\" title=\"1.5.2、版本\"></a>1.5.2、版本</h3><p>springcloud版本采用伦敦地铁站命名，根据首字母顺序排序 这样设计的目的是为了更好的管理每个springcloud子项目清单，避免了总版本号与子项目版本号混淆</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291014046.png\" alt=\"image.png\"></p>\n<h3 id=\"1-5-3、组件\"><a href=\"#1-5-3、组件\" class=\"headerlink\" title=\"1.5.3、组件\"></a>1.5.3、组件</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>spring cloud官方</th>\n<th>spring cloud netflix</th>\n<th>spring cloud alibaba</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务注册发现</td>\n<td>-</td>\n<td>Eureka</td>\n<td>nacos</td>\n</tr>\n<tr>\n<td>分布式配置</td>\n<td>spring cloud config</td>\n<td>Archaius</td>\n<td>nacos</td>\n</tr>\n<tr>\n<td>服务熔断</td>\n<td>-</td>\n<td>Hystrix</td>\n<td>Sentinel</td>\n</tr>\n<tr>\n<td>服务调用</td>\n<td>Open Fegin</td>\n<td>Fegin</td>\n<td>Dubbo RPC</td>\n</tr>\n<tr>\n<td>服务路由</td>\n<td>spring cloud gateway</td>\n<td>zuul</td>\n<td>dubbo proxy</td>\n</tr>\n<tr>\n<td>分布式消息</td>\n<td>rabbitmq</td>\n<td>-</td>\n<td>rocketmq</td>\n</tr>\n<tr>\n<td>负载均衡</td>\n<td>-</td>\n<td>ribbon</td>\n<td>dubbo LB</td>\n</tr>\n<tr>\n<td>分布式事务</td>\n<td>-</td>\n<td>-</td>\n<td>Seata</td>\n</tr>\n</tbody></table>\n<h1 id=\"2、项目搭建（父工程）\"><a href=\"#2、项目搭建（父工程）\" class=\"headerlink\" title=\"2、项目搭建（父工程）\"></a>2、项目搭建（父工程）</h1><h2 id=\"2-1、引入依赖\"><a href=\"#2-1、引入依赖\" class=\"headerlink\" title=\"2.1、引入依赖\"></a>2.1、引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--springBoot父项目--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.5.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--springBoot--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--springCloud--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>Hoxton.SR6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--maven只能有一个parent 所以这里以pom引入父项目--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3、eureka（注册中心）\"><a href=\"#3、eureka（注册中心）\" class=\"headerlink\" title=\"3、eureka（注册中心）\"></a>3、eureka（注册中心）</h1><h2 id=\"3-1、基本概念\"><a href=\"#3-1、基本概念\" class=\"headerlink\" title=\"3.1、基本概念\"></a>3.1、基本概念</h2><p>注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。两个重要的功能：<strong>服务注册</strong>和<strong>服务发现</strong></p>\n<h2 id=\"3-2、常用的注册中心\"><a href=\"#3-2、常用的注册中心\" class=\"headerlink\" title=\"3.2、常用的注册中心\"></a>3.2、常用的注册中心</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291044882.png\" alt=\"常用的注册中心\"></p>\n<h2 id=\"3-3、eureka角色\"><a href=\"#3-3、eureka角色\" class=\"headerlink\" title=\"3.3、eureka角色\"></a>3.3、eureka角色</h2><ul>\n<li><strong>服务注册中心（server</strong>）：Eureka的服务端应用，提供服务注册和发现功能.</li>\n<li><strong>服务提供者（client）</strong>： 启动后向Eureka注册自己信息（地址，提供什么服务）</li>\n</ul>\n<blockquote>\n<p>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</p>\n</blockquote>\n<ul>\n<li><strong>服务消费者（client）</strong>：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li>\n</ul>\n<h2 id=\"3-4、eureka-server开发\"><a href=\"#3-4、eureka-server开发\" class=\"headerlink\" title=\"3.4、eureka server开发\"></a>3.4、eureka server开发</h2><p>搭建eureka server子项目</p>\n<h3 id=\"3-4-1、引入依赖\"><a href=\"#3-4-1、引入依赖\" class=\"headerlink\" title=\"3.4.1、引入依赖\"></a>3.4.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--springBoot--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--eurekaServer--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-2、配置文件\"><a href=\"#3-4-2、配置文件\" class=\"headerlink\" title=\"3.4.2、配置文件\"></a>3.4.2、配置文件</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># eureka server端口号 （默认就是8761）</span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8761</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-3、入口类加注解\"><a href=\"#3-4-3、入口类加注解\" class=\"headerlink\" title=\"3.4.3、入口类加注解\"></a>3.4.3、入口类加注解</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableEurekaServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EurekaServerApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-5、eureka-client开发\"><a href=\"#3-5、eureka-client开发\" class=\"headerlink\" title=\"3.5、eureka client开发\"></a>3.5、eureka client开发</h2><h3 id=\"3-5-1、引入依赖\"><a href=\"#3-5-1、引入依赖\" class=\"headerlink\" title=\"3.5.1、引入依赖\"></a>3.5.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--eureka client依赖--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--springboot依赖--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-2、配置文件\"><a href=\"#3-5-2、配置文件\" class=\"headerlink\" title=\"3.5.2、配置文件\"></a>3.5.2、配置文件</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8989</span></span><br><span class=\"line\"><span class=\"comment\"># 应用名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKACLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-3、启动类\"><a href=\"#3-5-3、启动类\" class=\"headerlink\" title=\"3.5.3、启动类\"></a>3.5.3、启动类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableEurekaClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EurekaClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6、eureka自我保护机制\"><a href=\"#3-6、eureka自我保护机制\" class=\"headerlink\" title=\"3.6、eureka自我保护机制\"></a>3.6、eureka自我保护机制</h2><h3 id=\"3-6-1、自我保护机制\"><a href=\"#3-6-1、自我保护机制\" class=\"headerlink\" title=\"3.6.1、自我保护机制\"></a>3.6.1、自我保护机制</h3><p>默认情况下，如果eureka server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，eureka server将会移除掉该实例（eureka客户端每隔60秒会发送一次心跳包）</p>\n<p>但是当网络分区发生故障，微服务和eureka server之间无法通信，但是微服务本身是正常的，此时不应该移除这个服务，所以就引入了自我保护机制</p>\n<p>Eureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期</p>\n<blockquote>\n<p>自我保护机制清除：<br>（1）心跳次数高于预期值<br>（2）自我保护机制被禁用</p>\n</blockquote>\n<h3 id=\"3-6-2、如何关闭自我保护机制\"><a href=\"#3-6-2、如何关闭自我保护机制\" class=\"headerlink\" title=\"3.6.2、如何关闭自我保护机制\"></a>3.6.2、如何关闭自我保护机制</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">eureka</span>:<span class=\"string\"></span></span><br><span class=\"line\">  <span class=\"attr\">server</span>:<span class=\"string\"></span></span><br><span class=\"line\"><span class=\"comment\">    #服务端是否开启自我保护机制 （默认true）</span></span><br><span class=\"line\">    <span class=\"attr\">enable-self-preservation</span>: <span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\">    # eureka客户端每隔多长时间发一次心跳（单位毫秒，默认是60*1000）即60秒</span></span><br><span class=\"line\">    <span class=\"attr\">eviction-interval-timer-in-ms</span>: <span class=\"string\">60000</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、eureka-server集群\"><a href=\"#3-7、eureka-server集群\" class=\"headerlink\" title=\"3.7、eureka server集群\"></a>3.7、eureka server集群</h2><p>多个注册中心之间相互注册就可搭建eureka server集群</p>\n<blockquote>\n<p>服务端：eureka.client.service-url.defaultZone 配置其它的注册中心地址即可</p>\n</blockquote>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># eureka server端口号 （默认就是8761）</span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8761</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER01</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8762/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"># eureka server端口号 </span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8762</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER02</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>客户端：所有的注册中心地址都需要指明</p>\n</blockquote>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8989</span></span><br><span class=\"line\"><span class=\"comment\"># 应用名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKACLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka,http://localhost:8762/eureka</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"4、consul（注册中心）\"><a href=\"#4、consul（注册中心）\" class=\"headerlink\" title=\"4、consul（注册中心）\"></a>4、consul（注册中心）</h1><h2 id=\"4-1、简介\"><a href=\"#4-1、简介\" class=\"headerlink\" title=\"4.1、简介\"></a>4.1、简介</h2><p>consul是基于go语言进行开发的服务注册中心，是一个可以直接运行的注册中心工具，不需要像eureka注册中心一样再进行编码。使用起来较为简单</p>\n<h2 id=\"4-2、安装\"><a href=\"#4-2、安装\" class=\"headerlink\" title=\"4.2、安装\"></a>4.2、安装</h2><ol>\n<li><p>下载 <a href=\"https://www.consul.io/downloads\">https://www.consul.io/downloads</a></p>\n</li>\n<li><p>解压</p>\n</li>\n<li><p>启动服务注册中心（cmd）</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">consul</span> <span class=\"string\">agent -dev</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问管理界面：<a href=\"http://localhost:8500/\">http://localhost:8500/</a></p>\n</li>\n</ol>\n<h2 id=\"4-3、consul-client开发\"><a href=\"#4-3、consul-client开发\" class=\"headerlink\" title=\"4.3、consul client开发\"></a>4.3、consul client开发</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--springboot依赖--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--consul客户端组件--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"comment\">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写配置文件</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8082</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">CONSULCLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 向consul server服务注册地址</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.port</span>=<span class=\"string\">8500</span></span><br><span class=\"line\"><span class=\"comment\"># 默认为$&#123;spring.application.name&#125;</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.discovery.service-name</span>=<span class=\"string\">CONSULCLIENT</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动类添加注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">// 除了eureka，其它注册中心客户端都可以用该注解</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-4、consul健康检查\"><a href=\"#4-4、consul健康检查\" class=\"headerlink\" title=\"4.4、consul健康检查\"></a>4.4、consul健康检查</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291356805.png\" alt=\"image (10).png\"></p>\n<ol>\n<li>默认情况下consul监控健康是开启的，但必须依赖健康监控依赖才能正常响应客户端发来的心跳，否则界面会显示错误，引入健康依赖之后服务正常<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"5、openFeign（服务间通信）\"><a href=\"#5、openFeign（服务间通信）\" class=\"headerlink\" title=\"5、openFeign（服务间通信）\"></a>5、openFeign（服务间通信）</h1><h2 id=\"5-1、基于RestTemplate实现调用\"><a href=\"#5-1、基于RestTemplate实现调用\" class=\"headerlink\" title=\"5.1、基于RestTemplate实现调用\"></a>5.1、基于RestTemplate实现调用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2Controller</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;client 2 OK!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">RestTemplate</span> <span class=\"variable\">restTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> restTemplate.getForObject(<span class=\"string\">&quot;http://localhost:8088/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span>+result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2、基于RestTemplate-Ribbon实现负载均衡调用\"><a href=\"#5-2、基于RestTemplate-Ribbon实现负载均衡调用\" class=\"headerlink\" title=\"5.2、基于RestTemplate+Ribbon实现负载均衡调用\"></a>5.2、基于RestTemplate+Ribbon实现负载均衡调用</h2><p>spring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现，通过spring cloud封装，可以让我们轻松的进行客户端负载均衡调用。Ribbon可从注册中心中获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例</p>\n<ol>\n<li><strong>编码形式</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">// 服务注册与发现客户端对象（获取服务列表后需要手动选取）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiscoveryClient discoveryClient;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">// 具有负载均衡的服务注册与发现客户端对象（根据负载均衡策略自动选取一个）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// （1）DiscoveryClient</span></span><br><span class=\"line\">        List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(<span class=\"string\">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>().getForObject(serviceInstances.get(<span class=\"number\">0</span>).getUri() + <span class=\"string\">&quot;/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"comment\">// （2）LoadBalanceClient</span></span><br><span class=\"line\">        <span class=\"type\">ServiceInstance</span> <span class=\"variable\">serviceInstances2</span> <span class=\"operator\">=</span> loadBalancerClient.choose(<span class=\"string\">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>().getForObject(serviceInstances2.getUri() + <span class=\"string\">&quot;/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>@LoadBalance注解实现负载均衡</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@LoadBalanced</span> <span class=\"comment\">// 使RestTemplate对象具有ribbon负载均衡特性</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RestTemplate <span class=\"title function_\">restTemplate</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RestTemplate restTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result3</span> <span class=\"operator\">=</span> restTemplate.getForObject(<span class=\"string\">&quot;http://CONSULCLIENT2/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Ribbon负载均衡策略</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>策略类</th>\n<th>命名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RoundRobinRule</td>\n<td>轮询策略</td>\n<td>轮询选择，轮询index，选择index对应位置的Server</td>\n</tr>\n<tr>\n<td>RandomRule</td>\n<td>随机策略</td>\n<td>随机选择server</td>\n</tr>\n<tr>\n<td>BestAvailableRule</td>\n<td>最低并发策略</td>\n<td>选择其中并发链接最低的server</td>\n</tr>\n<tr>\n<td>RetryRule</td>\n<td>重试策略</td>\n<td>其实就是轮询策略的加强版，轮询策略服务不可用时不处理，重试策略会尝试其它节点</td>\n</tr>\n<tr>\n<td>AvailabilityFilteringRule</td>\n<td>可用过滤策略</td>\n<td>过滤掉一直连接失败的provider和繁忙的provider</td>\n</tr>\n<tr>\n<td>ZoneAvoidanceRule</td>\n<td>区域权重策略</td>\n<td>如果某个ip区域内有一个或多个示例不可达或响应慢，都会降低该ip区域内其它ip被选中的权重</td>\n</tr>\n</tbody></table>\n<ol start=\"4\">\n<li><strong>负载均衡策略设置</strong></li>\n</ol>\n<p>（1）局部修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 负载均衡策略 provider为调用的服务的名称</span><br><span class=\"line\"># 格式：服务应用名.ribbon.负载均衡策略名字</span><br><span class=\"line\">provider:</span><br><span class=\"line\">  ribbon:</span><br><span class=\"line\">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure>\n<p>（2）全局修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 所有被调用服务均使用该策略</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RandomRule <span class=\"title function_\">randomRule</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomRule</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-3、基于openFeign实现调用\"><a href=\"#5-3、基于openFeign实现调用\" class=\"headerlink\" title=\"5.3、基于openFeign实现调用\"></a>5.3、基于openFeign实现调用</h2><h3 id=\"5-3-1、Feign\"><a href=\"#5-3-1、Feign\" class=\"headerlink\" title=\"5.3.1、Feign\"></a>5.3.1、Feign</h3><blockquote>\n<p>Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务</p>\n</blockquote>\n<h3 id=\"5-3-2、openFeign\"><a href=\"#5-3-2、openFeign\" class=\"headerlink\" title=\"5.3.2、openFeign\"></a>5.3.2、openFeign</h3><blockquote>\n<p>OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。<br>OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，<br>并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</p>\n</blockquote>\n<h3 id=\"5-3-3、openFeign调用\"><a href=\"#5-3-3、openFeign调用\" class=\"headerlink\" title=\"5.3.3、openFeign调用\"></a>5.3.3、openFeign调用</h3><h4 id=\"5-3-3-1、编码\"><a href=\"#5-3-3-1、编码\" class=\"headerlink\" title=\"5.3.3.1、编码\"></a>5.3.3.1、编码</h4><p>（1）引入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--openFeign--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>（2）启动类开启openFeign的调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"meta\">@EnableFeignClients</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）创建业务层接口，添加@FeginClient注解声明需要调用的服务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FeignClient(&quot;CONSULCLIENT2&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Client2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    String <span class=\"title function_\">test2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（4）调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client2 client2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> client2.test2();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-3-3-2、接口参数传递详解\"><a href=\"#5-3-3-2、接口参数传递详解\" class=\"headerlink\" title=\"5.3.3.2、接口参数传递详解\"></a>5.3.3.2、接口参数传递详解</h4><blockquote>\n<p>（1）test？name&#x3D;xxx&amp;age&#x3D;10  —— @RequestParam(“name”)<br>（2）test&#x2F;{id}   ——  @PathVarible(“id”)<br>（3）test(@RequestBody User user)<br>（4）集合和数组作为参数时封装到VO对象中</p>\n</blockquote>\n<h4 id=\"5-3-3-3、超时处理\"><a href=\"#5-3-3-3、超时处理\" class=\"headerlink\" title=\"5.3.3.3、超时处理\"></a>5.3.3.3、超时处理</h4><ol>\n<li>默认超时时间：1s</li>\n<li>修改某个服务的超时时间</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feign.client.config.PRODUCTS.connecTimeOut</span>=<span class=\"string\">5000 # 配置指定服务连接超时</span></span><br><span class=\"line\"><span class=\"attr\">feign.client.config.PRODUCTS.readTimeOut</span>=<span class=\"string\">5000 # 配置指定服务等待超时</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改所有服务超时时间</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feign.client.config.default.connecTimeOut</span>=<span class=\"string\">5000 # 配置服务连接超时</span></span><br><span class=\"line\"><span class=\"attr\">feign.client.config.default.readTimeOut</span>=<span class=\"string\">5000 # 配置服务等待超时</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、Hystrix（服务熔断）\"><a href=\"#6、Hystrix（服务熔断）\" class=\"headerlink\" title=\"6、Hystrix（服务熔断）\"></a>6、Hystrix（服务熔断）</h1><h2 id=\"6-1、什么是服务雪崩？\"><a href=\"#6-1、什么是服务雪崩？\" class=\"headerlink\" title=\"6.1、什么是服务雪崩？\"></a>6.1、什么是服务雪崩？</h2><p>因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象</p>\n<blockquote>\n<p>（1）程序bug导致服务不可用，或者运行缓慢<br>（2）缓存击穿，导致调用全部访问某服务，导致down掉<br>（3）访问量的突然激增</p>\n</blockquote>\n<h2 id=\"6-2、解决服务雪崩（-熔断-降级）\"><a href=\"#6-2、解决服务雪崩（-熔断-降级）\" class=\"headerlink\" title=\"6.2、解决服务雪崩（ 熔断 + 降级）\"></a>6.2、解决服务雪崩（ 熔断 + 降级）</h2><ol>\n<li><strong>服务熔断</strong></li>\n</ol>\n<p>一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，向调用方返回一个符合预期的的备选响应，而不是长时间等待或抛出异常。所以很多地方把熔断亦称为过载保护</p>\n<ol start=\"2\">\n<li><strong>服务降级</strong></li>\n</ol>\n<p>当网站或服务流量突然增加时，为了保证系统核心服务正常运行，有策略的关闭系统中的边缘服务，以保证核心服务的正常运行</p>\n<ol start=\"3\">\n<li><strong>熔断降级的关系</strong></li>\n</ol>\n<p>熔断必会出发降级，所以熔断也是降级的一种，区别在于熔断是对调用链路的保护，降级是对系统过载的一种保护</p>\n<h2 id=\"6-3、Hystrix概念\"><a href=\"#6-3、Hystrix概念\" class=\"headerlink\" title=\"6.3、Hystrix概念\"></a>6.3、Hystrix概念</h2><p>Hystrix是处理分布式系统延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时，异常等。Hystrix能够保证在一个依赖出现问题时，不会导致整体服务失败，避免雪崩效应，提高分布式系统的弹性</p>\n<h2 id=\"6-4、编码\"><a href=\"#6-4、编码\" class=\"headerlink\" title=\"6.4、编码\"></a>6.4、编码</h2><ol>\n<li>所有服务引入Hystrix依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--hystrix--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>服务提供者</li>\n</ol>\n<p>（直接调用服务提供者的方案，是一种服务降级的思想）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启熔断功能</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span> <span class=\"comment\">//开启hystrix熔断功能</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClient2Application</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClient2Application.class,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2Controller</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand(fallbackMethod = &quot;demoFallBack&quot;,defaultFallback = &quot;defaultFallBack&quot;)</span> <span class=\"comment\">//熔断之后的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(Integer id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;发生异常！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;client 2:8088 OK!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">demoFallBack</span><span class=\"params\">(Integer id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务被熔断&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">defaultFallBack</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务被熔断(默认)&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>服务消费者</li>\n</ol>\n<p>（通过服务消费者调用的方案，服务者完全挂掉时的处理，是一种服务熔断的思想）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启openFeign支持服务降级</span><br><span class=\"line\">feign.hystrix.enabled=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span>  <span class=\"comment\">// 开启服务注册客户端</span></span><br><span class=\"line\"><span class=\"meta\">@EnableFeignClients</span>  <span class=\"comment\">// 开启openFeign调用</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span> <span class=\"comment\">// 开启hystrix熔断功能</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fallback:指定当服务不可用时，默认的备选处理</span></span><br><span class=\"line\"><span class=\"meta\">@FeignClient(value = &quot;CONSULCLIENT2&quot;,fallback = Client2FallBack.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Client2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class=\"line\">    String <span class=\"title function_\">test2</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2FallBack</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Client2</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test2</span><span class=\"params\">(Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;当前服务不可达&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client2 client2;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> client2.test2(id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、Hystrix服务熔断机制\"><a href=\"#6-5、Hystrix服务熔断机制\" class=\"headerlink\" title=\"6.5、Hystrix服务熔断机制\"></a>6.5、Hystrix服务熔断机制</h2><h3 id=\"6-5-1、Hystrix断路器打开的条件\"><a href=\"#6-5-1、Hystrix断路器打开的条件\" class=\"headerlink\" title=\"6.5.1、Hystrix断路器打开的条件\"></a>6.5.1、Hystrix断路器打开的条件</h3><p>a. 当满足一定阈值的时候（默认10秒内超过20个请求次数）<br>b. 当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p>\n<blockquote>\n<p>注意：一旦断路开启之后，所有到这个服务请求均不可用，只有在断路关闭之后才可用</p>\n</blockquote>\n<h3 id=\"6-5-2、Hystrix监控流程\"><a href=\"#6-5-2、Hystrix监控流程\" class=\"headerlink\" title=\"6.5.2、Hystrix监控流程\"></a>6.5.2、Hystrix监控流程</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291357597.png\" alt=\"Hystrix监控流程\"></p>\n<p>当服务调用达到两个阈值，会自动开启断路器，在熔断器打开期间，任何到该接口的请求均不可用，同时在断路器打开5s后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果执行成功，断路器彻底关闭，执行失败则重新打开</p>\n<h2 id=\"6-6、Hystrix-Dashboard（仪表盘）\"><a href=\"#6-6、Hystrix-Dashboard（仪表盘）\" class=\"headerlink\" title=\"6.6、Hystrix Dashboard（仪表盘）\"></a>6.6、Hystrix Dashboard（仪表盘）</h2><ol>\n<li>基本概念</li>\n</ol>\n<p>Hystrix Dashboard主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题</p>\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<p>（1）新建一个 Hystrix Dashboard 工程<br>（2）引入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Cloud Hystrix Dashboard --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>（3）启动类开启监控功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 开启 Hystrix Dashboard 监控功能 */</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure>\n<p>（4）访问仪表盘界面</p>\n<blockquote>\n<p><a href=\"http://localhost:9000/hystrix\">http://localhost:9000/hystrix</a><br>端口为项目的端口号</p>\n</blockquote>\n<h1 id=\"7、zuul（网关）\"><a href=\"#7、zuul（网关）\" class=\"headerlink\" title=\"7、zuul（网关）\"></a>7、zuul（网关）</h1><p>Zuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。zuul 包含了对请求的<strong>路由</strong>和<strong>过滤</strong>两个最主要的功能。</p>\n<p>Zuul是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能:</p>\n<p>（1）聚合接口使得服务对调用者透明，客户端与后端的耦合度降低<br>（2）聚合后台服务，节省流量，提高性能，提升用户体验<br>（3）提供安全、流控、过滤、缓存、计费、监控等 API 管理功能</p>\n<h2 id=\"7-1、搭建环境\"><a href=\"#7-1、搭建环境\" class=\"headerlink\" title=\"7.1、搭建环境\"></a>7.1、搭建环境</h2><p>创建一个应用，在启动类中添加注解@EnableZuulProxy，声明这是一个网关服务提供者</p>\n<h2 id=\"7-2、路由规则配置\"><a href=\"#7-2、路由规则配置\" class=\"headerlink\" title=\"7.2、路由规则配置\"></a>7.2、路由规则配置</h2><h3 id=\"7-2-1、URL地址路由\"><a href=\"#7-2-1、URL地址路由\" class=\"headerlink\" title=\"7.2.1、URL地址路由\"></a>7.2.1、URL地址路由</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 路由规则</span><br><span class=\"line\">zuul:</span><br><span class=\"line\">\troutes :</span><br><span class=\"line\">        # 路由 id 自定义</span><br><span class=\"line\">        product-service :</span><br><span class=\"line\">\t\t\tpath: /product-service<span class=\"comment\">/**配请求 ur1 的映射路径#</span></span><br><span class=\"line\"><span class=\"comment\">    \t\turl: http://localhost:7070/ # 映射路径对应的微服务地址</span></span><br></pre></td></tr></table></figure>\n<p>通配符含义：</p>\n<table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>含义</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>？</td>\n<td>匹配任意单个字符</td>\n<td>&#x2F;product-service&#x2F;?</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配任意数量字符不包括子路径</td>\n<td>&#x2F;product-service&#x2F;*</td>\n</tr>\n<tr>\n<td>**</td>\n<td>匹配任意数量字符包括所有子路径</td>\n<td>&#x2F;product-service&#x2F;**</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-2-2、服务名称路由\"><a href=\"#7-2-2、服务名称路由\" class=\"headerlink\" title=\"7.2.2、服务名称路由\"></a>7.2.2、服务名称路由</h3><p>微服务一般是由几十、上百个服务组成，对于 URL 地址路由的方式，如果对每个服务实例手动指定一个唯一访问地址，这样做显然是不合理的。<br>Zuul 支持与 Eureka 整合开发，根据 serviceld 自动从注册中心获取服务地并转发清求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而目在添加或移除服务实例时不用修改 Zuul 的路由配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">路由规则</span><br><span class=\"line\">Zuul</span><br><span class=\"line\">\troutes:</span><br><span class=\"line\">\t# 路由 id 自定义</span><br><span class=\"line\">\t\tproduct-service:</span><br><span class=\"line\">\t\tpath: /product-service<span class=\"comment\">/**#配置请 url 的映射路径</span></span><br><span class=\"line\"><span class=\"comment\">\t\tserviceId: product-service # 根据 serviceId 自动从注册中心获取服务地址并转发请求</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-2-3、简化路由配置\"><a href=\"#7-2-3、简化路由配置\" class=\"headerlink\" title=\"7.2.3、简化路由配置\"></a>7.2.3、简化路由配置</h3><p>Zuul 为了方便大家使用，提供了默认路由配置: 路由 id 和 微服务名称 一致，path 默认对应 微服务名称&#x2F;* ，所以以下配置就没必要再写了。</p>\n<h2 id=\"7-3、路由排除\"><a href=\"#7-3、路由排除\" class=\"headerlink\" title=\"7.3、路由排除\"></a>7.3、路由排除</h2><p>我们可以通过路由排除设置不允许被访问的资源。允许被访问的资源可以通过路由规则进行设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 路由规则</span><br><span class=\"line\">Zuul:</span><br><span class=\"line\">\t#ignored-patterns: <span class=\"comment\">/**/order/** # URL 地址排除，排除所有包含 /order/ 的路径</span></span><br><span class=\"line\"><span class=\"comment\">\tignored-services: order-service # 服务名称排除，多个服务逗号分隔，&#x27;*’排除所有</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-4、路由前缀\"><a href=\"#7-4、路由前缀\" class=\"headerlink\" title=\"7.4、路由前缀\"></a>7.4、路由前缀</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Zuul:</span><br><span class=\"line\">\tprefix: /api</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-5、网关过滤器\"><a href=\"#7-5、网关过滤器\" class=\"headerlink\" title=\"7.5、网关过滤器\"></a>7.5、网关过滤器</h2><h3 id=\"7-5-1、关键名词\"><a href=\"#7-5-1、关键名词\" class=\"headerlink\" title=\"7.5.1、关键名词\"></a>7.5.1、关键名词</h3><p>类型: 定义路由流程中应用过滤器的阶段。共 pre、routing、 post、error 4 个类型<br>执行顺序: 在同类型中，定义过滤器执行的顺序。比如多个 pre 类型的执行顺序.<br>条件: 执行过滤器所需的条件。true 开启，false 关闭.<br>动作: 如果符合条件，将执行的动作。具体操作。</p>\n<h3 id=\"7-5-2、过滤器类型\"><a href=\"#7-5-2、过滤器类型\" class=\"headerlink\" title=\"7.5.2、过滤器类型\"></a>7.5.2、过滤器类型</h3><p> <strong>pre</strong>: 请求被路由到源服务器之前执行的过滤器</p>\n<blockquote>\n<p>身份认证<br>选路由<br>请求日志</p>\n</blockquote>\n<p><strong>routing</strong>: 处理将请求发送到源服务器的过滤器。<br><strong>post</strong>: 响应从源服务器返回时执行的过滤器</p>\n<blockquote>\n<p>对响应增加 HTTP 头<br>收集统计和度量指标<br>将响应以流的方式发送回客户端</p>\n</blockquote>\n<p><strong>error</strong>:上述阶段中出现错误时执行的过滤器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginFilter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ZuulFilter</span>&#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">filterType</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 登录校验，肯定是在前置拦截 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;pre&quot;</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">filterOrder</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 顺序设置为1 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldFilter</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 返回true，代表过滤器生效。 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">run</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZuulException &#123;</span><br><span class=\"line\">    <span class=\"comment\">//处理业务逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-6、网关限流\"><a href=\"#7-6、网关限流\" class=\"headerlink\" title=\"7.6、网关限流\"></a>7.6、网关限流</h2><p>这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的</p>\n<p><strong>计数器</strong>：计算单元时间内访问接口的次数，如果达到次数，则限制访问</p>\n<p><strong>漏桶算法</strong>：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃</p>\n<p><strong>令牌桶算法：</strong><br>（1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理;<br>（2）根据限流大小，设置按照一定的速率往桶里添加令牌;<br>（3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝;<br>（4）请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除:<br>（5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。</p>\n<blockquote>\n<p>令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放回定数量的令牌</p>\n</blockquote>\n<h3 id=\"7-6-1、网关限流\"><a href=\"#7-6-1、网关限流\" class=\"headerlink\" title=\"7.6.1、网关限流\"></a>7.6.1、网关限流</h3><ol>\n<li>全局限流配置</li>\n</ol>\n<p>使用全局限流配置，zuul会对代理的所有服务提供限流保护</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启限流保护</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 60s内请求超过3次，服务端就抛出异常，60s后可以恢复正常请求</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.limit</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.refresh-interval</span>=<span class=\"string\">60</span></span><br><span class=\"line\"><span class=\"comment\"># 针对IP进行限流，不影响其他IP</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.type</span>=<span class=\"string\">origin</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>局部限流配置</li>\n</ol>\n<p>使用局部限流配置，zuul仅针对配置的服务提供限流保护</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启限流保护</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># hystrix-application-client服务60s内请求超过3次，服务抛出异常。</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.limit</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.refresh-interval</span>=<span class=\"string\">60</span></span><br><span class=\"line\"><span class=\"comment\"># 针对IP限流。</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.type</span>=<span class=\"string\">origin</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"8、sleuth（链路追踪）\"><a href=\"#8、sleuth（链路追踪）\" class=\"headerlink\" title=\"8、sleuth（链路追踪）\"></a>8、sleuth（链路追踪）</h1><h2 id=\"8-1、链路追踪\"><a href=\"#8-1、链路追踪\" class=\"headerlink\" title=\"8.1、链路追踪\"></a>8.1、链路追踪</h2><p>单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整记录下来.</p>\n<h2 id=\"8-2、sleuth\"><a href=\"#8-2、sleuth\" class=\"headerlink\" title=\"8.2、sleuth\"></a>8.2、sleuth</h2><p>Spring Cloud sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，和其他基于日志的追踪系统，例如ELK (Elasticsearch 、 Logstash、Kibana)<br>Spring cloud sleuth 提供了以下功能:</p>\n<ul>\n<li>辩路追踪: 通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。</li>\n<li>性能分析 :通过 sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。</li>\n<li>数据分析，优化链路 : 对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施.</li>\n<li>可视化错误 : 对于程序未捕获的异常，可以配合 Zipkin 查看。</li>\n</ul>\n<h2 id=\"8-3、专业术语\"><a href=\"#8-3、专业术语\" class=\"headerlink\" title=\"8.3、专业术语\"></a>8.3、专业术语</h2><h3 id=\"8-3-1、span\"><a href=\"#8-3-1、span\" class=\"headerlink\" title=\"8.3.1、span\"></a>8.3.1、span</h3><p>基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父ID，以重建在一次追踪过程中不同 Span 之间的关系</p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、微服务架构\"><a href=\"#1、微服务架构\" class=\"headerlink\" title=\"1、微服务架构\"></a>1、微服务架构</h1><h2 id=\"1-1、基本概念\"><a href=\"#1-1、基本概念\" class=\"headerlink\" title=\"1.1、基本概念\"></a>1.1、基本概念</h2><p>微服务是一种架构，这种架构是将单个整体应用程序分割成更小的项目关联的独立服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现，这些独立的微服务</p>\n<h2 id=\"1-2、为什么要用微服务？\"><a href=\"#1-2、为什么要用微服务？\" class=\"headerlink\" title=\"1.2、为什么要用微服务？\"></a>1.2、为什么要用微服务？</h2><h3 id=\"1-2-1、优点\"><a href=\"#1-2-1、优点\" class=\"headerlink\" title=\"1.2.1、优点\"></a>1.2.1、优点</h3><ol>\n<li>将服务拆分成单一职责的小服务，进行单独部署，服务之间通过网络进行通信</li>\n<li>每个服务应该有自己的管理团队，高度自治</li>\n<li>服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃</li>\n</ol>\n<h3 id=\"1-2-2、缺点\"><a href=\"#1-2-2、缺点\" class=\"headerlink\" title=\"1.2.2、缺点\"></a>1.2.2、缺点</h3><ol>\n<li>开发人员需要处理分布式系统的复杂性</li>\n<li>随着服务的增加，运维的压力也在增大</li>\n<li>服务治理（负载均衡，服务熔断，服务配置管理）和服务监控</li>\n</ol>\n<h2 id=\"1-3、架构的演变\"><a href=\"#1-3、架构的演变\" class=\"headerlink\" title=\"1.3、架构的演变\"></a>1.3、架构的演变</h2><h3 id=\"1-3-1、单一架构（all-in-one）\"><a href=\"#1-3-1、单一架构（all-in-one）\" class=\"headerlink\" title=\"1.3.1、单一架构（all in one）\"></a>1.3.1、单一架构（all in one）</h3><p>一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(<strong>ORM</strong>)是影响项目开发的关键（mybatis，hibernate）</p>\n<blockquote>\n<p>缺点：随着应用功能的增多，代码量越来越大，越来越难维护</p>\n</blockquote>\n<h3 id=\"1-3-2、垂直架构（vertical-application）\"><a href=\"#1-3-2、垂直架构（vertical-application）\" class=\"headerlink\" title=\"1.3.2、垂直架构（vertical application）\"></a>1.3.2、垂直架构（vertical application）</h3><p>当访问量逐渐增大，单一应用无法满足需求，我们就需要增加节点来提供系统的访问能力，但是并不是所有的模块都需要进行性能的提高，这时候单体应用架构无法满足我们的需求；我们需要将系统里面的模块进行拆分，这样对于后面的水平扩容是非常友好的；<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307290956007.jpg\" alt=\"垂直架构\"></p>\n<blockquote>\n<p>优点：系统拆分实现了流量分担，提高了系统并发量<br>   垂直架构中可以针对不同模块进行针对性优化<br>   方便水平扩展，负载均衡，系统容错率提高</p>\n</blockquote>\n<blockquote>\n<p>缺点：垂直架构中相同逻辑代码需要不断的复制，不能复用。每个垂直模块都相当于一个独立的系统</p>\n</blockquote>\n<h3 id=\"1-3-3、分布式服务架构（distributed-service）\"><a href=\"#1-3-3、分布式服务架构（distributed-service）\" class=\"headerlink\" title=\"1.3.3、分布式服务架构（distributed service）\"></a>1.3.3、分布式服务架构（distributed service）</h3><p>当垂直应用越来越多，重复的业务代码就会越来越多，并且在垂直架构中应用之间的交互不可避免，此时，为了解决基础代码重复太多、应用之间的调用等问题；我们将重复的代码抽取出来作为独立的服务，对外提供服务；</p>\n<blockquote>\n<p>rpc是传输层传输协议，效率比应用层传输要高<br>dubbo采用rpc<br>springcloud采用http，属于应用层传输</p>\n</blockquote>\n<blockquote>\n<p>优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</p>\n</blockquote>\n<blockquote>\n<p>缺点：服务越来越多，需要管理每个服务的地址，调用关系错综复杂，难以理清依赖关系，服务状态难以管理，无法根据服务情况动态管理</p>\n</blockquote>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291006525.jpg\" alt=\"分布式架构\"></p>\n<h3 id=\"1-3-4、SOA架构\"><a href=\"#1-3-4、SOA架构\" class=\"headerlink\" title=\"1.3.4、SOA架构\"></a>1.3.4、SOA架构</h3><p>在分布式架构下，当服务越来越多，容量的评估，小服务资源等浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理（根据请求量动态的分配资源）。它一般使用中心化的思想实现，服务的管理和调度都由中央的服务总线（ESB）来负责</p>\n<h3 id=\"1-3-4、微服务架构\"><a href=\"#1-3-4、微服务架构\" class=\"headerlink\" title=\"1.3.4、微服务架构\"></a>1.3.4、微服务架构</h3><p>微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中每个服务独立，互不影响；（怎么理解粒度更细？：微服务采用去中心化的思想来治理，注册中心只是服务发现的工具，而服务之间的调用，熔断，负载均衡等都是都是由服务自己控制的）</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291013480.png\" alt=\"微服务架构\"></p>\n<h2 id=\"1-4、微服务架构解决方案\"><a href=\"#1-4、微服务架构解决方案\" class=\"headerlink\" title=\"1.4、微服务架构解决方案\"></a>1.4、微服务架构解决方案</h2><ul>\n<li><strong>国内阿里系</strong></li>\n</ul>\n<p>springboot + dubbo + zookeeper</p>\n<ul>\n<li><strong>spring cloud技术栈</strong></li>\n</ul>\n<p>spring cloud netflix<br>spring cloud spring （spring自己封装的微服务解决方案）<br>spring cloud alibaba（阿里巴巴解决方案）</p>\n<h2 id=\"1-5、SpringCloud概念\"><a href=\"#1-5、SpringCloud概念\" class=\"headerlink\" title=\"1.5、SpringCloud概念\"></a>1.5、SpringCloud概念</h2><h3 id=\"1-5-1、基本概念\"><a href=\"#1-5-1、基本概念\" class=\"headerlink\" title=\"1.5.1、基本概念\"></a>1.5.1、基本概念</h3><p>Spring Cloud是一个含概多个子项目的微服务开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.Spring Cloud在整合过程中主要是针对Netflix(耐非),alibaba开源组件的封装</p>\n<h3 id=\"1-5-2、版本\"><a href=\"#1-5-2、版本\" class=\"headerlink\" title=\"1.5.2、版本\"></a>1.5.2、版本</h3><p>springcloud版本采用伦敦地铁站命名，根据首字母顺序排序 这样设计的目的是为了更好的管理每个springcloud子项目清单，避免了总版本号与子项目版本号混淆</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291014046.png\" alt=\"image.png\"></p>\n<h3 id=\"1-5-3、组件\"><a href=\"#1-5-3、组件\" class=\"headerlink\" title=\"1.5.3、组件\"></a>1.5.3、组件</h3><table>\n<thead>\n<tr>\n<th></th>\n<th>spring cloud官方</th>\n<th>spring cloud netflix</th>\n<th>spring cloud alibaba</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务注册发现</td>\n<td>-</td>\n<td>Eureka</td>\n<td>nacos</td>\n</tr>\n<tr>\n<td>分布式配置</td>\n<td>spring cloud config</td>\n<td>Archaius</td>\n<td>nacos</td>\n</tr>\n<tr>\n<td>服务熔断</td>\n<td>-</td>\n<td>Hystrix</td>\n<td>Sentinel</td>\n</tr>\n<tr>\n<td>服务调用</td>\n<td>Open Fegin</td>\n<td>Fegin</td>\n<td>Dubbo RPC</td>\n</tr>\n<tr>\n<td>服务路由</td>\n<td>spring cloud gateway</td>\n<td>zuul</td>\n<td>dubbo proxy</td>\n</tr>\n<tr>\n<td>分布式消息</td>\n<td>rabbitmq</td>\n<td>-</td>\n<td>rocketmq</td>\n</tr>\n<tr>\n<td>负载均衡</td>\n<td>-</td>\n<td>ribbon</td>\n<td>dubbo LB</td>\n</tr>\n<tr>\n<td>分布式事务</td>\n<td>-</td>\n<td>-</td>\n<td>Seata</td>\n</tr>\n</tbody></table>\n<h1 id=\"2、项目搭建（父工程）\"><a href=\"#2、项目搭建（父工程）\" class=\"headerlink\" title=\"2、项目搭建（父工程）\"></a>2、项目搭建（父工程）</h1><h2 id=\"2-1、引入依赖\"><a href=\"#2-1、引入依赖\" class=\"headerlink\" title=\"2.1、引入依赖\"></a>2.1、引入依赖</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--springBoot父项目--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.2.5.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencyManagement</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--springBoot--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--springCloud--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-dependencies<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>Hoxton.SR6<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">                <span class=\"comment\">&lt;!--maven只能有一个parent 所以这里以pom引入父项目--&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">type</span>&gt;</span>pom<span class=\"tag\">&lt;/<span class=\"name\">type</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>import<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"3、eureka（注册中心）\"><a href=\"#3、eureka（注册中心）\" class=\"headerlink\" title=\"3、eureka（注册中心）\"></a>3、eureka（注册中心）</h1><h2 id=\"3-1、基本概念\"><a href=\"#3-1、基本概念\" class=\"headerlink\" title=\"3.1、基本概念\"></a>3.1、基本概念</h2><p>注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。两个重要的功能：<strong>服务注册</strong>和<strong>服务发现</strong></p>\n<h2 id=\"3-2、常用的注册中心\"><a href=\"#3-2、常用的注册中心\" class=\"headerlink\" title=\"3.2、常用的注册中心\"></a>3.2、常用的注册中心</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291044882.png\" alt=\"常用的注册中心\"></p>\n<h2 id=\"3-3、eureka角色\"><a href=\"#3-3、eureka角色\" class=\"headerlink\" title=\"3.3、eureka角色\"></a>3.3、eureka角色</h2><ul>\n<li><strong>服务注册中心（server</strong>）：Eureka的服务端应用，提供服务注册和发现功能.</li>\n<li><strong>服务提供者（client）</strong>： 启动后向Eureka注册自己信息（地址，提供什么服务）</li>\n</ul>\n<blockquote>\n<p>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</p>\n</blockquote>\n<ul>\n<li><strong>服务消费者（client）</strong>：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li>\n</ul>\n<h2 id=\"3-4、eureka-server开发\"><a href=\"#3-4、eureka-server开发\" class=\"headerlink\" title=\"3.4、eureka server开发\"></a>3.4、eureka server开发</h2><p>搭建eureka server子项目</p>\n<h3 id=\"3-4-1、引入依赖\"><a href=\"#3-4-1、引入依赖\" class=\"headerlink\" title=\"3.4.1、引入依赖\"></a>3.4.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--springBoot--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--eurekaServer--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-2、配置文件\"><a href=\"#3-4-2、配置文件\" class=\"headerlink\" title=\"3.4.2、配置文件\"></a>3.4.2、配置文件</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># eureka server端口号 （默认就是8761）</span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8761</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-4-3、入口类加注解\"><a href=\"#3-4-3、入口类加注解\" class=\"headerlink\" title=\"3.4.3、入口类加注解\"></a>3.4.3、入口类加注解</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableEurekaServer</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EurekaServerApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-5、eureka-client开发\"><a href=\"#3-5、eureka-client开发\" class=\"headerlink\" title=\"3.5、eureka client开发\"></a>3.5、eureka client开发</h2><h3 id=\"3-5-1、引入依赖\"><a href=\"#3-5-1、引入依赖\" class=\"headerlink\" title=\"3.5.1、引入依赖\"></a>3.5.1、引入依赖</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--eureka client依赖--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"comment\">&lt;!--springboot依赖--&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-2、配置文件\"><a href=\"#3-5-2、配置文件\" class=\"headerlink\" title=\"3.5.2、配置文件\"></a>3.5.2、配置文件</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8989</span></span><br><span class=\"line\"><span class=\"comment\"># 应用名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKACLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-5-3、启动类\"><a href=\"#3-5-3、启动类\" class=\"headerlink\" title=\"3.5.3、启动类\"></a>3.5.3、启动类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableEurekaClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">EurekaClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6、eureka自我保护机制\"><a href=\"#3-6、eureka自我保护机制\" class=\"headerlink\" title=\"3.6、eureka自我保护机制\"></a>3.6、eureka自我保护机制</h2><h3 id=\"3-6-1、自我保护机制\"><a href=\"#3-6-1、自我保护机制\" class=\"headerlink\" title=\"3.6.1、自我保护机制\"></a>3.6.1、自我保护机制</h3><p>默认情况下，如果eureka server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，eureka server将会移除掉该实例（eureka客户端每隔60秒会发送一次心跳包）</p>\n<p>但是当网络分区发生故障，微服务和eureka server之间无法通信，但是微服务本身是正常的，此时不应该移除这个服务，所以就引入了自我保护机制</p>\n<p>Eureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期</p>\n<blockquote>\n<p>自我保护机制清除：<br>（1）心跳次数高于预期值<br>（2）自我保护机制被禁用</p>\n</blockquote>\n<h3 id=\"3-6-2、如何关闭自我保护机制\"><a href=\"#3-6-2、如何关闭自我保护机制\" class=\"headerlink\" title=\"3.6.2、如何关闭自我保护机制\"></a>3.6.2、如何关闭自我保护机制</h3><figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">eureka</span>:<span class=\"string\"></span></span><br><span class=\"line\">  <span class=\"attr\">server</span>:<span class=\"string\"></span></span><br><span class=\"line\"><span class=\"comment\">    #服务端是否开启自我保护机制 （默认true）</span></span><br><span class=\"line\">    <span class=\"attr\">enable-self-preservation</span>: <span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\">    # eureka客户端每隔多长时间发一次心跳（单位毫秒，默认是60*1000）即60秒</span></span><br><span class=\"line\">    <span class=\"attr\">eviction-interval-timer-in-ms</span>: <span class=\"string\">60000</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-7、eureka-server集群\"><a href=\"#3-7、eureka-server集群\" class=\"headerlink\" title=\"3.7、eureka server集群\"></a>3.7、eureka server集群</h2><p>多个注册中心之间相互注册就可搭建eureka server集群</p>\n<blockquote>\n<p>服务端：eureka.client.service-url.defaultZone 配置其它的注册中心地址即可</p>\n</blockquote>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># eureka server端口号 （默认就是8761）</span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8761</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER01</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8762/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\"># eureka server端口号 </span></span><br><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8762</span></span><br><span class=\"line\"><span class=\"comment\"># 指定服务名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKASERVER02</span></span><br><span class=\"line\"><span class=\"comment\"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka</span></span><br><span class=\"line\"><span class=\"comment\"># 关闭立即注册（避免控制台报错）</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.fetch-registry</span>=<span class=\"string\">false</span></span><br><span class=\"line\"><span class=\"comment\"># 让当前应用仅仅是服务注册中心</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.register-with-eureka</span>=<span class=\"string\">false</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>客户端：所有的注册中心地址都需要指明</p>\n</blockquote>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8989</span></span><br><span class=\"line\"><span class=\"comment\"># 应用名称</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">EUREKACLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 注册中心地址</span></span><br><span class=\"line\"><span class=\"attr\">eureka.client.service-url.defaultZone</span>=<span class=\"string\">http://localhost:8761/eureka,http://localhost:8762/eureka</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"4、consul（注册中心）\"><a href=\"#4、consul（注册中心）\" class=\"headerlink\" title=\"4、consul（注册中心）\"></a>4、consul（注册中心）</h1><h2 id=\"4-1、简介\"><a href=\"#4-1、简介\" class=\"headerlink\" title=\"4.1、简介\"></a>4.1、简介</h2><p>consul是基于go语言进行开发的服务注册中心，是一个可以直接运行的注册中心工具，不需要像eureka注册中心一样再进行编码。使用起来较为简单</p>\n<h2 id=\"4-2、安装\"><a href=\"#4-2、安装\" class=\"headerlink\" title=\"4.2、安装\"></a>4.2、安装</h2><ol>\n<li><p>下载 <a href=\"https://www.consul.io/downloads\">https://www.consul.io/downloads</a></p>\n</li>\n<li><p>解压</p>\n</li>\n<li><p>启动服务注册中心（cmd）</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">consul</span> <span class=\"string\">agent -dev</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问管理界面：<a href=\"http://localhost:8500/\">http://localhost:8500/</a></p>\n</li>\n</ol>\n<h2 id=\"4-3、consul-client开发\"><a href=\"#4-3、consul-client开发\" class=\"headerlink\" title=\"4.3、consul client开发\"></a>4.3、consul client开发</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--springboot依赖--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--consul客户端组件--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"comment\">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写配置文件</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server.port</span>=<span class=\"string\">8082</span></span><br><span class=\"line\"><span class=\"attr\">spring.application.name</span>=<span class=\"string\">CONSULCLIENT</span></span><br><span class=\"line\"><span class=\"comment\"># 向consul server服务注册地址</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.host</span>=<span class=\"string\">localhost</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.port</span>=<span class=\"string\">8500</span></span><br><span class=\"line\"><span class=\"comment\"># 默认为$&#123;spring.application.name&#125;</span></span><br><span class=\"line\"><span class=\"attr\">spring.cloud.consul.discovery.service-name</span>=<span class=\"string\">CONSULCLIENT</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>启动类添加注解</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"comment\">// 除了eureka，其它注册中心客户端都可以用该注解</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-4、consul健康检查\"><a href=\"#4-4、consul健康检查\" class=\"headerlink\" title=\"4.4、consul健康检查\"></a>4.4、consul健康检查</h2><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291356805.png\" alt=\"image (10).png\"></p>\n<ol>\n<li>默认情况下consul监控健康是开启的，但必须依赖健康监控依赖才能正常响应客户端发来的心跳，否则界面会显示错误，引入健康依赖之后服务正常<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"5、openFeign（服务间通信）\"><a href=\"#5、openFeign（服务间通信）\" class=\"headerlink\" title=\"5、openFeign（服务间通信）\"></a>5、openFeign（服务间通信）</h1><h2 id=\"5-1、基于RestTemplate实现调用\"><a href=\"#5-1、基于RestTemplate实现调用\" class=\"headerlink\" title=\"5.1、基于RestTemplate实现调用\"></a>5.1、基于RestTemplate实现调用</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2Controller</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;client 2 OK!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">RestTemplate</span> <span class=\"variable\">restTemplate</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>();</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> restTemplate.getForObject(<span class=\"string\">&quot;http://localhost:8088/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span>+result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2、基于RestTemplate-Ribbon实现负载均衡调用\"><a href=\"#5-2、基于RestTemplate-Ribbon实现负载均衡调用\" class=\"headerlink\" title=\"5.2、基于RestTemplate+Ribbon实现负载均衡调用\"></a>5.2、基于RestTemplate+Ribbon实现负载均衡调用</h2><p>spring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现，通过spring cloud封装，可以让我们轻松的进行客户端负载均衡调用。Ribbon可从注册中心中获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例</p>\n<ol>\n<li><strong>编码形式</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">// 服务注册与发现客户端对象（获取服务列表后需要手动选取）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DiscoveryClient discoveryClient;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span> <span class=\"comment\">// 具有负载均衡的服务注册与发现客户端对象（根据负载均衡策略自动选取一个）</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// （1）DiscoveryClient</span></span><br><span class=\"line\">        List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(<span class=\"string\">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>().getForObject(serviceInstances.get(<span class=\"number\">0</span>).getUri() + <span class=\"string\">&quot;/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"comment\">// （2）LoadBalanceClient</span></span><br><span class=\"line\">        <span class=\"type\">ServiceInstance</span> <span class=\"variable\">serviceInstances2</span> <span class=\"operator\">=</span> loadBalancerClient.choose(<span class=\"string\">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result2</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>().getForObject(serviceInstances2.getUri() + <span class=\"string\">&quot;/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>@LoadBalance注解实现负载均衡</strong></li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanConfig</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"meta\">@LoadBalanced</span> <span class=\"comment\">// 使RestTemplate对象具有ribbon负载均衡特性</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RestTemplate <span class=\"title function_\">restTemplate</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RestTemplate</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> RestTemplate restTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result3</span> <span class=\"operator\">=</span> restTemplate.getForObject(<span class=\"string\">&quot;http://CONSULCLIENT2/test&quot;</span>, String.class);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>Ribbon负载均衡策略</strong></li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>策略类</th>\n<th>命名</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>RoundRobinRule</td>\n<td>轮询策略</td>\n<td>轮询选择，轮询index，选择index对应位置的Server</td>\n</tr>\n<tr>\n<td>RandomRule</td>\n<td>随机策略</td>\n<td>随机选择server</td>\n</tr>\n<tr>\n<td>BestAvailableRule</td>\n<td>最低并发策略</td>\n<td>选择其中并发链接最低的server</td>\n</tr>\n<tr>\n<td>RetryRule</td>\n<td>重试策略</td>\n<td>其实就是轮询策略的加强版，轮询策略服务不可用时不处理，重试策略会尝试其它节点</td>\n</tr>\n<tr>\n<td>AvailabilityFilteringRule</td>\n<td>可用过滤策略</td>\n<td>过滤掉一直连接失败的provider和繁忙的provider</td>\n</tr>\n<tr>\n<td>ZoneAvoidanceRule</td>\n<td>区域权重策略</td>\n<td>如果某个ip区域内有一个或多个示例不可达或响应慢，都会降低该ip区域内其它ip被选中的权重</td>\n</tr>\n</tbody></table>\n<ol start=\"4\">\n<li><strong>负载均衡策略设置</strong></li>\n</ol>\n<p>（1）局部修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 负载均衡策略 provider为调用的服务的名称</span><br><span class=\"line\"># 格式：服务应用名.ribbon.负载均衡策略名字</span><br><span class=\"line\">provider:</span><br><span class=\"line\">  ribbon:</span><br><span class=\"line\">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure>\n<p>（2）全局修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 所有被调用服务均使用该策略</span></span><br><span class=\"line\">    <span class=\"meta\">@Bean</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> RandomRule <span class=\"title function_\">randomRule</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RandomRule</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"5-3、基于openFeign实现调用\"><a href=\"#5-3、基于openFeign实现调用\" class=\"headerlink\" title=\"5.3、基于openFeign实现调用\"></a>5.3、基于openFeign实现调用</h2><h3 id=\"5-3-1、Feign\"><a href=\"#5-3-1、Feign\" class=\"headerlink\" title=\"5.3.1、Feign\"></a>5.3.1、Feign</h3><blockquote>\n<p>Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务</p>\n</blockquote>\n<h3 id=\"5-3-2、openFeign\"><a href=\"#5-3-2、openFeign\" class=\"headerlink\" title=\"5.3.2、openFeign\"></a>5.3.2、openFeign</h3><blockquote>\n<p>OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。<br>OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，<br>并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</p>\n</blockquote>\n<h3 id=\"5-3-3、openFeign调用\"><a href=\"#5-3-3、openFeign调用\" class=\"headerlink\" title=\"5.3.3、openFeign调用\"></a>5.3.3、openFeign调用</h3><h4 id=\"5-3-3-1、编码\"><a href=\"#5-3-3-1、编码\" class=\"headerlink\" title=\"5.3.3.1、编码\"></a>5.3.3.1、编码</h4><p>（1）引入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--openFeign--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>（2）启动类开启openFeign的调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"meta\">@EnableFeignClients</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）创建业务层接口，添加@FeginClient注解声明需要调用的服务</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FeignClient(&quot;CONSULCLIENT2&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Client2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    String <span class=\"title function_\">test2</span><span class=\"params\">()</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（4）调用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client2 client2;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> client2.test2();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-3-3-2、接口参数传递详解\"><a href=\"#5-3-3-2、接口参数传递详解\" class=\"headerlink\" title=\"5.3.3.2、接口参数传递详解\"></a>5.3.3.2、接口参数传递详解</h4><blockquote>\n<p>（1）test？name&#x3D;xxx&amp;age&#x3D;10  —— @RequestParam(“name”)<br>（2）test&#x2F;{id}   ——  @PathVarible(“id”)<br>（3）test(@RequestBody User user)<br>（4）集合和数组作为参数时封装到VO对象中</p>\n</blockquote>\n<h4 id=\"5-3-3-3、超时处理\"><a href=\"#5-3-3-3、超时处理\" class=\"headerlink\" title=\"5.3.3.3、超时处理\"></a>5.3.3.3、超时处理</h4><ol>\n<li>默认超时时间：1s</li>\n<li>修改某个服务的超时时间</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feign.client.config.PRODUCTS.connecTimeOut</span>=<span class=\"string\">5000 # 配置指定服务连接超时</span></span><br><span class=\"line\"><span class=\"attr\">feign.client.config.PRODUCTS.readTimeOut</span>=<span class=\"string\">5000 # 配置指定服务等待超时</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改所有服务超时时间</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">feign.client.config.default.connecTimeOut</span>=<span class=\"string\">5000 # 配置服务连接超时</span></span><br><span class=\"line\"><span class=\"attr\">feign.client.config.default.readTimeOut</span>=<span class=\"string\">5000 # 配置服务等待超时</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"6、Hystrix（服务熔断）\"><a href=\"#6、Hystrix（服务熔断）\" class=\"headerlink\" title=\"6、Hystrix（服务熔断）\"></a>6、Hystrix（服务熔断）</h1><h2 id=\"6-1、什么是服务雪崩？\"><a href=\"#6-1、什么是服务雪崩？\" class=\"headerlink\" title=\"6.1、什么是服务雪崩？\"></a>6.1、什么是服务雪崩？</h2><p>因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象</p>\n<blockquote>\n<p>（1）程序bug导致服务不可用，或者运行缓慢<br>（2）缓存击穿，导致调用全部访问某服务，导致down掉<br>（3）访问量的突然激增</p>\n</blockquote>\n<h2 id=\"6-2、解决服务雪崩（-熔断-降级）\"><a href=\"#6-2、解决服务雪崩（-熔断-降级）\" class=\"headerlink\" title=\"6.2、解决服务雪崩（ 熔断 + 降级）\"></a>6.2、解决服务雪崩（ 熔断 + 降级）</h2><ol>\n<li><strong>服务熔断</strong></li>\n</ol>\n<p>一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，向调用方返回一个符合预期的的备选响应，而不是长时间等待或抛出异常。所以很多地方把熔断亦称为过载保护</p>\n<ol start=\"2\">\n<li><strong>服务降级</strong></li>\n</ol>\n<p>当网站或服务流量突然增加时，为了保证系统核心服务正常运行，有策略的关闭系统中的边缘服务，以保证核心服务的正常运行</p>\n<ol start=\"3\">\n<li><strong>熔断降级的关系</strong></li>\n</ol>\n<p>熔断必会出发降级，所以熔断也是降级的一种，区别在于熔断是对调用链路的保护，降级是对系统过载的一种保护</p>\n<h2 id=\"6-3、Hystrix概念\"><a href=\"#6-3、Hystrix概念\" class=\"headerlink\" title=\"6.3、Hystrix概念\"></a>6.3、Hystrix概念</h2><p>Hystrix是处理分布式系统延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时，异常等。Hystrix能够保证在一个依赖出现问题时，不会导致整体服务失败，避免雪崩效应，提高分布式系统的弹性</p>\n<h2 id=\"6-4、编码\"><a href=\"#6-4、编码\" class=\"headerlink\" title=\"6.4、编码\"></a>6.4、编码</h2><ol>\n<li>所有服务引入Hystrix依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--hystrix--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>服务提供者</li>\n</ol>\n<p>（直接调用服务提供者的方案，是一种服务降级的思想）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启熔断功能</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span> <span class=\"comment\">//开启hystrix熔断功能</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClient2Application</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClient2Application.class,args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2Controller</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@HystrixCommand(fallbackMethod = &quot;demoFallBack&quot;,defaultFallback = &quot;defaultFallBack&quot;)</span> <span class=\"comment\">//熔断之后的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(Integer id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (id &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">RuntimeException</span>(<span class=\"string\">&quot;发生异常！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;client 2:8088 OK!&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">demoFallBack</span><span class=\"params\">(Integer id)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务被熔断&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">defaultFallBack</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;服务被熔断(默认)&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>服务消费者</li>\n</ol>\n<p>（通过服务消费者调用的方案，服务者完全挂掉时的处理，是一种服务熔断的思想）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 开启openFeign支持服务降级</span><br><span class=\"line\">feign.hystrix.enabled=<span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"meta\">@EnableDiscoveryClient</span>  <span class=\"comment\">// 开启服务注册客户端</span></span><br><span class=\"line\"><span class=\"meta\">@EnableFeignClients</span>  <span class=\"comment\">// 开启openFeign调用</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrix</span> <span class=\"comment\">// 开启hystrix熔断功能</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ConsulClientApplication</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// fallback:指定当服务不可用时，默认的备选处理</span></span><br><span class=\"line\"><span class=\"meta\">@FeignClient(value = &quot;CONSULCLIENT2&quot;,fallback = Client2FallBack.class)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">interface</span> <span class=\"title class_\">Client2</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class=\"line\">    String <span class=\"title function_\">test2</span><span class=\"params\">(<span class=\"meta\">@RequestParam(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// </span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Client2FallBack</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">Client2</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test2</span><span class=\"params\">(Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;当前服务不可达&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">ClientController</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Client2 client2;</span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/test&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">test</span><span class=\"params\">(Integer id)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">String</span> <span class=\"variable\">result</span> <span class=\"operator\">=</span> client2.test2(id);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;调用client2成功：&quot;</span> + result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"6-5、Hystrix服务熔断机制\"><a href=\"#6-5、Hystrix服务熔断机制\" class=\"headerlink\" title=\"6.5、Hystrix服务熔断机制\"></a>6.5、Hystrix服务熔断机制</h2><h3 id=\"6-5-1、Hystrix断路器打开的条件\"><a href=\"#6-5-1、Hystrix断路器打开的条件\" class=\"headerlink\" title=\"6.5.1、Hystrix断路器打开的条件\"></a>6.5.1、Hystrix断路器打开的条件</h3><p>a. 当满足一定阈值的时候（默认10秒内超过20个请求次数）<br>b. 当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p>\n<blockquote>\n<p>注意：一旦断路开启之后，所有到这个服务请求均不可用，只有在断路关闭之后才可用</p>\n</blockquote>\n<h3 id=\"6-5-2、Hystrix监控流程\"><a href=\"#6-5-2、Hystrix监控流程\" class=\"headerlink\" title=\"6.5.2、Hystrix监控流程\"></a>6.5.2、Hystrix监控流程</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291357597.png\" alt=\"Hystrix监控流程\"></p>\n<p>当服务调用达到两个阈值，会自动开启断路器，在熔断器打开期间，任何到该接口的请求均不可用，同时在断路器打开5s后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果执行成功，断路器彻底关闭，执行失败则重新打开</p>\n<h2 id=\"6-6、Hystrix-Dashboard（仪表盘）\"><a href=\"#6-6、Hystrix-Dashboard（仪表盘）\" class=\"headerlink\" title=\"6.6、Hystrix Dashboard（仪表盘）\"></a>6.6、Hystrix Dashboard（仪表盘）</h2><ol>\n<li>基本概念</li>\n</ol>\n<p>Hystrix Dashboard主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题</p>\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<p>（1）新建一个 Hystrix Dashboard 工程<br>（2）引入依赖</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Spring Cloud Hystrix Dashboard --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>（3）启动类开启监控功能</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 开启 Hystrix Dashboard 监控功能 */</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure>\n<p>（4）访问仪表盘界面</p>\n<blockquote>\n<p><a href=\"http://localhost:9000/hystrix\">http://localhost:9000/hystrix</a><br>端口为项目的端口号</p>\n</blockquote>\n<h1 id=\"7、zuul（网关）\"><a href=\"#7、zuul（网关）\" class=\"headerlink\" title=\"7、zuul（网关）\"></a>7、zuul（网关）</h1><p>Zuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。zuul 包含了对请求的<strong>路由</strong>和<strong>过滤</strong>两个最主要的功能。</p>\n<p>Zuul是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能:</p>\n<p>（1）聚合接口使得服务对调用者透明，客户端与后端的耦合度降低<br>（2）聚合后台服务，节省流量，提高性能，提升用户体验<br>（3）提供安全、流控、过滤、缓存、计费、监控等 API 管理功能</p>\n<h2 id=\"7-1、搭建环境\"><a href=\"#7-1、搭建环境\" class=\"headerlink\" title=\"7.1、搭建环境\"></a>7.1、搭建环境</h2><p>创建一个应用，在启动类中添加注解@EnableZuulProxy，声明这是一个网关服务提供者</p>\n<h2 id=\"7-2、路由规则配置\"><a href=\"#7-2、路由规则配置\" class=\"headerlink\" title=\"7.2、路由规则配置\"></a>7.2、路由规则配置</h2><h3 id=\"7-2-1、URL地址路由\"><a href=\"#7-2-1、URL地址路由\" class=\"headerlink\" title=\"7.2.1、URL地址路由\"></a>7.2.1、URL地址路由</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 路由规则</span><br><span class=\"line\">zuul:</span><br><span class=\"line\">\troutes :</span><br><span class=\"line\">        # 路由 id 自定义</span><br><span class=\"line\">        product-service :</span><br><span class=\"line\">\t\t\tpath: /product-service<span class=\"comment\">/**配请求 ur1 的映射路径#</span></span><br><span class=\"line\"><span class=\"comment\">    \t\turl: http://localhost:7070/ # 映射路径对应的微服务地址</span></span><br></pre></td></tr></table></figure>\n<p>通配符含义：</p>\n<table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>含义</th>\n<th>举例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>？</td>\n<td>匹配任意单个字符</td>\n<td>&#x2F;product-service&#x2F;?</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配任意数量字符不包括子路径</td>\n<td>&#x2F;product-service&#x2F;*</td>\n</tr>\n<tr>\n<td>**</td>\n<td>匹配任意数量字符包括所有子路径</td>\n<td>&#x2F;product-service&#x2F;**</td>\n</tr>\n</tbody></table>\n<h3 id=\"7-2-2、服务名称路由\"><a href=\"#7-2-2、服务名称路由\" class=\"headerlink\" title=\"7.2.2、服务名称路由\"></a>7.2.2、服务名称路由</h3><p>微服务一般是由几十、上百个服务组成，对于 URL 地址路由的方式，如果对每个服务实例手动指定一个唯一访问地址，这样做显然是不合理的。<br>Zuul 支持与 Eureka 整合开发，根据 serviceld 自动从注册中心获取服务地并转发清求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而目在添加或移除服务实例时不用修改 Zuul 的路由配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">路由规则</span><br><span class=\"line\">Zuul</span><br><span class=\"line\">\troutes:</span><br><span class=\"line\">\t# 路由 id 自定义</span><br><span class=\"line\">\t\tproduct-service:</span><br><span class=\"line\">\t\tpath: /product-service<span class=\"comment\">/**#配置请 url 的映射路径</span></span><br><span class=\"line\"><span class=\"comment\">\t\tserviceId: product-service # 根据 serviceId 自动从注册中心获取服务地址并转发请求</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"7-2-3、简化路由配置\"><a href=\"#7-2-3、简化路由配置\" class=\"headerlink\" title=\"7.2.3、简化路由配置\"></a>7.2.3、简化路由配置</h3><p>Zuul 为了方便大家使用，提供了默认路由配置: 路由 id 和 微服务名称 一致，path 默认对应 微服务名称&#x2F;* ，所以以下配置就没必要再写了。</p>\n<h2 id=\"7-3、路由排除\"><a href=\"#7-3、路由排除\" class=\"headerlink\" title=\"7.3、路由排除\"></a>7.3、路由排除</h2><p>我们可以通过路由排除设置不允许被访问的资源。允许被访问的资源可以通过路由规则进行设置。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 路由规则</span><br><span class=\"line\">Zuul:</span><br><span class=\"line\">\t#ignored-patterns: <span class=\"comment\">/**/order/** # URL 地址排除，排除所有包含 /order/ 的路径</span></span><br><span class=\"line\"><span class=\"comment\">\tignored-services: order-service # 服务名称排除，多个服务逗号分隔，&#x27;*’排除所有</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-4、路由前缀\"><a href=\"#7-4、路由前缀\" class=\"headerlink\" title=\"7.4、路由前缀\"></a>7.4、路由前缀</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Zuul:</span><br><span class=\"line\">\tprefix: /api</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-5、网关过滤器\"><a href=\"#7-5、网关过滤器\" class=\"headerlink\" title=\"7.5、网关过滤器\"></a>7.5、网关过滤器</h2><h3 id=\"7-5-1、关键名词\"><a href=\"#7-5-1、关键名词\" class=\"headerlink\" title=\"7.5.1、关键名词\"></a>7.5.1、关键名词</h3><p>类型: 定义路由流程中应用过滤器的阶段。共 pre、routing、 post、error 4 个类型<br>执行顺序: 在同类型中，定义过滤器执行的顺序。比如多个 pre 类型的执行顺序.<br>条件: 执行过滤器所需的条件。true 开启，false 关闭.<br>动作: 如果符合条件，将执行的动作。具体操作。</p>\n<h3 id=\"7-5-2、过滤器类型\"><a href=\"#7-5-2、过滤器类型\" class=\"headerlink\" title=\"7.5.2、过滤器类型\"></a>7.5.2、过滤器类型</h3><p> <strong>pre</strong>: 请求被路由到源服务器之前执行的过滤器</p>\n<blockquote>\n<p>身份认证<br>选路由<br>请求日志</p>\n</blockquote>\n<p><strong>routing</strong>: 处理将请求发送到源服务器的过滤器。<br><strong>post</strong>: 响应从源服务器返回时执行的过滤器</p>\n<blockquote>\n<p>对响应增加 HTTP 头<br>收集统计和度量指标<br>将响应以流的方式发送回客户端</p>\n</blockquote>\n<p><strong>error</strong>:上述阶段中出现错误时执行的过滤器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> </span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">LoginFilter</span> <span class=\"keyword\">extends</span> <span class=\"title class_\">ZuulFilter</span>&#123; </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> String <span class=\"title function_\">filterType</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 登录校验，肯定是在前置拦截 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;pre&quot;</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span> <span class=\"title function_\">filterOrder</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 顺序设置为1 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">boolean</span> <span class=\"title function_\">shouldFilter</span><span class=\"params\">()</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 返回true，代表过滤器生效。 </span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span> </span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">run</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> ZuulException &#123;</span><br><span class=\"line\">    <span class=\"comment\">//处理业务逻辑</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"7-6、网关限流\"><a href=\"#7-6、网关限流\" class=\"headerlink\" title=\"7.6、网关限流\"></a>7.6、网关限流</h2><p>这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的</p>\n<p><strong>计数器</strong>：计算单元时间内访问接口的次数，如果达到次数，则限制访问</p>\n<p><strong>漏桶算法</strong>：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃</p>\n<p><strong>令牌桶算法：</strong><br>（1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理;<br>（2）根据限流大小，设置按照一定的速率往桶里添加令牌;<br>（3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝;<br>（4）请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除:<br>（5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。</p>\n<blockquote>\n<p>令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放回定数量的令牌</p>\n</blockquote>\n<h3 id=\"7-6-1、网关限流\"><a href=\"#7-6-1、网关限流\" class=\"headerlink\" title=\"7.6.1、网关限流\"></a>7.6.1、网关限流</h3><ol>\n<li>全局限流配置</li>\n</ol>\n<p>使用全局限流配置，zuul会对代理的所有服务提供限流保护</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启限流保护</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># 60s内请求超过3次，服务端就抛出异常，60s后可以恢复正常请求</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.limit</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.refresh-interval</span>=<span class=\"string\">60</span></span><br><span class=\"line\"><span class=\"comment\"># 针对IP进行限流，不影响其他IP</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.default-policy.type</span>=<span class=\"string\">origin</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>局部限流配置</li>\n</ol>\n<p>使用局部限流配置，zuul仅针对配置的服务提供限流保护</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开启限流保护</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.enabled</span>=<span class=\"string\">true</span></span><br><span class=\"line\"><span class=\"comment\"># hystrix-application-client服务60s内请求超过3次，服务抛出异常。</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.limit</span>=<span class=\"string\">3</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.refresh-interval</span>=<span class=\"string\">60</span></span><br><span class=\"line\"><span class=\"comment\"># 针对IP限流。</span></span><br><span class=\"line\"><span class=\"attr\">zuul.ratelimit.policies.hystrix-application-client.type</span>=<span class=\"string\">origin</span></span><br></pre></td></tr></table></figure>\n<h1 id=\"8、sleuth（链路追踪）\"><a href=\"#8、sleuth（链路追踪）\" class=\"headerlink\" title=\"8、sleuth（链路追踪）\"></a>8、sleuth（链路追踪）</h1><h2 id=\"8-1、链路追踪\"><a href=\"#8-1、链路追踪\" class=\"headerlink\" title=\"8.1、链路追踪\"></a>8.1、链路追踪</h2><p>单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整记录下来.</p>\n<h2 id=\"8-2、sleuth\"><a href=\"#8-2、sleuth\" class=\"headerlink\" title=\"8.2、sleuth\"></a>8.2、sleuth</h2><p>Spring Cloud sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，和其他基于日志的追踪系统，例如ELK (Elasticsearch 、 Logstash、Kibana)<br>Spring cloud sleuth 提供了以下功能:</p>\n<ul>\n<li>辩路追踪: 通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。</li>\n<li>性能分析 :通过 sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。</li>\n<li>数据分析，优化链路 : 对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施.</li>\n<li>可视化错误 : 对于程序未捕获的异常，可以配合 Zipkin 查看。</li>\n</ul>\n<h2 id=\"8-3、专业术语\"><a href=\"#8-3、专业术语\" class=\"headerlink\" title=\"8.3、专业术语\"></a>8.3、专业术语</h2><h3 id=\"8-3-1、span\"><a href=\"#8-3-1、span\" class=\"headerlink\" title=\"8.3.1、span\"></a>8.3.1、span</h3><p>基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父ID，以重建在一次追踪过程中不同 Span 之间的关系</p>\n"},{"title":"thymeleaf","date":"2023-09-04T16:00:00.000Z","abbrlink":2904,"_content":"\n# 1. 简介\n\nThymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT 等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端 HTML5 开发的理想选择\n\n# 2. 创建模板文件\n\n创建一个html模板文件：\n\n```html\n<!DOCTYPE HTML>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <title>Index Page</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n</head>\n<body>\n    <p th:text=\"${message}\">Welcome to BeiJing!</p>\n</body>\n</html>\n```\n\n1. <!DOCTYPE HTML> ：声明文档的解析类型(document.compatMode)，使用标准模式渲染页面，避免浏览器的怪异模式 (浏览器使用自己的怪异模式解析渲染页面).\n\n> 标准模式，浏览器使用W3C的标准解析渲染页面\n\n\n2. <html xmlns:th=\"[http://www.thymeleaf.org](http://www.thymeleaf.org)\">: 引入 Thymeleaf 命名空间 (xmlns 属性规定文档的 xml 命名空间)\n\n\n# 3、标准表达式语法\n\nThymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类：\n\n\n-  简单表达式 \n-  字面值 \n-  文本操作 \n-  算术运算 \n-  布尔运算 \n-  比较和相等 \n-  条件运算 \n-  无操作符 \n\n## 3.1 简单表达式\n\n| 语法 | 名称 | 描述 | 作用 |\n| --- | --- | --- | --- |\n| ${...} | Variable Expressions | 变量表达式 | 取出上下文变量的值 |\n| *{…} | Selection Variable Expressions | 选择表达式 | 取出选择的对象的属性值 |\n| #{...} | Message Expressions | 消息表达式 | 使文字消息国际化，I18N |\n| @{…} | Link URL Expressions | 链接表达式 | 用于表示各种超链接地址 |\n| ~{…} | Fragment Expressions | 片段表达式 | 引用一段公共的代码片段 |\n\n\n### 3.1.1 ${...}   变量表达式\n\n```java\n@GetMapping(\"/standard-expression-syntax/variables\")\npublic String variables(ModelMap model, HttpSession session) {\n    model.put(\"now\", new Date());\n    model.put(\"message\", \"Welcome to BeiJing!\");\n    session.setAttribute(\"user\", new User(\"fanlychie\", \"男\", 24));\n    ... ...\n}\n```\n\n通过变量表达式`${}`取出上下文环境中的`message`变量：\n\n```html\n<p th:text=\"${message}\"></p>\n```\n\n### 3.1.2  *{…}   选择表达式\n\n变量表达式`${}`是面向整个上下文的，而选择变量表达式`*{}`的上下文是父标签（`th:object`）所选择的对象\n\n```html\n<div th:object=\"${session.user}\">\n    <p th:text=\"*{name}\"></p>\n    <p th:text=\"*{sex}\"></p>\n    <p th:text=\"*{age}\"></p>\n</div>\n```\n\n### 3.1.3  #{...}   消息表达式\n\n消息表达式可用于国际化文字信息.首先我们来了解一下 i18n 资源文件的命名规则：\n\n- basename.properties\n- basename_language.properties\n- basename_language_country.properties\n\n`basename`是自定义的资源文件名称，`language`和`country`必须是 Java 支持的语言和国家。`basename.properties`是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。\n\n`basename`是自定义的资源文件名称，`language`和`country`必须是 Java 支持的语言和国家。`basename.properties`是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。\n\n创建文件`src/main/resources/messages.properties`\n\n```properties\nwelcome.message = 北京欢迎你！\n```\n\n创建文件`src/main/resources/messages_en_US.properties`\n\n```properties\nwelcome.message = Welcome to BeiJing!\n```\n\n在 IntelliJ IDEA 编辑视图：\n\n`messages`是 Spring Boot 加载资源文件默认采用的名称（`basename`），如果你所使用的资源文件名称不是以`messages`命名或所使用的资源文件不是在`src/main/resources`根目录，你可以通过`spring.messages.basename`属性来做具体的配置。如，资源文件`messages.properties`和`messages_en_US.properties`假设它们所在的目录位置是`src/main/resources/i18n`。\n\napplication.properties 配置示例：\n\n```properties\nspring.messages.basename:i18n/messages\n```\n\n静态文本消息示例：\n\n```html\n<!-- 北京欢迎你！ -->\n<p th:text=\"#{welcom.message}\"></p>\n```\n\n### 3.1.4 @{...} 链接表达式\n\n链接表达式`@{}`是专门用来处理 URL 链接地址的\n\n（1）绝对地址示例：\n\n```html\n<!-- https://fanlychie.github.io -->\n<p th:text=\"@{https://fanlychie.github.io}\"></p>\n```\n\n（2）页面相对地址示例：\n\n```html\n<!-- commons/base.html -->\n<p th:text=\"@{commons/base.html}\"></p>\n```\n\n（3）上下文相对地址（相对于当前的服务）示例：\n\n```html\n<!-- /css/mian.css -->\n<p th:text=\"@{/css/mian.css}\"></p>\n```\n\n（4）服务器相对地址（相对于部署在同一个服务器中的不同服务）示例：\n\n```html\n<!-- /image/upload -->\n<p th:text=\"@{~/image/upload}\"></p>\n```\n\n### 3.1.5 ~{…} 片段表达式\n\n片段表达式`~{}`可以用来引用一段公共的 HTML 代码片段\n\n| 语法 | 描述 |\n| --- | --- |\n| ~{templatename} | 引用整个模板文件的代码片段 |\n| ~{templatename :: selector} | selector 可以是 th:fragment 指定的名称或其他选择器。如类选择器、ID选择器等 |\n| ~{::selector} | 相当于 ~{this :: selector}，表示引用当前模板定义的代码片段 |\n\n\n在 Thymeleaf 模板文件中，你可以使用`th:fragment`属性来定义一段公共的代码片段，然后你可以通过使用`th:insert`、`th:replace`、`th:include`（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。\n\n（1）src/main/resources/templates/base.html，通过`th:fragment`属性定义一段公共的代码片段：\n\n```html\n<div id=\"footer\" th:fragment=\"footerFragment\">&copy; 2017 fanlychie</div>\n```\n\n（2）src/main/resources/templates/index.html，通过`th:insert`属性引用一段公共的代码片段：\n\n```html\n<div th:insert=\"~{base :: footerFragment}\"></div>\n```\n\n使用`th:fragment`属性定义代码片段时，你还可以声明一组参数：\n\n```html\n<div th:fragment=\"crumbs(parent, child)\">\n    <i th:text=\"${parent}\"></i> <i th:text=\"${child}\"></i>\n</div>\n    \n<!--\n<i>用户中心</i>\n<i>我的订单</i>\n-->\n<div th:insert=\"::crumbs('用户中心', '我的订单')\"></div>\n```\n\n此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段：\n\n```html\n<div th:insert=\"~{base :: #footer}\"></div>\n```\n\n### 3.1.6  内置对象\n\n| 对象 | 描述 |\n| --- | --- |\n| #ctx | 上下文对象 |\n| #vars | 同#ctx，表示上下文变量 |\n| #locale | 上下文本地化（特定地理区域）变量，可参考java.utils.Locale |\n| #request | HttpServletRequest对象 |\n| #response | HttpServletResponse 对象 |\n| #session | HttpSession对象 |\n| #servletContext | ServletContext 对象 |\n\n\n```html\n<!-- #ctx  -->\n<p th:text=\"${#ctx.getLocale()}\"></p>\n<p th:text=\"${#ctx.getVariable('message')}\"></p>\n<!-- #vars -->\n<p th:text=\"${#vars.getLocale()}\"></p>\n<p th:text=\"${#vars.getVariable('message')}\"></p>\n<!-- #locale -->\n<p th:text=\"${#locale}\"></p>\n<p th:text=\"${#locale.country}\"></p>\n<!-- #request -->\n<p th:text=\"${#request.serverName}\"></p>\n<p th:text=\"${#request.serverPort}\"></p>\n<p th:text=\"${#request.requestURL}\"></p>\n<!-- #response -->\n<p th:text=\"${#response.status}\"></p>\n<p th:text=\"${#response.characterEncoding}\"></p>\n<!-- #session -->\n<p th:text=\"${#session.id}\"></p>\n```\n\n### 3.1.7 工具类\n\n| 对象 | 描述 |\n| --- | --- |\n| #message | 消息工具类，与 ＃{…} 作用相同 |\n| #uris | 地址相关的工具类 |\n| #conversions | 对象转换工具 |\n| #dates | 日期转换工具 |\n| #calendars | 日历工具类 |\n| #numbers | 数字工具类 |\n| #strings | 字符串工具类 |\n| #objects | 对象工具类 |\n| #bools | 布尔工具类 |\n| #arrays | 数组工具类 |\n| #list | List工具类 |\n| #set | Set工具类 |\n| #maps | Map工具类 |\n\n\n\n```html\n<p th:text=\"${#strings.isEmpty(message)}\"></p>\n<p th:text=\"${#dates.format(now, 'yyyy-MM-dd HH:mm:ss')}\"></p>\n```\n\n## 3.2 字面值\n\n所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：`18`、`'welcome'`等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。\n\n### 3.2.1 文字字面值\n\n文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义：\n\n```html\n<!-- Welcome to BeiJing! -->\n<p th:text=\"'Welcome to BeiJing!'\"></p>\n<!-- 'Welcome to BeiJing!' -->\n<p th:text=\"'\\'Welcome to BeiJing!\\''\"></p>\n```\n\n### 3.2.2 数字字面量\n\n```html\n<!-- 2017 -->\n<p th:text=\"2017\"></p>\n<!-- 2018 -->\n<p th:text=\"2017 + 1\"></p>\n```\n\n### 3.2.3 布尔字面值\n\n```html\n<!-- false -->\n<p th:text=\"1 > 2\"></p>\n<!-- 否 -->\n<p th:text=\"1 > 2 ? '是' : '否'\"></p>\n```\n\n### 3.2.4 空字面值\n\n```html\n<!-- false -->\n<p th:text=\"${user == null}\"></p>\n```\n\n### 3.2.5 字面令牌\n\n字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）：\n\n- 大写或小写的字母、中文等不含空格和特殊符号的文本\n- 0 到 9 的数字\n- 中括号\n- 下划线\n- 连字符（-）\n- 点符号（.）\n\n实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉：\n\n```html\n<p th:text=\"Welcome to BeiJing!\"></p>\n等效于\n<p th:text=\"'Welcome to BeiJing!'\"></p>\n```\n\n## 3.3 文本操作\n\n我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换\n\n### 3.3.1 字符串连接\n\n```html\n<!-- Welcome to BeiJing! -->\n<p th:text=\"'Welcome to ' + ${location} + '!'\"></p>\n```\n\n### 3.3.2 字面值替换\n\n符号`||`可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用`+`连接符：\n\n```html\n<!-- Welcome to BeiJing! -->\n<p th:text=\"|Welcome to ${location}!|\"></p>\n```\n\n## 3.4 算数运算\n\n支持`+`（加）、`-`（减）、`*`（乘）、`/`（除）、`%`（模）运算：\n\n```html\n<!-- 6 -->\n<p th:text=\"4 + 2\"></p>\n<!-- 2 -->\n<p th:text=\"${pagination.page + 1}\"></p>\n<!-- 2 -->\n<p th:text=\"${pagination.page} + 1\"></p>\n```\n\n## 3.5 布尔运算\n\n支持`and`（且）、`or`（或）、`!`（非）、`not`（非）运算：\n\n```html\n<p th:text=\"${user.online and user.vip}\"></p>\n<p th:text=\"${user.online or user.vip}\"></p>\n<p th:text=\"${!user.online}\"></p>\n<p th:text=\"${not user.online}\"></p>\n```\n\n## 3.6 比较和相等\n\n支持`<`（`lt`）、`>`（`gt`）、`<=`（`le`）、`>=`（`ge`）、`==`（`eq`）、`！=`（`ne`）：\n\n```html\n<p th:text=\"${user.age < 60}\"></p>\n<p th:text=\"${user.age <= 60}\"></p>\n<p th:text=\"${user.age > 18}\"></p>\n<p th:text=\"${user.age >= 18}\"></p>\n<p th:text=\"${user.age == 18}\"></p>\n<p th:text=\"${user.age != 18}\"></p>\n```\n\n## 3.7 条件运算\n\n三元运算符：`(if) ? (then) : (else)`\n\n```html\n<p th:text=\"${user.online ? '在线' : '离线'}\"></p>\n```\n\n二元运算符：`(value) ?: (defaultValue)`。\n\n其中，`value`非空（null）即真，条件为真时输出`value`，否则输出`defaultValue`\n\n```html\n<!-- 你还没有登录，请先登录 -->\n<p th:text=\"${token} ?: '你还没有登录，请先登录'\"></p>\n<!-- fanlychie@gmail.com -->\n<p th:text=\"${user.email} ?: '你还没有绑定邮箱'\"></p>\n```\n\n## 3.8 无操作符\n\n当模板运行在服务器端时，Thymeleaf 会解析`th:*`属性的具体值替换标签体的内容。无操作符（`_`）则允许你使用原型标签体的内容作为默认值：\n\n```html\n<!-- 你还没有登录，请先登录 -->\n<p th:text=\"${token} ?: _\">你还没有登录，请先登录</p>\n```\n\n# 4. 使用文本\n\n首先介绍两个最基础的`th:*`属`th:text`和`th:utext`，它们都是用于处理文本消息内容\n\n## 4.1 th:text\n\n在标签体中展示表达式评估结果的文本内容：\n\n```html\n<p th:text=\"${message}\"></p>\n```\n\n使用外部化的文本内容：\n\n```html\n<p th:text=\"${message}\">Welcome to BeiJing!</p>\n```\n\n当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的`th:text`属性，而显示`<p>`标签体的文本内容`Welcome to BeiJing!`\n\n当它作为模板文件运行在服务器端时，`th:text`属性的具体值将会替换`<p>`标签体的文本内容。\n\n## 4.2 th:utext\n\n属性`th:utext`与`th:text`的区别在于：\n\n- `th:text`默认会对含有 HTML 标签的内容进行字符转义；\n- `th:utext`（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义；\n\n假设：`message = \"<b>Welcome to BeiJing!</b>\"`。\n\n（1）使用`th:text`属性：\n\n```html\n<p th:text=\"${message}\"></p>\n```\n\n`th:text`效果：<b>Welcome to BeiJing!</b>\n\n（2）使用`th:utext`属性：\n\n```html\n<p th:utext=\"${message}\"></p>\n```\n\n`th:utext`效果：**Welcome to BeiJing!**\n\n# 5. 设置属性值\n\n在 Thymeleaf 模板文件中，你可以使用`th:*`（或者使用`th:attr`属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以`th:*-*`来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用`th:attrappend`和`th:attrprepend`来追加新的值到现有的标签属性值中。\n\n## 5.1 th:attr\n\n这种方式是不被推荐的，了解一下就行。下面是用`th:attr=\"href=...\"`来设置标签`href`属性的值：\n\n```html\n<a th:attr=\"href=@{https://www.google.com.hk}\">谷歌一下你就知道</a>\n```\n\n## 5.2 th:*\n\n显然`th:attr=\"href=@{http://www.baidu.com}\"`不够简洁，我们更推荐下面的这种语法：\n\n```html\n<a th:href=\"@{https://www.google.com.hk}\">谷歌一下你就知道</a>\n```\n\n其中`th:*`中的`*`可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的：\n\n```html\n<!-- <div item-id=\"1001\">Welcome to BeiJing!</div> -->\n<div th:item-id=\"${user.id}\">Welcome to BeiJing!</div>\n```\n\n## 5.3 th:*-*\n\n如果想要同时为标签的多个不同属性设置相同的一个值，可以使用`th:*-*`的语法：\n\n```html\n<img src=\"logo.png\" th:alt-title=\"LOGO图片\">\n```\n\n它相当于\n\n```html\n<img src=\"logo.png\" th:alt=\"LOGO图片\" th:title=\"LOGO图片\">\n```\n\n## 5.4 th:attrappend & th:attrprepend\n\n`th:attrappend`和`th:attrprepend`可以将表达式的结果分别追加到指定的属性值之后和之前。\n\n```html\n<!-- <button class=\"btn enable\">购买</button> -->\n<button class=\"btn\" th:attrappend=\"class=${outOfStock} ? ' enable' : ' disable'\">购买</button>\n<!-- <button class=\"enable btn\">购买</button> -->\n<button class=\"btn\" th:attrprepend=\"class=${outOfStock} ? 'enable ' : 'disable '\">购买</button>\n```\n\n另外，还有两个常用的具体附加属性`th:classappend=\"...\"`和`th:styleappend=\"\"`。\n\n它们分别用来代替`th:attrappend=\"class=...\"`和`th:attrappend=\"style=...\"`\n\n```html\n<!-- <button class=\"btn enable\">购买</button> -->\n<button class=\"btn\" th:classappend=\"${outOfStock} ? ' enable' : ' disable'\">购买</button>\n```\n\n## 5.5 布尔属性\n\n在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如`readonly`、`checked`、`selected`等。它们若存在那就意味着值为 true\n\n```html\n<input type=\"checkbox\" name=\"rememberme\" checked /> 记住我\n<input type=\"radio\" name=\"sex\" value=\"male\" checked> 男\n<input type=\"radio\" name=\"sex\" value=\"female\"> 女\n<input type=\"text\" name=\"appId\" value=\"J123654\" readonly>\n<select>\n    <option selected>北京</option>\n    <option>上海</option>\n    <option>广州</option>\n    <option>深圳</option>\n</select>\n```\n\nThymeleaf 也允许我们通过`th:*`（这里的`*`表示任意的布尔属性） 来选择是否使用这些布尔属性。\n\n```html\n<input type=\"checkbox\" name=\"rememberme\" ch:checked=\"${rememberme}\" /> 记住我\n```\n\n如果表达式的结果为`true`，则自动勾选复选框，若为`false`，则不会自动勾选\n\n# 6. 遍历\n\n遍历（迭代）的语法`th:each=\"自定义的元素变量名称 : ${集合变量名称}\"`：\n\n```html\n<div>\n    <spn>你所在城市：</spn>\n    <select name=\"mycity\">\n        <option th:each=\"city : ${cities}\" th:text=\"${city.name}\"></option>\n    </select>\n</div>\n```\n\n属性`th:each`提供了一个用于跟踪迭代的状态变量，它包含以下几个属性：\n\n| 属性 | 类型 | 描述 |\n| --- | --- | --- |\n| index | int | 当前迭代的索引，从0开始 |\n| count | int | 当前迭代的计数，从1开始 |\n| size | int | 集合中元素的总个数 |\n| current | int | 当前的元素对象 |\n| even | boolean | 当前迭代的计数是否是偶数 |\n| odd | boolean | 当前迭代的计数是否是奇数 |\n| first | boolean | 当前元素是否是集合的第一个元素 |\n| last | boolean | 当前元素是否是集合的最后一个元素 |\n\n\n状态变量的使用语法：`th:each=\"自定义的元素变量名称, 自定义的状态变量名称 : ${集合变量名称}\"`：\n\n```html\n<div>\n    <spn>所在城市：</spn>\n    <select name=\"mycity\">\n        <option th:each=\"city, status : ${cities}\" th:text=\"${city.name}\" th:item-index=\"${status.count}\"></option>\n    </select>\n</div>\n```\n\n不管什么时候，Thymeleaf 始终会为每个`th:each`创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加`Stat`字符串组成：\n\n```html\n<div>\n    <spn>所在城市：</spn>\n    <select name=\"mycity\">\n        <option th:each=\"city : ${cities}\" th:text=\"${city.name}\" th:item-index=\"${cityStat.count}\"></option>\n    </select>\n</div>\n```\n\n# 7. 条件判断\n\n条件判断语句有三种，分别是：th:if，th:unless，th:swith\n\n## 7.1 th:if\n\n当表达式的评估结果为真时则显示内容，否则不显示\n\n```html\n<a th:href=\"@{/user/order(uid=${user.id})}\" th:if=\"${user != null}\">我的订单</a>\n```\n\n真假评估的依据：\n\n- 当表达式的值不为空（null）时 \n   - 如果表达式的值是一个布尔类型，且值为`true`评估为真，否则为假\n   - 如果表达式的值是一个数字类型，且值为非`0`评估为真，否则为假\n   - 如果表达式的值是一个字符类型，且值为非`0`评估为真，否则为假\n   - 如果表达式的值是一个字符串类型，且值为非`\"false\"`、`\"off\"`、`\"no\"`评估为真，否则为假\n   - 如果表达式的值不是一个`布尔`、`数字`、`字符`或`字符串`评估为真\n- 当表达式的值为空（null）时，评估结果为假\n\n因此，上面代码我们也可以简写成：\n\n```html\n<a th:href=\"@{/user/order(uid=${user.id})}\" th:if=\"${user}\">我的订单</a>\n```\n\n但是，为了代码的可读性，我们并不建议这样使用\n\n## 7.2 th:unless\n\n`th:unless`与`th:if`判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示：\n\n```html\n<a th:href=\"@{/user/order(uid=${user.id})}\" th:unless=\"${user == null}\">我的订单</a>\n```\n\n## 7.3 th:swith\n\n多路选择语句，它需要搭配th:case来使用：\n\n```html\n<div th:switch=\"${user.role}\">\n    <p th:case=\"admin\">管理员</p>\n    <p th:case=\"user\">普通用户</p>\n</div>\n```\n\n# 8. 定义局部变量\n\n使用th:with属性可以定义局部变量\n\n```html\n<p th:with=\"name='fanlychie'\">\n    <span th:text=\"${name}\"></span>\n</p>\n```\n\n同时定义多个局部变量时，用英文`,`号分隔开：\n\n```html\n<p th:with=\"name=${user.name},age={user.age}\">\n    ......\n</p>\n```\n\n# 9. 注释\n\n## 9.1 标准注释\n\n语法：`<!-- ... --->`，注释的代码块会在文件源代码中显示出来。\n\n### 9.1.1 单行注释\n\n```html\n<!-- <span>${message}</span> --->\n```\n\n### 9.1.2 多行注释\n\n```html\n<!--\n<div th:switch=\"${user.role}\">\n    <p th:case=\"admin\">管理员</p>\n    <p th:case=\"user\">普通用户</p>\n</div>\n--->\n```\n\n## 9.2 解析器级注释\n\n语法：`<!--/* ... */-->`，注释的代码块会在引擎解析的时候抹去\n\n### 9.2.1 单行注释\n\n```html\n<!--/* <span>${message}</span> */-->\n```\n\n### 9.2.2 多行注释\n\n```html\n<!--/*-->\n<div th:switch=\"${user.role}\">\n    <p th:case=\"admin\">管理员</p>\n    <p th:case=\"user\">普通用户</p>\n</div>\n<!--*/-->\n```\n\n# 10. 内联表达式\n\n内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用`th:*`标签属性\n\n## 10.1 [[...]]\n\n[[]]相当于th:text，对含有HTML标签的内容自动进行字符转义\n\n```html\n<p>The message is : [[${htmlContent}]]</p>\n```\n\n## 10.2 [(...)]\n\n[()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义\n\n```html\n<p>The message is : [(${htmlContent})]</p>\n```\n\n## 10.3 th:inline\n\n我们已经了解到，使用`[[]]`和`[()]`语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用`th:inline`属性来激活，它的取值如下：\n\n| 值 | 描述 |\n| --- | --- |\n| none | 禁止内联表达式，可以原样输出[[]]和[()]字符串 |\n| text | 文本内联，可以使用th:each等高级语法 |\n| css | 样式内联，如：`<style th:inline=\"css\">` |\n| javascript | 脚本内联，如：`<style th:inline=\"javascript\">` |\n\n\n#### 10.3.1 none\n\n```html\n<!-- [[1, 2], [3, 4]] -->\n<p th:inline=\"none\">[[1, 2], [3, 4]]</p>\n```\n\n#### 10.3.2 text\n\n```html\n<!-- 北京 上海 广州 深圳 -->\n<p th:inline=\"text\">\n    [# th:each=\"city : ${cities}\"]\n        [(${city.name})]\n    [/]\n</p>\n```\n\n#### 10.3.3 css\n\n```html\n<style th:inline=\"css\">\n    body {\n        background-color:[[${bgColor}]];\n    }\n</style>\n```\n\n### 10.3.4 javascript\n\n```html\n<script th:inline=\"javascript\">\n    var user = [[${user}]];\n    alert(\"用户名：\" + user.name);\n</script>\n```\n","source":"_posts/thymeleaf.md","raw":"---\ntitle: thymeleaf\ndate: 2023/09/05\ncategories:\n  - coding\ntags:\n  - thymeleaf\n  - 编程基础\nabbrlink: 2904\n---\n\n# 1. 简介\n\nThymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT 等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端 HTML5 开发的理想选择\n\n# 2. 创建模板文件\n\n创建一个html模板文件：\n\n```html\n<!DOCTYPE HTML>\n<html xmlns:th=\"http://www.thymeleaf.org\">\n<head>\n    <title>Index Page</title>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n</head>\n<body>\n    <p th:text=\"${message}\">Welcome to BeiJing!</p>\n</body>\n</html>\n```\n\n1. <!DOCTYPE HTML> ：声明文档的解析类型(document.compatMode)，使用标准模式渲染页面，避免浏览器的怪异模式 (浏览器使用自己的怪异模式解析渲染页面).\n\n> 标准模式，浏览器使用W3C的标准解析渲染页面\n\n\n2. <html xmlns:th=\"[http://www.thymeleaf.org](http://www.thymeleaf.org)\">: 引入 Thymeleaf 命名空间 (xmlns 属性规定文档的 xml 命名空间)\n\n\n# 3、标准表达式语法\n\nThymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类：\n\n\n-  简单表达式 \n-  字面值 \n-  文本操作 \n-  算术运算 \n-  布尔运算 \n-  比较和相等 \n-  条件运算 \n-  无操作符 \n\n## 3.1 简单表达式\n\n| 语法 | 名称 | 描述 | 作用 |\n| --- | --- | --- | --- |\n| ${...} | Variable Expressions | 变量表达式 | 取出上下文变量的值 |\n| *{…} | Selection Variable Expressions | 选择表达式 | 取出选择的对象的属性值 |\n| #{...} | Message Expressions | 消息表达式 | 使文字消息国际化，I18N |\n| @{…} | Link URL Expressions | 链接表达式 | 用于表示各种超链接地址 |\n| ~{…} | Fragment Expressions | 片段表达式 | 引用一段公共的代码片段 |\n\n\n### 3.1.1 ${...}   变量表达式\n\n```java\n@GetMapping(\"/standard-expression-syntax/variables\")\npublic String variables(ModelMap model, HttpSession session) {\n    model.put(\"now\", new Date());\n    model.put(\"message\", \"Welcome to BeiJing!\");\n    session.setAttribute(\"user\", new User(\"fanlychie\", \"男\", 24));\n    ... ...\n}\n```\n\n通过变量表达式`${}`取出上下文环境中的`message`变量：\n\n```html\n<p th:text=\"${message}\"></p>\n```\n\n### 3.1.2  *{…}   选择表达式\n\n变量表达式`${}`是面向整个上下文的，而选择变量表达式`*{}`的上下文是父标签（`th:object`）所选择的对象\n\n```html\n<div th:object=\"${session.user}\">\n    <p th:text=\"*{name}\"></p>\n    <p th:text=\"*{sex}\"></p>\n    <p th:text=\"*{age}\"></p>\n</div>\n```\n\n### 3.1.3  #{...}   消息表达式\n\n消息表达式可用于国际化文字信息.首先我们来了解一下 i18n 资源文件的命名规则：\n\n- basename.properties\n- basename_language.properties\n- basename_language_country.properties\n\n`basename`是自定义的资源文件名称，`language`和`country`必须是 Java 支持的语言和国家。`basename.properties`是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。\n\n`basename`是自定义的资源文件名称，`language`和`country`必须是 Java 支持的语言和国家。`basename.properties`是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。\n\n创建文件`src/main/resources/messages.properties`\n\n```properties\nwelcome.message = 北京欢迎你！\n```\n\n创建文件`src/main/resources/messages_en_US.properties`\n\n```properties\nwelcome.message = Welcome to BeiJing!\n```\n\n在 IntelliJ IDEA 编辑视图：\n\n`messages`是 Spring Boot 加载资源文件默认采用的名称（`basename`），如果你所使用的资源文件名称不是以`messages`命名或所使用的资源文件不是在`src/main/resources`根目录，你可以通过`spring.messages.basename`属性来做具体的配置。如，资源文件`messages.properties`和`messages_en_US.properties`假设它们所在的目录位置是`src/main/resources/i18n`。\n\napplication.properties 配置示例：\n\n```properties\nspring.messages.basename:i18n/messages\n```\n\n静态文本消息示例：\n\n```html\n<!-- 北京欢迎你！ -->\n<p th:text=\"#{welcom.message}\"></p>\n```\n\n### 3.1.4 @{...} 链接表达式\n\n链接表达式`@{}`是专门用来处理 URL 链接地址的\n\n（1）绝对地址示例：\n\n```html\n<!-- https://fanlychie.github.io -->\n<p th:text=\"@{https://fanlychie.github.io}\"></p>\n```\n\n（2）页面相对地址示例：\n\n```html\n<!-- commons/base.html -->\n<p th:text=\"@{commons/base.html}\"></p>\n```\n\n（3）上下文相对地址（相对于当前的服务）示例：\n\n```html\n<!-- /css/mian.css -->\n<p th:text=\"@{/css/mian.css}\"></p>\n```\n\n（4）服务器相对地址（相对于部署在同一个服务器中的不同服务）示例：\n\n```html\n<!-- /image/upload -->\n<p th:text=\"@{~/image/upload}\"></p>\n```\n\n### 3.1.5 ~{…} 片段表达式\n\n片段表达式`~{}`可以用来引用一段公共的 HTML 代码片段\n\n| 语法 | 描述 |\n| --- | --- |\n| ~{templatename} | 引用整个模板文件的代码片段 |\n| ~{templatename :: selector} | selector 可以是 th:fragment 指定的名称或其他选择器。如类选择器、ID选择器等 |\n| ~{::selector} | 相当于 ~{this :: selector}，表示引用当前模板定义的代码片段 |\n\n\n在 Thymeleaf 模板文件中，你可以使用`th:fragment`属性来定义一段公共的代码片段，然后你可以通过使用`th:insert`、`th:replace`、`th:include`（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。\n\n（1）src/main/resources/templates/base.html，通过`th:fragment`属性定义一段公共的代码片段：\n\n```html\n<div id=\"footer\" th:fragment=\"footerFragment\">&copy; 2017 fanlychie</div>\n```\n\n（2）src/main/resources/templates/index.html，通过`th:insert`属性引用一段公共的代码片段：\n\n```html\n<div th:insert=\"~{base :: footerFragment}\"></div>\n```\n\n使用`th:fragment`属性定义代码片段时，你还可以声明一组参数：\n\n```html\n<div th:fragment=\"crumbs(parent, child)\">\n    <i th:text=\"${parent}\"></i> <i th:text=\"${child}\"></i>\n</div>\n    \n<!--\n<i>用户中心</i>\n<i>我的订单</i>\n-->\n<div th:insert=\"::crumbs('用户中心', '我的订单')\"></div>\n```\n\n此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段：\n\n```html\n<div th:insert=\"~{base :: #footer}\"></div>\n```\n\n### 3.1.6  内置对象\n\n| 对象 | 描述 |\n| --- | --- |\n| #ctx | 上下文对象 |\n| #vars | 同#ctx，表示上下文变量 |\n| #locale | 上下文本地化（特定地理区域）变量，可参考java.utils.Locale |\n| #request | HttpServletRequest对象 |\n| #response | HttpServletResponse 对象 |\n| #session | HttpSession对象 |\n| #servletContext | ServletContext 对象 |\n\n\n```html\n<!-- #ctx  -->\n<p th:text=\"${#ctx.getLocale()}\"></p>\n<p th:text=\"${#ctx.getVariable('message')}\"></p>\n<!-- #vars -->\n<p th:text=\"${#vars.getLocale()}\"></p>\n<p th:text=\"${#vars.getVariable('message')}\"></p>\n<!-- #locale -->\n<p th:text=\"${#locale}\"></p>\n<p th:text=\"${#locale.country}\"></p>\n<!-- #request -->\n<p th:text=\"${#request.serverName}\"></p>\n<p th:text=\"${#request.serverPort}\"></p>\n<p th:text=\"${#request.requestURL}\"></p>\n<!-- #response -->\n<p th:text=\"${#response.status}\"></p>\n<p th:text=\"${#response.characterEncoding}\"></p>\n<!-- #session -->\n<p th:text=\"${#session.id}\"></p>\n```\n\n### 3.1.7 工具类\n\n| 对象 | 描述 |\n| --- | --- |\n| #message | 消息工具类，与 ＃{…} 作用相同 |\n| #uris | 地址相关的工具类 |\n| #conversions | 对象转换工具 |\n| #dates | 日期转换工具 |\n| #calendars | 日历工具类 |\n| #numbers | 数字工具类 |\n| #strings | 字符串工具类 |\n| #objects | 对象工具类 |\n| #bools | 布尔工具类 |\n| #arrays | 数组工具类 |\n| #list | List工具类 |\n| #set | Set工具类 |\n| #maps | Map工具类 |\n\n\n\n```html\n<p th:text=\"${#strings.isEmpty(message)}\"></p>\n<p th:text=\"${#dates.format(now, 'yyyy-MM-dd HH:mm:ss')}\"></p>\n```\n\n## 3.2 字面值\n\n所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：`18`、`'welcome'`等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。\n\n### 3.2.1 文字字面值\n\n文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义：\n\n```html\n<!-- Welcome to BeiJing! -->\n<p th:text=\"'Welcome to BeiJing!'\"></p>\n<!-- 'Welcome to BeiJing!' -->\n<p th:text=\"'\\'Welcome to BeiJing!\\''\"></p>\n```\n\n### 3.2.2 数字字面量\n\n```html\n<!-- 2017 -->\n<p th:text=\"2017\"></p>\n<!-- 2018 -->\n<p th:text=\"2017 + 1\"></p>\n```\n\n### 3.2.3 布尔字面值\n\n```html\n<!-- false -->\n<p th:text=\"1 > 2\"></p>\n<!-- 否 -->\n<p th:text=\"1 > 2 ? '是' : '否'\"></p>\n```\n\n### 3.2.4 空字面值\n\n```html\n<!-- false -->\n<p th:text=\"${user == null}\"></p>\n```\n\n### 3.2.5 字面令牌\n\n字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）：\n\n- 大写或小写的字母、中文等不含空格和特殊符号的文本\n- 0 到 9 的数字\n- 中括号\n- 下划线\n- 连字符（-）\n- 点符号（.）\n\n实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉：\n\n```html\n<p th:text=\"Welcome to BeiJing!\"></p>\n等效于\n<p th:text=\"'Welcome to BeiJing!'\"></p>\n```\n\n## 3.3 文本操作\n\n我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换\n\n### 3.3.1 字符串连接\n\n```html\n<!-- Welcome to BeiJing! -->\n<p th:text=\"'Welcome to ' + ${location} + '!'\"></p>\n```\n\n### 3.3.2 字面值替换\n\n符号`||`可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用`+`连接符：\n\n```html\n<!-- Welcome to BeiJing! -->\n<p th:text=\"|Welcome to ${location}!|\"></p>\n```\n\n## 3.4 算数运算\n\n支持`+`（加）、`-`（减）、`*`（乘）、`/`（除）、`%`（模）运算：\n\n```html\n<!-- 6 -->\n<p th:text=\"4 + 2\"></p>\n<!-- 2 -->\n<p th:text=\"${pagination.page + 1}\"></p>\n<!-- 2 -->\n<p th:text=\"${pagination.page} + 1\"></p>\n```\n\n## 3.5 布尔运算\n\n支持`and`（且）、`or`（或）、`!`（非）、`not`（非）运算：\n\n```html\n<p th:text=\"${user.online and user.vip}\"></p>\n<p th:text=\"${user.online or user.vip}\"></p>\n<p th:text=\"${!user.online}\"></p>\n<p th:text=\"${not user.online}\"></p>\n```\n\n## 3.6 比较和相等\n\n支持`<`（`lt`）、`>`（`gt`）、`<=`（`le`）、`>=`（`ge`）、`==`（`eq`）、`！=`（`ne`）：\n\n```html\n<p th:text=\"${user.age < 60}\"></p>\n<p th:text=\"${user.age <= 60}\"></p>\n<p th:text=\"${user.age > 18}\"></p>\n<p th:text=\"${user.age >= 18}\"></p>\n<p th:text=\"${user.age == 18}\"></p>\n<p th:text=\"${user.age != 18}\"></p>\n```\n\n## 3.7 条件运算\n\n三元运算符：`(if) ? (then) : (else)`\n\n```html\n<p th:text=\"${user.online ? '在线' : '离线'}\"></p>\n```\n\n二元运算符：`(value) ?: (defaultValue)`。\n\n其中，`value`非空（null）即真，条件为真时输出`value`，否则输出`defaultValue`\n\n```html\n<!-- 你还没有登录，请先登录 -->\n<p th:text=\"${token} ?: '你还没有登录，请先登录'\"></p>\n<!-- fanlychie@gmail.com -->\n<p th:text=\"${user.email} ?: '你还没有绑定邮箱'\"></p>\n```\n\n## 3.8 无操作符\n\n当模板运行在服务器端时，Thymeleaf 会解析`th:*`属性的具体值替换标签体的内容。无操作符（`_`）则允许你使用原型标签体的内容作为默认值：\n\n```html\n<!-- 你还没有登录，请先登录 -->\n<p th:text=\"${token} ?: _\">你还没有登录，请先登录</p>\n```\n\n# 4. 使用文本\n\n首先介绍两个最基础的`th:*`属`th:text`和`th:utext`，它们都是用于处理文本消息内容\n\n## 4.1 th:text\n\n在标签体中展示表达式评估结果的文本内容：\n\n```html\n<p th:text=\"${message}\"></p>\n```\n\n使用外部化的文本内容：\n\n```html\n<p th:text=\"${message}\">Welcome to BeiJing!</p>\n```\n\n当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的`th:text`属性，而显示`<p>`标签体的文本内容`Welcome to BeiJing!`\n\n当它作为模板文件运行在服务器端时，`th:text`属性的具体值将会替换`<p>`标签体的文本内容。\n\n## 4.2 th:utext\n\n属性`th:utext`与`th:text`的区别在于：\n\n- `th:text`默认会对含有 HTML 标签的内容进行字符转义；\n- `th:utext`（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义；\n\n假设：`message = \"<b>Welcome to BeiJing!</b>\"`。\n\n（1）使用`th:text`属性：\n\n```html\n<p th:text=\"${message}\"></p>\n```\n\n`th:text`效果：<b>Welcome to BeiJing!</b>\n\n（2）使用`th:utext`属性：\n\n```html\n<p th:utext=\"${message}\"></p>\n```\n\n`th:utext`效果：**Welcome to BeiJing!**\n\n# 5. 设置属性值\n\n在 Thymeleaf 模板文件中，你可以使用`th:*`（或者使用`th:attr`属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以`th:*-*`来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用`th:attrappend`和`th:attrprepend`来追加新的值到现有的标签属性值中。\n\n## 5.1 th:attr\n\n这种方式是不被推荐的，了解一下就行。下面是用`th:attr=\"href=...\"`来设置标签`href`属性的值：\n\n```html\n<a th:attr=\"href=@{https://www.google.com.hk}\">谷歌一下你就知道</a>\n```\n\n## 5.2 th:*\n\n显然`th:attr=\"href=@{http://www.baidu.com}\"`不够简洁，我们更推荐下面的这种语法：\n\n```html\n<a th:href=\"@{https://www.google.com.hk}\">谷歌一下你就知道</a>\n```\n\n其中`th:*`中的`*`可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的：\n\n```html\n<!-- <div item-id=\"1001\">Welcome to BeiJing!</div> -->\n<div th:item-id=\"${user.id}\">Welcome to BeiJing!</div>\n```\n\n## 5.3 th:*-*\n\n如果想要同时为标签的多个不同属性设置相同的一个值，可以使用`th:*-*`的语法：\n\n```html\n<img src=\"logo.png\" th:alt-title=\"LOGO图片\">\n```\n\n它相当于\n\n```html\n<img src=\"logo.png\" th:alt=\"LOGO图片\" th:title=\"LOGO图片\">\n```\n\n## 5.4 th:attrappend & th:attrprepend\n\n`th:attrappend`和`th:attrprepend`可以将表达式的结果分别追加到指定的属性值之后和之前。\n\n```html\n<!-- <button class=\"btn enable\">购买</button> -->\n<button class=\"btn\" th:attrappend=\"class=${outOfStock} ? ' enable' : ' disable'\">购买</button>\n<!-- <button class=\"enable btn\">购买</button> -->\n<button class=\"btn\" th:attrprepend=\"class=${outOfStock} ? 'enable ' : 'disable '\">购买</button>\n```\n\n另外，还有两个常用的具体附加属性`th:classappend=\"...\"`和`th:styleappend=\"\"`。\n\n它们分别用来代替`th:attrappend=\"class=...\"`和`th:attrappend=\"style=...\"`\n\n```html\n<!-- <button class=\"btn enable\">购买</button> -->\n<button class=\"btn\" th:classappend=\"${outOfStock} ? ' enable' : ' disable'\">购买</button>\n```\n\n## 5.5 布尔属性\n\n在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如`readonly`、`checked`、`selected`等。它们若存在那就意味着值为 true\n\n```html\n<input type=\"checkbox\" name=\"rememberme\" checked /> 记住我\n<input type=\"radio\" name=\"sex\" value=\"male\" checked> 男\n<input type=\"radio\" name=\"sex\" value=\"female\"> 女\n<input type=\"text\" name=\"appId\" value=\"J123654\" readonly>\n<select>\n    <option selected>北京</option>\n    <option>上海</option>\n    <option>广州</option>\n    <option>深圳</option>\n</select>\n```\n\nThymeleaf 也允许我们通过`th:*`（这里的`*`表示任意的布尔属性） 来选择是否使用这些布尔属性。\n\n```html\n<input type=\"checkbox\" name=\"rememberme\" ch:checked=\"${rememberme}\" /> 记住我\n```\n\n如果表达式的结果为`true`，则自动勾选复选框，若为`false`，则不会自动勾选\n\n# 6. 遍历\n\n遍历（迭代）的语法`th:each=\"自定义的元素变量名称 : ${集合变量名称}\"`：\n\n```html\n<div>\n    <spn>你所在城市：</spn>\n    <select name=\"mycity\">\n        <option th:each=\"city : ${cities}\" th:text=\"${city.name}\"></option>\n    </select>\n</div>\n```\n\n属性`th:each`提供了一个用于跟踪迭代的状态变量，它包含以下几个属性：\n\n| 属性 | 类型 | 描述 |\n| --- | --- | --- |\n| index | int | 当前迭代的索引，从0开始 |\n| count | int | 当前迭代的计数，从1开始 |\n| size | int | 集合中元素的总个数 |\n| current | int | 当前的元素对象 |\n| even | boolean | 当前迭代的计数是否是偶数 |\n| odd | boolean | 当前迭代的计数是否是奇数 |\n| first | boolean | 当前元素是否是集合的第一个元素 |\n| last | boolean | 当前元素是否是集合的最后一个元素 |\n\n\n状态变量的使用语法：`th:each=\"自定义的元素变量名称, 自定义的状态变量名称 : ${集合变量名称}\"`：\n\n```html\n<div>\n    <spn>所在城市：</spn>\n    <select name=\"mycity\">\n        <option th:each=\"city, status : ${cities}\" th:text=\"${city.name}\" th:item-index=\"${status.count}\"></option>\n    </select>\n</div>\n```\n\n不管什么时候，Thymeleaf 始终会为每个`th:each`创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加`Stat`字符串组成：\n\n```html\n<div>\n    <spn>所在城市：</spn>\n    <select name=\"mycity\">\n        <option th:each=\"city : ${cities}\" th:text=\"${city.name}\" th:item-index=\"${cityStat.count}\"></option>\n    </select>\n</div>\n```\n\n# 7. 条件判断\n\n条件判断语句有三种，分别是：th:if，th:unless，th:swith\n\n## 7.1 th:if\n\n当表达式的评估结果为真时则显示内容，否则不显示\n\n```html\n<a th:href=\"@{/user/order(uid=${user.id})}\" th:if=\"${user != null}\">我的订单</a>\n```\n\n真假评估的依据：\n\n- 当表达式的值不为空（null）时 \n   - 如果表达式的值是一个布尔类型，且值为`true`评估为真，否则为假\n   - 如果表达式的值是一个数字类型，且值为非`0`评估为真，否则为假\n   - 如果表达式的值是一个字符类型，且值为非`0`评估为真，否则为假\n   - 如果表达式的值是一个字符串类型，且值为非`\"false\"`、`\"off\"`、`\"no\"`评估为真，否则为假\n   - 如果表达式的值不是一个`布尔`、`数字`、`字符`或`字符串`评估为真\n- 当表达式的值为空（null）时，评估结果为假\n\n因此，上面代码我们也可以简写成：\n\n```html\n<a th:href=\"@{/user/order(uid=${user.id})}\" th:if=\"${user}\">我的订单</a>\n```\n\n但是，为了代码的可读性，我们并不建议这样使用\n\n## 7.2 th:unless\n\n`th:unless`与`th:if`判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示：\n\n```html\n<a th:href=\"@{/user/order(uid=${user.id})}\" th:unless=\"${user == null}\">我的订单</a>\n```\n\n## 7.3 th:swith\n\n多路选择语句，它需要搭配th:case来使用：\n\n```html\n<div th:switch=\"${user.role}\">\n    <p th:case=\"admin\">管理员</p>\n    <p th:case=\"user\">普通用户</p>\n</div>\n```\n\n# 8. 定义局部变量\n\n使用th:with属性可以定义局部变量\n\n```html\n<p th:with=\"name='fanlychie'\">\n    <span th:text=\"${name}\"></span>\n</p>\n```\n\n同时定义多个局部变量时，用英文`,`号分隔开：\n\n```html\n<p th:with=\"name=${user.name},age={user.age}\">\n    ......\n</p>\n```\n\n# 9. 注释\n\n## 9.1 标准注释\n\n语法：`<!-- ... --->`，注释的代码块会在文件源代码中显示出来。\n\n### 9.1.1 单行注释\n\n```html\n<!-- <span>${message}</span> --->\n```\n\n### 9.1.2 多行注释\n\n```html\n<!--\n<div th:switch=\"${user.role}\">\n    <p th:case=\"admin\">管理员</p>\n    <p th:case=\"user\">普通用户</p>\n</div>\n--->\n```\n\n## 9.2 解析器级注释\n\n语法：`<!--/* ... */-->`，注释的代码块会在引擎解析的时候抹去\n\n### 9.2.1 单行注释\n\n```html\n<!--/* <span>${message}</span> */-->\n```\n\n### 9.2.2 多行注释\n\n```html\n<!--/*-->\n<div th:switch=\"${user.role}\">\n    <p th:case=\"admin\">管理员</p>\n    <p th:case=\"user\">普通用户</p>\n</div>\n<!--*/-->\n```\n\n# 10. 内联表达式\n\n内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用`th:*`标签属性\n\n## 10.1 [[...]]\n\n[[]]相当于th:text，对含有HTML标签的内容自动进行字符转义\n\n```html\n<p>The message is : [[${htmlContent}]]</p>\n```\n\n## 10.2 [(...)]\n\n[()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义\n\n```html\n<p>The message is : [(${htmlContent})]</p>\n```\n\n## 10.3 th:inline\n\n我们已经了解到，使用`[[]]`和`[()]`语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用`th:inline`属性来激活，它的取值如下：\n\n| 值 | 描述 |\n| --- | --- |\n| none | 禁止内联表达式，可以原样输出[[]]和[()]字符串 |\n| text | 文本内联，可以使用th:each等高级语法 |\n| css | 样式内联，如：`<style th:inline=\"css\">` |\n| javascript | 脚本内联，如：`<style th:inline=\"javascript\">` |\n\n\n#### 10.3.1 none\n\n```html\n<!-- [[1, 2], [3, 4]] -->\n<p th:inline=\"none\">[[1, 2], [3, 4]]</p>\n```\n\n#### 10.3.2 text\n\n```html\n<!-- 北京 上海 广州 深圳 -->\n<p th:inline=\"text\">\n    [# th:each=\"city : ${cities}\"]\n        [(${city.name})]\n    [/]\n</p>\n```\n\n#### 10.3.3 css\n\n```html\n<style th:inline=\"css\">\n    body {\n        background-color:[[${bgColor}]];\n    }\n</style>\n```\n\n### 10.3.4 javascript\n\n```html\n<script th:inline=\"javascript\">\n    var user = [[${user}]];\n    alert(\"用户名：\" + user.name);\n</script>\n```\n","slug":"thymeleaf","published":1,"updated":"2023-09-06T13:10:32.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sr9r001100uj2o9w9aql","content":"<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>Thymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT 等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端 HTML5 开发的理想选择</p>\n<h1 id=\"2-创建模板文件\"><a href=\"#2-创建模板文件\" class=\"headerlink\" title=\"2. 创建模板文件\"></a>2. 创建模板文件</h1><p>创建一个html模板文件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">HTML</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">xmlns:th</span>=<span class=\"string\">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Index Page<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;Content-Type&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span>Welcome to BeiJing!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><!DOCTYPE HTML> ：声明文档的解析类型(document.compatMode)，使用标准模式渲染页面，避免浏览器的怪异模式 (浏览器使用自己的怪异模式解析渲染页面).</li>\n</ol>\n<blockquote>\n<p>标准模式，浏览器使用W3C的标准解析渲染页面</p>\n</blockquote>\n<ol start=\"2\">\n<li><html xmlns:th=\"[http://www.thymeleaf.org](http://www.thymeleaf.org)\">: 引入 Thymeleaf 命名空间 (xmlns 属性规定文档的 xml 命名空间)</li>\n</ol>\n<h1 id=\"3、标准表达式语法\"><a href=\"#3、标准表达式语法\" class=\"headerlink\" title=\"3、标准表达式语法\"></a>3、标准表达式语法</h1><p>Thymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类：</p>\n<ul>\n<li>简单表达式 </li>\n<li>字面值 </li>\n<li>文本操作 </li>\n<li>算术运算 </li>\n<li>布尔运算 </li>\n<li>比较和相等 </li>\n<li>条件运算 </li>\n<li>无操作符</li>\n</ul>\n<h2 id=\"3-1-简单表达式\"><a href=\"#3-1-简单表达式\" class=\"headerlink\" title=\"3.1 简单表达式\"></a>3.1 简单表达式</h2><table>\n<thead>\n<tr>\n<th>语法</th>\n<th>名称</th>\n<th>描述</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>${…}</td>\n<td>Variable Expressions</td>\n<td>变量表达式</td>\n<td>取出上下文变量的值</td>\n</tr>\n<tr>\n<td>*{…}</td>\n<td>Selection Variable Expressions</td>\n<td>选择表达式</td>\n<td>取出选择的对象的属性值</td>\n</tr>\n<tr>\n<td>#{…}</td>\n<td>Message Expressions</td>\n<td>消息表达式</td>\n<td>使文字消息国际化，I18N</td>\n</tr>\n<tr>\n<td>@{…}</td>\n<td>Link URL Expressions</td>\n<td>链接表达式</td>\n<td>用于表示各种超链接地址</td>\n</tr>\n<tr>\n<td>~{…}</td>\n<td>Fragment Expressions</td>\n<td>片段表达式</td>\n<td>引用一段公共的代码片段</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-1-1-…-变量表达式\"><a href=\"#3-1-1-…-变量表达式\" class=\"headerlink\" title=\"3.1.1 ${…}   变量表达式\"></a>3.1.1 ${…}   变量表达式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/standard-expression-syntax/variables&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">variables</span><span class=\"params\">(ModelMap model, HttpSession session)</span> &#123;</span><br><span class=\"line\">    model.put(<span class=\"string\">&quot;now&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">    model.put(<span class=\"string\">&quot;message&quot;</span>, <span class=\"string\">&quot;Welcome to BeiJing!&quot;</span>);</span><br><span class=\"line\">    session.setAttribute(<span class=\"string\">&quot;user&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;fanlychie&quot;</span>, <span class=\"string\">&quot;男&quot;</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过变量表达式<code>$&#123;&#125;</code>取出上下文环境中的<code>message</code>变量：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-2-…-选择表达式\"><a href=\"#3-1-2-…-选择表达式\" class=\"headerlink\" title=\"3.1.2  *{…}   选择表达式\"></a>3.1.2  *{…}   选择表达式</h3><p>变量表达式<code>$&#123;&#125;</code>是面向整个上下文的，而选择变量表达式<code>*&#123;&#125;</code>的上下文是父标签（<code>th:object</code>）所选择的对象</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:object</span>=<span class=\"string\">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;*&#123;name&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;*&#123;sex&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;*&#123;age&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-3-…-消息表达式\"><a href=\"#3-1-3-…-消息表达式\" class=\"headerlink\" title=\"3.1.3  #{…}   消息表达式\"></a>3.1.3  #{…}   消息表达式</h3><p>消息表达式可用于国际化文字信息.首先我们来了解一下 i18n 资源文件的命名规则：</p>\n<ul>\n<li>basename.properties</li>\n<li>basename_language.properties</li>\n<li>basename_language_country.properties</li>\n</ul>\n<p><code>basename</code>是自定义的资源文件名称，<code>language</code>和<code>country</code>必须是 Java 支持的语言和国家。<code>basename.properties</code>是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。</p>\n<p><code>basename</code>是自定义的资源文件名称，<code>language</code>和<code>country</code>必须是 Java 支持的语言和国家。<code>basename.properties</code>是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。</p>\n<p>创建文件<code>src/main/resources/messages.properties</code></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">welcome.message</span> = <span class=\"string\">北京欢迎你！</span></span><br></pre></td></tr></table></figure>\n\n<p>创建文件<code>src/main/resources/messages_en_US.properties</code></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">welcome.message</span> = <span class=\"string\">Welcome to BeiJing!</span></span><br></pre></td></tr></table></figure>\n\n<p>在 IntelliJ IDEA 编辑视图：</p>\n<p><code>messages</code>是 Spring Boot 加载资源文件默认采用的名称（<code>basename</code>），如果你所使用的资源文件名称不是以<code>messages</code>命名或所使用的资源文件不是在<code>src/main/resources</code>根目录，你可以通过<code>spring.messages.basename</code>属性来做具体的配置。如，资源文件<code>messages.properties</code>和<code>messages_en_US.properties</code>假设它们所在的目录位置是<code>src/main/resources/i18n</code>。</p>\n<p>application.properties 配置示例：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.messages.basename</span>:<span class=\"string\">i18n/messages</span></span><br></pre></td></tr></table></figure>\n\n<p>静态文本消息示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 北京欢迎你！ --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;#&#123;welcom.message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-4-…-链接表达式\"><a href=\"#3-1-4-…-链接表达式\" class=\"headerlink\" title=\"3.1.4 @{…} 链接表达式\"></a>3.1.4 @{…} 链接表达式</h3><p>链接表达式<code>@&#123;&#125;</code>是专门用来处理 URL 链接地址的</p>\n<p>（1）绝对地址示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://fanlychie.github.io --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;@&#123;https://fanlychie.github.io&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）页面相对地址示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- commons/base.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;@&#123;commons/base.html&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）上下文相对地址（相对于当前的服务）示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /css/mian.css --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;@&#123;/css/mian.css&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）服务器相对地址（相对于部署在同一个服务器中的不同服务）示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /image/upload --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;@&#123;~/image/upload&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-5-…-片段表达式\"><a href=\"#3-1-5-…-片段表达式\" class=\"headerlink\" title=\"3.1.5 ~{…} 片段表达式\"></a>3.1.5 ~{…} 片段表达式</h3><p>片段表达式<code>~&#123;&#125;</code>可以用来引用一段公共的 HTML 代码片段</p>\n<table>\n<thead>\n<tr>\n<th>语法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>~{templatename}</td>\n<td>引用整个模板文件的代码片段</td>\n</tr>\n<tr>\n<td>~{templatename :: selector}</td>\n<td>selector 可以是 th:fragment 指定的名称或其他选择器。如类选择器、ID选择器等</td>\n</tr>\n<tr>\n<td>~{::selector}</td>\n<td>相当于 ~{this :: selector}，表示引用当前模板定义的代码片段</td>\n</tr>\n</tbody></table>\n<p>在 Thymeleaf 模板文件中，你可以使用<code>th:fragment</code>属性来定义一段公共的代码片段，然后你可以通过使用<code>th:insert</code>、<code>th:replace</code>、<code>th:include</code>（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。</p>\n<p>（1）src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;base.html，通过<code>th:fragment</code>属性定义一段公共的代码片段：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;footer&quot;</span> <span class=\"attr\">th:fragment</span>=<span class=\"string\">&quot;footerFragment&quot;</span>&gt;</span><span class=\"symbol\">&amp;copy;</span> 2017 fanlychie<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;index.html，通过<code>th:insert</code>属性引用一段公共的代码片段：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:insert</span>=<span class=\"string\">&quot;~&#123;base :: footerFragment&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>th:fragment</code>属性定义代码片段时，你还可以声明一组参数：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:fragment</span>=<span class=\"string\">&quot;crumbs(parent, child)&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;parent&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;child&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">&lt;i&gt;用户中心&lt;/i&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;i&gt;我的订单&lt;/i&gt;</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:insert</span>=<span class=\"string\">&quot;::crumbs(&#x27;用户中心&#x27;, &#x27;我的订单&#x27;)&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:insert</span>=<span class=\"string\">&quot;~&#123;base :: #footer&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-6-内置对象\"><a href=\"#3-1-6-内置对象\" class=\"headerlink\" title=\"3.1.6  内置对象\"></a>3.1.6  内置对象</h3><table>\n<thead>\n<tr>\n<th>对象</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>#ctx</td>\n<td>上下文对象</td>\n</tr>\n<tr>\n<td>#vars</td>\n<td>同#ctx，表示上下文变量</td>\n</tr>\n<tr>\n<td>#locale</td>\n<td>上下文本地化（特定地理区域）变量，可参考java.utils.Locale</td>\n</tr>\n<tr>\n<td>#request</td>\n<td>HttpServletRequest对象</td>\n</tr>\n<tr>\n<td>#response</td>\n<td>HttpServletResponse 对象</td>\n</tr>\n<tr>\n<td>#session</td>\n<td>HttpSession对象</td>\n</tr>\n<tr>\n<td>#servletContext</td>\n<td>ServletContext 对象</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- #ctx  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#ctx.getLocale()&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#ctx.getVariable(&#x27;message&#x27;)&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #vars --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#vars.getLocale()&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#vars.getVariable(&#x27;message&#x27;)&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #locale --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#locale&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#locale.country&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #request --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#request.serverName&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#request.serverPort&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#request.requestURL&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #response --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#response.status&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#response.characterEncoding&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #session --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#session.id&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-7-工具类\"><a href=\"#3-1-7-工具类\" class=\"headerlink\" title=\"3.1.7 工具类\"></a>3.1.7 工具类</h3><table>\n<thead>\n<tr>\n<th>对象</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>#message</td>\n<td>消息工具类，与 ＃{…} 作用相同</td>\n</tr>\n<tr>\n<td>#uris</td>\n<td>地址相关的工具类</td>\n</tr>\n<tr>\n<td>#conversions</td>\n<td>对象转换工具</td>\n</tr>\n<tr>\n<td>#dates</td>\n<td>日期转换工具</td>\n</tr>\n<tr>\n<td>#calendars</td>\n<td>日历工具类</td>\n</tr>\n<tr>\n<td>#numbers</td>\n<td>数字工具类</td>\n</tr>\n<tr>\n<td>#strings</td>\n<td>字符串工具类</td>\n</tr>\n<tr>\n<td>#objects</td>\n<td>对象工具类</td>\n</tr>\n<tr>\n<td>#bools</td>\n<td>布尔工具类</td>\n</tr>\n<tr>\n<td>#arrays</td>\n<td>数组工具类</td>\n</tr>\n<tr>\n<td>#list</td>\n<td>List工具类</td>\n</tr>\n<tr>\n<td>#set</td>\n<td>Set工具类</td>\n</tr>\n<tr>\n<td>#maps</td>\n<td>Map工具类</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#strings.isEmpty(message)&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#dates.format(now, &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-字面值\"><a href=\"#3-2-字面值\" class=\"headerlink\" title=\"3.2 字面值\"></a>3.2 字面值</h2><p>所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：<code>18</code>、<code>&#39;welcome&#39;</code>等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。</p>\n<h3 id=\"3-2-1-文字字面值\"><a href=\"#3-2-1-文字字面值\" class=\"headerlink\" title=\"3.2.1 文字字面值\"></a>3.2.1 文字字面值</h3><p>文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;&#x27;Welcome to BeiJing!&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &#x27;Welcome to BeiJing!&#x27; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;&#x27;\\&#x27;Welcome to BeiJing!\\&#x27;&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-数字字面量\"><a href=\"#3-2-2-数字字面量\" class=\"headerlink\" title=\"3.2.2 数字字面量\"></a>3.2.2 数字字面量</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 2017 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;2017&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2018 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;2017 + 1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-3-布尔字面值\"><a href=\"#3-2-3-布尔字面值\" class=\"headerlink\" title=\"3.2.3 布尔字面值\"></a>3.2.3 布尔字面值</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- false --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;1 &gt; 2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 否 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;1 &gt; 2 ? &#x27;是&#x27; : &#x27;否&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-4-空字面值\"><a href=\"#3-2-4-空字面值\" class=\"headerlink\" title=\"3.2.4 空字面值\"></a>3.2.4 空字面值</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- false --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user == null&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-5-字面令牌\"><a href=\"#3-2-5-字面令牌\" class=\"headerlink\" title=\"3.2.5 字面令牌\"></a>3.2.5 字面令牌</h3><p>字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）：</p>\n<ul>\n<li>大写或小写的字母、中文等不含空格和特殊符号的文本</li>\n<li>0 到 9 的数字</li>\n<li>中括号</li>\n<li>下划线</li>\n<li>连字符（-）</li>\n<li>点符号（.）</li>\n</ul>\n<p>实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;Welcome to BeiJing!&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">等效于</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;&#x27;Welcome to BeiJing!&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-文本操作\"><a href=\"#3-3-文本操作\" class=\"headerlink\" title=\"3.3 文本操作\"></a>3.3 文本操作</h2><p>我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换</p>\n<h3 id=\"3-3-1-字符串连接\"><a href=\"#3-3-1-字符串连接\" class=\"headerlink\" title=\"3.3.1 字符串连接\"></a>3.3.1 字符串连接</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;&#x27;Welcome to &#x27; + $&#123;location&#125; + &#x27;!&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-2-字面值替换\"><a href=\"#3-3-2-字面值替换\" class=\"headerlink\" title=\"3.3.2 字面值替换\"></a>3.3.2 字面值替换</h3><p>符号<code>||</code>可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用<code>+</code>连接符：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;|Welcome to $&#123;location&#125;!|&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4-算数运算\"><a href=\"#3-4-算数运算\" class=\"headerlink\" title=\"3.4 算数运算\"></a>3.4 算数运算</h2><p>支持<code>+</code>（加）、<code>-</code>（减）、<code>*</code>（乘）、<code>/</code>（除）、<code>%</code>（模）运算：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 6 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;4 + 2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;pagination.page + 1&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;pagination.page&#125; + 1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-布尔运算\"><a href=\"#3-5-布尔运算\" class=\"headerlink\" title=\"3.5 布尔运算\"></a>3.5 布尔运算</h2><p>支持<code>and</code>（且）、<code>or</code>（或）、<code>!</code>（非）、<code>not</code>（非）运算：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.online and user.vip&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.online or user.vip&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;!user.online&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;not user.online&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-比较和相等\"><a href=\"#3-6-比较和相等\" class=\"headerlink\" title=\"3.6 比较和相等\"></a>3.6 比较和相等</h2><p>支持<code>&lt;</code>（<code>lt</code>）、<code>&gt;</code>（<code>gt</code>）、<code>&lt;=</code>（<code>le</code>）、<code>&gt;=</code>（<code>ge</code>）、<code>==</code>（<code>eq</code>）、<code>！=</code>（<code>ne</code>）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age &lt; 60&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age &lt;= 60&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age &gt; 18&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age &gt;= 18&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age == 18&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age != 18&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7-条件运算\"><a href=\"#3-7-条件运算\" class=\"headerlink\" title=\"3.7 条件运算\"></a>3.7 条件运算</h2><p>三元运算符：<code>(if) ? (then) : (else)</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.online ? &#x27;在线&#x27; : &#x27;离线&#x27;&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>二元运算符：<code>(value) ?: (defaultValue)</code>。</p>\n<p>其中，<code>value</code>非空（null）即真，条件为真时输出<code>value</code>，否则输出<code>defaultValue</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 你还没有登录，请先登录 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;token&#125; ?: &#x27;你还没有登录，请先登录&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- fanlychie@gmail.com --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.email&#125; ?: &#x27;你还没有绑定邮箱&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-8-无操作符\"><a href=\"#3-8-无操作符\" class=\"headerlink\" title=\"3.8 无操作符\"></a>3.8 无操作符</h2><p>当模板运行在服务器端时，Thymeleaf 会解析<code>th:*</code>属性的具体值替换标签体的内容。无操作符（<code>_</code>）则允许你使用原型标签体的内容作为默认值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 你还没有登录，请先登录 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;token&#125; ?: _&quot;</span>&gt;</span>你还没有登录，请先登录<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-使用文本\"><a href=\"#4-使用文本\" class=\"headerlink\" title=\"4. 使用文本\"></a>4. 使用文本</h1><p>首先介绍两个最基础的<code>th:*</code>属<code>th:text</code>和<code>th:utext</code>，它们都是用于处理文本消息内容</p>\n<h2 id=\"4-1-th-text\"><a href=\"#4-1-th-text\" class=\"headerlink\" title=\"4.1 th:text\"></a>4.1 th:text</h2><p>在标签体中展示表达式评估结果的文本内容：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用外部化的文本内容：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span>Welcome to BeiJing!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的<code>th:text</code>属性，而显示<code>&lt;p&gt;</code>标签体的文本内容<code>Welcome to BeiJing!</code></p>\n<p>当它作为模板文件运行在服务器端时，<code>th:text</code>属性的具体值将会替换<code>&lt;p&gt;</code>标签体的文本内容。</p>\n<h2 id=\"4-2-th-utext\"><a href=\"#4-2-th-utext\" class=\"headerlink\" title=\"4.2 th:utext\"></a>4.2 th:utext</h2><p>属性<code>th:utext</code>与<code>th:text</code>的区别在于：</p>\n<ul>\n<li><code>th:text</code>默认会对含有 HTML 标签的内容进行字符转义；</li>\n<li><code>th:utext</code>（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义；</li>\n</ul>\n<p>假设：<code>message = &quot;&lt;b&gt;Welcome to BeiJing!&lt;/b&gt;&quot;</code>。</p>\n<p>（1）使用<code>th:text</code>属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>th:text</code>效果：<b>Welcome to BeiJing!</b></p>\n<p>（2）使用<code>th:utext</code>属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:utext</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>th:utext</code>效果：<strong>Welcome to BeiJing!</strong></p>\n<h1 id=\"5-设置属性值\"><a href=\"#5-设置属性值\" class=\"headerlink\" title=\"5. 设置属性值\"></a>5. 设置属性值</h1><p>在 Thymeleaf 模板文件中，你可以使用<code>th:*</code>（或者使用<code>th:attr</code>属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以<code>th:*-*</code>来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用<code>th:attrappend</code>和<code>th:attrprepend</code>来追加新的值到现有的标签属性值中。</p>\n<h2 id=\"5-1-th-attr\"><a href=\"#5-1-th-attr\" class=\"headerlink\" title=\"5.1 th:attr\"></a>5.1 th:attr</h2><p>这种方式是不被推荐的，了解一下就行。下面是用<code>th:attr=&quot;href=...&quot;</code>来设置标签<code>href</code>属性的值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:attr</span>=<span class=\"string\">&quot;href=@&#123;https://www.google.com.hk&#125;&quot;</span>&gt;</span>谷歌一下你就知道<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-th\"><a href=\"#5-2-th\" class=\"headerlink\" title=\"5.2 th:*\"></a>5.2 th:*</h2><p>显然<code>th:attr=&quot;href=@&#123;http://www.baidu.com&#125;&quot;</code>不够简洁，我们更推荐下面的这种语法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:href</span>=<span class=\"string\">&quot;@&#123;https://www.google.com.hk&#125;&quot;</span>&gt;</span>谷歌一下你就知道<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中<code>th:*</code>中的<code>*</code>可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;div item-id=&quot;1001&quot;&gt;Welcome to BeiJing!&lt;/div&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:item-id</span>=<span class=\"string\">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span>Welcome to BeiJing!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3-th\"><a href=\"#5-3-th\" class=\"headerlink\" title=\"5.3 th:-\"></a>5.3 th:<em>-</em></h2><p>如果想要同时为标签的多个不同属性设置相同的一个值，可以使用<code>th:*-*</code>的语法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;logo.png&quot;</span> <span class=\"attr\">th:alt-title</span>=<span class=\"string\">&quot;LOGO图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>它相当于</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;logo.png&quot;</span> <span class=\"attr\">th:alt</span>=<span class=\"string\">&quot;LOGO图片&quot;</span> <span class=\"attr\">th:title</span>=<span class=\"string\">&quot;LOGO图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4-th-attrappend-th-attrprepend\"><a href=\"#5-4-th-attrappend-th-attrprepend\" class=\"headerlink\" title=\"5.4 th:attrappend &amp; th:attrprepend\"></a>5.4 th:attrappend &amp; th:attrprepend</h2><p><code>th:attrappend</code>和<code>th:attrprepend</code>可以将表达式的结果分别追加到指定的属性值之后和之前。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;btn&quot;</span> <span class=\"attr\">th:attrappend</span>=<span class=\"string\">&quot;class=$&#123;outOfStock&#125; ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;</span>&gt;</span>购买<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;button class=&quot;enable btn&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;btn&quot;</span> <span class=\"attr\">th:attrprepend</span>=<span class=\"string\">&quot;class=$&#123;outOfStock&#125; ? &#x27;enable &#x27; : &#x27;disable &#x27;&quot;</span>&gt;</span>购买<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，还有两个常用的具体附加属性<code>th:classappend=&quot;...&quot;</code>和<code>th:styleappend=&quot;&quot;</code>。</p>\n<p>它们分别用来代替<code>th:attrappend=&quot;class=...&quot;</code>和<code>th:attrappend=&quot;style=...&quot;</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;btn&quot;</span> <span class=\"attr\">th:classappend</span>=<span class=\"string\">&quot;$&#123;outOfStock&#125; ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;</span>&gt;</span>购买<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-5-布尔属性\"><a href=\"#5-5-布尔属性\" class=\"headerlink\" title=\"5.5 布尔属性\"></a>5.5 布尔属性</h2><p>在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如<code>readonly</code>、<code>checked</code>、<code>selected</code>等。它们若存在那就意味着值为 true</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;rememberme&quot;</span> <span class=\"attr\">checked</span> /&gt;</span> 记住我</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sex&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;male&quot;</span> <span class=\"attr\">checked</span>&gt;</span> 男</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sex&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;female&quot;</span>&gt;</span> 女</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;appId&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;J123654&quot;</span> <span class=\"attr\">readonly</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">selected</span>&gt;</span>北京<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>上海<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>广州<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>深圳<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Thymeleaf 也允许我们通过<code>th:*</code>（这里的<code>*</code>表示任意的布尔属性） 来选择是否使用这些布尔属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;rememberme&quot;</span> <span class=\"attr\">ch:checked</span>=<span class=\"string\">&quot;$&#123;rememberme&#125;&quot;</span> /&gt;</span> 记住我</span><br></pre></td></tr></table></figure>\n\n<p>如果表达式的结果为<code>true</code>，则自动勾选复选框，若为<code>false</code>，则不会自动勾选</p>\n<h1 id=\"6-遍历\"><a href=\"#6-遍历\" class=\"headerlink\" title=\"6. 遍历\"></a>6. 遍历</h1><p>遍历（迭代）的语法<code>th:each=&quot;自定义的元素变量名称 : $&#123;集合变量名称&#125;&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">spn</span>&gt;</span>你所在城市：<span class=\"tag\">&lt;/<span class=\"name\">spn</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mycity&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">th:each</span>=<span class=\"string\">&quot;city : $&#123;cities&#125;&quot;</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;city.name&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性<code>th:each</code>提供了一个用于跟踪迭代的状态变量，它包含以下几个属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>index</td>\n<td>int</td>\n<td>当前迭代的索引，从0开始</td>\n</tr>\n<tr>\n<td>count</td>\n<td>int</td>\n<td>当前迭代的计数，从1开始</td>\n</tr>\n<tr>\n<td>size</td>\n<td>int</td>\n<td>集合中元素的总个数</td>\n</tr>\n<tr>\n<td>current</td>\n<td>int</td>\n<td>当前的元素对象</td>\n</tr>\n<tr>\n<td>even</td>\n<td>boolean</td>\n<td>当前迭代的计数是否是偶数</td>\n</tr>\n<tr>\n<td>odd</td>\n<td>boolean</td>\n<td>当前迭代的计数是否是奇数</td>\n</tr>\n<tr>\n<td>first</td>\n<td>boolean</td>\n<td>当前元素是否是集合的第一个元素</td>\n</tr>\n<tr>\n<td>last</td>\n<td>boolean</td>\n<td>当前元素是否是集合的最后一个元素</td>\n</tr>\n</tbody></table>\n<p>状态变量的使用语法：<code>th:each=&quot;自定义的元素变量名称, 自定义的状态变量名称 : $&#123;集合变量名称&#125;&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">spn</span>&gt;</span>所在城市：<span class=\"tag\">&lt;/<span class=\"name\">spn</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mycity&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">th:each</span>=<span class=\"string\">&quot;city, status : $&#123;cities&#125;&quot;</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;city.name&#125;&quot;</span> <span class=\"attr\">th:item-index</span>=<span class=\"string\">&quot;$&#123;status.count&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>不管什么时候，Thymeleaf 始终会为每个<code>th:each</code>创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加<code>Stat</code>字符串组成：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">spn</span>&gt;</span>所在城市：<span class=\"tag\">&lt;/<span class=\"name\">spn</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mycity&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">th:each</span>=<span class=\"string\">&quot;city : $&#123;cities&#125;&quot;</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;city.name&#125;&quot;</span> <span class=\"attr\">th:item-index</span>=<span class=\"string\">&quot;$&#123;cityStat.count&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-条件判断\"><a href=\"#7-条件判断\" class=\"headerlink\" title=\"7. 条件判断\"></a>7. 条件判断</h1><p>条件判断语句有三种，分别是：th:if，th:unless，th:swith</p>\n<h2 id=\"7-1-th-if\"><a href=\"#7-1-th-if\" class=\"headerlink\" title=\"7.1 th:if\"></a>7.1 th:if</h2><p>当表达式的评估结果为真时则显示内容，否则不显示</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:href</span>=<span class=\"string\">&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot;</span> <span class=\"attr\">th:if</span>=<span class=\"string\">&quot;$&#123;user != null&#125;&quot;</span>&gt;</span>我的订单<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>真假评估的依据：</p>\n<ul>\n<li>当表达式的值不为空（null）时 <ul>\n<li>如果表达式的值是一个布尔类型，且值为<code>true</code>评估为真，否则为假</li>\n<li>如果表达式的值是一个数字类型，且值为非<code>0</code>评估为真，否则为假</li>\n<li>如果表达式的值是一个字符类型，且值为非<code>0</code>评估为真，否则为假</li>\n<li>如果表达式的值是一个字符串类型，且值为非<code>&quot;false&quot;</code>、<code>&quot;off&quot;</code>、<code>&quot;no&quot;</code>评估为真，否则为假</li>\n<li>如果表达式的值不是一个<code>布尔</code>、<code>数字</code>、<code>字符</code>或<code>字符串</code>评估为真</li>\n</ul>\n</li>\n<li>当表达式的值为空（null）时，评估结果为假</li>\n</ul>\n<p>因此，上面代码我们也可以简写成：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:href</span>=<span class=\"string\">&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot;</span> <span class=\"attr\">th:if</span>=<span class=\"string\">&quot;$&#123;user&#125;&quot;</span>&gt;</span>我的订单<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但是，为了代码的可读性，我们并不建议这样使用</p>\n<h2 id=\"7-2-th-unless\"><a href=\"#7-2-th-unless\" class=\"headerlink\" title=\"7.2 th:unless\"></a>7.2 th:unless</h2><p><code>th:unless</code>与<code>th:if</code>判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:href</span>=<span class=\"string\">&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot;</span> <span class=\"attr\">th:unless</span>=<span class=\"string\">&quot;$&#123;user == null&#125;&quot;</span>&gt;</span>我的订单<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-3-th-swith\"><a href=\"#7-3-th-swith\" class=\"headerlink\" title=\"7.3 th:swith\"></a>7.3 th:swith</h2><p>多路选择语句，它需要搭配th:case来使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:switch</span>=<span class=\"string\">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:case</span>=<span class=\"string\">&quot;admin&quot;</span>&gt;</span>管理员<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:case</span>=<span class=\"string\">&quot;user&quot;</span>&gt;</span>普通用户<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"8-定义局部变量\"><a href=\"#8-定义局部变量\" class=\"headerlink\" title=\"8. 定义局部变量\"></a>8. 定义局部变量</h1><p>使用th:with属性可以定义局部变量</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:with</span>=<span class=\"string\">&quot;name=&#x27;fanlychie&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>同时定义多个局部变量时，用英文<code>,</code>号分隔开：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:with</span>=<span class=\"string\">&quot;name=$&#123;user.name&#125;,age=&#123;user.age&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"9-注释\"><a href=\"#9-注释\" class=\"headerlink\" title=\"9. 注释\"></a>9. 注释</h1><h2 id=\"9-1-标准注释\"><a href=\"#9-1-标准注释\" class=\"headerlink\" title=\"9.1 标准注释\"></a>9.1 标准注释</h2><p>语法：<code>&lt;!-- ... ---&gt;</code>，注释的代码块会在文件源代码中显示出来。</p>\n<h3 id=\"9-1-1-单行注释\"><a href=\"#9-1-1-单行注释\" class=\"headerlink\" title=\"9.1.1 单行注释\"></a>9.1.1 单行注释</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;span&gt;$&#123;message&#125;&lt;/span&gt; ---&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-1-2-多行注释\"><a href=\"#9-1-2-多行注释\" class=\"headerlink\" title=\"9.1.2 多行注释\"></a>9.1.2 多行注释</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;p th:case=&quot;admin&quot;&gt;管理员&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;p th:case=&quot;user&quot;&gt;普通用户&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">---&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-2-解析器级注释\"><a href=\"#9-2-解析器级注释\" class=\"headerlink\" title=\"9.2 解析器级注释\"></a>9.2 解析器级注释</h2><p>语法：<code>&lt;!--/* ... */--&gt;</code>，注释的代码块会在引擎解析的时候抹去</p>\n<h3 id=\"9-2-1-单行注释\"><a href=\"#9-2-1-单行注释\" class=\"headerlink\" title=\"9.2.1 单行注释\"></a>9.2.1 单行注释</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--/* &lt;span&gt;$&#123;message&#125;&lt;/span&gt; */--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-2-2-多行注释\"><a href=\"#9-2-2-多行注释\" class=\"headerlink\" title=\"9.2.2 多行注释\"></a>9.2.2 多行注释</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--/*--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:switch</span>=<span class=\"string\">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:case</span>=<span class=\"string\">&quot;admin&quot;</span>&gt;</span>管理员<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:case</span>=<span class=\"string\">&quot;user&quot;</span>&gt;</span>普通用户<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--*/--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"10-内联表达式\"><a href=\"#10-内联表达式\" class=\"headerlink\" title=\"10. 内联表达式\"></a>10. 内联表达式</h1><p>内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用<code>th:*</code>标签属性</p>\n<h2 id=\"10-1-…\"><a href=\"#10-1-…\" class=\"headerlink\" title=\"10.1 [[…]]\"></a>10.1 [[…]]</h2><p>[[]]相当于th:text，对含有HTML标签的内容自动进行字符转义</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The message is : [[$&#123;htmlContent&#125;]]<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-2-…\"><a href=\"#10-2-…\" class=\"headerlink\" title=\"10.2 [(…)]\"></a>10.2 [(…)]</h2><p>[()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The message is : [($&#123;htmlContent&#125;)]<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-3-th-inline\"><a href=\"#10-3-th-inline\" class=\"headerlink\" title=\"10.3 th:inline\"></a>10.3 th:inline</h2><p>我们已经了解到，使用<code>[[]]</code>和<code>[()]</code>语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用<code>th:inline</code>属性来激活，它的取值如下：</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>none</td>\n<td>禁止内联表达式，可以原样输出[[]]和[()]字符串</td>\n</tr>\n<tr>\n<td>text</td>\n<td>文本内联，可以使用th:each等高级语法</td>\n</tr>\n<tr>\n<td>css</td>\n<td>样式内联，如：<code>&lt;style th:inline=&quot;css&quot;&gt;</code></td>\n</tr>\n<tr>\n<td>javascript</td>\n<td>脚本内联，如：<code>&lt;style th:inline=&quot;javascript&quot;&gt;</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"10-3-1-none\"><a href=\"#10-3-1-none\" class=\"headerlink\" title=\"10.3.1 none\"></a>10.3.1 none</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- [[1, 2], [3, 4]] --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:inline</span>=<span class=\"string\">&quot;none&quot;</span>&gt;</span>[[1, 2], [3, 4]]<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"10-3-2-text\"><a href=\"#10-3-2-text\" class=\"headerlink\" title=\"10.3.2 text\"></a>10.3.2 text</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 北京 上海 广州 深圳 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:inline</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span></span><br><span class=\"line\">    [# th:each=&quot;city : $&#123;cities&#125;&quot;]</span><br><span class=\"line\">        [($&#123;city.name&#125;)]</span><br><span class=\"line\">    [/]</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"10-3-3-css\"><a href=\"#10-3-3-css\" class=\"headerlink\" title=\"10.3.3 css\"></a>10.3.3 css</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">th:inline</span>=<span class=\"string\">&quot;css&quot;</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-tag\">body</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">        <span class=\"attribute\">background-color</span>:[[$&#123;bgColor&#125;]];</span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-3-4-javascript\"><a href=\"#10-3-4-javascript\" class=\"headerlink\" title=\"10.3.4 javascript\"></a>10.3.4 javascript</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">th:inline</span>=<span class=\"string\">&quot;javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> user = [[$&#123;user&#125;]];</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;用户名：&quot;</span> + user.<span class=\"property\">name</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1-简介\"><a href=\"#1-简介\" class=\"headerlink\" title=\"1. 简介\"></a>1. 简介</h1><p>Thymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT 等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端 HTML5 开发的理想选择</p>\n<h1 id=\"2-创建模板文件\"><a href=\"#2-创建模板文件\" class=\"headerlink\" title=\"2. 创建模板文件\"></a>2. 创建模板文件</h1><p>创建一个html模板文件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">HTML</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">xmlns:th</span>=<span class=\"string\">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>Index Page<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;Content-Type&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span>Welcome to BeiJing!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li><!DOCTYPE HTML> ：声明文档的解析类型(document.compatMode)，使用标准模式渲染页面，避免浏览器的怪异模式 (浏览器使用自己的怪异模式解析渲染页面).</li>\n</ol>\n<blockquote>\n<p>标准模式，浏览器使用W3C的标准解析渲染页面</p>\n</blockquote>\n<ol start=\"2\">\n<li><html xmlns:th=\"[http://www.thymeleaf.org](http://www.thymeleaf.org)\">: 引入 Thymeleaf 命名空间 (xmlns 属性规定文档的 xml 命名空间)</li>\n</ol>\n<h1 id=\"3、标准表达式语法\"><a href=\"#3、标准表达式语法\" class=\"headerlink\" title=\"3、标准表达式语法\"></a>3、标准表达式语法</h1><p>Thymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类：</p>\n<ul>\n<li>简单表达式 </li>\n<li>字面值 </li>\n<li>文本操作 </li>\n<li>算术运算 </li>\n<li>布尔运算 </li>\n<li>比较和相等 </li>\n<li>条件运算 </li>\n<li>无操作符</li>\n</ul>\n<h2 id=\"3-1-简单表达式\"><a href=\"#3-1-简单表达式\" class=\"headerlink\" title=\"3.1 简单表达式\"></a>3.1 简单表达式</h2><table>\n<thead>\n<tr>\n<th>语法</th>\n<th>名称</th>\n<th>描述</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>${…}</td>\n<td>Variable Expressions</td>\n<td>变量表达式</td>\n<td>取出上下文变量的值</td>\n</tr>\n<tr>\n<td>*{…}</td>\n<td>Selection Variable Expressions</td>\n<td>选择表达式</td>\n<td>取出选择的对象的属性值</td>\n</tr>\n<tr>\n<td>#{…}</td>\n<td>Message Expressions</td>\n<td>消息表达式</td>\n<td>使文字消息国际化，I18N</td>\n</tr>\n<tr>\n<td>@{…}</td>\n<td>Link URL Expressions</td>\n<td>链接表达式</td>\n<td>用于表示各种超链接地址</td>\n</tr>\n<tr>\n<td>~{…}</td>\n<td>Fragment Expressions</td>\n<td>片段表达式</td>\n<td>引用一段公共的代码片段</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-1-1-…-变量表达式\"><a href=\"#3-1-1-…-变量表达式\" class=\"headerlink\" title=\"3.1.1 ${…}   变量表达式\"></a>3.1.1 ${…}   变量表达式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@GetMapping(&quot;/standard-expression-syntax/variables&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> String <span class=\"title function_\">variables</span><span class=\"params\">(ModelMap model, HttpSession session)</span> &#123;</span><br><span class=\"line\">    model.put(<span class=\"string\">&quot;now&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>());</span><br><span class=\"line\">    model.put(<span class=\"string\">&quot;message&quot;</span>, <span class=\"string\">&quot;Welcome to BeiJing!&quot;</span>);</span><br><span class=\"line\">    session.setAttribute(<span class=\"string\">&quot;user&quot;</span>, <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>(<span class=\"string\">&quot;fanlychie&quot;</span>, <span class=\"string\">&quot;男&quot;</span>, <span class=\"number\">24</span>));</span><br><span class=\"line\">    ... ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>通过变量表达式<code>$&#123;&#125;</code>取出上下文环境中的<code>message</code>变量：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-2-…-选择表达式\"><a href=\"#3-1-2-…-选择表达式\" class=\"headerlink\" title=\"3.1.2  *{…}   选择表达式\"></a>3.1.2  *{…}   选择表达式</h3><p>变量表达式<code>$&#123;&#125;</code>是面向整个上下文的，而选择变量表达式<code>*&#123;&#125;</code>的上下文是父标签（<code>th:object</code>）所选择的对象</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:object</span>=<span class=\"string\">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;*&#123;name&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;*&#123;sex&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;*&#123;age&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-3-…-消息表达式\"><a href=\"#3-1-3-…-消息表达式\" class=\"headerlink\" title=\"3.1.3  #{…}   消息表达式\"></a>3.1.3  #{…}   消息表达式</h3><p>消息表达式可用于国际化文字信息.首先我们来了解一下 i18n 资源文件的命名规则：</p>\n<ul>\n<li>basename.properties</li>\n<li>basename_language.properties</li>\n<li>basename_language_country.properties</li>\n</ul>\n<p><code>basename</code>是自定义的资源文件名称，<code>language</code>和<code>country</code>必须是 Java 支持的语言和国家。<code>basename.properties</code>是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。</p>\n<p><code>basename</code>是自定义的资源文件名称，<code>language</code>和<code>country</code>必须是 Java 支持的语言和国家。<code>basename.properties</code>是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。</p>\n<p>创建文件<code>src/main/resources/messages.properties</code></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">welcome.message</span> = <span class=\"string\">北京欢迎你！</span></span><br></pre></td></tr></table></figure>\n\n<p>创建文件<code>src/main/resources/messages_en_US.properties</code></p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">welcome.message</span> = <span class=\"string\">Welcome to BeiJing!</span></span><br></pre></td></tr></table></figure>\n\n<p>在 IntelliJ IDEA 编辑视图：</p>\n<p><code>messages</code>是 Spring Boot 加载资源文件默认采用的名称（<code>basename</code>），如果你所使用的资源文件名称不是以<code>messages</code>命名或所使用的资源文件不是在<code>src/main/resources</code>根目录，你可以通过<code>spring.messages.basename</code>属性来做具体的配置。如，资源文件<code>messages.properties</code>和<code>messages_en_US.properties</code>假设它们所在的目录位置是<code>src/main/resources/i18n</code>。</p>\n<p>application.properties 配置示例：</p>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">spring.messages.basename</span>:<span class=\"string\">i18n/messages</span></span><br></pre></td></tr></table></figure>\n\n<p>静态文本消息示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 北京欢迎你！ --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;#&#123;welcom.message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-4-…-链接表达式\"><a href=\"#3-1-4-…-链接表达式\" class=\"headerlink\" title=\"3.1.4 @{…} 链接表达式\"></a>3.1.4 @{…} 链接表达式</h3><p>链接表达式<code>@&#123;&#125;</code>是专门用来处理 URL 链接地址的</p>\n<p>（1）绝对地址示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://fanlychie.github.io --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;@&#123;https://fanlychie.github.io&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）页面相对地址示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- commons/base.html --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;@&#123;commons/base.html&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）上下文相对地址（相对于当前的服务）示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /css/mian.css --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;@&#123;/css/mian.css&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）服务器相对地址（相对于部署在同一个服务器中的不同服务）示例：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- /image/upload --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;@&#123;~/image/upload&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-5-…-片段表达式\"><a href=\"#3-1-5-…-片段表达式\" class=\"headerlink\" title=\"3.1.5 ~{…} 片段表达式\"></a>3.1.5 ~{…} 片段表达式</h3><p>片段表达式<code>~&#123;&#125;</code>可以用来引用一段公共的 HTML 代码片段</p>\n<table>\n<thead>\n<tr>\n<th>语法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>~{templatename}</td>\n<td>引用整个模板文件的代码片段</td>\n</tr>\n<tr>\n<td>~{templatename :: selector}</td>\n<td>selector 可以是 th:fragment 指定的名称或其他选择器。如类选择器、ID选择器等</td>\n</tr>\n<tr>\n<td>~{::selector}</td>\n<td>相当于 ~{this :: selector}，表示引用当前模板定义的代码片段</td>\n</tr>\n</tbody></table>\n<p>在 Thymeleaf 模板文件中，你可以使用<code>th:fragment</code>属性来定义一段公共的代码片段，然后你可以通过使用<code>th:insert</code>、<code>th:replace</code>、<code>th:include</code>（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。</p>\n<p>（1）src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;base.html，通过<code>th:fragment</code>属性定义一段公共的代码片段：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;footer&quot;</span> <span class=\"attr\">th:fragment</span>=<span class=\"string\">&quot;footerFragment&quot;</span>&gt;</span><span class=\"symbol\">&amp;copy;</span> 2017 fanlychie<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;index.html，通过<code>th:insert</code>属性引用一段公共的代码片段：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:insert</span>=<span class=\"string\">&quot;~&#123;base :: footerFragment&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>th:fragment</code>属性定义代码片段时，你还可以声明一组参数：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:fragment</span>=<span class=\"string\">&quot;crumbs(parent, child)&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;parent&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">i</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;child&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">i</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">&lt;i&gt;用户中心&lt;/i&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;i&gt;我的订单&lt;/i&gt;</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:insert</span>=<span class=\"string\">&quot;::crumbs(&#x27;用户中心&#x27;, &#x27;我的订单&#x27;)&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:insert</span>=<span class=\"string\">&quot;~&#123;base :: #footer&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-6-内置对象\"><a href=\"#3-1-6-内置对象\" class=\"headerlink\" title=\"3.1.6  内置对象\"></a>3.1.6  内置对象</h3><table>\n<thead>\n<tr>\n<th>对象</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>#ctx</td>\n<td>上下文对象</td>\n</tr>\n<tr>\n<td>#vars</td>\n<td>同#ctx，表示上下文变量</td>\n</tr>\n<tr>\n<td>#locale</td>\n<td>上下文本地化（特定地理区域）变量，可参考java.utils.Locale</td>\n</tr>\n<tr>\n<td>#request</td>\n<td>HttpServletRequest对象</td>\n</tr>\n<tr>\n<td>#response</td>\n<td>HttpServletResponse 对象</td>\n</tr>\n<tr>\n<td>#session</td>\n<td>HttpSession对象</td>\n</tr>\n<tr>\n<td>#servletContext</td>\n<td>ServletContext 对象</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- #ctx  --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#ctx.getLocale()&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#ctx.getVariable(&#x27;message&#x27;)&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #vars --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#vars.getLocale()&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#vars.getVariable(&#x27;message&#x27;)&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #locale --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#locale&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#locale.country&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #request --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#request.serverName&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#request.serverPort&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#request.requestURL&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #response --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#response.status&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#response.characterEncoding&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- #session --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#session.id&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-1-7-工具类\"><a href=\"#3-1-7-工具类\" class=\"headerlink\" title=\"3.1.7 工具类\"></a>3.1.7 工具类</h3><table>\n<thead>\n<tr>\n<th>对象</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>#message</td>\n<td>消息工具类，与 ＃{…} 作用相同</td>\n</tr>\n<tr>\n<td>#uris</td>\n<td>地址相关的工具类</td>\n</tr>\n<tr>\n<td>#conversions</td>\n<td>对象转换工具</td>\n</tr>\n<tr>\n<td>#dates</td>\n<td>日期转换工具</td>\n</tr>\n<tr>\n<td>#calendars</td>\n<td>日历工具类</td>\n</tr>\n<tr>\n<td>#numbers</td>\n<td>数字工具类</td>\n</tr>\n<tr>\n<td>#strings</td>\n<td>字符串工具类</td>\n</tr>\n<tr>\n<td>#objects</td>\n<td>对象工具类</td>\n</tr>\n<tr>\n<td>#bools</td>\n<td>布尔工具类</td>\n</tr>\n<tr>\n<td>#arrays</td>\n<td>数组工具类</td>\n</tr>\n<tr>\n<td>#list</td>\n<td>List工具类</td>\n</tr>\n<tr>\n<td>#set</td>\n<td>Set工具类</td>\n</tr>\n<tr>\n<td>#maps</td>\n<td>Map工具类</td>\n</tr>\n</tbody></table>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#strings.isEmpty(message)&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;#dates.format(now, &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-2-字面值\"><a href=\"#3-2-字面值\" class=\"headerlink\" title=\"3.2 字面值\"></a>3.2 字面值</h2><p>所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：<code>18</code>、<code>&#39;welcome&#39;</code>等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。</p>\n<h3 id=\"3-2-1-文字字面值\"><a href=\"#3-2-1-文字字面值\" class=\"headerlink\" title=\"3.2.1 文字字面值\"></a>3.2.1 文字字面值</h3><p>文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;&#x27;Welcome to BeiJing!&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &#x27;Welcome to BeiJing!&#x27; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;&#x27;\\&#x27;Welcome to BeiJing!\\&#x27;&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-2-数字字面量\"><a href=\"#3-2-2-数字字面量\" class=\"headerlink\" title=\"3.2.2 数字字面量\"></a>3.2.2 数字字面量</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 2017 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;2017&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2018 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;2017 + 1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-3-布尔字面值\"><a href=\"#3-2-3-布尔字面值\" class=\"headerlink\" title=\"3.2.3 布尔字面值\"></a>3.2.3 布尔字面值</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- false --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;1 &gt; 2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 否 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;1 &gt; 2 ? &#x27;是&#x27; : &#x27;否&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-4-空字面值\"><a href=\"#3-2-4-空字面值\" class=\"headerlink\" title=\"3.2.4 空字面值\"></a>3.2.4 空字面值</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- false --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user == null&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-5-字面令牌\"><a href=\"#3-2-5-字面令牌\" class=\"headerlink\" title=\"3.2.5 字面令牌\"></a>3.2.5 字面令牌</h3><p>字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）：</p>\n<ul>\n<li>大写或小写的字母、中文等不含空格和特殊符号的文本</li>\n<li>0 到 9 的数字</li>\n<li>中括号</li>\n<li>下划线</li>\n<li>连字符（-）</li>\n<li>点符号（.）</li>\n</ul>\n<p>实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;Welcome to BeiJing!&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">等效于</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;&#x27;Welcome to BeiJing!&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-3-文本操作\"><a href=\"#3-3-文本操作\" class=\"headerlink\" title=\"3.3 文本操作\"></a>3.3 文本操作</h2><p>我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换</p>\n<h3 id=\"3-3-1-字符串连接\"><a href=\"#3-3-1-字符串连接\" class=\"headerlink\" title=\"3.3.1 字符串连接\"></a>3.3.1 字符串连接</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;&#x27;Welcome to &#x27; + $&#123;location&#125; + &#x27;!&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-3-2-字面值替换\"><a href=\"#3-3-2-字面值替换\" class=\"headerlink\" title=\"3.3.2 字面值替换\"></a>3.3.2 字面值替换</h3><p>符号<code>||</code>可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用<code>+</code>连接符：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;|Welcome to $&#123;location&#125;!|&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-4-算数运算\"><a href=\"#3-4-算数运算\" class=\"headerlink\" title=\"3.4 算数运算\"></a>3.4 算数运算</h2><p>支持<code>+</code>（加）、<code>-</code>（减）、<code>*</code>（乘）、<code>/</code>（除）、<code>%</code>（模）运算：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 6 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;4 + 2&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;pagination.page + 1&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 2 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;pagination.page&#125; + 1&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-5-布尔运算\"><a href=\"#3-5-布尔运算\" class=\"headerlink\" title=\"3.5 布尔运算\"></a>3.5 布尔运算</h2><p>支持<code>and</code>（且）、<code>or</code>（或）、<code>!</code>（非）、<code>not</code>（非）运算：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.online and user.vip&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.online or user.vip&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;!user.online&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;not user.online&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-6-比较和相等\"><a href=\"#3-6-比较和相等\" class=\"headerlink\" title=\"3.6 比较和相等\"></a>3.6 比较和相等</h2><p>支持<code>&lt;</code>（<code>lt</code>）、<code>&gt;</code>（<code>gt</code>）、<code>&lt;=</code>（<code>le</code>）、<code>&gt;=</code>（<code>ge</code>）、<code>==</code>（<code>eq</code>）、<code>！=</code>（<code>ne</code>）：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age &lt; 60&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age &lt;= 60&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age &gt; 18&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age &gt;= 18&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age == 18&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.age != 18&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-7-条件运算\"><a href=\"#3-7-条件运算\" class=\"headerlink\" title=\"3.7 条件运算\"></a>3.7 条件运算</h2><p>三元运算符：<code>(if) ? (then) : (else)</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.online ? &#x27;在线&#x27; : &#x27;离线&#x27;&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>二元运算符：<code>(value) ?: (defaultValue)</code>。</p>\n<p>其中，<code>value</code>非空（null）即真，条件为真时输出<code>value</code>，否则输出<code>defaultValue</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 你还没有登录，请先登录 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;token&#125; ?: &#x27;你还没有登录，请先登录&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- fanlychie@gmail.com --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;user.email&#125; ?: &#x27;你还没有绑定邮箱&#x27;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-8-无操作符\"><a href=\"#3-8-无操作符\" class=\"headerlink\" title=\"3.8 无操作符\"></a>3.8 无操作符</h2><p>当模板运行在服务器端时，Thymeleaf 会解析<code>th:*</code>属性的具体值替换标签体的内容。无操作符（<code>_</code>）则允许你使用原型标签体的内容作为默认值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 你还没有登录，请先登录 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;token&#125; ?: _&quot;</span>&gt;</span>你还没有登录，请先登录<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4-使用文本\"><a href=\"#4-使用文本\" class=\"headerlink\" title=\"4. 使用文本\"></a>4. 使用文本</h1><p>首先介绍两个最基础的<code>th:*</code>属<code>th:text</code>和<code>th:utext</code>，它们都是用于处理文本消息内容</p>\n<h2 id=\"4-1-th-text\"><a href=\"#4-1-th-text\" class=\"headerlink\" title=\"4.1 th:text\"></a>4.1 th:text</h2><p>在标签体中展示表达式评估结果的文本内容：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>使用外部化的文本内容：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span>Welcome to BeiJing!<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的<code>th:text</code>属性，而显示<code>&lt;p&gt;</code>标签体的文本内容<code>Welcome to BeiJing!</code></p>\n<p>当它作为模板文件运行在服务器端时，<code>th:text</code>属性的具体值将会替换<code>&lt;p&gt;</code>标签体的文本内容。</p>\n<h2 id=\"4-2-th-utext\"><a href=\"#4-2-th-utext\" class=\"headerlink\" title=\"4.2 th:utext\"></a>4.2 th:utext</h2><p>属性<code>th:utext</code>与<code>th:text</code>的区别在于：</p>\n<ul>\n<li><code>th:text</code>默认会对含有 HTML 标签的内容进行字符转义；</li>\n<li><code>th:utext</code>（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义；</li>\n</ul>\n<p>假设：<code>message = &quot;&lt;b&gt;Welcome to BeiJing!&lt;/b&gt;&quot;</code>。</p>\n<p>（1）使用<code>th:text</code>属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>th:text</code>效果：<b>Welcome to BeiJing!</b></p>\n<p>（2）使用<code>th:utext</code>属性：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:utext</span>=<span class=\"string\">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><code>th:utext</code>效果：<strong>Welcome to BeiJing!</strong></p>\n<h1 id=\"5-设置属性值\"><a href=\"#5-设置属性值\" class=\"headerlink\" title=\"5. 设置属性值\"></a>5. 设置属性值</h1><p>在 Thymeleaf 模板文件中，你可以使用<code>th:*</code>（或者使用<code>th:attr</code>属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以<code>th:*-*</code>来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用<code>th:attrappend</code>和<code>th:attrprepend</code>来追加新的值到现有的标签属性值中。</p>\n<h2 id=\"5-1-th-attr\"><a href=\"#5-1-th-attr\" class=\"headerlink\" title=\"5.1 th:attr\"></a>5.1 th:attr</h2><p>这种方式是不被推荐的，了解一下就行。下面是用<code>th:attr=&quot;href=...&quot;</code>来设置标签<code>href</code>属性的值：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:attr</span>=<span class=\"string\">&quot;href=@&#123;https://www.google.com.hk&#125;&quot;</span>&gt;</span>谷歌一下你就知道<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-2-th\"><a href=\"#5-2-th\" class=\"headerlink\" title=\"5.2 th:*\"></a>5.2 th:*</h2><p>显然<code>th:attr=&quot;href=@&#123;http://www.baidu.com&#125;&quot;</code>不够简洁，我们更推荐下面的这种语法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:href</span>=<span class=\"string\">&quot;@&#123;https://www.google.com.hk&#125;&quot;</span>&gt;</span>谷歌一下你就知道<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>其中<code>th:*</code>中的<code>*</code>可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;div item-id=&quot;1001&quot;&gt;Welcome to BeiJing!&lt;/div&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:item-id</span>=<span class=\"string\">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span>Welcome to BeiJing!<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-3-th\"><a href=\"#5-3-th\" class=\"headerlink\" title=\"5.3 th:-\"></a>5.3 th:<em>-</em></h2><p>如果想要同时为标签的多个不同属性设置相同的一个值，可以使用<code>th:*-*</code>的语法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;logo.png&quot;</span> <span class=\"attr\">th:alt-title</span>=<span class=\"string\">&quot;LOGO图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>它相当于</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;logo.png&quot;</span> <span class=\"attr\">th:alt</span>=<span class=\"string\">&quot;LOGO图片&quot;</span> <span class=\"attr\">th:title</span>=<span class=\"string\">&quot;LOGO图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-4-th-attrappend-th-attrprepend\"><a href=\"#5-4-th-attrappend-th-attrprepend\" class=\"headerlink\" title=\"5.4 th:attrappend &amp; th:attrprepend\"></a>5.4 th:attrappend &amp; th:attrprepend</h2><p><code>th:attrappend</code>和<code>th:attrprepend</code>可以将表达式的结果分别追加到指定的属性值之后和之前。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;btn&quot;</span> <span class=\"attr\">th:attrappend</span>=<span class=\"string\">&quot;class=$&#123;outOfStock&#125; ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;</span>&gt;</span>购买<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;button class=&quot;enable btn&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;btn&quot;</span> <span class=\"attr\">th:attrprepend</span>=<span class=\"string\">&quot;class=$&#123;outOfStock&#125; ? &#x27;enable &#x27; : &#x27;disable &#x27;&quot;</span>&gt;</span>购买<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>另外，还有两个常用的具体附加属性<code>th:classappend=&quot;...&quot;</code>和<code>th:styleappend=&quot;&quot;</code>。</p>\n<p>它们分别用来代替<code>th:attrappend=&quot;class=...&quot;</code>和<code>th:attrappend=&quot;style=...&quot;</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;btn&quot;</span> <span class=\"attr\">th:classappend</span>=<span class=\"string\">&quot;$&#123;outOfStock&#125; ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;</span>&gt;</span>购买<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"5-5-布尔属性\"><a href=\"#5-5-布尔属性\" class=\"headerlink\" title=\"5.5 布尔属性\"></a>5.5 布尔属性</h2><p>在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如<code>readonly</code>、<code>checked</code>、<code>selected</code>等。它们若存在那就意味着值为 true</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;rememberme&quot;</span> <span class=\"attr\">checked</span> /&gt;</span> 记住我</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sex&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;male&quot;</span> <span class=\"attr\">checked</span>&gt;</span> 男</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sex&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;female&quot;</span>&gt;</span> 女</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;appId&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;J123654&quot;</span> <span class=\"attr\">readonly</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">selected</span>&gt;</span>北京<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>上海<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>广州<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">option</span>&gt;</span>深圳<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>Thymeleaf 也允许我们通过<code>th:*</code>（这里的<code>*</code>表示任意的布尔属性） 来选择是否使用这些布尔属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;rememberme&quot;</span> <span class=\"attr\">ch:checked</span>=<span class=\"string\">&quot;$&#123;rememberme&#125;&quot;</span> /&gt;</span> 记住我</span><br></pre></td></tr></table></figure>\n\n<p>如果表达式的结果为<code>true</code>，则自动勾选复选框，若为<code>false</code>，则不会自动勾选</p>\n<h1 id=\"6-遍历\"><a href=\"#6-遍历\" class=\"headerlink\" title=\"6. 遍历\"></a>6. 遍历</h1><p>遍历（迭代）的语法<code>th:each=&quot;自定义的元素变量名称 : $&#123;集合变量名称&#125;&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">spn</span>&gt;</span>你所在城市：<span class=\"tag\">&lt;/<span class=\"name\">spn</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mycity&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">th:each</span>=<span class=\"string\">&quot;city : $&#123;cities&#125;&quot;</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;city.name&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>属性<code>th:each</code>提供了一个用于跟踪迭代的状态变量，它包含以下几个属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性</th>\n<th>类型</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>index</td>\n<td>int</td>\n<td>当前迭代的索引，从0开始</td>\n</tr>\n<tr>\n<td>count</td>\n<td>int</td>\n<td>当前迭代的计数，从1开始</td>\n</tr>\n<tr>\n<td>size</td>\n<td>int</td>\n<td>集合中元素的总个数</td>\n</tr>\n<tr>\n<td>current</td>\n<td>int</td>\n<td>当前的元素对象</td>\n</tr>\n<tr>\n<td>even</td>\n<td>boolean</td>\n<td>当前迭代的计数是否是偶数</td>\n</tr>\n<tr>\n<td>odd</td>\n<td>boolean</td>\n<td>当前迭代的计数是否是奇数</td>\n</tr>\n<tr>\n<td>first</td>\n<td>boolean</td>\n<td>当前元素是否是集合的第一个元素</td>\n</tr>\n<tr>\n<td>last</td>\n<td>boolean</td>\n<td>当前元素是否是集合的最后一个元素</td>\n</tr>\n</tbody></table>\n<p>状态变量的使用语法：<code>th:each=&quot;自定义的元素变量名称, 自定义的状态变量名称 : $&#123;集合变量名称&#125;&quot;</code>：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">spn</span>&gt;</span>所在城市：<span class=\"tag\">&lt;/<span class=\"name\">spn</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mycity&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">th:each</span>=<span class=\"string\">&quot;city, status : $&#123;cities&#125;&quot;</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;city.name&#125;&quot;</span> <span class=\"attr\">th:item-index</span>=<span class=\"string\">&quot;$&#123;status.count&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>不管什么时候，Thymeleaf 始终会为每个<code>th:each</code>创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加<code>Stat</code>字符串组成：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">spn</span>&gt;</span>所在城市：<span class=\"tag\">&lt;/<span class=\"name\">spn</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mycity&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">th:each</span>=<span class=\"string\">&quot;city : $&#123;cities&#125;&quot;</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;city.name&#125;&quot;</span> <span class=\"attr\">th:item-index</span>=<span class=\"string\">&quot;$&#123;cityStat.count&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"7-条件判断\"><a href=\"#7-条件判断\" class=\"headerlink\" title=\"7. 条件判断\"></a>7. 条件判断</h1><p>条件判断语句有三种，分别是：th:if，th:unless，th:swith</p>\n<h2 id=\"7-1-th-if\"><a href=\"#7-1-th-if\" class=\"headerlink\" title=\"7.1 th:if\"></a>7.1 th:if</h2><p>当表达式的评估结果为真时则显示内容，否则不显示</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:href</span>=<span class=\"string\">&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot;</span> <span class=\"attr\">th:if</span>=<span class=\"string\">&quot;$&#123;user != null&#125;&quot;</span>&gt;</span>我的订单<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>真假评估的依据：</p>\n<ul>\n<li>当表达式的值不为空（null）时 <ul>\n<li>如果表达式的值是一个布尔类型，且值为<code>true</code>评估为真，否则为假</li>\n<li>如果表达式的值是一个数字类型，且值为非<code>0</code>评估为真，否则为假</li>\n<li>如果表达式的值是一个字符类型，且值为非<code>0</code>评估为真，否则为假</li>\n<li>如果表达式的值是一个字符串类型，且值为非<code>&quot;false&quot;</code>、<code>&quot;off&quot;</code>、<code>&quot;no&quot;</code>评估为真，否则为假</li>\n<li>如果表达式的值不是一个<code>布尔</code>、<code>数字</code>、<code>字符</code>或<code>字符串</code>评估为真</li>\n</ul>\n</li>\n<li>当表达式的值为空（null）时，评估结果为假</li>\n</ul>\n<p>因此，上面代码我们也可以简写成：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:href</span>=<span class=\"string\">&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot;</span> <span class=\"attr\">th:if</span>=<span class=\"string\">&quot;$&#123;user&#125;&quot;</span>&gt;</span>我的订单<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>但是，为了代码的可读性，我们并不建议这样使用</p>\n<h2 id=\"7-2-th-unless\"><a href=\"#7-2-th-unless\" class=\"headerlink\" title=\"7.2 th:unless\"></a>7.2 th:unless</h2><p><code>th:unless</code>与<code>th:if</code>判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">th:href</span>=<span class=\"string\">&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot;</span> <span class=\"attr\">th:unless</span>=<span class=\"string\">&quot;$&#123;user == null&#125;&quot;</span>&gt;</span>我的订单<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"7-3-th-swith\"><a href=\"#7-3-th-swith\" class=\"headerlink\" title=\"7.3 th:swith\"></a>7.3 th:swith</h2><p>多路选择语句，它需要搭配th:case来使用：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:switch</span>=<span class=\"string\">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:case</span>=<span class=\"string\">&quot;admin&quot;</span>&gt;</span>管理员<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:case</span>=<span class=\"string\">&quot;user&quot;</span>&gt;</span>普通用户<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"8-定义局部变量\"><a href=\"#8-定义局部变量\" class=\"headerlink\" title=\"8. 定义局部变量\"></a>8. 定义局部变量</h1><p>使用th:with属性可以定义局部变量</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:with</span>=<span class=\"string\">&quot;name=&#x27;fanlychie&#x27;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">th:text</span>=<span class=\"string\">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>同时定义多个局部变量时，用英文<code>,</code>号分隔开：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:with</span>=<span class=\"string\">&quot;name=$&#123;user.name&#125;,age=&#123;user.age&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    ......</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"9-注释\"><a href=\"#9-注释\" class=\"headerlink\" title=\"9. 注释\"></a>9. 注释</h1><h2 id=\"9-1-标准注释\"><a href=\"#9-1-标准注释\" class=\"headerlink\" title=\"9.1 标准注释\"></a>9.1 标准注释</h2><p>语法：<code>&lt;!-- ... ---&gt;</code>，注释的代码块会在文件源代码中显示出来。</p>\n<h3 id=\"9-1-1-单行注释\"><a href=\"#9-1-1-单行注释\" class=\"headerlink\" title=\"9.1.1 单行注释\"></a>9.1.1 单行注释</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- &lt;span&gt;$&#123;message&#125;&lt;/span&gt; ---&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-1-2-多行注释\"><a href=\"#9-1-2-多行注释\" class=\"headerlink\" title=\"9.1.2 多行注释\"></a>9.1.2 多行注释</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;p th:case=&quot;admin&quot;&gt;管理员&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">    &lt;p th:case=&quot;user&quot;&gt;普通用户&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"comment\">---&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"9-2-解析器级注释\"><a href=\"#9-2-解析器级注释\" class=\"headerlink\" title=\"9.2 解析器级注释\"></a>9.2 解析器级注释</h2><p>语法：<code>&lt;!--/* ... */--&gt;</code>，注释的代码块会在引擎解析的时候抹去</p>\n<h3 id=\"9-2-1-单行注释\"><a href=\"#9-2-1-单行注释\" class=\"headerlink\" title=\"9.2.1 单行注释\"></a>9.2.1 单行注释</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--/* &lt;span&gt;$&#123;message&#125;&lt;/span&gt; */--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"9-2-2-多行注释\"><a href=\"#9-2-2-多行注释\" class=\"headerlink\" title=\"9.2.2 多行注释\"></a>9.2.2 多行注释</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--/*--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">th:switch</span>=<span class=\"string\">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:case</span>=<span class=\"string\">&quot;admin&quot;</span>&gt;</span>管理员<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:case</span>=<span class=\"string\">&quot;user&quot;</span>&gt;</span>普通用户<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--*/--&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"10-内联表达式\"><a href=\"#10-内联表达式\" class=\"headerlink\" title=\"10. 内联表达式\"></a>10. 内联表达式</h1><p>内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用<code>th:*</code>标签属性</p>\n<h2 id=\"10-1-…\"><a href=\"#10-1-…\" class=\"headerlink\" title=\"10.1 [[…]]\"></a>10.1 [[…]]</h2><p>[[]]相当于th:text，对含有HTML标签的内容自动进行字符转义</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The message is : [[$&#123;htmlContent&#125;]]<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-2-…\"><a href=\"#10-2-…\" class=\"headerlink\" title=\"10.2 [(…)]\"></a>10.2 [(…)]</h2><p>[()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>The message is : [($&#123;htmlContent&#125;)]<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"10-3-th-inline\"><a href=\"#10-3-th-inline\" class=\"headerlink\" title=\"10.3 th:inline\"></a>10.3 th:inline</h2><p>我们已经了解到，使用<code>[[]]</code>和<code>[()]</code>语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用<code>th:inline</code>属性来激活，它的取值如下：</p>\n<table>\n<thead>\n<tr>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>none</td>\n<td>禁止内联表达式，可以原样输出[[]]和[()]字符串</td>\n</tr>\n<tr>\n<td>text</td>\n<td>文本内联，可以使用th:each等高级语法</td>\n</tr>\n<tr>\n<td>css</td>\n<td>样式内联，如：<code>&lt;style th:inline=&quot;css&quot;&gt;</code></td>\n</tr>\n<tr>\n<td>javascript</td>\n<td>脚本内联，如：<code>&lt;style th:inline=&quot;javascript&quot;&gt;</code></td>\n</tr>\n</tbody></table>\n<h4 id=\"10-3-1-none\"><a href=\"#10-3-1-none\" class=\"headerlink\" title=\"10.3.1 none\"></a>10.3.1 none</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- [[1, 2], [3, 4]] --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:inline</span>=<span class=\"string\">&quot;none&quot;</span>&gt;</span>[[1, 2], [3, 4]]<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"10-3-2-text\"><a href=\"#10-3-2-text\" class=\"headerlink\" title=\"10.3.2 text\"></a>10.3.2 text</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- 北京 上海 广州 深圳 --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span> <span class=\"attr\">th:inline</span>=<span class=\"string\">&quot;text&quot;</span>&gt;</span></span><br><span class=\"line\">    [# th:each=&quot;city : $&#123;cities&#125;&quot;]</span><br><span class=\"line\">        [($&#123;city.name&#125;)]</span><br><span class=\"line\">    [/]</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"10-3-3-css\"><a href=\"#10-3-3-css\" class=\"headerlink\" title=\"10.3.3 css\"></a>10.3.3 css</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">th:inline</span>=<span class=\"string\">&quot;css&quot;</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-tag\">body</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">        <span class=\"attribute\">background-color</span>:[[$&#123;bgColor&#125;]];</span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"10-3-4-javascript\"><a href=\"#10-3-4-javascript\" class=\"headerlink\" title=\"10.3.4 javascript\"></a>10.3.4 javascript</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">th:inline</span>=<span class=\"string\">&quot;javascript&quot;</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"keyword\">var</span> user = [[$&#123;user&#125;]];</span></span><br><span class=\"line\"><span class=\"language-javascript\">    <span class=\"title function_\">alert</span>(<span class=\"string\">&quot;用户名：&quot;</span> + user.<span class=\"property\">name</span>);</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n"},{"title":"spring","date":"2023-07-21T16:00:00.000Z","abbrlink":9964,"_content":"# 1、前置内容\n## 1.1、EJB的问题\n它是一个重量级的框架，体现在：\n\n1. 运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源\n2. 代码移植性差\n## 1.2、什么是spring\nspring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式\n\n- 轻量级\n\n> 1. 对于运行环境没有额外要求（tomcat jetty weblogic等都可以）\n> 2. 代码一致性高（不需要实现额外接口）\n\n\n- javaEE解决方案\n\n> 包含了java web开发中 controller service dao层的解决方案\n\n\n- 整合设计模式\n\n> 工厂\n> 代理\n> 模板\n> 策略\n\n## 1.3、工厂设计模式\n### 1.3.1、什么是工厂设计模式\n```markdown\n1. 概念：通过工厂类创建对象\n2. 好处：解耦合\n   问题：不利于代码维护\n```\n### 1.3.2、通用工厂的设计（简单工厂+反射）\n```java\n// 工厂类\npublic class BeanFactory{\n    private static Properties env = new Properties();\n    static {\n        InputStream inputStream = BeanFactory.class.getResourceAsStream(\"/applicationContext.properties\");\n        try {\n            env.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static Object getBean(String key){\n        Object ret = null;\n        try{\n           Class clazz = Class.forName(env.getProperty(\"userBean\"));\n           ret = clazz.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return ret;\n    }\n}\n```\n# 2、spring IOC\n## 2.1、第一个spring程序\n### 2.1.1、核心API\n\n- ApplicationContext\n\n```markdown\n1. 作用：屏蔽实现的差异\n\n2. 好处：解耦合\n\n3. 接口类型：\n非web环境：ClassPathXmlApplicationContext\nweb环境：XmlWebApplicationContext（需要导入spring-webmvc）\n\n4. 重量级资源\napplicationContext工厂的对象占用大量内存\n不会频繁的创建，一个应用程序只会创建一个工厂对象\n所以applicationContext工厂一定是线程安全的\n```\n### 2.1.2、程序开发\n\n1. 引入依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.4.RELEASE</version>\n        </dependency>\n```\n\n2. 创建配置文件\n\nnew - xmlConfiguration File - spring config\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"person\" class=\"bean.Person\"/>\n</beans>\n```\n\n3. 通过工厂获取实例\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        Person person = (Person)ctx.getBean(\"person\");\n        System.out.println(person);\n    }\n}\n```\n\n### 2.1.3、思考\n\n1. 使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化\n\n2. 在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）\n\n\n## 2.2、spring与日志框架整合\nspring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息\n\n![日志框架](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png)\n\n\n- spring如何整合日志框架？\n\n> spring 1,2,3 早期都是jcl\nspring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2\n\n当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j\n1. pom\n\n```xml\n\t\t<!--日志门面-->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.7.25</version>\n        </dependency>\n        <!--log4j-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n```\n\n2. log4j.properties\n\n```properties\n### 配置根\nlog4j.rootLogger = debug, console\n\n### 配置输出到控制台\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern =  %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n```\n## 2.3、注入\n### 2.3.1、什么是注入？\n通过spring工厂及配置文件，为所创建对象的成员变量赋值\n\n### 2.3.2、为什么需要注入？\n之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合\n\n### 2.3.3、如何进行注入？\n#### 2.3.3.1、属性（field ）注入\n所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）\n\n```java\n@Autowired\nprivate Svc svc;\n```\n\n#### 2.3.3.2、setter注入\n通过对应变量的`setXXX()`方法以及在方法上面使用注解，来完成依赖注入。比如：\n```java\nprivate Helper helper;\n\n@Autowired\npublic void setHelper(Helper helper) {\n    this.helper = helper;\n}\n```\n#### 2.3.3.3、构造方法注入\n将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：\n```java\nprivate final Svc svc;\n\n@Autowired\npublic HelpService(@Qualifier(\"svcB\") Svc svc) {\n    this.svc = svc;\n}\n```\n\n## 2.4、spring对象的生命周期\n### 2.4.1、spring bean的生命周期\n\n![spring bean生命周期](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png)\n\n\n1. 实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。\n2. 属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中\n3. 回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。\n\n> Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。\n> 但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  \n\n1. 初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器\n2. 使用（In Use）：在初始化完成之后，Bean就可以被使用了。\n3. 销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用\n\n\n# 3、spring AOP\n\n## 3.1、spring动态代理\n### 3.1.1、spring动态代理概念\n\n1. 概念：通过代理类为目标类增加额外功能\n2. 好处：利于目标类的维护\n### 3.1.2、搭建开发环境\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>5.1.14.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjrt</artifactId>\n            <version>1.8.8</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.3</version>\n        </dependency>\n```\n### 3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\n\n1. 创建目标对象\n\n```java\npublic class UserServiceImpl implements UserService{\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n<bean id=\"userService\" class=\"service.UserServiceImpl\"></bean>\n```\n\n2. 额外功能\n\nMethodBeforeAdvice接口\n\n\n```java\npublic class Before implements MethodBeforeAdvice {\n    // 参数： 目标方法 目标方法参数 目标对象\n    public void before(Method method, Object[] objects, Object o) throws Throwable {\n        System.out.println(\"--method before advice log--\");\n    }\n}\n\n<bean id=\"before\" class=\"dynamic.Before\"></bean>\n```\n\n3. 定义切入点\n\n 切入点：额外功能加入的位置(方法)\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n    </aop:config>\n```\n\n4. 组装（2 3步整合）\n\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n        <!--组装：目的把切入点和额外功能进行整合-->\n        <aop:advisor advice-ref=\"before\" pointcut-ref=\"pc\"/>\n    </aop:config>\n```\n\n5. 测试\n\n```java\n    public static void main(String[] args) {\n        //目的：获得spring工厂创建的动态代理对象并进行调用\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        /**\n         * 1. spring的工厂通过原始对象的id值获得的是代理对象\n         * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储\n         */\n        UserService userService = (UserService)ctx.getBean(\"userService\");\n        userService.login();\n    }\n```\n### 3.1.4、思考\n\n1. spring创建的动态代理类在哪里？\n\n```java\nspring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失\n\n动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题\n\n```\n\n2. 动态字节码技术？\n\n```java\n通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失\n```\n### 3.1.5、额外功能详解\nMethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前\nMethodInterceptor 前，后，抛出异常 都可以运行\n所以我们实战中用到的更多的还是MethodInterceptor \n```java\npublic class Around  implements MethodInterceptor {\n    //methodInvocation : 额外功能所增加给的那个原始方法\n    public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n        System.out.println(\"--目标方法之前额外功能--\");\n        //原始方法执行\n        Object proceed = null;\n        try {\n            proceed = methodInvocation.proceed();\n        } catch (Throwable throwable){\n            System.out.println(\"--目标方法抛出异常额外功能--\");\n            throwable.printStackTrace();\n        }\n        System.out.println(\"--目标方法之后额外功能--\");\n        return proceed;\n    }\n}\n```\n> MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）\n\n### 3.1.6、切入点详解\n#### 3.1.6.1、切入点表达式\n\n\n```java\n<aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n\nexecution() ：切入点函数\n* *(..)：切入点表达式\n\n第一个* ：修饰符 返回值\n第二个* ：方法名(包+类+方法 or 直接方法)\n()：参数表 \n..：对于参数没有要求\n```\n\n- 定义login方法且login方法有两个字符串类型的参数作为切入点\n\n```java\n* login(String,String)\n```\n\n- 定义login方法且login方法有第一个参数必须为String作为切入点\n\n```java\n* login(String,..)\n```\n\n- kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）\n\n```java\n* com.kaka.UserServiceImpl.login(..)\n```\n\n- kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）\n\n```java\n* com.kaka..*.*()\n    \n    其中的..*代表当前包及其子包\n    如果是.*代表当前包\n```\n\n- 任意包下UserServiceImpl类作为切入点（类切入点表达式）\n\n```java\n* *..UserServiceImpl.*(..)\n  \n    其中的*..代表层级为1级或多级的包\n    如果是*.UserService 只能查找第一层级下的类\n```\n#### 3.1.6.2、切入点函数\n切入点函数：用于执行切入点表达式\n\n1. execution\n\n```java\n作用：最为重要的切入点函数，功能最全\n\t  执行方法切入点表达式 类切入点表达式 包切入点表达式\nexecution执行切入点表达式，书写麻烦\n注意：其他的切入点函数简化execution书写复杂度，功能上完全一致\n\n```\n\n2. args\n\n```java\n作用：主要用于函数（方法）参数的匹配\n方法参数必须是两个字符串类型的参数\n\nargs(String,String)\n等同于 execution(* *(String,String))\n```\n\n3. within\n\n```java\n作用：主要用于进行类，包切入点表达式的匹配\n\nwithin(*..UserServiceImpl)\n等同于execution(* *..UserServiceImpl.*(..))\n```\n\n4. @annotation\n\n```java\n作用：@annotation表示标注了某个注解的所有方法\n\n// 修饰的对象范围\n@Target(ElementType.METHOD)\n// 注解生命周期  SOURCE < CLASS < RUNTIME\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Log {\n}\n\npublic class UserServiceImpl implements UserService{\n    @Log\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n\n<aop:pointcut id=\"pc\" expression=\"@annotation(bean.Log)\"/>\n```\n#### 3.1.6.3、切入点函数的逻辑运算\n\n1. and与操作\n\n```java\n案例：login 同时 参数 两个字符串\n\nexecution(* login(..)) and args(String,String)\n等同于 execution(* login(String,String))    \n    \n注意：与操作不能用于同种类型的切入点函数\n```\n\n2. or或操作\n\n```java\n案例：register方法和login方法作为切入点\n\nexecution(* login(..)) or execution(* register(..))\n```\n## 3.2、AOP编程\n### 3.2.1、基本概念\n\n\n```java\n1. AOP：面向切面编程\n   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建\n\n2. OOP：面向对象编程\n   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建\n   \n3. POP：面向过程编程\n   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建\n \n```\n12.2、切面名词解释\n\n> 切面 = 切入点 + 额外功能\n\n多个额外功能相同的方法所代表的点连起来就是一个面\n\n![aop切面](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png)\n\n\n### 3.2.2、AOP底层实现原理\n#### 3.2.2.1、核心问题\n\n\n> 1. aop如何创建动态代理类（动态字节码技术）\n> 2. 如何实现通过原始对象的id值，获得的是代理对象\n\n\n### 3.2.3、动态代理类的创建\n#### 3.2.3.1、JDK动态代理\n\n- Proxy.newProxyInstancec：\n\n- 编码实现\n\n```java\npublic class TestJDKProxy {\n    /**\n     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以\n     2. JDK8.x 前必须加 final\n     final UserService userService = new UserServiceImpl();\n     */\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserServiceImpl();\n\n        // 2. JDK 动态代理\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(\"---- proxy log ----\");\n                // 原始方法运行\n                Object ret = method.invoke(userService, args);\n                return ret;\n            }\n        };\n        UserService userServiceProxy = (UserService) Proxy.\n                newProxyInstance(TestJDKProxy.class.getClassLoader(),\n                                userService.getClass().getInterfaces(),\n                                handler);\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n\n        userServiceProxy.register(new User());\n    }\n}\n```\n#### 3.2.3.2、CGLib动态代理\n\n- CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）\n\n> 在原始类没有实现接口的情况下cglib是一种很好的实现方式\n\n- cglib原理\n\n```java\npublic class TestCglib {\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserService();\n\n        /*\n         2. 通过 cglib 方式创建动态代理对象\n         对比 jdk 动态代理 ---> Proxy.newProxyInstance(classLoader, interface, invocationHandler);\n\n         Enhancer.setClassLoader()\n         Enhancer.setSuperClass()\n         Enhancer.setCallBack() ---> MethodInterceptor(cglib)\n         Enhancer.createProxy() ---> 创建代理对象\n         */\n        Enhancer enhancer = new Enhancer();\n\n        enhancer.setClassLoader(TestCglib.class.getClassLoader());\n        enhancer.setSuperclass(userService.getClass());\n\n        MethodInterceptor interceptor = new MethodInterceptor() {\n            @Override\n            public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n                System.out.println(\"--- cglib log ----\");\n                Object ret = method.invoke(userService, args); // 执行原始方法\n                return ret;\n            }\n        };\n\n        enhancer.setCallback(interceptor);\n        UserService userServiceProxy = (UserService) enhancer.create();\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n        userServiceProxy.register(new User());\n    }\n}\n```\n 总结：\n\n1. JDK 动态代理\nProxy.newProxyInstance：通过接口创建代理的实现类\n2. Cglib 动态代理\nEnhancer：通过继承父类创建的代理类\n\n### 3.2.4、基于注解的AOP编程\n#### 3.2.4.1、开发步骤\n\n1. 原始功能\n\n包含原始功能和实现类等\n\n2. 额外功能+切入点+组装切面\n\n```java\n/*\n    1. 额外功能\n        public class MyAround implements MethodInterceptor {\n            public Object invoke(MethodInvocation invocation) {\n                Object ret = invocation.invoke();\n                return ret;\n            }\n        }\n        <bean id=\"around\" class=\"com.yusael.dynamic.Around\"/>\n\n    2. 切入点\n        <aop:config>\n            <aop:pointcut id=\"pc\" expression=\"execution(* login(..)))\"/>\n            <aop:advisor advice-ref=\"around\" pointcut-ref=\"pc\"/>\n        </aop:config>\n */\n\n@Aspect\npublic class MyAspect {\n    @Around(\"execution(* login(..))\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n\n```\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <bean id=\"userService\" class=\"com.yusael.aspect.UserServiceImpl\"/>\n    <!--\n        切面:\n            1. 额外功能\n            2. 切入点\n            3. 组装切面\n    -->\n    <bean id=\"around\" class=\"com.yusael.aspect.MyAspect\"/>\n    <!--告知 Spring 基于注解进行 AOP 编程-->\n    <aop:aspectj-autoproxy/>\n\n</beans>\n\n```\n\n3. 切入点复用\n\n切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。\n\t通过这种方式定义切入点表达式，后续更加有利于切入点复用\n```java\n@Aspect\npublic class MyAspect {\n\n    @Pointcut(\"execution(* login(..))\")\n    public void myPoincut() {}\n\n    @Around(value = \"myPoincut()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n    @Around(value = \"myPoincut()\")\n    public Object around1(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect transaction ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n```\n#### 3.2.4.2、动态代理创建方式\n\nAOP 底层实现 2 种代理创建方式：\n\n1. JDK：通过 **实现接口，做新的实现类** 创建代理对象\n2. Cglib：通过 **继承父类，做新的子类** 创建代理对象\n\n**默认情况 AOP 编程 底层应用 JDK动态代理创建方式**\n```java\n<!-- 动态代理模式切换为cglib -->\n<aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n```\n\n# 4、spring 持久层\n## 4.1、spring与mybatis整合\n\n1. 引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-jdbc</artifactId>\n  <version>5.2.6.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis-spring</artifactId>\n  <version>2.0.4</version>\n</dependency>\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.1.12</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>5.1.43</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>3.5.4</version>\n</dependency>\n```\n\n2. spring配置文件\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <!--连接池-->\n        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n            <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n            <property name=\"url\" value=\"jdbc:mysql://localhost:3306/yus?useSSL=false\"/>\n            <property name=\"username\" value=\"root\"/>\n            <property name=\"password\" value=\"1234\"/>\n        </bean>\n\n        <!--创建SqlSessionFactory SqlSessionFactoryBean-->\n        <bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n            <property name=\"dataSource\" ref=\"dataSource\"/>\n            <property name=\"typeAliasesPackage\" value=\"com.yusael.entity\"/>\n            <property name=\"mapperLocations\">\n                <list>\n                    <value>classpath:com.yusael.dao/*Mapper.xml</value>\n                </list>\n            </property>\n        </bean>\n\n        <!--创建DAO对象 MapperScannerConfigure-->\n        <bean id=\"scanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n            <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactoryBean\"/>\n            <property name=\"basePackage\" value=\"com.yusael.dao\"/>\n        </bean>\n</beans>\n```\n\n3. 测试\n\n```java\n@Test\npublic void test() {\n    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n    UserDAO userDAO = (UserDAO) ctx.getBean(\"userDAO\");\n\n    User user = new User();\n    user.setName(\"xiaojr\");\n    user.setPassword(\"999999\");\n\n    userDAO.save(user);\n}\n```\n## 4.2、关于事务提交的疑问\n\n**问题**：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？\n\n> Mybatis 提供的连接池对象 —> 创建 Connection\n> Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。\n> Druid（C3P0、DBCP）作为连接池 —> 创建 Connection\n> Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。\n\n\n**答案**：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。\n\n**注意**：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题\n\n## 4.3、spring事务处理\n### 4.3.1、事务基本概念\n\n1. 什么是事务？\n\n事务时保证业务操作完整性的一种**数据库机制**\n\n2. 事务的四大特性？\n\nA 原子性\tC 一致性 I 隔离性\tD 持久性\n\n3. 如何控制事务？\n\n**JDBC：**\nConnection.setAutoCommit(false);\nConnection.commit();\nConnection.rollback();\n**Mybatis：**\nMybatis 自动开启事务\nsqlSession.commit();，底层还是调用的 Connection\nsqlSession.rollback();，底层还是调用的 Connection\n> 结论：控制事务的底层，都是通过 Connection 对象完成的\n\n### 4.3.2、spring控制事务的开发\nspring是通过aop的方式进行事务开发\n**增强功能：**原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法\n\n**切入点：**@Transactional （1）作用于类上（2）作用域方法。<\n\n**组装切面：**tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/> 自动扫描所有的@Transactional注解\n\n1. 搭建开发环境\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-tx</artifactId>\n\t<version>5.2.6.RELEASE</version>\n</dependency>\n```\n\n2. 编码\n\n```xml\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/>\n```\n进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib\n```xml\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\" proxy-target-class=\"true\"/>\n```\n### 4.3.3、事务的属性\n5个：隔离属性，传播属性，只读属性，超时属性，异常属性\n```markdown\n@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）\n```\n#### 4.3.3.1、隔离属性\n\n##### 4.3.3.1.1、并发问题&解决方案？\n**（1）脏读**：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象\n> eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了\n\n```java\n// 隔离级别：读已提交\n@Transaction(isolation=Isolation.READ_COMMITTED)\n```\n\n**（2）不可重复读**：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象\n> eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了\n> 注意：1.不是脏读 2.在一个事务中\n\n```java\n// 隔离级别：可重复读\n@Transaction(isolation=Isolation.REPEATABLE_READ)\n```\n> 本质：一把行锁（对数据库表的某一行加锁）\n\n\n\n**（3）幻读**：一个事务中，多次对**整表**进行**查询统计**，但是**结果不一样**，会在本事务中产生数据不一致的问题\n> 查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致\n\n```java\n// 隔离级别：序列化\n@Transaction(isolation=Isolation.SERIALIZABLE)\n```\n\n> 本质：表锁（对数据库某个表加锁）\n\n##### 4.3.3.1.2、安全与效率对比：\n\n- 并发安全：SERIALIZABLE > READ_ONLY > READ_COMMITTED\n- 运行效率：READ_COMMITTED > READ_ONLY > SERIALIZABLE\n\n##### 4.3.3.1.3、数据库默认隔离属性\nmysql：可重复读（REPEATABLE_READ）\nOracle：读已提交（READ_COMMITTED）\n\n#### 4.3.3.2、传播属性\n##### 4.3.3.2.1、基本概念\n传播属性：描述了事务解决 嵌套 问题 的特征\n**事务的嵌套**：指的是一个大的事务中，包含了若干个小的事务。\n**事务嵌套产生的问题**： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）\n\n##### 4.3.3.2.2、传播属性的值及用法\n| 传播属性的值 | 外部不存在事务 | 外部存在事务 | 用法 | 备注 |\n| --- | --- | --- | --- | --- |\n| REQUIRED | 开启新的事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.REQUIRED) | 增、删、改方法（保证了肯定会有事务的存在） |\n| REQUIRES_NEW | 开启新的事务 | 挂起外部事务，创建新的事务 | @Transactional(propagation = Propagation.REQUIRES_NEW) | 日志记录方法中（保证外部事务异常时能正常的记录日志） |\n| SUPPORTS | 不开启事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.SUPPORTS) | 查询方法 |\n| NOT_SUPPORTED | 不开启事务 | 挂起外部事务| @Transactional(propagation = Propagation.NOT_SUPPORTED) | 极其不常用 |\n| NEVER | 不开启事务 | 抛出异常 | @Transactional(propagation = Propagation.NEVER) | 极其不常用 |\n| MANDATORY（强制的） | 抛出异常 | 融合到外部事物中 | @Transactional(propagation = Propagation.MANDATORY) | 极其不常用 |\n\nSpring 中**传播属性的默认值**是：REQUIRED\n\n推荐传播属性的使用方式：\n\n- 增删改 方法：使用默认值 REQUIRED\n- 查询 方法：显示指定传播属性的值为 SUPPORTS\n\n\n#### 4.2.2.3、只读属性\n针对于 **只进行查询操作的业务方法**，可以加入只读属性，提高运行效率。\n默认值：false\n```java\n@Transactional(readOnly = true)\n```\n#### 4.2.2.4、超时属性\n指定了事务等待的最长时间。\n\n1. 为什么事务会进行等待？\n\n当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。\n\n2. 等待时间，单位是 秒\n3. 如何使用：@Transactional(timeout = 2)\n4. 超时属性的默认值：-1\n\n-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）\n\n#### 4.2.2.5、异常属性\nSpring 事务处理过程中：\n\n- 默认对于 RuntimeException 及其子类，采用 **回滚** 的策略。\n- 默认对于 对于其他类型的异常，采用 **提交** 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）\n\n```java\n@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)\n\n@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)\n```\n\n\n# 5、spring mvc\nspring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 \n\n## 5.1、父子容器关系\n1. Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）\n2. Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等\n3. Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）\n4. 调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止\n\n\n## 5.2、为什么要划分父子容器\n1. 分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）\n2. 性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能\n\n## 5.3、springBoot舍弃了父子容器的概念\n\nSpringBoot只有一个容器。\nSpring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署\n\n\n# 6、注解编程\n## 6.1、spring基础注解（spring2.X）\n### 6.1.1、对象创建相关\n#### 6.1.1.1、@Component\n\n1. 作用：替换原有Spring配置文件中的 <bean> 标签\n- id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO --> userDAO）\n- class 属性：通过反射获得的 class 的内容\n2. 细节：如何显式指定工厂创建对象的 id 值\n\n```java\n@Component(\"u\")\n```\n#### 6.1.1.2、@Repository、@Service、@Contoller\n@Repository、@Service、@Controller 都是 @Component 的 **衍生注解**。\n本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；\n它们的存在是为了：**更加准确的表达一个类型的作用**\n\n#### 6.1.1.3、@Scope\n作用：控制简单对象创建次数\n注意：不添加 @Scope，Spring 提供默认值 singleton\n```java\n// 创建单例对象\n@Component\n@Scope(\"singleton\")\npublic class Customer {}\n\n// 创建多例对象\n@Component\n@Scope(\"prototype\")\npublic class Customer {}\n```\n#### 6.1.1.4、@Lazy\n作用：延迟创建单实例对象\n注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象\n```java\n@Component\n@Lazy\npublic class Account {\n    public Account() {\n        System.out.println(\"Account.Account\");\n    }\n}\n```\n#### 6.1.1.5、@PostConstruct、@PreDestroy\n初始化相关方法： @PostConstruct\n```java\nInitializingBean\n<bean init-method=\"\"/>\n```\n销毁方法：@PreDestory\n```java\nDisposableBean\n<bean destory-method=\"\"/>\n```\n### 6.1.2、注入相关注解\n#### 6.1.2.1、@Autowired（用户自定义类型）\n\n1. @Autowired 注解 **基于类型进行注入** [推荐]：\n- 注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）\n\n```java\n@Autowired\nprivate UserDAO userDAO;\n```\n\n2. @Autowired、@Qualifier 注解联合实现 **基于名字进行注入** [了解]\n- 注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同\n\n```java\n@Autowired\n@Qualifier(\"userDAOImpl\")\nprivate UserDAO userDAO;\n```\n\n3. @Autowired 注解放置位置：\n- 放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）\n- **直接放置在成员变量上**，Spring 通过反射直接对成员变量进行赋值\n\n4. JSR提供的@Resource注解\n\n> JavaEE 规范中类似功能的注解：\n> - JSR250 提供的 @Resource(name=\"xxx\") **基于名字进行注入**\n等价于 @Autowired 与 @Qualifier 联合实现的效果\n注意：@Resource 注解如果名字没有配对成功，会继续 **按照类型进行注入**\n\n#### 6.1.2.2、@value、@PropertySource（JDK 类型）\n\n1. @value 注解的基本使用（xml配置）：\n\n```java\n1. 设置xxx.properties \n   id = 10\n   name = suns\n2. Spring的工厂读取这个配置文件 \n   <context:property-placeholder location=\"\"/>\n3. 代码中进行注入\n   属性 @Value(\"${key}\")\n\n```\n\n2. 使用 @PropertySource 取代 xml配置\n\n```java\n@Configuration\n@PropertySource(\"classpath:/init.properties\")\npublic class AppConfig1 {\n\n\t@Value(\"${id}\")\n\tprivate Integer id;\n\t@Value(\"${name}\")\n\tprivate String name;\n\t\n\t@Bean\n\tpublic Customer customer() {\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setId(id);\n\t\tcustomer.setName(name);\n\t\treturn customer;\n\t}\n}\n\n```\n\n3. @value 注解使用细节：\n- @Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null\n- @Value 注解 + Properties 这种方式，不能注入集合类型\nSpring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)\n## \n## 6.2、spring的高级注解（spring3.X及以上）\n### 6.2.1、@Configuration（配置bean）\n\n1. Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件\n2. 使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：\n\n```xml\n方法1: 指定配置bean的Class\nApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n\n方法2: 指定配置bean所在的路径(某个包及其子包)\nApplicationContext ctx = new AnnotationConfigApplicationContext(\"com.yusael\");\n```\n### 6.2.2、@Bean\n@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <bean 标签\n> **简单对象**：直接能够通过 new 方式创建的对象\n> - User、UserService、UserDAO\n> \n**复杂对象**：不能通过 new 的方式直接创建的对象\n> - Connection、SqlSessionFactory\n\n```java\n@Configuration\npublic class AppConfig{\n  // 简单对象\n\t@Bean\n  public Customer customer() {\n    Customer customer = new Customer();\n    return customer;\n  }\n\n  // 复杂对象\n  @Bean\n  public Connection conn1() {\n    Connection conn = null;\n    try {\n      ConnectionFactoryBean factoryBean = new ConnectionFactoryBean();\n      conn = factoryBean.getObject();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    return conn;\n  }\n}\n```\n### 6.2.3、@ComponentScan\n@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <context:component-scan> 标签\n目的：进行相关注解的扫描（@Component、@Value、@Autowired …)\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.yusael.scan\",\n               excludeFilters = {@ComponentScan.Filter(type= FilterType.ANNOTATION, value={Service.class}),\n                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = \"*..User1\")})\npublic class AppConfig2 {\n}\n```\n\n","source":"_posts/spring.md","raw":"---\ntitle: spring\ndate: 2023/07/22\ncategories:\n  - coding\ntags:\n  - spring\nabbrlink: 9964\n---\n# 1、前置内容\n## 1.1、EJB的问题\n它是一个重量级的框架，体现在：\n\n1. 运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源\n2. 代码移植性差\n## 1.2、什么是spring\nspring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式\n\n- 轻量级\n\n> 1. 对于运行环境没有额外要求（tomcat jetty weblogic等都可以）\n> 2. 代码一致性高（不需要实现额外接口）\n\n\n- javaEE解决方案\n\n> 包含了java web开发中 controller service dao层的解决方案\n\n\n- 整合设计模式\n\n> 工厂\n> 代理\n> 模板\n> 策略\n\n## 1.3、工厂设计模式\n### 1.3.1、什么是工厂设计模式\n```markdown\n1. 概念：通过工厂类创建对象\n2. 好处：解耦合\n   问题：不利于代码维护\n```\n### 1.3.2、通用工厂的设计（简单工厂+反射）\n```java\n// 工厂类\npublic class BeanFactory{\n    private static Properties env = new Properties();\n    static {\n        InputStream inputStream = BeanFactory.class.getResourceAsStream(\"/applicationContext.properties\");\n        try {\n            env.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    public static Object getBean(String key){\n        Object ret = null;\n        try{\n           Class clazz = Class.forName(env.getProperty(\"userBean\"));\n           ret = clazz.newInstance();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return ret;\n    }\n}\n```\n# 2、spring IOC\n## 2.1、第一个spring程序\n### 2.1.1、核心API\n\n- ApplicationContext\n\n```markdown\n1. 作用：屏蔽实现的差异\n\n2. 好处：解耦合\n\n3. 接口类型：\n非web环境：ClassPathXmlApplicationContext\nweb环境：XmlWebApplicationContext（需要导入spring-webmvc）\n\n4. 重量级资源\napplicationContext工厂的对象占用大量内存\n不会频繁的创建，一个应用程序只会创建一个工厂对象\n所以applicationContext工厂一定是线程安全的\n```\n### 2.1.2、程序开发\n\n1. 引入依赖\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.1.4.RELEASE</version>\n        </dependency>\n```\n\n2. 创建配置文件\n\nnew - xmlConfiguration File - spring config\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"person\" class=\"bean.Person\"/>\n</beans>\n```\n\n3. 通过工厂获取实例\n\n```java\npublic class Demo {\n    public static void main(String[] args) {\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        Person person = (Person)ctx.getBean(\"person\");\n        System.out.println(person);\n    }\n}\n```\n\n### 2.1.3、思考\n\n1. 使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化\n\n2. 在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）\n\n\n## 2.2、spring与日志框架整合\nspring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息\n\n![日志框架](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png)\n\n\n- spring如何整合日志框架？\n\n> spring 1,2,3 早期都是jcl\nspring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2\n\n当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j\n1. pom\n\n```xml\n\t\t<!--日志门面-->\n        <dependency>\n            <groupId>org.slf4j</groupId>\n            <artifactId>slf4j-log4j12</artifactId>\n            <version>1.7.25</version>\n        </dependency>\n        <!--log4j-->\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n```\n\n2. log4j.properties\n\n```properties\n### 配置根\nlog4j.rootLogger = debug, console\n\n### 配置输出到控制台\nlog4j.appender.console = org.apache.log4j.ConsoleAppender\nlog4j.appender.console.Target = System.out\nlog4j.appender.console.layout = org.apache.log4j.PatternLayout\nlog4j.appender.console.layout.ConversionPattern =  %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n\n```\n## 2.3、注入\n### 2.3.1、什么是注入？\n通过spring工厂及配置文件，为所创建对象的成员变量赋值\n\n### 2.3.2、为什么需要注入？\n之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合\n\n### 2.3.3、如何进行注入？\n#### 2.3.3.1、属性（field ）注入\n所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）\n\n```java\n@Autowired\nprivate Svc svc;\n```\n\n#### 2.3.3.2、setter注入\n通过对应变量的`setXXX()`方法以及在方法上面使用注解，来完成依赖注入。比如：\n```java\nprivate Helper helper;\n\n@Autowired\npublic void setHelper(Helper helper) {\n    this.helper = helper;\n}\n```\n#### 2.3.3.3、构造方法注入\n将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：\n```java\nprivate final Svc svc;\n\n@Autowired\npublic HelpService(@Qualifier(\"svcB\") Svc svc) {\n    this.svc = svc;\n}\n```\n\n## 2.4、spring对象的生命周期\n### 2.4.1、spring bean的生命周期\n\n![spring bean生命周期](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png)\n\n\n1. 实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。\n2. 属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中\n3. 回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。\n\n> Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。\n> 但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  \n\n1. 初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器\n2. 使用（In Use）：在初始化完成之后，Bean就可以被使用了。\n3. 销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用\n\n\n# 3、spring AOP\n\n## 3.1、spring动态代理\n### 3.1.1、spring动态代理概念\n\n1. 概念：通过代理类为目标类增加额外功能\n2. 好处：利于目标类的维护\n### 3.1.2、搭建开发环境\n\n```xml\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aop</artifactId>\n            <version>5.1.14.RELEASE</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjrt</artifactId>\n            <version>1.8.8</version>\n        </dependency>\n        <dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.8.3</version>\n        </dependency>\n```\n### 3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\n\n1. 创建目标对象\n\n```java\npublic class UserServiceImpl implements UserService{\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n<bean id=\"userService\" class=\"service.UserServiceImpl\"></bean>\n```\n\n2. 额外功能\n\nMethodBeforeAdvice接口\n\n\n```java\npublic class Before implements MethodBeforeAdvice {\n    // 参数： 目标方法 目标方法参数 目标对象\n    public void before(Method method, Object[] objects, Object o) throws Throwable {\n        System.out.println(\"--method before advice log--\");\n    }\n}\n\n<bean id=\"before\" class=\"dynamic.Before\"></bean>\n```\n\n3. 定义切入点\n\n 切入点：额外功能加入的位置(方法)\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n    </aop:config>\n```\n\n4. 组装（2 3步整合）\n\n```java\n    <aop:config>\n        <!--所有方法，都作为切入点，加入额外功能-->\n        <aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n        <!--组装：目的把切入点和额外功能进行整合-->\n        <aop:advisor advice-ref=\"before\" pointcut-ref=\"pc\"/>\n    </aop:config>\n```\n\n5. 测试\n\n```java\n    public static void main(String[] args) {\n        //目的：获得spring工厂创建的动态代理对象并进行调用\n        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n        /**\n         * 1. spring的工厂通过原始对象的id值获得的是代理对象\n         * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储\n         */\n        UserService userService = (UserService)ctx.getBean(\"userService\");\n        userService.login();\n    }\n```\n### 3.1.4、思考\n\n1. spring创建的动态代理类在哪里？\n\n```java\nspring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失\n\n动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题\n\n```\n\n2. 动态字节码技术？\n\n```java\n通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失\n```\n### 3.1.5、额外功能详解\nMethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前\nMethodInterceptor 前，后，抛出异常 都可以运行\n所以我们实战中用到的更多的还是MethodInterceptor \n```java\npublic class Around  implements MethodInterceptor {\n    //methodInvocation : 额外功能所增加给的那个原始方法\n    public Object invoke(MethodInvocation methodInvocation) throws Throwable {\n        System.out.println(\"--目标方法之前额外功能--\");\n        //原始方法执行\n        Object proceed = null;\n        try {\n            proceed = methodInvocation.proceed();\n        } catch (Throwable throwable){\n            System.out.println(\"--目标方法抛出异常额外功能--\");\n            throwable.printStackTrace();\n        }\n        System.out.println(\"--目标方法之后额外功能--\");\n        return proceed;\n    }\n}\n```\n> MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）\n\n### 3.1.6、切入点详解\n#### 3.1.6.1、切入点表达式\n\n\n```java\n<aop:pointcut id=\"pc\" expression=\"execution(* *(..))\"/>\n\nexecution() ：切入点函数\n* *(..)：切入点表达式\n\n第一个* ：修饰符 返回值\n第二个* ：方法名(包+类+方法 or 直接方法)\n()：参数表 \n..：对于参数没有要求\n```\n\n- 定义login方法且login方法有两个字符串类型的参数作为切入点\n\n```java\n* login(String,String)\n```\n\n- 定义login方法且login方法有第一个参数必须为String作为切入点\n\n```java\n* login(String,..)\n```\n\n- kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）\n\n```java\n* com.kaka.UserServiceImpl.login(..)\n```\n\n- kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）\n\n```java\n* com.kaka..*.*()\n    \n    其中的..*代表当前包及其子包\n    如果是.*代表当前包\n```\n\n- 任意包下UserServiceImpl类作为切入点（类切入点表达式）\n\n```java\n* *..UserServiceImpl.*(..)\n  \n    其中的*..代表层级为1级或多级的包\n    如果是*.UserService 只能查找第一层级下的类\n```\n#### 3.1.6.2、切入点函数\n切入点函数：用于执行切入点表达式\n\n1. execution\n\n```java\n作用：最为重要的切入点函数，功能最全\n\t  执行方法切入点表达式 类切入点表达式 包切入点表达式\nexecution执行切入点表达式，书写麻烦\n注意：其他的切入点函数简化execution书写复杂度，功能上完全一致\n\n```\n\n2. args\n\n```java\n作用：主要用于函数（方法）参数的匹配\n方法参数必须是两个字符串类型的参数\n\nargs(String,String)\n等同于 execution(* *(String,String))\n```\n\n3. within\n\n```java\n作用：主要用于进行类，包切入点表达式的匹配\n\nwithin(*..UserServiceImpl)\n等同于execution(* *..UserServiceImpl.*(..))\n```\n\n4. @annotation\n\n```java\n作用：@annotation表示标注了某个注解的所有方法\n\n// 修饰的对象范围\n@Target(ElementType.METHOD)\n// 注解生命周期  SOURCE < CLASS < RUNTIME\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Log {\n}\n\npublic class UserServiceImpl implements UserService{\n    @Log\n    public void login() {\n        System.out.println(\"user login...\");\n    }\n}\n\n\n<aop:pointcut id=\"pc\" expression=\"@annotation(bean.Log)\"/>\n```\n#### 3.1.6.3、切入点函数的逻辑运算\n\n1. and与操作\n\n```java\n案例：login 同时 参数 两个字符串\n\nexecution(* login(..)) and args(String,String)\n等同于 execution(* login(String,String))    \n    \n注意：与操作不能用于同种类型的切入点函数\n```\n\n2. or或操作\n\n```java\n案例：register方法和login方法作为切入点\n\nexecution(* login(..)) or execution(* register(..))\n```\n## 3.2、AOP编程\n### 3.2.1、基本概念\n\n\n```java\n1. AOP：面向切面编程\n   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建\n\n2. OOP：面向对象编程\n   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建\n   \n3. POP：面向过程编程\n   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建\n \n```\n12.2、切面名词解释\n\n> 切面 = 切入点 + 额外功能\n\n多个额外功能相同的方法所代表的点连起来就是一个面\n\n![aop切面](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png)\n\n\n### 3.2.2、AOP底层实现原理\n#### 3.2.2.1、核心问题\n\n\n> 1. aop如何创建动态代理类（动态字节码技术）\n> 2. 如何实现通过原始对象的id值，获得的是代理对象\n\n\n### 3.2.3、动态代理类的创建\n#### 3.2.3.1、JDK动态代理\n\n- Proxy.newProxyInstancec：\n\n- 编码实现\n\n```java\npublic class TestJDKProxy {\n    /**\n     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以\n     2. JDK8.x 前必须加 final\n     final UserService userService = new UserServiceImpl();\n     */\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserServiceImpl();\n\n        // 2. JDK 动态代理\n        InvocationHandler handler = new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(\"---- proxy log ----\");\n                // 原始方法运行\n                Object ret = method.invoke(userService, args);\n                return ret;\n            }\n        };\n        UserService userServiceProxy = (UserService) Proxy.\n                newProxyInstance(TestJDKProxy.class.getClassLoader(),\n                                userService.getClass().getInterfaces(),\n                                handler);\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n\n        userServiceProxy.register(new User());\n    }\n}\n```\n#### 3.2.3.2、CGLib动态代理\n\n- CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）\n\n> 在原始类没有实现接口的情况下cglib是一种很好的实现方式\n\n- cglib原理\n\n```java\npublic class TestCglib {\n    public static void main(String[] args) {\n        // 1. 创建原始对象\n        UserService userService = new UserService();\n\n        /*\n         2. 通过 cglib 方式创建动态代理对象\n         对比 jdk 动态代理 ---> Proxy.newProxyInstance(classLoader, interface, invocationHandler);\n\n         Enhancer.setClassLoader()\n         Enhancer.setSuperClass()\n         Enhancer.setCallBack() ---> MethodInterceptor(cglib)\n         Enhancer.createProxy() ---> 创建代理对象\n         */\n        Enhancer enhancer = new Enhancer();\n\n        enhancer.setClassLoader(TestCglib.class.getClassLoader());\n        enhancer.setSuperclass(userService.getClass());\n\n        MethodInterceptor interceptor = new MethodInterceptor() {\n            @Override\n            public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n                System.out.println(\"--- cglib log ----\");\n                Object ret = method.invoke(userService, args); // 执行原始方法\n                return ret;\n            }\n        };\n\n        enhancer.setCallback(interceptor);\n        UserService userServiceProxy = (UserService) enhancer.create();\n        userServiceProxy.login(\"zhenyu\", \"123456\");\n        userServiceProxy.register(new User());\n    }\n}\n```\n 总结：\n\n1. JDK 动态代理\nProxy.newProxyInstance：通过接口创建代理的实现类\n2. Cglib 动态代理\nEnhancer：通过继承父类创建的代理类\n\n### 3.2.4、基于注解的AOP编程\n#### 3.2.4.1、开发步骤\n\n1. 原始功能\n\n包含原始功能和实现类等\n\n2. 额外功能+切入点+组装切面\n\n```java\n/*\n    1. 额外功能\n        public class MyAround implements MethodInterceptor {\n            public Object invoke(MethodInvocation invocation) {\n                Object ret = invocation.invoke();\n                return ret;\n            }\n        }\n        <bean id=\"around\" class=\"com.yusael.dynamic.Around\"/>\n\n    2. 切入点\n        <aop:config>\n            <aop:pointcut id=\"pc\" expression=\"execution(* login(..)))\"/>\n            <aop:advisor advice-ref=\"around\" pointcut-ref=\"pc\"/>\n        </aop:config>\n */\n\n@Aspect\npublic class MyAspect {\n    @Around(\"execution(* login(..))\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n\n```\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n    <bean id=\"userService\" class=\"com.yusael.aspect.UserServiceImpl\"/>\n    <!--\n        切面:\n            1. 额外功能\n            2. 切入点\n            3. 组装切面\n    -->\n    <bean id=\"around\" class=\"com.yusael.aspect.MyAspect\"/>\n    <!--告知 Spring 基于注解进行 AOP 编程-->\n    <aop:aspectj-autoproxy/>\n\n</beans>\n\n```\n\n3. 切入点复用\n\n切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。\n\t通过这种方式定义切入点表达式，后续更加有利于切入点复用\n```java\n@Aspect\npublic class MyAspect {\n\n    @Pointcut(\"execution(* login(..))\")\n    public void myPoincut() {}\n\n    @Around(value = \"myPoincut()\")\n    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect log ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n    @Around(value = \"myPoincut()\")\n    public Object around1(ProceedingJoinPoint joinPoint) throws Throwable {\n        System.out.println(\"---- aspect transaction ----\");\n        Object ret = joinPoint.proceed();\n        return ret;\n    }\n}\n```\n#### 3.2.4.2、动态代理创建方式\n\nAOP 底层实现 2 种代理创建方式：\n\n1. JDK：通过 **实现接口，做新的实现类** 创建代理对象\n2. Cglib：通过 **继承父类，做新的子类** 创建代理对象\n\n**默认情况 AOP 编程 底层应用 JDK动态代理创建方式**\n```java\n<!-- 动态代理模式切换为cglib -->\n<aop:aspectj-autoproxy proxy-target-class=\"true\"/>\n```\n\n# 4、spring 持久层\n## 4.1、spring与mybatis整合\n\n1. 引入依赖\n\n```xml\n<dependency>\n  <groupId>org.springframework</groupId>\n  <artifactId>spring-jdbc</artifactId>\n  <version>5.2.6.RELEASE</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis-spring</artifactId>\n  <version>2.0.4</version>\n</dependency>\n\n<dependency>\n  <groupId>com.alibaba</groupId>\n  <artifactId>druid</artifactId>\n  <version>1.1.12</version>\n</dependency>\n\n<dependency>\n  <groupId>mysql</groupId>\n  <artifactId>mysql-connector-java</artifactId>\n  <version>5.1.43</version>\n</dependency>\n\n<dependency>\n  <groupId>org.mybatis</groupId>\n  <artifactId>mybatis</artifactId>\n  <version>3.5.4</version>\n</dependency>\n```\n\n2. spring配置文件\n\n```xml\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n        <!--连接池-->\n        <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n            <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n            <property name=\"url\" value=\"jdbc:mysql://localhost:3306/yus?useSSL=false\"/>\n            <property name=\"username\" value=\"root\"/>\n            <property name=\"password\" value=\"1234\"/>\n        </bean>\n\n        <!--创建SqlSessionFactory SqlSessionFactoryBean-->\n        <bean id=\"sqlSessionFactoryBean\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n            <property name=\"dataSource\" ref=\"dataSource\"/>\n            <property name=\"typeAliasesPackage\" value=\"com.yusael.entity\"/>\n            <property name=\"mapperLocations\">\n                <list>\n                    <value>classpath:com.yusael.dao/*Mapper.xml</value>\n                </list>\n            </property>\n        </bean>\n\n        <!--创建DAO对象 MapperScannerConfigure-->\n        <bean id=\"scanner\" class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n            <property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactoryBean\"/>\n            <property name=\"basePackage\" value=\"com.yusael.dao\"/>\n        </bean>\n</beans>\n```\n\n3. 测试\n\n```java\n@Test\npublic void test() {\n    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"/applicationContext.xml\");\n    UserDAO userDAO = (UserDAO) ctx.getBean(\"userDAO\");\n\n    User user = new User();\n    user.setName(\"xiaojr\");\n    user.setPassword(\"999999\");\n\n    userDAO.save(user);\n}\n```\n## 4.2、关于事务提交的疑问\n\n**问题**：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？\n\n> Mybatis 提供的连接池对象 —> 创建 Connection\n> Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。\n> Druid（C3P0、DBCP）作为连接池 —> 创建 Connection\n> Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。\n\n\n**答案**：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。\n\n**注意**：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题\n\n## 4.3、spring事务处理\n### 4.3.1、事务基本概念\n\n1. 什么是事务？\n\n事务时保证业务操作完整性的一种**数据库机制**\n\n2. 事务的四大特性？\n\nA 原子性\tC 一致性 I 隔离性\tD 持久性\n\n3. 如何控制事务？\n\n**JDBC：**\nConnection.setAutoCommit(false);\nConnection.commit();\nConnection.rollback();\n**Mybatis：**\nMybatis 自动开启事务\nsqlSession.commit();，底层还是调用的 Connection\nsqlSession.rollback();，底层还是调用的 Connection\n> 结论：控制事务的底层，都是通过 Connection 对象完成的\n\n### 4.3.2、spring控制事务的开发\nspring是通过aop的方式进行事务开发\n**增强功能：**原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法\n\n**切入点：**@Transactional （1）作用于类上（2）作用域方法。<\n\n**组装切面：**tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/> 自动扫描所有的@Transactional注解\n\n1. 搭建开发环境\n\n```xml\n<dependency>\n\t<groupId>org.springframework</groupId>\n\t<artifactId>spring-tx</artifactId>\n\t<version>5.2.6.RELEASE</version>\n</dependency>\n```\n\n2. 编码\n\n```xml\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<bean id=\"userService\" class=\"com.yusael.service.UserServiceImpl\">\n\t<property name=\"userDAO\" ref=\"userDAO\"/>\n</bean>\n\n<!--DataSourceTransactionManager-->\n<bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n\t<property name=\"dataSource\" ref=\"dataSource\"/>\n</bean>\n\n@Transactional\npublic class UserServiceImpl implements UserService {\n    private UserDAO userDAO;\n\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"/>\n```\n进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib\n```xml\n<tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\" proxy-target-class=\"true\"/>\n```\n### 4.3.3、事务的属性\n5个：隔离属性，传播属性，只读属性，超时属性，异常属性\n```markdown\n@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）\n```\n#### 4.3.3.1、隔离属性\n\n##### 4.3.3.1.1、并发问题&解决方案？\n**（1）脏读**：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象\n> eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了\n\n```java\n// 隔离级别：读已提交\n@Transaction(isolation=Isolation.READ_COMMITTED)\n```\n\n**（2）不可重复读**：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象\n> eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了\n> 注意：1.不是脏读 2.在一个事务中\n\n```java\n// 隔离级别：可重复读\n@Transaction(isolation=Isolation.REPEATABLE_READ)\n```\n> 本质：一把行锁（对数据库表的某一行加锁）\n\n\n\n**（3）幻读**：一个事务中，多次对**整表**进行**查询统计**，但是**结果不一样**，会在本事务中产生数据不一致的问题\n> 查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致\n\n```java\n// 隔离级别：序列化\n@Transaction(isolation=Isolation.SERIALIZABLE)\n```\n\n> 本质：表锁（对数据库某个表加锁）\n\n##### 4.3.3.1.2、安全与效率对比：\n\n- 并发安全：SERIALIZABLE > READ_ONLY > READ_COMMITTED\n- 运行效率：READ_COMMITTED > READ_ONLY > SERIALIZABLE\n\n##### 4.3.3.1.3、数据库默认隔离属性\nmysql：可重复读（REPEATABLE_READ）\nOracle：读已提交（READ_COMMITTED）\n\n#### 4.3.3.2、传播属性\n##### 4.3.3.2.1、基本概念\n传播属性：描述了事务解决 嵌套 问题 的特征\n**事务的嵌套**：指的是一个大的事务中，包含了若干个小的事务。\n**事务嵌套产生的问题**： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）\n\n##### 4.3.3.2.2、传播属性的值及用法\n| 传播属性的值 | 外部不存在事务 | 外部存在事务 | 用法 | 备注 |\n| --- | --- | --- | --- | --- |\n| REQUIRED | 开启新的事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.REQUIRED) | 增、删、改方法（保证了肯定会有事务的存在） |\n| REQUIRES_NEW | 开启新的事务 | 挂起外部事务，创建新的事务 | @Transactional(propagation = Propagation.REQUIRES_NEW) | 日志记录方法中（保证外部事务异常时能正常的记录日志） |\n| SUPPORTS | 不开启事务 | 融合到外部事务中 | @Transactional(propagation = Propagation.SUPPORTS) | 查询方法 |\n| NOT_SUPPORTED | 不开启事务 | 挂起外部事务| @Transactional(propagation = Propagation.NOT_SUPPORTED) | 极其不常用 |\n| NEVER | 不开启事务 | 抛出异常 | @Transactional(propagation = Propagation.NEVER) | 极其不常用 |\n| MANDATORY（强制的） | 抛出异常 | 融合到外部事物中 | @Transactional(propagation = Propagation.MANDATORY) | 极其不常用 |\n\nSpring 中**传播属性的默认值**是：REQUIRED\n\n推荐传播属性的使用方式：\n\n- 增删改 方法：使用默认值 REQUIRED\n- 查询 方法：显示指定传播属性的值为 SUPPORTS\n\n\n#### 4.2.2.3、只读属性\n针对于 **只进行查询操作的业务方法**，可以加入只读属性，提高运行效率。\n默认值：false\n```java\n@Transactional(readOnly = true)\n```\n#### 4.2.2.4、超时属性\n指定了事务等待的最长时间。\n\n1. 为什么事务会进行等待？\n\n当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。\n\n2. 等待时间，单位是 秒\n3. 如何使用：@Transactional(timeout = 2)\n4. 超时属性的默认值：-1\n\n-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）\n\n#### 4.2.2.5、异常属性\nSpring 事务处理过程中：\n\n- 默认对于 RuntimeException 及其子类，采用 **回滚** 的策略。\n- 默认对于 对于其他类型的异常，采用 **提交** 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）\n\n```java\n@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)\n\n@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)\n```\n\n\n# 5、spring mvc\nspring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 \n\n## 5.1、父子容器关系\n1. Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）\n2. Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等\n3. Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）\n4. 调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止\n\n\n## 5.2、为什么要划分父子容器\n1. 分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）\n2. 性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能\n\n## 5.3、springBoot舍弃了父子容器的概念\n\nSpringBoot只有一个容器。\nSpring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署\n\n\n# 6、注解编程\n## 6.1、spring基础注解（spring2.X）\n### 6.1.1、对象创建相关\n#### 6.1.1.1、@Component\n\n1. 作用：替换原有Spring配置文件中的 <bean> 标签\n- id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO --> userDAO）\n- class 属性：通过反射获得的 class 的内容\n2. 细节：如何显式指定工厂创建对象的 id 值\n\n```java\n@Component(\"u\")\n```\n#### 6.1.1.2、@Repository、@Service、@Contoller\n@Repository、@Service、@Controller 都是 @Component 的 **衍生注解**。\n本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；\n它们的存在是为了：**更加准确的表达一个类型的作用**\n\n#### 6.1.1.3、@Scope\n作用：控制简单对象创建次数\n注意：不添加 @Scope，Spring 提供默认值 singleton\n```java\n// 创建单例对象\n@Component\n@Scope(\"singleton\")\npublic class Customer {}\n\n// 创建多例对象\n@Component\n@Scope(\"prototype\")\npublic class Customer {}\n```\n#### 6.1.1.4、@Lazy\n作用：延迟创建单实例对象\n注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象\n```java\n@Component\n@Lazy\npublic class Account {\n    public Account() {\n        System.out.println(\"Account.Account\");\n    }\n}\n```\n#### 6.1.1.5、@PostConstruct、@PreDestroy\n初始化相关方法： @PostConstruct\n```java\nInitializingBean\n<bean init-method=\"\"/>\n```\n销毁方法：@PreDestory\n```java\nDisposableBean\n<bean destory-method=\"\"/>\n```\n### 6.1.2、注入相关注解\n#### 6.1.2.1、@Autowired（用户自定义类型）\n\n1. @Autowired 注解 **基于类型进行注入** [推荐]：\n- 注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）\n\n```java\n@Autowired\nprivate UserDAO userDAO;\n```\n\n2. @Autowired、@Qualifier 注解联合实现 **基于名字进行注入** [了解]\n- 注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同\n\n```java\n@Autowired\n@Qualifier(\"userDAOImpl\")\nprivate UserDAO userDAO;\n```\n\n3. @Autowired 注解放置位置：\n- 放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）\n- **直接放置在成员变量上**，Spring 通过反射直接对成员变量进行赋值\n\n4. JSR提供的@Resource注解\n\n> JavaEE 规范中类似功能的注解：\n> - JSR250 提供的 @Resource(name=\"xxx\") **基于名字进行注入**\n等价于 @Autowired 与 @Qualifier 联合实现的效果\n注意：@Resource 注解如果名字没有配对成功，会继续 **按照类型进行注入**\n\n#### 6.1.2.2、@value、@PropertySource（JDK 类型）\n\n1. @value 注解的基本使用（xml配置）：\n\n```java\n1. 设置xxx.properties \n   id = 10\n   name = suns\n2. Spring的工厂读取这个配置文件 \n   <context:property-placeholder location=\"\"/>\n3. 代码中进行注入\n   属性 @Value(\"${key}\")\n\n```\n\n2. 使用 @PropertySource 取代 xml配置\n\n```java\n@Configuration\n@PropertySource(\"classpath:/init.properties\")\npublic class AppConfig1 {\n\n\t@Value(\"${id}\")\n\tprivate Integer id;\n\t@Value(\"${name}\")\n\tprivate String name;\n\t\n\t@Bean\n\tpublic Customer customer() {\n\t\tCustomer customer = new Customer();\n\t\tcustomer.setId(id);\n\t\tcustomer.setName(name);\n\t\treturn customer;\n\t}\n}\n\n```\n\n3. @value 注解使用细节：\n- @Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null\n- @Value 注解 + Properties 这种方式，不能注入集合类型\nSpring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)\n## \n## 6.2、spring的高级注解（spring3.X及以上）\n### 6.2.1、@Configuration（配置bean）\n\n1. Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件\n2. 使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：\n\n```xml\n方法1: 指定配置bean的Class\nApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);\n\n方法2: 指定配置bean所在的路径(某个包及其子包)\nApplicationContext ctx = new AnnotationConfigApplicationContext(\"com.yusael\");\n```\n### 6.2.2、@Bean\n@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <bean 标签\n> **简单对象**：直接能够通过 new 方式创建的对象\n> - User、UserService、UserDAO\n> \n**复杂对象**：不能通过 new 的方式直接创建的对象\n> - Connection、SqlSessionFactory\n\n```java\n@Configuration\npublic class AppConfig{\n  // 简单对象\n\t@Bean\n  public Customer customer() {\n    Customer customer = new Customer();\n    return customer;\n  }\n\n  // 复杂对象\n  @Bean\n  public Connection conn1() {\n    Connection conn = null;\n    try {\n      ConnectionFactoryBean factoryBean = new ConnectionFactoryBean();\n      conn = factoryBean.getObject();\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n    return conn;\n  }\n}\n```\n### 6.2.3、@ComponentScan\n@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <context:component-scan> 标签\n目的：进行相关注解的扫描（@Component、@Value、@Autowired …)\n```java\n@Configuration\n@ComponentScan(basePackages = \"com.yusael.scan\",\n               excludeFilters = {@ComponentScan.Filter(type= FilterType.ANNOTATION, value={Service.class}),\n                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = \"*..User1\")})\npublic class AppConfig2 {\n}\n```\n\n","slug":"spring","published":1,"updated":"2023-07-25T13:19:14.801Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sra3002s00uj1d03fmfh","content":"<h1 id=\"1、前置内容\"><a href=\"#1、前置内容\" class=\"headerlink\" title=\"1、前置内容\"></a>1、前置内容</h1><h2 id=\"1-1、EJB的问题\"><a href=\"#1-1、EJB的问题\" class=\"headerlink\" title=\"1.1、EJB的问题\"></a>1.1、EJB的问题</h2><p>它是一个重量级的框架，体现在：</p>\n<ol>\n<li>运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源</li>\n<li>代码移植性差</li>\n</ol>\n<h2 id=\"1-2、什么是spring\"><a href=\"#1-2、什么是spring\" class=\"headerlink\" title=\"1.2、什么是spring\"></a>1.2、什么是spring</h2><p>spring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式</p>\n<ul>\n<li>轻量级</li>\n</ul>\n<blockquote>\n<ol>\n<li>对于运行环境没有额外要求（tomcat jetty weblogic等都可以）</li>\n<li>代码一致性高（不需要实现额外接口）</li>\n</ol>\n</blockquote>\n<ul>\n<li>javaEE解决方案</li>\n</ul>\n<blockquote>\n<p>包含了java web开发中 controller service dao层的解决方案</p>\n</blockquote>\n<ul>\n<li>整合设计模式</li>\n</ul>\n<blockquote>\n<p>工厂<br>代理<br>模板<br>策略</p>\n</blockquote>\n<h2 id=\"1-3、工厂设计模式\"><a href=\"#1-3、工厂设计模式\" class=\"headerlink\" title=\"1.3、工厂设计模式\"></a>1.3、工厂设计模式</h2><h3 id=\"1-3-1、什么是工厂设计模式\"><a href=\"#1-3-1、什么是工厂设计模式\" class=\"headerlink\" title=\"1.3.1、什么是工厂设计模式\"></a>1.3.1、什么是工厂设计模式</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 概念：通过工厂类创建对象</span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\">   问题：不利于代码维护</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-2、通用工厂的设计（简单工厂-反射）\"><a href=\"#1-3-2、通用工厂的设计（简单工厂-反射）\" class=\"headerlink\" title=\"1.3.2、通用工厂的设计（简单工厂+反射）\"></a>1.3.2、通用工厂的设计（简单工厂+反射）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Properties</span> <span class=\"variable\">env</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> BeanFactory.class.getResourceAsStream(<span class=\"string\">&quot;/applicationContext.properties&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            env.load(inputStream);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(env.getProperty(<span class=\"string\">&quot;userBean&quot;</span>));</span><br><span class=\"line\">           ret = clazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、spring-IOC\"><a href=\"#2、spring-IOC\" class=\"headerlink\" title=\"2、spring IOC\"></a>2、spring IOC</h1><h2 id=\"2-1、第一个spring程序\"><a href=\"#2-1、第一个spring程序\" class=\"headerlink\" title=\"2.1、第一个spring程序\"></a>2.1、第一个spring程序</h2><h3 id=\"2-1-1、核心API\"><a href=\"#2-1-1、核心API\" class=\"headerlink\" title=\"2.1.1、核心API\"></a>2.1.1、核心API</h3><ul>\n<li>ApplicationContext</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 作用：屏蔽实现的差异</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">3.</span> 接口类型：</span><br><span class=\"line\">非web环境：ClassPathXmlApplicationContext</span><br><span class=\"line\">web环境：XmlWebApplicationContext（需要导入spring-webmvc）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">4.</span> 重量级资源</span><br><span class=\"line\">applicationContext工厂的对象占用大量内存</span><br><span class=\"line\">不会频繁的创建，一个应用程序只会创建一个工厂对象</span><br><span class=\"line\">所以applicationContext工厂一定是线程安全的</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、程序开发\"><a href=\"#2-1-2、程序开发\" class=\"headerlink\" title=\"2.1.2、程序开发\"></a>2.1.2、程序开发</h3><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建配置文件</li>\n</ol>\n<p>new - xmlConfiguration File - spring config</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;person&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;bean.Person&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过工厂获取实例</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person)ctx.getBean(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">        System.out.println(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-3、思考\"><a href=\"#2-1-3、思考\" class=\"headerlink\" title=\"2.1.3、思考\"></a>2.1.3、思考</h3><ol>\n<li><p>使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化</p>\n</li>\n<li><p>在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）</p>\n</li>\n</ol>\n<h2 id=\"2-2、spring与日志框架整合\"><a href=\"#2-2、spring与日志框架整合\" class=\"headerlink\" title=\"2.2、spring与日志框架整合\"></a>2.2、spring与日志框架整合</h2><p>spring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png\" alt=\"日志框架\"></p>\n<ul>\n<li>spring如何整合日志框架？</li>\n</ul>\n<blockquote>\n<p>spring 1,2,3 早期都是jcl<br>spring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2</p>\n</blockquote>\n<p>当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j</p>\n<ol>\n<li>pom</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--日志门面--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.25<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--log4j--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.17<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>log4j.properties</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 配置根</span></span><br><span class=\"line\"><span class=\"attr\">log4j.rootLogger</span> = <span class=\"string\">debug, console</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### 配置输出到控制台</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console</span> = <span class=\"string\">org.apache.log4j.ConsoleAppender</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.Target</span> = <span class=\"string\">System.out</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout</span> = <span class=\"string\">org.apache.log4j.PatternLayout</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout.ConversionPattern</span> =  <span class=\"string\">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3、注入\"><a href=\"#2-3、注入\" class=\"headerlink\" title=\"2.3、注入\"></a>2.3、注入</h2><h3 id=\"2-3-1、什么是注入？\"><a href=\"#2-3-1、什么是注入？\" class=\"headerlink\" title=\"2.3.1、什么是注入？\"></a>2.3.1、什么是注入？</h3><p>通过spring工厂及配置文件，为所创建对象的成员变量赋值</p>\n<h3 id=\"2-3-2、为什么需要注入？\"><a href=\"#2-3-2、为什么需要注入？\" class=\"headerlink\" title=\"2.3.2、为什么需要注入？\"></a>2.3.2、为什么需要注入？</h3><p>之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合</p>\n<h3 id=\"2-3-3、如何进行注入？\"><a href=\"#2-3-3、如何进行注入？\" class=\"headerlink\" title=\"2.3.3、如何进行注入？\"></a>2.3.3、如何进行注入？</h3><h4 id=\"2-3-3-1、属性（field-）注入\"><a href=\"#2-3-3-1、属性（field-）注入\" class=\"headerlink\" title=\"2.3.3.1、属性（field ）注入\"></a>2.3.3.1、属性（field ）注入</h4><p>所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Svc svc;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-2、setter注入\"><a href=\"#2-3-3-2、setter注入\" class=\"headerlink\" title=\"2.3.3.2、setter注入\"></a>2.3.3.2、setter注入</h4><p>通过对应变量的<code>setXXX()</code>方法以及在方法上面使用注解，来完成依赖注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Helper helper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHelper</span><span class=\"params\">(Helper helper)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.helper = helper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-3-3、构造方法注入\"><a href=\"#2-3-3-3、构造方法注入\" class=\"headerlink\" title=\"2.3.3.3、构造方法注入\"></a>2.3.3.3、构造方法注入</h4><p>将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Svc svc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HelpService</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;svcB&quot;)</span> Svc svc)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.svc = svc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4、spring对象的生命周期\"><a href=\"#2-4、spring对象的生命周期\" class=\"headerlink\" title=\"2.4、spring对象的生命周期\"></a>2.4、spring对象的生命周期</h2><h3 id=\"2-4-1、spring-bean的生命周期\"><a href=\"#2-4-1、spring-bean的生命周期\" class=\"headerlink\" title=\"2.4.1、spring bean的生命周期\"></a>2.4.1、spring bean的生命周期</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png\" alt=\"spring bean生命周期\"></p>\n<ol>\n<li>实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。</li>\n<li>属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中</li>\n<li>回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。</li>\n</ol>\n<blockquote>\n<p>Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。<br>但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  </p>\n</blockquote>\n<ol>\n<li>初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器</li>\n<li>使用（In Use）：在初始化完成之后，Bean就可以被使用了。</li>\n<li>销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用</li>\n</ol>\n<h1 id=\"3、spring-AOP\"><a href=\"#3、spring-AOP\" class=\"headerlink\" title=\"3、spring AOP\"></a>3、spring AOP</h1><h2 id=\"3-1、spring动态代理\"><a href=\"#3-1、spring动态代理\" class=\"headerlink\" title=\"3.1、spring动态代理\"></a>3.1、spring动态代理</h2><h3 id=\"3-1-1、spring动态代理概念\"><a href=\"#3-1-1、spring动态代理概念\" class=\"headerlink\" title=\"3.1.1、spring动态代理概念\"></a>3.1.1、spring动态代理概念</h3><ol>\n<li>概念：通过代理类为目标类增加额外功能</li>\n<li>好处：利于目标类的维护</li>\n</ol>\n<h3 id=\"3-1-2、搭建开发环境\"><a href=\"#3-1-2、搭建开发环境\" class=\"headerlink\" title=\"3.1.2、搭建开发环境\"></a>3.1.2、搭建开发环境</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.14.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.8<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\"><a href=\"#3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\" class=\"headerlink\" title=\"3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\"></a>3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）</h3><ol>\n<li>创建目标对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;userService&quot;</span> class=<span class=\"string\">&quot;service.UserServiceImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>额外功能</li>\n</ol>\n<p>MethodBeforeAdvice接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Before</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodBeforeAdvice</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数： 目标方法 目标方法参数 目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(Method method, Object[] objects, Object o)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--method before advice log--&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;before&quot;</span> class=<span class=\"string\">&quot;dynamic.Before&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>定义切入点</li>\n</ol>\n<p> 切入点：额外功能加入的位置(方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>组装（2 3步整合）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">    &lt;!--组装：目的把切入点和额外功能进行整合--&gt;</span><br><span class=\"line\">    &lt;aop:advisor advice-ref=<span class=\"string\">&quot;before&quot;</span> pointcut-ref=<span class=\"string\">&quot;pc&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//目的：获得spring工厂创建的动态代理对象并进行调用</span></span><br><span class=\"line\">    <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. spring的工厂通过原始对象的id值获得的是代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> (UserService)ctx.getBean(<span class=\"string\">&quot;userService&quot;</span>);</span><br><span class=\"line\">    userService.login();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-4、思考\"><a href=\"#3-1-4、思考\" class=\"headerlink\" title=\"3.1.4、思考\"></a>3.1.4、思考</h3><ol>\n<li>spring创建的动态代理类在哪里？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失</span><br><span class=\"line\"></span><br><span class=\"line\">动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>动态字节码技术？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-5、额外功能详解\"><a href=\"#3-1-5、额外功能详解\" class=\"headerlink\" title=\"3.1.5、额外功能详解\"></a>3.1.5、额外功能详解</h3><p>MethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前<br>MethodInterceptor 前，后，抛出异常 都可以运行<br>所以我们实战中用到的更多的还是MethodInterceptor </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Around</span>  <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//methodInvocation : 额外功能所增加给的那个原始方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(MethodInvocation methodInvocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之前额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//原始方法执行</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">proceed</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            proceed = methodInvocation.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;--目标方法抛出异常额外功能--&quot;</span>);</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之后额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proceed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）</p>\n</blockquote>\n<h3 id=\"3-1-6、切入点详解\"><a href=\"#3-1-6、切入点详解\" class=\"headerlink\" title=\"3.1.6、切入点详解\"></a>3.1.6、切入点详解</h3><h4 id=\"3-1-6-1、切入点表达式\"><a href=\"#3-1-6-1、切入点表达式\" class=\"headerlink\" title=\"3.1.6.1、切入点表达式\"></a>3.1.6.1、切入点表达式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">execution() ：切入点函数</span><br><span class=\"line\">* *(..)：切入点表达式</span><br><span class=\"line\"></span><br><span class=\"line\">第一个* ：修饰符 返回值</span><br><span class=\"line\">第二个* ：方法名(包+类+方法 or 直接方法)</span><br><span class=\"line\">()：参数表 </span><br><span class=\"line\">..：对于参数没有要求</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有两个字符串类型的参数作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,String)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有第一个参数必须为String作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka.UserServiceImpl.login(..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka..*.*()</span><br><span class=\"line\">    </span><br><span class=\"line\">    其中的..*代表当前包及其子包</span><br><span class=\"line\">    如果是.*代表当前包</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任意包下UserServiceImpl类作为切入点（类切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* *..UserServiceImpl.*(..)</span><br><span class=\"line\">  </span><br><span class=\"line\">    其中的*..代表层级为<span class=\"number\">1</span>级或多级的包</span><br><span class=\"line\">    如果是*.UserService 只能查找第一层级下的类</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-2、切入点函数\"><a href=\"#3-1-6-2、切入点函数\" class=\"headerlink\" title=\"3.1.6.2、切入点函数\"></a>3.1.6.2、切入点函数</h4><p>切入点函数：用于执行切入点表达式</p>\n<ol>\n<li>execution</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：最为重要的切入点函数，功能最全</span><br><span class=\"line\">\t  执行方法切入点表达式 类切入点表达式 包切入点表达式</span><br><span class=\"line\">execution执行切入点表达式，书写麻烦</span><br><span class=\"line\">注意：其他的切入点函数简化execution书写复杂度，功能上完全一致</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>args</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于函数（方法）参数的匹配</span><br><span class=\"line\">方法参数必须是两个字符串类型的参数</span><br><span class=\"line\"></span><br><span class=\"line\">args(String,String)</span><br><span class=\"line\">等同于 execution(* *(String,String))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>within</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于进行类，包切入点表达式的匹配</span><br><span class=\"line\"></span><br><span class=\"line\">within(*..UserServiceImpl)</span><br><span class=\"line\">等同于execution(* *..UserServiceImpl.*(..))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>@annotation</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：<span class=\"meta\">@annotation</span>表示标注了某个注解的所有方法</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修饰的对象范围</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"comment\">// 注解生命周期  SOURCE &lt; CLASS &lt; RUNTIME</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Log &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Log</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;@annotation(bean.Log)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-3、切入点函数的逻辑运算\"><a href=\"#3-1-6-3、切入点函数的逻辑运算\" class=\"headerlink\" title=\"3.1.6.3、切入点函数的逻辑运算\"></a>3.1.6.3、切入点函数的逻辑运算</h4><ol>\n<li>and与操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：login 同时 参数 两个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) and <span class=\"title function_\">args</span><span class=\"params\">(String,String)</span></span><br><span class=\"line\">等同于 execution(* login(String,String))    </span><br><span class=\"line\">    </span><br><span class=\"line\">注意：与操作不能用于同种类型的切入点函数</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>or或操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：register方法和login方法作为切入点</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) or <span class=\"title function_\">execution</span><span class=\"params\">(* register(..)</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2、AOP编程\"><a href=\"#3-2、AOP编程\" class=\"headerlink\" title=\"3.2、AOP编程\"></a>3.2、AOP编程</h2><h3 id=\"3-2-1、基本概念\"><a href=\"#3-2-1、基本概念\" class=\"headerlink\" title=\"3.2.1、基本概念\"></a>3.2.1、基本概念</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> AOP：面向切面编程</span><br><span class=\"line\">   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> OOP：面向对象编程</span><br><span class=\"line\">   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"number\">3.</span> POP：面向过程编程</span><br><span class=\"line\">   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>12.2、切面名词解释</p>\n<blockquote>\n<p>切面 &#x3D; 切入点 + 额外功能</p>\n</blockquote>\n<p>多个额外功能相同的方法所代表的点连起来就是一个面</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png\" alt=\"aop切面\"></p>\n<h3 id=\"3-2-2、AOP底层实现原理\"><a href=\"#3-2-2、AOP底层实现原理\" class=\"headerlink\" title=\"3.2.2、AOP底层实现原理\"></a>3.2.2、AOP底层实现原理</h3><h4 id=\"3-2-2-1、核心问题\"><a href=\"#3-2-2-1、核心问题\" class=\"headerlink\" title=\"3.2.2.1、核心问题\"></a>3.2.2.1、核心问题</h4><blockquote>\n<ol>\n<li>aop如何创建动态代理类（动态字节码技术）</li>\n<li>如何实现通过原始对象的id值，获得的是代理对象</li>\n</ol>\n</blockquote>\n<h3 id=\"3-2-3、动态代理类的创建\"><a href=\"#3-2-3、动态代理类的创建\" class=\"headerlink\" title=\"3.2.3、动态代理类的创建\"></a>3.2.3、动态代理类的创建</h3><h4 id=\"3-2-3-1、JDK动态代理\"><a href=\"#3-2-3-1、JDK动态代理\" class=\"headerlink\" title=\"3.2.3.1、JDK动态代理\"></a>3.2.3.1、JDK动态代理</h4><ul>\n<li><p>Proxy.newProxyInstancec：</p>\n</li>\n<li><p>编码实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestJDKProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以</span></span><br><span class=\"line\"><span class=\"comment\">     2. JDK8.x 前必须加 final</span></span><br><span class=\"line\"><span class=\"comment\">     final UserService userService = new UserServiceImpl();</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. JDK 动态代理</span></span><br><span class=\"line\">        <span class=\"type\">InvocationHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;---- proxy log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 原始方法运行</span></span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) Proxy.</span><br><span class=\"line\">                newProxyInstance(TestJDKProxy.class.getClassLoader(),</span><br><span class=\"line\">                                userService.getClass().getInterfaces(),</span><br><span class=\"line\">                                handler);</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-2、CGLib动态代理\"><a href=\"#3-2-3-2、CGLib动态代理\" class=\"headerlink\" title=\"3.2.3.2、CGLib动态代理\"></a>3.2.3.2、CGLib动态代理</h4><ul>\n<li>CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）</li>\n</ul>\n<blockquote>\n<p>在原始类没有实现接口的情况下cglib是一种很好的实现方式</p>\n</blockquote>\n<ul>\n<li>cglib原理</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCglib</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         2. 通过 cglib 方式创建动态代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setClassLoader()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setSuperClass()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib)</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.createProxy() ---&gt; 创建代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setClassLoader(TestCglib.class.getClassLoader());</span><br><span class=\"line\">        enhancer.setSuperclass(userService.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">MethodInterceptor</span> <span class=\"variable\">interceptor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MethodInterceptor</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;--- cglib log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args); <span class=\"comment\">// 执行原始方法</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setCallback(interceptor);</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) enhancer.create();</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 总结：</p>\n<ol>\n<li>JDK 动态代理<br>Proxy.newProxyInstance：通过接口创建代理的实现类</li>\n<li>Cglib 动态代理<br>Enhancer：通过继承父类创建的代理类</li>\n</ol>\n<h3 id=\"3-2-4、基于注解的AOP编程\"><a href=\"#3-2-4、基于注解的AOP编程\" class=\"headerlink\" title=\"3.2.4、基于注解的AOP编程\"></a>3.2.4、基于注解的AOP编程</h3><h4 id=\"3-2-4-1、开发步骤\"><a href=\"#3-2-4-1、开发步骤\" class=\"headerlink\" title=\"3.2.4.1、开发步骤\"></a>3.2.4.1、开发步骤</h4><ol>\n<li>原始功能</li>\n</ol>\n<p>包含原始功能和实现类等</p>\n<ol start=\"2\">\n<li>额外功能+切入点+组装切面</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">        public class MyAround implements MethodInterceptor &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            public Object invoke(MethodInvocation invocation) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                Object ret = invocation.invoke();</span></span><br><span class=\"line\"><span class=\"comment\">                return ret;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;bean id=&quot;around&quot; class=&quot;com.yusael.dynamic.Around&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)))&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:advisor advice-ref=&quot;around&quot; pointcut-ref=&quot;pc&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;/aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        切面:</span></span><br><span class=\"line\"><span class=\"comment\">            1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">            2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">            3. 组装切面</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;around&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.MyAspect&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--告知 Spring 基于注解进行 AOP 编程--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>切入点复用</li>\n</ol>\n<p>切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。<br>    通过这种方式定义切入点表达式，后续更加有利于切入点复用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myPoincut</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around1</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect transaction ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-4-2、动态代理创建方式\"><a href=\"#3-2-4-2、动态代理创建方式\" class=\"headerlink\" title=\"3.2.4.2、动态代理创建方式\"></a>3.2.4.2、动态代理创建方式</h4><p>AOP 底层实现 2 种代理创建方式：</p>\n<ol>\n<li>JDK：通过 <strong>实现接口，做新的实现类</strong> 创建代理对象</li>\n<li>Cglib：通过 <strong>继承父类，做新的子类</strong> 创建代理对象</li>\n</ol>\n<p><strong>默认情况 AOP 编程 底层应用 JDK动态代理创建方式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 动态代理模式切换为cglib --&gt;</span><br><span class=\"line\">&lt;aop:aspectj-autoproxy proxy-target-class=<span class=\"string\">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、spring-持久层\"><a href=\"#4、spring-持久层\" class=\"headerlink\" title=\"4、spring 持久层\"></a>4、spring 持久层</h1><h2 id=\"4-1、spring与mybatis整合\"><a href=\"#4-1、spring与mybatis整合\" class=\"headerlink\" title=\"4.1、spring与mybatis整合\"></a>4.1、spring与mybatis整合</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>druid<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.43<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>spring配置文件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--连接池--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1234&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;typeAliasesPackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.entity&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapperLocations&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;scanner&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sqlSessionFactoryBeanName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;basePackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.dao&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">UserDAO</span> <span class=\"variable\">userDAO</span> <span class=\"operator\">=</span> (UserDAO) ctx.getBean(<span class=\"string\">&quot;userDAO&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">    user.setName(<span class=\"string\">&quot;xiaojr&quot;</span>);</span><br><span class=\"line\">    user.setPassword(<span class=\"string\">&quot;999999&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    userDAO.save(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2、关于事务提交的疑问\"><a href=\"#4-2、关于事务提交的疑问\" class=\"headerlink\" title=\"4.2、关于事务提交的疑问\"></a>4.2、关于事务提交的疑问</h2><p><strong>问题</strong>：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？</p>\n<blockquote>\n<p>Mybatis 提供的连接池对象 —&gt; 创建 Connection<br>Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。<br>Druid（C3P0、DBCP）作为连接池 —&gt; 创建 Connection<br>Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。</p>\n</blockquote>\n<p><strong>答案</strong>：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。</p>\n<p><strong>注意</strong>：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题</p>\n<h2 id=\"4-3、spring事务处理\"><a href=\"#4-3、spring事务处理\" class=\"headerlink\" title=\"4.3、spring事务处理\"></a>4.3、spring事务处理</h2><h3 id=\"4-3-1、事务基本概念\"><a href=\"#4-3-1、事务基本概念\" class=\"headerlink\" title=\"4.3.1、事务基本概念\"></a>4.3.1、事务基本概念</h3><ol>\n<li>什么是事务？</li>\n</ol>\n<p>事务时保证业务操作完整性的一种<strong>数据库机制</strong></p>\n<ol start=\"2\">\n<li>事务的四大特性？</li>\n</ol>\n<p>A 原子性\tC 一致性 I 隔离性\tD 持久性</p>\n<ol start=\"3\">\n<li>如何控制事务？</li>\n</ol>\n<p><strong>JDBC：</strong><br>Connection.setAutoCommit(false);<br>Connection.commit();<br>Connection.rollback();<br><strong>Mybatis：</strong><br>Mybatis 自动开启事务<br>sqlSession.commit();，底层还是调用的 Connection<br>sqlSession.rollback();，底层还是调用的 Connection</p>\n<blockquote>\n<p>结论：控制事务的底层，都是通过 Connection 对象完成的</p>\n</blockquote>\n<h3 id=\"4-3-2、spring控制事务的开发\"><a href=\"#4-3-2、spring控制事务的开发\" class=\"headerlink\" title=\"4.3.2、spring控制事务的开发\"></a>4.3.2、spring控制事务的开发</h3><p>spring是通过aop的方式进行事务开发<br><strong>增强功能：</strong>原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法</p>\n<p><strong>切入点：</strong>@Transactional （1）作用于类上（2）作用域方法。&lt;</p>\n<p><strong>组装切面：</strong>tx:annotation-driven transaction-manager&#x3D;”dataSourceTransactionManager”&#x2F;&gt; 自动扫描所有的@Transactional注解</p>\n<ol>\n<li>搭建开发环境</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-tx<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-3、事务的属性\"><a href=\"#4-3-3、事务的属性\" class=\"headerlink\" title=\"4.3.3、事务的属性\"></a>4.3.3、事务的属性</h3><p>5个：隔离属性，传播属性，只读属性，超时属性，异常属性</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-3-1、隔离属性\"><a href=\"#4-3-3-1、隔离属性\" class=\"headerlink\" title=\"4.3.3.1、隔离属性\"></a>4.3.3.1、隔离属性</h4><h5 id=\"4-3-3-1-1、并发问题-解决方案？\"><a href=\"#4-3-3-1-1、并发问题-解决方案？\" class=\"headerlink\" title=\"4.3.3.1.1、并发问题&amp;解决方案？\"></a>4.3.3.1.1、并发问题&amp;解决方案？</h5><p><strong>（1）脏读</strong>：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：读已提交</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）不可重复读</strong>：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了<br>注意：1.不是脏读 2.在一个事务中</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：可重复读</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.REPEATABLE_READ)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>本质：一把行锁（对数据库表的某一行加锁）</p>\n</blockquote>\n<p><strong>（3）幻读</strong>：一个事务中，多次对<strong>整表</strong>进行<strong>查询统计</strong>，但是<strong>结果不一样</strong>，会在本事务中产生数据不一致的问题</p>\n<blockquote>\n<p>查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：序列化</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.SERIALIZABLE)</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本质：表锁（对数据库某个表加锁）</p>\n</blockquote>\n<h5 id=\"4-3-3-1-2、安全与效率对比：\"><a href=\"#4-3-3-1-2、安全与效率对比：\" class=\"headerlink\" title=\"4.3.3.1.2、安全与效率对比：\"></a>4.3.3.1.2、安全与效率对比：</h5><ul>\n<li>并发安全：SERIALIZABLE &gt; READ_ONLY &gt; READ_COMMITTED</li>\n<li>运行效率：READ_COMMITTED &gt; READ_ONLY &gt; SERIALIZABLE</li>\n</ul>\n<h5 id=\"4-3-3-1-3、数据库默认隔离属性\"><a href=\"#4-3-3-1-3、数据库默认隔离属性\" class=\"headerlink\" title=\"4.3.3.1.3、数据库默认隔离属性\"></a>4.3.3.1.3、数据库默认隔离属性</h5><p>mysql：可重复读（REPEATABLE_READ）<br>Oracle：读已提交（READ_COMMITTED）</p>\n<h4 id=\"4-3-3-2、传播属性\"><a href=\"#4-3-3-2、传播属性\" class=\"headerlink\" title=\"4.3.3.2、传播属性\"></a>4.3.3.2、传播属性</h4><h5 id=\"4-3-3-2-1、基本概念\"><a href=\"#4-3-3-2-1、基本概念\" class=\"headerlink\" title=\"4.3.3.2.1、基本概念\"></a>4.3.3.2.1、基本概念</h5><p>传播属性：描述了事务解决 嵌套 问题 的特征<br><strong>事务的嵌套</strong>：指的是一个大的事务中，包含了若干个小的事务。<br><strong>事务嵌套产生的问题</strong>： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）</p>\n<h5 id=\"4-3-3-2-2、传播属性的值及用法\"><a href=\"#4-3-3-2-2、传播属性的值及用法\" class=\"headerlink\" title=\"4.3.3.2.2、传播属性的值及用法\"></a>4.3.3.2.2、传播属性的值及用法</h5><table>\n<thead>\n<tr>\n<th>传播属性的值</th>\n<th>外部不存在事务</th>\n<th>外部存在事务</th>\n<th>用法</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>REQUIRED</td>\n<td>开启新的事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRED)</td>\n<td>增、删、改方法（保证了肯定会有事务的存在）</td>\n</tr>\n<tr>\n<td>REQUIRES_NEW</td>\n<td>开启新的事务</td>\n<td>挂起外部事务，创建新的事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</td>\n<td>日志记录方法中（保证外部事务异常时能正常的记录日志）</td>\n</tr>\n<tr>\n<td>SUPPORTS</td>\n<td>不开启事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.SUPPORTS)</td>\n<td>查询方法</td>\n</tr>\n<tr>\n<td>NOT_SUPPORTED</td>\n<td>不开启事务</td>\n<td>挂起外部事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>NEVER</td>\n<td>不开启事务</td>\n<td>抛出异常</td>\n<td>@Transactional(propagation &#x3D; Propagation.NEVER)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>MANDATORY（强制的）</td>\n<td>抛出异常</td>\n<td>融合到外部事物中</td>\n<td>@Transactional(propagation &#x3D; Propagation.MANDATORY)</td>\n<td>极其不常用</td>\n</tr>\n</tbody></table>\n<p>Spring 中<strong>传播属性的默认值</strong>是：REQUIRED</p>\n<p>推荐传播属性的使用方式：</p>\n<ul>\n<li>增删改 方法：使用默认值 REQUIRED</li>\n<li>查询 方法：显示指定传播属性的值为 SUPPORTS</li>\n</ul>\n<h4 id=\"4-2-2-3、只读属性\"><a href=\"#4-2-2-3、只读属性\" class=\"headerlink\" title=\"4.2.2.3、只读属性\"></a>4.2.2.3、只读属性</h4><p>针对于 <strong>只进行查询操作的业务方法</strong>，可以加入只读属性，提高运行效率。<br>默认值：false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-2-4、超时属性\"><a href=\"#4-2-2-4、超时属性\" class=\"headerlink\" title=\"4.2.2.4、超时属性\"></a>4.2.2.4、超时属性</h4><p>指定了事务等待的最长时间。</p>\n<ol>\n<li>为什么事务会进行等待？</li>\n</ol>\n<p>当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。</p>\n<ol start=\"2\">\n<li>等待时间，单位是 秒</li>\n<li>如何使用：@Transactional(timeout &#x3D; 2)</li>\n<li>超时属性的默认值：-1</li>\n</ol>\n<p>-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）</p>\n<h4 id=\"4-2-2-5、异常属性\"><a href=\"#4-2-2-5、异常属性\" class=\"headerlink\" title=\"4.2.2.5、异常属性\"></a>4.2.2.5、异常属性</h4><p>Spring 事务处理过程中：</p>\n<ul>\n<li>默认对于 RuntimeException 及其子类，采用 <strong>回滚</strong> 的策略。</li>\n<li>默认对于 对于其他类型的异常，采用 <strong>提交</strong> 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"5、spring-mvc\"><a href=\"#5、spring-mvc\" class=\"headerlink\" title=\"5、spring mvc\"></a>5、spring mvc</h1><p>spring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 </p>\n<h2 id=\"5-1、父子容器关系\"><a href=\"#5-1、父子容器关系\" class=\"headerlink\" title=\"5.1、父子容器关系\"></a>5.1、父子容器关系</h2><ol>\n<li>Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）</li>\n<li>Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等</li>\n<li>Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）</li>\n<li>调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止</li>\n</ol>\n<h2 id=\"5-2、为什么要划分父子容器\"><a href=\"#5-2、为什么要划分父子容器\" class=\"headerlink\" title=\"5.2、为什么要划分父子容器\"></a>5.2、为什么要划分父子容器</h2><ol>\n<li>分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）</li>\n<li>性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能</li>\n</ol>\n<h2 id=\"5-3、springBoot舍弃了父子容器的概念\"><a href=\"#5-3、springBoot舍弃了父子容器的概念\" class=\"headerlink\" title=\"5.3、springBoot舍弃了父子容器的概念\"></a>5.3、springBoot舍弃了父子容器的概念</h2><p>SpringBoot只有一个容器。<br>Spring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署</p>\n<h1 id=\"6、注解编程\"><a href=\"#6、注解编程\" class=\"headerlink\" title=\"6、注解编程\"></a>6、注解编程</h1><h2 id=\"6-1、spring基础注解（spring2-X）\"><a href=\"#6-1、spring基础注解（spring2-X）\" class=\"headerlink\" title=\"6.1、spring基础注解（spring2.X）\"></a>6.1、spring基础注解（spring2.X）</h2><h3 id=\"6-1-1、对象创建相关\"><a href=\"#6-1-1、对象创建相关\" class=\"headerlink\" title=\"6.1.1、对象创建相关\"></a>6.1.1、对象创建相关</h3><h4 id=\"6-1-1-1、-Component\"><a href=\"#6-1-1-1、-Component\" class=\"headerlink\" title=\"6.1.1.1、@Component\"></a>6.1.1.1、@Component</h4><ol>\n<li>作用：替换原有Spring配置文件中的 <bean> 标签</li>\n</ol>\n<ul>\n<li>id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO –&gt; userDAO）</li>\n<li>class 属性：通过反射获得的 class 的内容</li>\n</ul>\n<ol start=\"2\">\n<li>细节：如何显式指定工厂创建对象的 id 值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;u&quot;)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-2、-Repository、-Service、-Contoller\"><a href=\"#6-1-1-2、-Repository、-Service、-Contoller\" class=\"headerlink\" title=\"6.1.1.2、@Repository、@Service、@Contoller\"></a>6.1.1.2、@Repository、@Service、@Contoller</h4><p>@Repository、@Service、@Controller 都是 @Component 的 <strong>衍生注解</strong>。<br>本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；<br>它们的存在是为了：<strong>更加准确的表达一个类型的作用</strong></p>\n<h4 id=\"6-1-1-3、-Scope\"><a href=\"#6-1-1-3、-Scope\" class=\"headerlink\" title=\"6.1.1.3、@Scope\"></a>6.1.1.3、@Scope</h4><p>作用：控制简单对象创建次数<br>注意：不添加 @Scope，Spring 提供默认值 singleton</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建单例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;singleton&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建多例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-4、-Lazy\"><a href=\"#6-1-1-4、-Lazy\" class=\"headerlink\" title=\"6.1.1.4、@Lazy\"></a>6.1.1.4、@Lazy</h4><p>作用：延迟创建单实例对象<br>注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Account</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Account</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Account.Account&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-5、-PostConstruct、-PreDestroy\"><a href=\"#6-1-1-5、-PostConstruct、-PreDestroy\" class=\"headerlink\" title=\"6.1.1.5、@PostConstruct、@PreDestroy\"></a>6.1.1.5、@PostConstruct、@PreDestroy</h4><p>初始化相关方法： @PostConstruct</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InitializingBean</span><br><span class=\"line\">&lt;bean init-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>销毁方法：@PreDestory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableBean</span><br><span class=\"line\">&lt;bean destory-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-1-2、注入相关注解\"><a href=\"#6-1-2、注入相关注解\" class=\"headerlink\" title=\"6.1.2、注入相关注解\"></a>6.1.2、注入相关注解</h3><h4 id=\"6-1-2-1、-Autowired（用户自定义类型）\"><a href=\"#6-1-2-1、-Autowired（用户自定义类型）\" class=\"headerlink\" title=\"6.1.2.1、@Autowired（用户自定义类型）\"></a>6.1.2.1、@Autowired（用户自定义类型）</h4><ol>\n<li>@Autowired 注解 <strong>基于类型进行注入</strong> [推荐]：</li>\n</ol>\n<ul>\n<li>注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>@Autowired、@Qualifier 注解联合实现 <strong>基于名字进行注入</strong> [了解]</li>\n</ol>\n<ul>\n<li>注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;userDAOImpl&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@Autowired 注解放置位置：</li>\n</ol>\n<ul>\n<li>放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）</li>\n<li><strong>直接放置在成员变量上</strong>，Spring 通过反射直接对成员变量进行赋值</li>\n</ul>\n<ol start=\"4\">\n<li>JSR提供的@Resource注解</li>\n</ol>\n<blockquote>\n<p>JavaEE 规范中类似功能的注解：</p>\n<ul>\n<li>JSR250 提供的 @Resource(name&#x3D;”xxx”) <strong>基于名字进行注入</strong><br>等价于 @Autowired 与 @Qualifier 联合实现的效果<br>注意：@Resource 注解如果名字没有配对成功，会继续 <strong>按照类型进行注入</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"6-1-2-2、-value、-PropertySource（JDK-类型）\"><a href=\"#6-1-2-2、-value、-PropertySource（JDK-类型）\" class=\"headerlink\" title=\"6.1.2.2、@value、@PropertySource（JDK 类型）\"></a>6.1.2.2、@value、@PropertySource（JDK 类型）</h4><ol>\n<li>@value 注解的基本使用（xml配置）：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 设置xxx.<span class=\"type\">properties</span> </span><br><span class=\"line\">   <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">   name = suns</span><br><span class=\"line\"><span class=\"number\">2.</span> Spring的工厂读取这个配置文件 </span><br><span class=\"line\">   &lt;context:property-placeholder location=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br><span class=\"line\"><span class=\"number\">3.</span> 代码中进行注入</span><br><span class=\"line\">   属性 <span class=\"meta\">@Value(&quot;$&#123;key&#125;&quot;)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 @PropertySource 取代 xml配置</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource(&quot;classpath:/init.properties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;id&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">\t\tcustomer.setId(id);</span><br><span class=\"line\">\t\tcustomer.setName(name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@value 注解使用细节：</li>\n</ol>\n<ul>\n<li>@Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null</li>\n<li>@Value 注解 + Properties 这种方式，不能注入集合类型<br>Spring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"6-2、spring的高级注解（spring3-X及以上）\"><a href=\"#6-2、spring的高级注解（spring3-X及以上）\" class=\"headerlink\" title=\"6.2、spring的高级注解（spring3.X及以上）\"></a>6.2、spring的高级注解（spring3.X及以上）</h2><h3 id=\"6-2-1、-Configuration（配置bean）\"><a href=\"#6-2-1、-Configuration（配置bean）\" class=\"headerlink\" title=\"6.2.1、@Configuration（配置bean）\"></a>6.2.1、@Configuration（配置bean）</h3><ol>\n<li>Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件</li>\n<li>使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法1: 指定配置bean的Class</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\">方法2: 指定配置bean所在的路径(某个包及其子包)</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.yusael&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2、-Bean\"><a href=\"#6-2-2、-Bean\" class=\"headerlink\" title=\"6.2.2、@Bean\"></a>6.2.2、@Bean</h3><p>@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 &lt;bean 标签</p>\n<blockquote>\n<p><strong>简单对象</strong>：直接能够通过 new 方式创建的对象</p>\n<ul>\n<li>User、UserService、UserDAO</li>\n</ul>\n</blockquote>\n<p><strong>复杂对象</strong>：不能通过 new 的方式直接创建的对象</p>\n<blockquote>\n<ul>\n<li>Connection、SqlSessionFactory</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 简单对象</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 复杂对象</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Connection <span class=\"title function_\">conn1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ConnectionFactoryBean</span> <span class=\"variable\">factoryBean</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactoryBean</span>();</span><br><span class=\"line\">      conn = factoryBean.getObject();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-3、-ComponentScan\"><a href=\"#6-2-3、-ComponentScan\" class=\"headerlink\" title=\"6.2.3、@ComponentScan\"></a>6.2.3、@ComponentScan</h3><p>@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <a href=\"context:component-scan\">context:component-scan</a> 标签<br>目的：进行相关注解的扫描（@Component、@Value、@Autowired …)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">               excludeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION, value=&#123;Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = &quot;*..User1&quot;)&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig2</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、前置内容\"><a href=\"#1、前置内容\" class=\"headerlink\" title=\"1、前置内容\"></a>1、前置内容</h1><h2 id=\"1-1、EJB的问题\"><a href=\"#1-1、EJB的问题\" class=\"headerlink\" title=\"1.1、EJB的问题\"></a>1.1、EJB的问题</h2><p>它是一个重量级的框架，体现在：</p>\n<ol>\n<li>运行环境苛刻：需要运行在EJB容器（weblogic  websphere），需要收费，并且容器代码闭源</li>\n<li>代码移植性差</li>\n</ol>\n<h2 id=\"1-2、什么是spring\"><a href=\"#1-2、什么是spring\" class=\"headerlink\" title=\"1.2、什么是spring\"></a>1.2、什么是spring</h2><p>spring是一个轻量级的javaEE解决方案，整合了众多优秀的设计模式</p>\n<ul>\n<li>轻量级</li>\n</ul>\n<blockquote>\n<ol>\n<li>对于运行环境没有额外要求（tomcat jetty weblogic等都可以）</li>\n<li>代码一致性高（不需要实现额外接口）</li>\n</ol>\n</blockquote>\n<ul>\n<li>javaEE解决方案</li>\n</ul>\n<blockquote>\n<p>包含了java web开发中 controller service dao层的解决方案</p>\n</blockquote>\n<ul>\n<li>整合设计模式</li>\n</ul>\n<blockquote>\n<p>工厂<br>代理<br>模板<br>策略</p>\n</blockquote>\n<h2 id=\"1-3、工厂设计模式\"><a href=\"#1-3、工厂设计模式\" class=\"headerlink\" title=\"1.3、工厂设计模式\"></a>1.3、工厂设计模式</h2><h3 id=\"1-3-1、什么是工厂设计模式\"><a href=\"#1-3-1、什么是工厂设计模式\" class=\"headerlink\" title=\"1.3.1、什么是工厂设计模式\"></a>1.3.1、什么是工厂设计模式</h3><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 概念：通过工厂类创建对象</span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\">   问题：不利于代码维护</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-3-2、通用工厂的设计（简单工厂-反射）\"><a href=\"#1-3-2、通用工厂的设计（简单工厂-反射）\" class=\"headerlink\" title=\"1.3.2、通用工厂的设计（简单工厂+反射）\"></a>1.3.2、通用工厂的设计（简单工厂+反射）</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 工厂类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">BeanFactory</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"type\">Properties</span> <span class=\"variable\">env</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Properties</span>();</span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">InputStream</span> <span class=\"variable\">inputStream</span> <span class=\"operator\">=</span> BeanFactory.class.getResourceAsStream(<span class=\"string\">&quot;/applicationContext.properties&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            env.load(inputStream);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Object <span class=\"title function_\">getBean</span><span class=\"params\">(String key)</span>&#123;</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span>&#123;</span><br><span class=\"line\">           <span class=\"type\">Class</span> <span class=\"variable\">clazz</span> <span class=\"operator\">=</span> Class.forName(env.getProperty(<span class=\"string\">&quot;userBean&quot;</span>));</span><br><span class=\"line\">           ret = clazz.newInstance();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"2、spring-IOC\"><a href=\"#2、spring-IOC\" class=\"headerlink\" title=\"2、spring IOC\"></a>2、spring IOC</h1><h2 id=\"2-1、第一个spring程序\"><a href=\"#2-1、第一个spring程序\" class=\"headerlink\" title=\"2.1、第一个spring程序\"></a>2.1、第一个spring程序</h2><h3 id=\"2-1-1、核心API\"><a href=\"#2-1-1、核心API\" class=\"headerlink\" title=\"2.1.1、核心API\"></a>2.1.1、核心API</h3><ul>\n<li>ApplicationContext</li>\n</ul>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">1.</span> 作用：屏蔽实现的差异</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">2.</span> 好处：解耦合</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">3.</span> 接口类型：</span><br><span class=\"line\">非web环境：ClassPathXmlApplicationContext</span><br><span class=\"line\">web环境：XmlWebApplicationContext（需要导入spring-webmvc）</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">4.</span> 重量级资源</span><br><span class=\"line\">applicationContext工厂的对象占用大量内存</span><br><span class=\"line\">不会频繁的创建，一个应用程序只会创建一个工厂对象</span><br><span class=\"line\">所以applicationContext工厂一定是线程安全的</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-1-2、程序开发\"><a href=\"#2-1-2、程序开发\" class=\"headerlink\" title=\"2.1.2、程序开发\"></a>2.1.2、程序开发</h3><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-context<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.4.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>创建配置文件</li>\n</ol>\n<p>new - xmlConfiguration File - spring config</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=<span class=\"string\">&quot;1.0&quot;</span> encoding=<span class=\"string\">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;person&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;bean.Person&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>通过工厂获取实例</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Demo</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Person</span> <span class=\"variable\">person</span> <span class=\"operator\">=</span> (Person)ctx.getBean(<span class=\"string\">&quot;person&quot;</span>);</span><br><span class=\"line\">        System.out.println(person);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-1-3、思考\"><a href=\"#2-1-3、思考\" class=\"headerlink\" title=\"2.1.3、思考\"></a>2.1.3、思考</h3><ol>\n<li><p>使用Spring工厂创建对象时，Spring会利用反射机制来实例化对象，并且会调用对象的构造方法来完成对象的初始化</p>\n</li>\n<li><p>在开发中，并不是所有的对象都会交给Spring工厂来创建。通常来说，我们会将那些需要频繁创建和管理的对象交给Spring容器来管理和创建，而对于那些只需要创建一次或者创建次数很少的对象，我们可以直接使用new关键字来实例化对象。并且实体对象是不会交给spring创建的，它是由持久层框架进行创建（当我们调用 MyBatis 的查询方法时，MyBatis 会根据 SQL 语句和结果集映射关系来查询数据库，并将查询结果映射到实体对象中。在这个过程中，MyBatis 会利用 Java 的反射机制来动态创建实体对象，并调用实体对象的 setter 方法来设置属性的值）</p>\n</li>\n</ol>\n<h2 id=\"2-2、spring与日志框架整合\"><a href=\"#2-2、spring与日志框架整合\" class=\"headerlink\" title=\"2.2、spring与日志框架整合\"></a>2.2、spring与日志框架整合</h2><p>spring与日志框架整合，日志框架就可以在控制台中，输出spring框架运行过程中的一些重要信息</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230929873.png\" alt=\"日志框架\"></p>\n<ul>\n<li>spring如何整合日志框架？</li>\n</ul>\n<blockquote>\n<p>spring 1,2,3 早期都是jcl<br>spring4.x开始使用slf4j，默认整合的日志框架logback 或 log4j2</p>\n</blockquote>\n<p>当然spring5中我们也可以不采用默认，而去整合我们熟悉的log4j</p>\n<ol>\n<li>pom</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!--日志门面--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.slf4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>slf4j-log4j12<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.7.25<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!--log4j--&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>log4j<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.2.17<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>log4j.properties</li>\n</ol>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">### 配置根</span></span><br><span class=\"line\"><span class=\"attr\">log4j.rootLogger</span> = <span class=\"string\">debug, console</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">### 配置输出到控制台</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console</span> = <span class=\"string\">org.apache.log4j.ConsoleAppender</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.Target</span> = <span class=\"string\">System.out</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout</span> = <span class=\"string\">org.apache.log4j.PatternLayout</span></span><br><span class=\"line\"><span class=\"attr\">log4j.appender.console.layout.ConversionPattern</span> =  <span class=\"string\">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %-5p %c&#123;1&#125;:%L - %m%n</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-3、注入\"><a href=\"#2-3、注入\" class=\"headerlink\" title=\"2.3、注入\"></a>2.3、注入</h2><h3 id=\"2-3-1、什么是注入？\"><a href=\"#2-3-1、什么是注入？\" class=\"headerlink\" title=\"2.3.1、什么是注入？\"></a>2.3.1、什么是注入？</h3><p>通过spring工厂及配置文件，为所创建对象的成员变量赋值</p>\n<h3 id=\"2-3-2、为什么需要注入？\"><a href=\"#2-3-2、为什么需要注入？\" class=\"headerlink\" title=\"2.3.2、为什么需要注入？\"></a>2.3.2、为什么需要注入？</h3><p>之前我们为成员变量赋值是通过set方法，但这种方式会产生耦合</p>\n<h3 id=\"2-3-3、如何进行注入？\"><a href=\"#2-3-3、如何进行注入？\" class=\"headerlink\" title=\"2.3.3、如何进行注入？\"></a>2.3.3、如何进行注入？</h3><h4 id=\"2-3-3-1、属性（field-）注入\"><a href=\"#2-3-3-1、属性（field-）注入\" class=\"headerlink\" title=\"2.3.3.1、属性（field ）注入\"></a>2.3.3.1、属性（field ）注入</h4><p>所谓基于 field 注入，就是在bean的变量上使用注解进行依赖注入。本质上是通过反射的方式直接注入到field。这是我平常开发中看的最多也是最熟悉的一种方式，同时，也正是 Spring 团队所不推荐的方式（容易违背了单一职责原则：使用这种基于 field 注入的方式，添加依赖是很简单的，就算你的类中有十几个依赖你可能都觉得没有什么问题，普通的开发者很可能会无意识地给一个类添加很多的依赖）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Svc svc;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-2、setter注入\"><a href=\"#2-3-3-2、setter注入\" class=\"headerlink\" title=\"2.3.3.2、setter注入\"></a>2.3.3.2、setter注入</h4><p>通过对应变量的<code>setXXX()</code>方法以及在方法上面使用注解，来完成依赖注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Helper helper;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">setHelper</span><span class=\"params\">(Helper helper)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.helper = helper;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-3-3-3、构造方法注入\"><a href=\"#2-3-3-3、构造方法注入\" class=\"headerlink\" title=\"2.3.3.3、构造方法注入\"></a>2.3.3.3、构造方法注入</h4><p>将各个必需的依赖全部放在带有注解构造方法的参数中，并在构造方法中完成对应变量的初始化，这种方式，就是基于构造方法的注入。比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Svc svc;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"title function_\">HelpService</span><span class=\"params\">(<span class=\"meta\">@Qualifier(&quot;svcB&quot;)</span> Svc svc)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.svc = svc;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-4、spring对象的生命周期\"><a href=\"#2-4、spring对象的生命周期\" class=\"headerlink\" title=\"2.4、spring对象的生命周期\"></a>2.4、spring对象的生命周期</h2><h3 id=\"2-4-1、spring-bean的生命周期\"><a href=\"#2-4-1、spring-bean的生命周期\" class=\"headerlink\" title=\"2.4.1、spring bean的生命周期\"></a>2.4.1、spring bean的生命周期</h3><p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png\" alt=\"spring bean生命周期\"></p>\n<ol>\n<li>实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。</li>\n<li>属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中</li>\n<li>回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。</li>\n</ol>\n<blockquote>\n<p>Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。<br>但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  </p>\n</blockquote>\n<ol>\n<li>初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器</li>\n<li>使用（In Use）：在初始化完成之后，Bean就可以被使用了。</li>\n<li>销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用</li>\n</ol>\n<h1 id=\"3、spring-AOP\"><a href=\"#3、spring-AOP\" class=\"headerlink\" title=\"3、spring AOP\"></a>3、spring AOP</h1><h2 id=\"3-1、spring动态代理\"><a href=\"#3-1、spring动态代理\" class=\"headerlink\" title=\"3.1、spring动态代理\"></a>3.1、spring动态代理</h2><h3 id=\"3-1-1、spring动态代理概念\"><a href=\"#3-1-1、spring动态代理概念\" class=\"headerlink\" title=\"3.1.1、spring动态代理概念\"></a>3.1.1、spring动态代理概念</h3><ol>\n<li>概念：通过代理类为目标类增加额外功能</li>\n<li>好处：利于目标类的维护</li>\n</ol>\n<h3 id=\"3-1-2、搭建开发环境\"><a href=\"#3-1-2、搭建开发环境\" class=\"headerlink\" title=\"3.1.2、搭建开发环境\"></a>3.1.2、搭建开发环境</h3><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-aop<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.14.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjrt<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.8<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.aspectj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>aspectjweaver<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.8.3<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\"><a href=\"#3-1-3、spring动态代理开发步骤（MethodBeforeAdvice）\" class=\"headerlink\" title=\"3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）\"></a>3.1.3、spring动态代理开发步骤（MethodBeforeAdvice）</h3><ol>\n<li>创建目标对象</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;userService&quot;</span> class=<span class=\"string\">&quot;service.UserServiceImpl&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>额外功能</li>\n</ol>\n<p>MethodBeforeAdvice接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Before</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodBeforeAdvice</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数： 目标方法 目标方法参数 目标对象</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">before</span><span class=\"params\">(Method method, Object[] objects, Object o)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--method before advice log--&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;bean id=<span class=\"string\">&quot;before&quot;</span> class=<span class=\"string\">&quot;dynamic.Before&quot;</span>&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>定义切入点</li>\n</ol>\n<p> 切入点：额外功能加入的位置(方法)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>组装（2 3步整合）</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:config&gt;</span><br><span class=\"line\">    &lt;!--所有方法，都作为切入点，加入额外功能--&gt;</span><br><span class=\"line\">    &lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\">    &lt;!--组装：目的把切入点和额外功能进行整合--&gt;</span><br><span class=\"line\">    &lt;aop:advisor advice-ref=<span class=\"string\">&quot;before&quot;</span> pointcut-ref=<span class=\"string\">&quot;pc&quot;</span>/&gt;</span><br><span class=\"line\">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//目的：获得spring工厂创建的动态代理对象并进行调用</span></span><br><span class=\"line\">    <span class=\"type\">ClassPathXmlApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 1. spring的工厂通过原始对象的id值获得的是代理对象</span></span><br><span class=\"line\"><span class=\"comment\">     * 2. 获得代理对象后，可以通过声明接口类型，进行对象的存储</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> (UserService)ctx.getBean(<span class=\"string\">&quot;userService&quot;</span>);</span><br><span class=\"line\">    userService.login();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-4、思考\"><a href=\"#3-1-4、思考\" class=\"headerlink\" title=\"3.1.4、思考\"></a>3.1.4、思考</h3><ol>\n<li>spring创建的动态代理类在哪里？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">spring框架在运行时，通过动态字节码技术，在JVM创建的，运行在JVM内部，等程序结束后，会和JVM一起消失</span><br><span class=\"line\"></span><br><span class=\"line\">动态代理不需要定义类文件，都是JVM运行过程中动态创建的，所以不会造成静态代理类文件数量过多影响项目管理的问题</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>动态字节码技术？</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">通过第三方动态字节码框架（ASM, Javassist, cglib）直接在JVM生成字节码，进而创建对象，当虚拟机结束，动态字节码跟着消失</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-1-5、额外功能详解\"><a href=\"#3-1-5、额外功能详解\" class=\"headerlink\" title=\"3.1.5、额外功能详解\"></a>3.1.5、额外功能详解</h3><p>MethodBeforeAdvice接口实现的的方法只能运行在目标方法执行之前<br>MethodInterceptor 前，后，抛出异常 都可以运行<br>所以我们实战中用到的更多的还是MethodInterceptor </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Around</span>  <span class=\"keyword\">implements</span> <span class=\"title class_\">MethodInterceptor</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//methodInvocation : 额外功能所增加给的那个原始方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(MethodInvocation methodInvocation)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之前额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"comment\">//原始方法执行</span></span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">proceed</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            proceed = methodInvocation.proceed();</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable throwable)&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">&quot;--目标方法抛出异常额外功能--&quot;</span>);</span><br><span class=\"line\">            throwable.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;--目标方法之后额外功能--&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> proceed;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>MethodInterceptor可以影响原始方法的返回值（invoke方法不返回原始方法返回值）</p>\n</blockquote>\n<h3 id=\"3-1-6、切入点详解\"><a href=\"#3-1-6、切入点详解\" class=\"headerlink\" title=\"3.1.6、切入点详解\"></a>3.1.6、切入点详解</h3><h4 id=\"3-1-6-1、切入点表达式\"><a href=\"#3-1-6-1、切入点表达式\" class=\"headerlink\" title=\"3.1.6.1、切入点表达式\"></a>3.1.6.1、切入点表达式</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;execution(* *(..))&quot;</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">execution() ：切入点函数</span><br><span class=\"line\">* *(..)：切入点表达式</span><br><span class=\"line\"></span><br><span class=\"line\">第一个* ：修饰符 返回值</span><br><span class=\"line\">第二个* ：方法名(包+类+方法 or 直接方法)</span><br><span class=\"line\">()：参数表 </span><br><span class=\"line\">..：对于参数没有要求</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有两个字符串类型的参数作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,String)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义login方法且login方法有第一个参数必须为String作为切入点</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* login(String,..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包下UserServiceImpl类的login方法作为切入点（方法切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka.UserServiceImpl.login(..)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>kaka包及其子包下的所有类的方法作为切入点（包切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* com.kaka..*.*()</span><br><span class=\"line\">    </span><br><span class=\"line\">    其中的..*代表当前包及其子包</span><br><span class=\"line\">    如果是.*代表当前包</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>任意包下UserServiceImpl类作为切入点（类切入点表达式）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* *..UserServiceImpl.*(..)</span><br><span class=\"line\">  </span><br><span class=\"line\">    其中的*..代表层级为<span class=\"number\">1</span>级或多级的包</span><br><span class=\"line\">    如果是*.UserService 只能查找第一层级下的类</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-2、切入点函数\"><a href=\"#3-1-6-2、切入点函数\" class=\"headerlink\" title=\"3.1.6.2、切入点函数\"></a>3.1.6.2、切入点函数</h4><p>切入点函数：用于执行切入点表达式</p>\n<ol>\n<li>execution</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：最为重要的切入点函数，功能最全</span><br><span class=\"line\">\t  执行方法切入点表达式 类切入点表达式 包切入点表达式</span><br><span class=\"line\">execution执行切入点表达式，书写麻烦</span><br><span class=\"line\">注意：其他的切入点函数简化execution书写复杂度，功能上完全一致</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>args</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于函数（方法）参数的匹配</span><br><span class=\"line\">方法参数必须是两个字符串类型的参数</span><br><span class=\"line\"></span><br><span class=\"line\">args(String,String)</span><br><span class=\"line\">等同于 execution(* *(String,String))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>within</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：主要用于进行类，包切入点表达式的匹配</span><br><span class=\"line\"></span><br><span class=\"line\">within(*..UserServiceImpl)</span><br><span class=\"line\">等同于execution(* *..UserServiceImpl.*(..))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>@annotation</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">作用：<span class=\"meta\">@annotation</span>表示标注了某个注解的所有方法</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修饰的对象范围</span></span><br><span class=\"line\"><span class=\"meta\">@Target(ElementType.METHOD)</span></span><br><span class=\"line\"><span class=\"comment\">// 注解生命周期  SOURCE &lt; CLASS &lt; RUNTIME</span></span><br><span class=\"line\"><span class=\"meta\">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"meta\">@interface</span> Log &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title class_\">UserService</span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Log</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">login</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;user login...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;aop:pointcut id=<span class=\"string\">&quot;pc&quot;</span> expression=<span class=\"string\">&quot;@annotation(bean.Log)&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-1-6-3、切入点函数的逻辑运算\"><a href=\"#3-1-6-3、切入点函数的逻辑运算\" class=\"headerlink\" title=\"3.1.6.3、切入点函数的逻辑运算\"></a>3.1.6.3、切入点函数的逻辑运算</h4><ol>\n<li>and与操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：login 同时 参数 两个字符串</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) and <span class=\"title function_\">args</span><span class=\"params\">(String,String)</span></span><br><span class=\"line\">等同于 execution(* login(String,String))    </span><br><span class=\"line\">    </span><br><span class=\"line\">注意：与操作不能用于同种类型的切入点函数</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>or或操作</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">案例：register方法和login方法作为切入点</span><br><span class=\"line\"></span><br><span class=\"line\">execution(* login(..)) or <span class=\"title function_\">execution</span><span class=\"params\">(* register(..)</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"3-2、AOP编程\"><a href=\"#3-2、AOP编程\" class=\"headerlink\" title=\"3.2、AOP编程\"></a>3.2、AOP编程</h2><h3 id=\"3-2-1、基本概念\"><a href=\"#3-2-1、基本概念\" class=\"headerlink\" title=\"3.2.1、基本概念\"></a>3.2.1、基本概念</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> AOP：面向切面编程</span><br><span class=\"line\">   以切面为基本单位的程序开发，通过切面间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> OOP：面向对象编程</span><br><span class=\"line\">   以对象为基本单位的程序开发，通过对象间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"number\">3.</span> POP：面向过程编程</span><br><span class=\"line\">   以过程为基本单位的程序开发，通过过程间彼此协同，相互调用，完成程序构建</span><br><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n<p>12.2、切面名词解释</p>\n<blockquote>\n<p>切面 &#x3D; 切入点 + 额外功能</p>\n</blockquote>\n<p>多个额外功能相同的方法所代表的点连起来就是一个面</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230928946.png\" alt=\"aop切面\"></p>\n<h3 id=\"3-2-2、AOP底层实现原理\"><a href=\"#3-2-2、AOP底层实现原理\" class=\"headerlink\" title=\"3.2.2、AOP底层实现原理\"></a>3.2.2、AOP底层实现原理</h3><h4 id=\"3-2-2-1、核心问题\"><a href=\"#3-2-2-1、核心问题\" class=\"headerlink\" title=\"3.2.2.1、核心问题\"></a>3.2.2.1、核心问题</h4><blockquote>\n<ol>\n<li>aop如何创建动态代理类（动态字节码技术）</li>\n<li>如何实现通过原始对象的id值，获得的是代理对象</li>\n</ol>\n</blockquote>\n<h3 id=\"3-2-3、动态代理类的创建\"><a href=\"#3-2-3、动态代理类的创建\" class=\"headerlink\" title=\"3.2.3、动态代理类的创建\"></a>3.2.3、动态代理类的创建</h3><h4 id=\"3-2-3-1、JDK动态代理\"><a href=\"#3-2-3-1、JDK动态代理\" class=\"headerlink\" title=\"3.2.3.1、JDK动态代理\"></a>3.2.3.1、JDK动态代理</h4><ul>\n<li><p>Proxy.newProxyInstancec：</p>\n</li>\n<li><p>编码实现</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestJDKProxy</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     1. 借⽤类加载器  TestJDKProxy 或 UserServiceImpl 都可以</span></span><br><span class=\"line\"><span class=\"comment\">     2. JDK8.x 前必须加 final</span></span><br><span class=\"line\"><span class=\"comment\">     final UserService userService = new UserServiceImpl();</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserServiceImpl</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 2. JDK 动态代理</span></span><br><span class=\"line\">        <span class=\"type\">InvocationHandler</span> <span class=\"variable\">handler</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">InvocationHandler</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;---- proxy log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"comment\">// 原始方法运行</span></span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) Proxy.</span><br><span class=\"line\">                newProxyInstance(TestJDKProxy.class.getClassLoader(),</span><br><span class=\"line\">                                userService.getClass().getInterfaces(),</span><br><span class=\"line\">                                handler);</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-3-2、CGLib动态代理\"><a href=\"#3-2-3-2、CGLib动态代理\" class=\"headerlink\" title=\"3.2.3.2、CGLib动态代理\"></a>3.2.3.2、CGLib动态代理</h4><ul>\n<li>CGlib 创建动态代理的原理：通过父子继承关系创建代理对象，原始类作为父类，代理类作为子类，这样既可以保证 2 者方法⼀致，同时在代理类中可以提供新的实现（额外功能+原始方法）</li>\n</ul>\n<blockquote>\n<p>在原始类没有实现接口的情况下cglib是一种很好的实现方式</p>\n</blockquote>\n<ul>\n<li>cglib原理</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">TestCglib</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 创建原始对象</span></span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userService</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">UserService</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         2. 通过 cglib 方式创建动态代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         对比 jdk 动态代理 ---&gt; Proxy.newProxyInstance(classLoader, interface, invocationHandler);</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setClassLoader()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setSuperClass()</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.setCallBack() ---&gt; MethodInterceptor(cglib)</span></span><br><span class=\"line\"><span class=\"comment\">         Enhancer.createProxy() ---&gt; 创建代理对象</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"type\">Enhancer</span> <span class=\"variable\">enhancer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Enhancer</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setClassLoader(TestCglib.class.getClassLoader());</span><br><span class=\"line\">        enhancer.setSuperclass(userService.getClass());</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">MethodInterceptor</span> <span class=\"variable\">interceptor</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">MethodInterceptor</span>() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"keyword\">public</span> Object <span class=\"title function_\">intercept</span><span class=\"params\">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;--- cglib log ----&quot;</span>);</span><br><span class=\"line\">                <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> method.invoke(userService, args); <span class=\"comment\">// 执行原始方法</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        enhancer.setCallback(interceptor);</span><br><span class=\"line\">        <span class=\"type\">UserService</span> <span class=\"variable\">userServiceProxy</span> <span class=\"operator\">=</span> (UserService) enhancer.create();</span><br><span class=\"line\">        userServiceProxy.login(<span class=\"string\">&quot;zhenyu&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>);</span><br><span class=\"line\">        userServiceProxy.register(<span class=\"keyword\">new</span> <span class=\"title class_\">User</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 总结：</p>\n<ol>\n<li>JDK 动态代理<br>Proxy.newProxyInstance：通过接口创建代理的实现类</li>\n<li>Cglib 动态代理<br>Enhancer：通过继承父类创建的代理类</li>\n</ol>\n<h3 id=\"3-2-4、基于注解的AOP编程\"><a href=\"#3-2-4、基于注解的AOP编程\" class=\"headerlink\" title=\"3.2.4、基于注解的AOP编程\"></a>3.2.4、基于注解的AOP编程</h3><h4 id=\"3-2-4-1、开发步骤\"><a href=\"#3-2-4-1、开发步骤\" class=\"headerlink\" title=\"3.2.4.1、开发步骤\"></a>3.2.4.1、开发步骤</h4><ol>\n<li>原始功能</li>\n</ol>\n<p>包含原始功能和实现类等</p>\n<ol start=\"2\">\n<li>额外功能+切入点+组装切面</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">        public class MyAround implements MethodInterceptor &#123;</span></span><br><span class=\"line\"><span class=\"comment\">            public Object invoke(MethodInvocation invocation) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">                Object ret = invocation.invoke();</span></span><br><span class=\"line\"><span class=\"comment\">                return ret;</span></span><br><span class=\"line\"><span class=\"comment\">            &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &#125;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;bean id=&quot;around&quot; class=&quot;com.yusael.dynamic.Around&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">    2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:pointcut id=&quot;pc&quot; expression=&quot;execution(* login(..)))&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">            &lt;aop:advisor advice-ref=&quot;around&quot; pointcut-ref=&quot;pc&quot;/&gt;</span></span><br><span class=\"line\"><span class=\"comment\">        &lt;/aop:config&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Around(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class=\"attr\">xmlns:aop</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">        切面:</span></span><br><span class=\"line\"><span class=\"comment\">            1. 额外功能</span></span><br><span class=\"line\"><span class=\"comment\">            2. 切入点</span></span><br><span class=\"line\"><span class=\"comment\">            3. 组装切面</span></span><br><span class=\"line\"><span class=\"comment\">    --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;around&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.aspect.MyAspect&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--告知 Spring 基于注解进行 AOP 编程--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>切入点复用</li>\n</ol>\n<p>切入点复用：在切面类中定义⼀个函数，上面用 @Pointcut 注解。<br>    通过这种方式定义切入点表达式，后续更加有利于切入点复用</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">MyAspect</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Pointcut(&quot;execution(* login(..))&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">myPoincut</span><span class=\"params\">()</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect log ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Around(value = &quot;myPoincut()&quot;)</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Object <span class=\"title function_\">around1</span><span class=\"params\">(ProceedingJoinPoint joinPoint)</span> <span class=\"keyword\">throws</span> Throwable &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;---- aspect transaction ----&quot;</span>);</span><br><span class=\"line\">        <span class=\"type\">Object</span> <span class=\"variable\">ret</span> <span class=\"operator\">=</span> joinPoint.proceed();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-2-4-2、动态代理创建方式\"><a href=\"#3-2-4-2、动态代理创建方式\" class=\"headerlink\" title=\"3.2.4.2、动态代理创建方式\"></a>3.2.4.2、动态代理创建方式</h4><p>AOP 底层实现 2 种代理创建方式：</p>\n<ol>\n<li>JDK：通过 <strong>实现接口，做新的实现类</strong> 创建代理对象</li>\n<li>Cglib：通过 <strong>继承父类，做新的子类</strong> 创建代理对象</li>\n</ol>\n<p><strong>默认情况 AOP 编程 底层应用 JDK动态代理创建方式</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 动态代理模式切换为cglib --&gt;</span><br><span class=\"line\">&lt;aop:aspectj-autoproxy proxy-target-class=<span class=\"string\">&quot;true&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"4、spring-持久层\"><a href=\"#4、spring-持久层\" class=\"headerlink\" title=\"4、spring 持久层\"></a>4、spring 持久层</h1><h2 id=\"4-1、spring与mybatis整合\"><a href=\"#4-1、spring与mybatis整合\" class=\"headerlink\" title=\"4.1、spring与mybatis整合\"></a>4.1、spring与mybatis整合</h2><ol>\n<li>引入依赖</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-jdbc<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.alibaba<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>druid<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>1.1.12<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.43<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.5.4<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>spring配置文件</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">beans</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">       <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class=\"line\"><span class=\"string\"><span class=\"tag\">                           http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--连接池--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;driverClassName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;url&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/yus?useSSL=false&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;username&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;root&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;password&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1234&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建SqlSessionFactory SqlSessionFactoryBean--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;typeAliasesPackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.entity&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;mapperLocations&quot;</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">                    <span class=\"tag\">&lt;<span class=\"name\">value</span>&gt;</span>classpath:com.yusael.dao/*Mapper.xml<span class=\"tag\">&lt;/<span class=\"name\">value</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;/<span class=\"name\">list</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">property</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--创建DAO对象 MapperScannerConfigure--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;scanner&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;sqlSessionFactoryBeanName&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;sqlSessionFactoryBean&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;basePackage&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;com.yusael.dao&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>测试</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title function_\">test</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ApplicationContext</span> <span class=\"variable\">ctx</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ClassPathXmlApplicationContext</span>(<span class=\"string\">&quot;/applicationContext.xml&quot;</span>);</span><br><span class=\"line\">    <span class=\"type\">UserDAO</span> <span class=\"variable\">userDAO</span> <span class=\"operator\">=</span> (UserDAO) ctx.getBean(<span class=\"string\">&quot;userDAO&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">User</span> <span class=\"variable\">user</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">User</span>();</span><br><span class=\"line\">    user.setName(<span class=\"string\">&quot;xiaojr&quot;</span>);</span><br><span class=\"line\">    user.setPassword(<span class=\"string\">&quot;999999&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    userDAO.save(user);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"4-2、关于事务提交的疑问\"><a href=\"#4-2、关于事务提交的疑问\" class=\"headerlink\" title=\"4.2、关于事务提交的疑问\"></a>4.2、关于事务提交的疑问</h2><p><strong>问题</strong>：Spring 与 Myabatis 整合后，为什么 DAO 不提交事务，但是数据能够插入数据库中？</p>\n<blockquote>\n<p>Mybatis 提供的连接池对象 —&gt; 创建 Connection<br>Connection.setAutoCommit(false) 手工的控制了事务，操作完成后，需要手工提交。<br>Druid（C3P0、DBCP）作为连接池 —&gt; 创建 Connection<br>Connection.setAutoCommit(true) 默认值为 true，保持自动控制事务，一条 sql 自动提交。</p>\n</blockquote>\n<p><strong>答案</strong>：因为 Spring 与 Mybatis 整合时，引入了外部连接池对象，保持自动的事务提交这个机制Connection.setAutoCommit(true)，不需要手工进行事务的操作，也能进行事务的提交。</p>\n<p><strong>注意</strong>：实战中，还是会手工控制事务（多条SQL一起成功，一起失败）后续 Spring 通过 事务控制 解决这个问题</p>\n<h2 id=\"4-3、spring事务处理\"><a href=\"#4-3、spring事务处理\" class=\"headerlink\" title=\"4.3、spring事务处理\"></a>4.3、spring事务处理</h2><h3 id=\"4-3-1、事务基本概念\"><a href=\"#4-3-1、事务基本概念\" class=\"headerlink\" title=\"4.3.1、事务基本概念\"></a>4.3.1、事务基本概念</h3><ol>\n<li>什么是事务？</li>\n</ol>\n<p>事务时保证业务操作完整性的一种<strong>数据库机制</strong></p>\n<ol start=\"2\">\n<li>事务的四大特性？</li>\n</ol>\n<p>A 原子性\tC 一致性 I 隔离性\tD 持久性</p>\n<ol start=\"3\">\n<li>如何控制事务？</li>\n</ol>\n<p><strong>JDBC：</strong><br>Connection.setAutoCommit(false);<br>Connection.commit();<br>Connection.rollback();<br><strong>Mybatis：</strong><br>Mybatis 自动开启事务<br>sqlSession.commit();，底层还是调用的 Connection<br>sqlSession.rollback();，底层还是调用的 Connection</p>\n<blockquote>\n<p>结论：控制事务的底层，都是通过 Connection 对象完成的</p>\n</blockquote>\n<h3 id=\"4-3-2、spring控制事务的开发\"><a href=\"#4-3-2、spring控制事务的开发\" class=\"headerlink\" title=\"4.3.2、spring控制事务的开发\"></a>4.3.2、spring控制事务的开发</h3><p>spring是通过aop的方式进行事务开发<br><strong>增强功能：</strong>原理也是在方法执行前关闭自动提交，spring帮我们封装成datasourcetransactionmanager，不需要自己去写增强方法</p>\n<p><strong>切入点：</strong>@Transactional （1）作用于类上（2）作用域方法。&lt;</p>\n<p><strong>组装切面：</strong>tx:annotation-driven transaction-manager&#x3D;”dataSourceTransactionManager”&#x2F;&gt; 自动扫描所有的@Transactional注解</p>\n<ol>\n<li>搭建开发环境</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-tx<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.2.6.RELEASE<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编码</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;userService&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;com.yusael.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;userDAO&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;userDAO&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!--DataSourceTransactionManager--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">bean</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">property</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;dataSource&quot;</span> <span class=\"attr\">ref</span>=<span class=\"string\">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">bean</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Transactional</span><br><span class=\"line\">public class UserServiceImpl implements UserService &#123;</span><br><span class=\"line\">    private UserDAO userDAO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<p>进行动态代理底层实现的切换，默认 false 是 JDK，true 是 Cglib</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">tx:annotation-driven</span> <span class=\"attr\">transaction-manager</span>=<span class=\"string\">&quot;dataSourceTransactionManager&quot;</span> <span class=\"attr\">proxy-target-class</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"4-3-3、事务的属性\"><a href=\"#4-3-3、事务的属性\" class=\"headerlink\" title=\"4.3.3、事务的属性\"></a>4.3.3、事务的属性</h3><p>5个：隔离属性，传播属性，只读属性，超时属性，异常属性</p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Transactional（isolation=, propagation=, readOnly=,timeout=,rollbackFor=,noRollbackFor=）</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-3-3-1、隔离属性\"><a href=\"#4-3-3-1、隔离属性\" class=\"headerlink\" title=\"4.3.3.1、隔离属性\"></a>4.3.3.1、隔离属性</h4><h5 id=\"4-3-3-1-1、并发问题-解决方案？\"><a href=\"#4-3-3-1-1、并发问题-解决方案？\" class=\"headerlink\" title=\"4.3.3.1.1、并发问题&amp;解决方案？\"></a>4.3.3.1.1、并发问题&amp;解决方案？</h5><p><strong>（1）脏读</strong>：一个事务，读取了另一个事务中没有提交的数据，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A取300还没提交，B读取到还700，然后取200，A回滚，B提交后账户只剩500了</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：读已提交</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.READ_COMMITTED)</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>（2）不可重复读</strong>：一个事务中，多次读取相同的数据，但是读取结果不一样，会在本事务中产生数据不一样的现象</p>\n<blockquote>\n<p>eg：账户1000，A查询到1000(事务还没提交)，B取200，A再查就剩800了<br>注意：1.不是脏读 2.在一个事务中</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：可重复读</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.REPEATABLE_READ)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>本质：一把行锁（对数据库表的某一行加锁）</p>\n</blockquote>\n<p><strong>（3）幻读</strong>：一个事务中，多次对<strong>整表</strong>进行<strong>查询统计</strong>，但是<strong>结果不一样</strong>，会在本事务中产生数据不一致的问题</p>\n<blockquote>\n<p>查询表中数据行数count，一个事务两次查询中间，其它用户添加并提交了数据，再读取行数count就会不一致</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 隔离级别：序列化</span></span><br><span class=\"line\"><span class=\"meta\">@Transaction(isolation=Isolation.SERIALIZABLE)</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>本质：表锁（对数据库某个表加锁）</p>\n</blockquote>\n<h5 id=\"4-3-3-1-2、安全与效率对比：\"><a href=\"#4-3-3-1-2、安全与效率对比：\" class=\"headerlink\" title=\"4.3.3.1.2、安全与效率对比：\"></a>4.3.3.1.2、安全与效率对比：</h5><ul>\n<li>并发安全：SERIALIZABLE &gt; READ_ONLY &gt; READ_COMMITTED</li>\n<li>运行效率：READ_COMMITTED &gt; READ_ONLY &gt; SERIALIZABLE</li>\n</ul>\n<h5 id=\"4-3-3-1-3、数据库默认隔离属性\"><a href=\"#4-3-3-1-3、数据库默认隔离属性\" class=\"headerlink\" title=\"4.3.3.1.3、数据库默认隔离属性\"></a>4.3.3.1.3、数据库默认隔离属性</h5><p>mysql：可重复读（REPEATABLE_READ）<br>Oracle：读已提交（READ_COMMITTED）</p>\n<h4 id=\"4-3-3-2、传播属性\"><a href=\"#4-3-3-2、传播属性\" class=\"headerlink\" title=\"4.3.3.2、传播属性\"></a>4.3.3.2、传播属性</h4><h5 id=\"4-3-3-2-1、基本概念\"><a href=\"#4-3-3-2-1、基本概念\" class=\"headerlink\" title=\"4.3.3.2.1、基本概念\"></a>4.3.3.2.1、基本概念</h5><p>传播属性：描述了事务解决 嵌套 问题 的特征<br><strong>事务的嵌套</strong>：指的是一个大的事务中，包含了若干个小的事务。<br><strong>事务嵌套产生的问题</strong>： 大事务中融入了很多小的事务，他们彼此影响，最终就导致外部大的事务丧失了事务的原子性（一旦外部的事务出现问题，内部已提交的事务无法一起回滚）</p>\n<h5 id=\"4-3-3-2-2、传播属性的值及用法\"><a href=\"#4-3-3-2-2、传播属性的值及用法\" class=\"headerlink\" title=\"4.3.3.2.2、传播属性的值及用法\"></a>4.3.3.2.2、传播属性的值及用法</h5><table>\n<thead>\n<tr>\n<th>传播属性的值</th>\n<th>外部不存在事务</th>\n<th>外部存在事务</th>\n<th>用法</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>REQUIRED</td>\n<td>开启新的事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRED)</td>\n<td>增、删、改方法（保证了肯定会有事务的存在）</td>\n</tr>\n<tr>\n<td>REQUIRES_NEW</td>\n<td>开启新的事务</td>\n<td>挂起外部事务，创建新的事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.REQUIRES_NEW)</td>\n<td>日志记录方法中（保证外部事务异常时能正常的记录日志）</td>\n</tr>\n<tr>\n<td>SUPPORTS</td>\n<td>不开启事务</td>\n<td>融合到外部事务中</td>\n<td>@Transactional(propagation &#x3D; Propagation.SUPPORTS)</td>\n<td>查询方法</td>\n</tr>\n<tr>\n<td>NOT_SUPPORTED</td>\n<td>不开启事务</td>\n<td>挂起外部事务</td>\n<td>@Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>NEVER</td>\n<td>不开启事务</td>\n<td>抛出异常</td>\n<td>@Transactional(propagation &#x3D; Propagation.NEVER)</td>\n<td>极其不常用</td>\n</tr>\n<tr>\n<td>MANDATORY（强制的）</td>\n<td>抛出异常</td>\n<td>融合到外部事物中</td>\n<td>@Transactional(propagation &#x3D; Propagation.MANDATORY)</td>\n<td>极其不常用</td>\n</tr>\n</tbody></table>\n<p>Spring 中<strong>传播属性的默认值</strong>是：REQUIRED</p>\n<p>推荐传播属性的使用方式：</p>\n<ul>\n<li>增删改 方法：使用默认值 REQUIRED</li>\n<li>查询 方法：显示指定传播属性的值为 SUPPORTS</li>\n</ul>\n<h4 id=\"4-2-2-3、只读属性\"><a href=\"#4-2-2-3、只读属性\" class=\"headerlink\" title=\"4.2.2.3、只读属性\"></a>4.2.2.3、只读属性</h4><p>针对于 <strong>只进行查询操作的业务方法</strong>，可以加入只读属性，提高运行效率。<br>默认值：false</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(readOnly = true)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-2-2-4、超时属性\"><a href=\"#4-2-2-4、超时属性\" class=\"headerlink\" title=\"4.2.2.4、超时属性\"></a>4.2.2.4、超时属性</h4><p>指定了事务等待的最长时间。</p>\n<ol>\n<li>为什么事务会进行等待？</li>\n</ol>\n<p>当前事务访问数据时，有可能访问的数据被别的事务进行加锁的处理，那么此时本事务就必须进行等待。</p>\n<ol start=\"2\">\n<li>等待时间，单位是 秒</li>\n<li>如何使用：@Transactional(timeout &#x3D; 2)</li>\n<li>超时属性的默认值：-1</li>\n</ol>\n<p>-1 表示超时属性由对应的数据库来指定（一般不会主动指定，-1 即可）</p>\n<h4 id=\"4-2-2-5、异常属性\"><a href=\"#4-2-2-5、异常属性\" class=\"headerlink\" title=\"4.2.2.5、异常属性\"></a>4.2.2.5、异常属性</h4><p>Spring 事务处理过程中：</p>\n<ul>\n<li>默认对于 RuntimeException 及其子类，采用 <strong>回滚</strong> 的策略。</li>\n<li>默认对于 对于其他类型的异常，采用 <strong>提交</strong> 的策略（例如IO异常、网络异常等，可以在程序中使用try-catch块来处理这些异常，或者在方法签名中使用throws关键字将异常抛出给调用者处理。如果Spring默认采用回滚策略，会导致这些异常被回滚，可能会带来意想不到的后果，例如文件未能正确关闭、网络连接未能正确关闭等）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Transactional(rollbackFor = java.lang.Exception.class, xxx, xxx)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Transactional(noRollbackFor = java.lang.RuntimeException, xxx, xxx)</span></span><br></pre></td></tr></table></figure>\n\n\n<h1 id=\"5、spring-mvc\"><a href=\"#5、spring-mvc\" class=\"headerlink\" title=\"5、spring mvc\"></a>5、spring mvc</h1><p>spring mvc相关内容请参考spring mvc的笔记，这里只讨论spring mvc和spring 容器的关系 </p>\n<h2 id=\"5-1、父子容器关系\"><a href=\"#5-1、父子容器关系\" class=\"headerlink\" title=\"5.1、父子容器关系\"></a>5.1、父子容器关系</h2><ol>\n<li>Spring框架的核心是Spring容器（BeanFactory，ApplicationContext ）。Spring MVC是Spring框架中的一个模块，它提供了一种基于MVC模式的Web应用程序开发方式。 Spring MVC框架的核心是Spring MVC容器（WebApplicationContext）</li>\n<li>Spring MVC容器继承了Spring容器的所有功能，并且提供了一些额外的功能，如处理HTTP请求和响应、支持多种视图技术等</li>\n<li>Spring 容器是父容器，SpringMVC 是子容器，子容器可以访问父容器的 Bean，但是父容器不能访问子容器的 Bean（参考类继承的访问权限）</li>\n<li>调用子容器的getBean方法获取bean的时候，会沿着当前容器开始向上面的容器进行查找，直到找到对应的bean为止</li>\n</ol>\n<h2 id=\"5-2、为什么要划分父子容器\"><a href=\"#5-2、为什么要划分父子容器\" class=\"headerlink\" title=\"5.2、为什么要划分父子容器\"></a>5.2、为什么要划分父子容器</h2><ol>\n<li>分离关注点：Spring MVC负责处理Web请求和响应，与业务逻辑无关，因此需要将Spring MVC容器与Spring容器分离，以便更好地分离关注点，简化应用程序的开发和维护（单一职责原则）</li>\n<li>性能优化：Spring MVC容器的初始化速度比Spring容器快，因为它只需要初始化与Web请求相关的对象。而Spring容器需要初始化整个应用程序中的所有对象，这可能会影响应用程序的性能</li>\n</ol>\n<h2 id=\"5-3、springBoot舍弃了父子容器的概念\"><a href=\"#5-3、springBoot舍弃了父子容器的概念\" class=\"headerlink\" title=\"5.3、springBoot舍弃了父子容器的概念\"></a>5.3、springBoot舍弃了父子容器的概念</h2><p>SpringBoot只有一个容器。<br>Spring Boot框架采用了“约定优于配置”的设计理念，旨在简化Spring应用程序的开发和部署</p>\n<h1 id=\"6、注解编程\"><a href=\"#6、注解编程\" class=\"headerlink\" title=\"6、注解编程\"></a>6、注解编程</h1><h2 id=\"6-1、spring基础注解（spring2-X）\"><a href=\"#6-1、spring基础注解（spring2-X）\" class=\"headerlink\" title=\"6.1、spring基础注解（spring2.X）\"></a>6.1、spring基础注解（spring2.X）</h2><h3 id=\"6-1-1、对象创建相关\"><a href=\"#6-1-1、对象创建相关\" class=\"headerlink\" title=\"6.1.1、对象创建相关\"></a>6.1.1、对象创建相关</h3><h4 id=\"6-1-1-1、-Component\"><a href=\"#6-1-1-1、-Component\" class=\"headerlink\" title=\"6.1.1.1、@Component\"></a>6.1.1.1、@Component</h4><ol>\n<li>作用：替换原有Spring配置文件中的 <bean> 标签</li>\n</ol>\n<ul>\n<li>id 属性：在 @Component 中提供了默认的设置方式：首单词首字母小写（UserDAO –&gt; userDAO）</li>\n<li>class 属性：通过反射获得的 class 的内容</li>\n</ul>\n<ol start=\"2\">\n<li>细节：如何显式指定工厂创建对象的 id 值</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component(&quot;u&quot;)</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-2、-Repository、-Service、-Contoller\"><a href=\"#6-1-1-2、-Repository、-Service、-Contoller\" class=\"headerlink\" title=\"6.1.1.2、@Repository、@Service、@Contoller\"></a>6.1.1.2、@Repository、@Service、@Contoller</h4><p>@Repository、@Service、@Controller 都是 @Component 的 <strong>衍生注解</strong>。<br>本质上这些衍生注解就是 @Component，通过源码可以看见他们都使用了 @Component；<br>它们的存在是为了：<strong>更加准确的表达一个类型的作用</strong></p>\n<h4 id=\"6-1-1-3、-Scope\"><a href=\"#6-1-1-3、-Scope\" class=\"headerlink\" title=\"6.1.1.3、@Scope\"></a>6.1.1.3、@Scope</h4><p>作用：控制简单对象创建次数<br>注意：不添加 @Scope，Spring 提供默认值 singleton</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建单例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;singleton&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建多例对象</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Scope(&quot;prototype&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Customer</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-4、-Lazy\"><a href=\"#6-1-1-4、-Lazy\" class=\"headerlink\" title=\"6.1.1.4、@Lazy\"></a>6.1.1.4、@Lazy</h4><p>作用：延迟创建单实例对象<br>注意：一旦使用 @Lazy 注解后，Spring 会在使用这个对象的时候，才创建这个对象</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"meta\">@Lazy</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">Account</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"title function_\">Account</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Account.Account&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-1-1-5、-PostConstruct、-PreDestroy\"><a href=\"#6-1-1-5、-PostConstruct、-PreDestroy\" class=\"headerlink\" title=\"6.1.1.5、@PostConstruct、@PreDestroy\"></a>6.1.1.5、@PostConstruct、@PreDestroy</h4><p>初始化相关方法： @PostConstruct</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InitializingBean</span><br><span class=\"line\">&lt;bean init-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<p>销毁方法：@PreDestory</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DisposableBean</span><br><span class=\"line\">&lt;bean destory-method=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-1-2、注入相关注解\"><a href=\"#6-1-2、注入相关注解\" class=\"headerlink\" title=\"6.1.2、注入相关注解\"></a>6.1.2、注入相关注解</h3><h4 id=\"6-1-2-1、-Autowired（用户自定义类型）\"><a href=\"#6-1-2-1、-Autowired（用户自定义类型）\" class=\"headerlink\" title=\"6.1.2.1、@Autowired（用户自定义类型）\"></a>6.1.2.1、@Autowired（用户自定义类型）</h4><ol>\n<li>@Autowired 注解 <strong>基于类型进行注入</strong> [推荐]：</li>\n</ol>\n<ul>\n<li>注入对象的类型，必须与目标成员变量类型相同或者是其子类（实现类）</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>@Autowired、@Qualifier 注解联合实现 <strong>基于名字进行注入</strong> [了解]</li>\n</ol>\n<ul>\n<li>注入对象的 id 值，必须与 @Qualifier 注解中设置的名字相同</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier(&quot;userDAOImpl&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> UserDAO userDAO;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@Autowired 注解放置位置：</li>\n</ol>\n<ul>\n<li>放置在对应成员变量的 set 方法上，调用 set 方法赋值（在 set 里写的代码会被执行）</li>\n<li><strong>直接放置在成员变量上</strong>，Spring 通过反射直接对成员变量进行赋值</li>\n</ul>\n<ol start=\"4\">\n<li>JSR提供的@Resource注解</li>\n</ol>\n<blockquote>\n<p>JavaEE 规范中类似功能的注解：</p>\n<ul>\n<li>JSR250 提供的 @Resource(name&#x3D;”xxx”) <strong>基于名字进行注入</strong><br>等价于 @Autowired 与 @Qualifier 联合实现的效果<br>注意：@Resource 注解如果名字没有配对成功，会继续 <strong>按照类型进行注入</strong></li>\n</ul>\n</blockquote>\n<h4 id=\"6-1-2-2、-value、-PropertySource（JDK-类型）\"><a href=\"#6-1-2-2、-value、-PropertySource（JDK-类型）\" class=\"headerlink\" title=\"6.1.2.2、@value、@PropertySource（JDK 类型）\"></a>6.1.2.2、@value、@PropertySource（JDK 类型）</h4><ol>\n<li>@value 注解的基本使用（xml配置）：</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1.</span> 设置xxx.<span class=\"type\">properties</span> </span><br><span class=\"line\">   <span class=\"variable\">id</span> <span class=\"operator\">=</span> <span class=\"number\">10</span></span><br><span class=\"line\">   name = suns</span><br><span class=\"line\"><span class=\"number\">2.</span> Spring的工厂读取这个配置文件 </span><br><span class=\"line\">   &lt;context:property-placeholder location=<span class=\"string\">&quot;&quot;</span>/&gt;</span><br><span class=\"line\"><span class=\"number\">3.</span> 代码中进行注入</span><br><span class=\"line\">   属性 <span class=\"meta\">@Value(&quot;$&#123;key&#125;&quot;)</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>使用 @PropertySource 取代 xml配置</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@PropertySource(&quot;classpath:/init.properties&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig1</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;id&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> Integer id;</span><br><span class=\"line\">\t<span class=\"meta\">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">\t<span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">\t\tcustomer.setId(id);</span><br><span class=\"line\">\t\tcustomer.setName(name);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>@value 注解使用细节：</li>\n</ol>\n<ul>\n<li>@Value 注解不能应用在静态成员变量上，如果使用，获取的值为 null</li>\n<li>@Value 注解 + Properties 这种方式，不能注入集合类型<br>Spring 提供新的配置形式 YAML(YML) (更多的用于SpringBoot中)</li>\n</ul>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h2><h2 id=\"6-2、spring的高级注解（spring3-X及以上）\"><a href=\"#6-2、spring的高级注解（spring3-X及以上）\" class=\"headerlink\" title=\"6.2、spring的高级注解（spring3.X及以上）\"></a>6.2、spring的高级注解（spring3.X及以上）</h2><h3 id=\"6-2-1、-Configuration（配置bean）\"><a href=\"#6-2-1、-Configuration（配置bean）\" class=\"headerlink\" title=\"6.2.1、@Configuration（配置bean）\"></a>6.2.1、@Configuration（配置bean）</h3><ol>\n<li>Spring 在 3.x 提供的新的注解@Configuration，用于替换 XML 配置文件</li>\n<li>使用了 @Configuration 后，用 AnnotationConfigApplicationContext 创建工厂：</li>\n</ol>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">方法1: 指定配置bean的Class</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);</span><br><span class=\"line\"></span><br><span class=\"line\">方法2: 指定配置bean所在的路径(某个包及其子包)</span><br><span class=\"line\">ApplicationContext ctx = new AnnotationConfigApplicationContext(&quot;com.yusael&quot;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-2、-Bean\"><a href=\"#6-2-2、-Bean\" class=\"headerlink\" title=\"6.2.2、@Bean\"></a>6.2.2、@Bean</h3><p>@Bean 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 &lt;bean 标签</p>\n<blockquote>\n<p><strong>简单对象</strong>：直接能够通过 new 方式创建的对象</p>\n<ul>\n<li>User、UserService、UserDAO</li>\n</ul>\n</blockquote>\n<p><strong>复杂对象</strong>：不能通过 new 的方式直接创建的对象</p>\n<blockquote>\n<ul>\n<li>Connection、SqlSessionFactory</li>\n</ul>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 简单对象</span></span><br><span class=\"line\">\t<span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Customer <span class=\"title function_\">customer</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Customer</span> <span class=\"variable\">customer</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Customer</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> customer;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 复杂对象</span></span><br><span class=\"line\">  <span class=\"meta\">@Bean</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> Connection <span class=\"title function_\">conn1</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">Connection</span> <span class=\"variable\">conn</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"type\">ConnectionFactoryBean</span> <span class=\"variable\">factoryBean</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">ConnectionFactoryBean</span>();</span><br><span class=\"line\">      conn = factoryBean.getObject();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">      e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> conn;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-2-3、-ComponentScan\"><a href=\"#6-2-3、-ComponentScan\" class=\"headerlink\" title=\"6.2.3、@ComponentScan\"></a>6.2.3、@ComponentScan</h3><p>@ComponentScan 注解在配置 bean 中进行使用，等同于 XML 配置文件中的 <a href=\"context:component-scan\">context:component-scan</a> 标签<br>目的：进行相关注解的扫描（@Component、@Value、@Autowired …)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ComponentScan(basePackages = &quot;com.yusael.scan&quot;,</span></span><br><span class=\"line\"><span class=\"meta\">               excludeFilters = &#123;@ComponentScan.Filter(type= FilterType.ANNOTATION, value=&#123;Service.class&#125;),</span></span><br><span class=\"line\"><span class=\"meta\">                                 @ComponentScan.Filter(type= FilterType.ASPECTJ, pattern = &quot;*..User1&quot;)&#125;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">AppConfig2</span> &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"快乐源泉","date":"2023-07-31T16:00:00.000Z","updated":"2023-08-01T16:00:00.000Z","abbrlink":60552,"_content":"\n# 1、段子\n\n1. 小明考了零分， 老师把小明拽到讲台前说道：“大家都看看， 这就是平时注意力不集中， 不好好听我讲课， 竟然考了零分， 大家要以此为鉴！” 这时，小明泪流满面地说：“老师，啥时候考的试呀， 下回能不能到门外通知我一下？”\n2. 天气预报说今晚会有台风登陆，但是一直没登陆，你知道是为什么吗？因为台风忘记密码\n3. 唉！模拟地震没有地震；模拟火灾没有火；那为什么模拟考试就有考试了啊啊啊！\n4. 司机:你们为什么要去四十公里外的地方吃饭 我:看小红书推荐的 司机:现在还看书的年轻人不多了\n5. 两程序员聊天，程序员甲抱怨：\"做程序员太辛苦了，我想换行……我该怎么办？\"程序员乙：\"敲一下回车。\"\n6. 你为家乡脱贫做出了什么贡献？我出门打工，减少贫困人口\n7. 野外有野生龟，家有家规\n8. 大熊猫点外卖，笋到家了\n9. \n\n\n\n# 2、沙雕图\n\n1. 马奎尔\n\n![微信图片_20230801214020.jpg|450](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012146393.jpg)\n\n2. 小孩那桌\n\n![3f7321086b3c5333a90bdcf7675430d.jpg|440](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012148418.jpg)\n\n3. 马夏尔 马厂长\n\n![3ed1d74fa053bbacb0f6b5f862f6c08.jpg|450](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012149967.jpg)\n\n\n4. 奥特曼和怪兽\n\n![0aafd5767693bc0085eca2323b0d5da.jpg|425](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012149723.jpg)\n\n5. 坤坤\n\n![4cb6fca5847a265748ef54781a532e2.jpg|425](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012150033.jpg)\n\n6. 不能真杀\n\n![f3bc8f6a0f68971b63d38bab144eb7f.jpg|450](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012151766.jpg)\n\n7. 充气女友\n\n![充气女友](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308022222086.jpg)\n\n8. 相亲交友\n\n![相亲交友|400](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308041600016.jpg)\n\n9. bug\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308181402278.png)\n\n10. 善有善报\n![善有善报|500](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222147229.jpg)\n\n11. 棕熊\n![棕熊](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222149675.jpg)\n\n12. 程序员的情人节\n![8a6ced841979d7f9dc8d8fc3e3f48a2.jpg](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222156761.jpg)\n\n13. 企业解决方案\n![企业解决方案|500](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231441866.png)\n\n14. 大头照\n\n![大头照](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051725070.png)\n\n15. 为什么汉字停止了演化\n\n![汉字演化](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051730176.png)\n\n16. 帮我撑下袋\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051806713.png)\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051806677.png)\n","source":"_posts/快乐源泉.md","raw":"---\ntitle: 快乐源泉\ndate: 2023/08/01\nupdated: 2023/08/02\ncategories:\n  - 生活\ntags:\n  - 段子\n  - 沙雕图\nabbrlink: 60552\n---\n\n# 1、段子\n\n1. 小明考了零分， 老师把小明拽到讲台前说道：“大家都看看， 这就是平时注意力不集中， 不好好听我讲课， 竟然考了零分， 大家要以此为鉴！” 这时，小明泪流满面地说：“老师，啥时候考的试呀， 下回能不能到门外通知我一下？”\n2. 天气预报说今晚会有台风登陆，但是一直没登陆，你知道是为什么吗？因为台风忘记密码\n3. 唉！模拟地震没有地震；模拟火灾没有火；那为什么模拟考试就有考试了啊啊啊！\n4. 司机:你们为什么要去四十公里外的地方吃饭 我:看小红书推荐的 司机:现在还看书的年轻人不多了\n5. 两程序员聊天，程序员甲抱怨：\"做程序员太辛苦了，我想换行……我该怎么办？\"程序员乙：\"敲一下回车。\"\n6. 你为家乡脱贫做出了什么贡献？我出门打工，减少贫困人口\n7. 野外有野生龟，家有家规\n8. 大熊猫点外卖，笋到家了\n9. \n\n\n\n# 2、沙雕图\n\n1. 马奎尔\n\n![微信图片_20230801214020.jpg|450](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012146393.jpg)\n\n2. 小孩那桌\n\n![3f7321086b3c5333a90bdcf7675430d.jpg|440](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012148418.jpg)\n\n3. 马夏尔 马厂长\n\n![3ed1d74fa053bbacb0f6b5f862f6c08.jpg|450](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012149967.jpg)\n\n\n4. 奥特曼和怪兽\n\n![0aafd5767693bc0085eca2323b0d5da.jpg|425](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012149723.jpg)\n\n5. 坤坤\n\n![4cb6fca5847a265748ef54781a532e2.jpg|425](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012150033.jpg)\n\n6. 不能真杀\n\n![f3bc8f6a0f68971b63d38bab144eb7f.jpg|450](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012151766.jpg)\n\n7. 充气女友\n\n![充气女友](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308022222086.jpg)\n\n8. 相亲交友\n\n![相亲交友|400](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308041600016.jpg)\n\n9. bug\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308181402278.png)\n\n10. 善有善报\n![善有善报|500](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222147229.jpg)\n\n11. 棕熊\n![棕熊](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222149675.jpg)\n\n12. 程序员的情人节\n![8a6ced841979d7f9dc8d8fc3e3f48a2.jpg](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222156761.jpg)\n\n13. 企业解决方案\n![企业解决方案|500](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231441866.png)\n\n14. 大头照\n\n![大头照](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051725070.png)\n\n15. 为什么汉字停止了演化\n\n![汉字演化](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051730176.png)\n\n16. 帮我撑下袋\n\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051806713.png)\n![image.png](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051806677.png)\n","slug":"快乐源泉","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sra3002t00ujf1ojg2mb","content":"<h1 id=\"1、段子\"><a href=\"#1、段子\" class=\"headerlink\" title=\"1、段子\"></a>1、段子</h1><ol>\n<li>小明考了零分， 老师把小明拽到讲台前说道：“大家都看看， 这就是平时注意力不集中， 不好好听我讲课， 竟然考了零分， 大家要以此为鉴！” 这时，小明泪流满面地说：“老师，啥时候考的试呀， 下回能不能到门外通知我一下？”</li>\n<li>天气预报说今晚会有台风登陆，但是一直没登陆，你知道是为什么吗？因为台风忘记密码</li>\n<li>唉！模拟地震没有地震；模拟火灾没有火；那为什么模拟考试就有考试了啊啊啊！</li>\n<li>司机:你们为什么要去四十公里外的地方吃饭 我:看小红书推荐的 司机:现在还看书的年轻人不多了</li>\n<li>两程序员聊天，程序员甲抱怨：”做程序员太辛苦了，我想换行……我该怎么办？”程序员乙：”敲一下回车。”</li>\n<li>你为家乡脱贫做出了什么贡献？我出门打工，减少贫困人口</li>\n<li>野外有野生龟，家有家规</li>\n<li>大熊猫点外卖，笋到家了</li>\n<li></li>\n</ol>\n<h1 id=\"2、沙雕图\"><a href=\"#2、沙雕图\" class=\"headerlink\" title=\"2、沙雕图\"></a>2、沙雕图</h1><ol>\n<li>马奎尔</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012146393.jpg\" alt=\"微信图片_20230801214020.jpg|450\"></p>\n<ol start=\"2\">\n<li>小孩那桌</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012148418.jpg\" alt=\"3f7321086b3c5333a90bdcf7675430d.jpg|440\"></p>\n<ol start=\"3\">\n<li>马夏尔 马厂长</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012149967.jpg\" alt=\"3ed1d74fa053bbacb0f6b5f862f6c08.jpg|450\"></p>\n<ol start=\"4\">\n<li>奥特曼和怪兽</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012149723.jpg\" alt=\"0aafd5767693bc0085eca2323b0d5da.jpg|425\"></p>\n<ol start=\"5\">\n<li>坤坤</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012150033.jpg\" alt=\"4cb6fca5847a265748ef54781a532e2.jpg|425\"></p>\n<ol start=\"6\">\n<li>不能真杀</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012151766.jpg\" alt=\"f3bc8f6a0f68971b63d38bab144eb7f.jpg|450\"></p>\n<ol start=\"7\">\n<li>充气女友</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308022222086.jpg\" alt=\"充气女友\"></p>\n<ol start=\"8\">\n<li>相亲交友</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308041600016.jpg\" alt=\"相亲交友|400\"></p>\n<ol start=\"9\">\n<li>bug</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308181402278.png\" alt=\"image.png\"></p>\n<ol start=\"10\">\n<li><p>善有善报<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222147229.jpg\" alt=\"善有善报|500\"></p>\n</li>\n<li><p>棕熊<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222149675.jpg\" alt=\"棕熊\"></p>\n</li>\n<li><p>程序员的情人节<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222156761.jpg\" alt=\"8a6ced841979d7f9dc8d8fc3e3f48a2.jpg\"></p>\n</li>\n<li><p>企业解决方案<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231441866.png\" alt=\"企业解决方案|500\"></p>\n</li>\n<li><p>大头照</p>\n</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051725070.png\" alt=\"大头照\"></p>\n<ol start=\"15\">\n<li>为什么汉字停止了演化</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051730176.png\" alt=\"汉字演化\"></p>\n<ol start=\"16\">\n<li>帮我撑下袋</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051806713.png\" alt=\"image.png\"><br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051806677.png\" alt=\"image.png\"></p>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、段子\"><a href=\"#1、段子\" class=\"headerlink\" title=\"1、段子\"></a>1、段子</h1><ol>\n<li>小明考了零分， 老师把小明拽到讲台前说道：“大家都看看， 这就是平时注意力不集中， 不好好听我讲课， 竟然考了零分， 大家要以此为鉴！” 这时，小明泪流满面地说：“老师，啥时候考的试呀， 下回能不能到门外通知我一下？”</li>\n<li>天气预报说今晚会有台风登陆，但是一直没登陆，你知道是为什么吗？因为台风忘记密码</li>\n<li>唉！模拟地震没有地震；模拟火灾没有火；那为什么模拟考试就有考试了啊啊啊！</li>\n<li>司机:你们为什么要去四十公里外的地方吃饭 我:看小红书推荐的 司机:现在还看书的年轻人不多了</li>\n<li>两程序员聊天，程序员甲抱怨：”做程序员太辛苦了，我想换行……我该怎么办？”程序员乙：”敲一下回车。”</li>\n<li>你为家乡脱贫做出了什么贡献？我出门打工，减少贫困人口</li>\n<li>野外有野生龟，家有家规</li>\n<li>大熊猫点外卖，笋到家了</li>\n<li></li>\n</ol>\n<h1 id=\"2、沙雕图\"><a href=\"#2、沙雕图\" class=\"headerlink\" title=\"2、沙雕图\"></a>2、沙雕图</h1><ol>\n<li>马奎尔</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012146393.jpg\" alt=\"微信图片_20230801214020.jpg|450\"></p>\n<ol start=\"2\">\n<li>小孩那桌</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012148418.jpg\" alt=\"3f7321086b3c5333a90bdcf7675430d.jpg|440\"></p>\n<ol start=\"3\">\n<li>马夏尔 马厂长</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012149967.jpg\" alt=\"3ed1d74fa053bbacb0f6b5f862f6c08.jpg|450\"></p>\n<ol start=\"4\">\n<li>奥特曼和怪兽</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012149723.jpg\" alt=\"0aafd5767693bc0085eca2323b0d5da.jpg|425\"></p>\n<ol start=\"5\">\n<li>坤坤</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012150033.jpg\" alt=\"4cb6fca5847a265748ef54781a532e2.jpg|425\"></p>\n<ol start=\"6\">\n<li>不能真杀</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308012151766.jpg\" alt=\"f3bc8f6a0f68971b63d38bab144eb7f.jpg|450\"></p>\n<ol start=\"7\">\n<li>充气女友</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308022222086.jpg\" alt=\"充气女友\"></p>\n<ol start=\"8\">\n<li>相亲交友</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308041600016.jpg\" alt=\"相亲交友|400\"></p>\n<ol start=\"9\">\n<li>bug</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308181402278.png\" alt=\"image.png\"></p>\n<ol start=\"10\">\n<li><p>善有善报<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222147229.jpg\" alt=\"善有善报|500\"></p>\n</li>\n<li><p>棕熊<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222149675.jpg\" alt=\"棕熊\"></p>\n</li>\n<li><p>程序员的情人节<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308222156761.jpg\" alt=\"8a6ced841979d7f9dc8d8fc3e3f48a2.jpg\"></p>\n</li>\n<li><p>企业解决方案<br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231441866.png\" alt=\"企业解决方案|500\"></p>\n</li>\n<li><p>大头照</p>\n</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051725070.png\" alt=\"大头照\"></p>\n<ol start=\"15\">\n<li>为什么汉字停止了演化</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051730176.png\" alt=\"汉字演化\"></p>\n<ol start=\"16\">\n<li>帮我撑下袋</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051806713.png\" alt=\"image.png\"><br><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309051806677.png\" alt=\"image.png\"></p>\n"},{"title":"西方哲学史","date":"2023-10-27T16:00:00.000Z","abbrlink":40984,"_content":"\n\n\n# 1、智慧的痛苦\n\n## 1.1、什么是哲学\n\n1. 关于哲学错误的看法：\n\n（1）哲学是科学：它不具备一门科学知识应该具备的最基本特征：普遍性和必然性\n（2）哲学是让人聪明的学问：哲学的理论学说都处在众说纷纭，莫衷一事的处境中。那么你想想学哲学会让你聪明还是糊涂\n（3）哲学是讲道理的学问：哲学是讲大道理的，可是哲学这个大道理大到什么程度，大到没有办法去印证的程度。那么道理道理之间的冲突就变成没有道理\n\t哲学往往被看做是为意识形态服务的工具，今天是这样一种政策，理论家们就要给我论证它的理论基础，非常完善的一套逻辑，过一段时间政策变了，还是这群哲学家，仍然还可以给你论证那套基础。不恰当的讲，可以把煤球论证成黑的，也可以论证成白的。\n\t科学知识的对象 -> 现实性\n\t哲学的对象 -> 理想性，带有乌托邦的性质，它是人们不满足于这个世界，而为它建立的一个理想世界，但每个人不同的时代社会和所处的环境，使人们对这个理想的境界理解不同\n（4）哲学无用，无用只用，是为大用。所有学科都比哲学有用，但是是唯有哲学是自由的学问，因为所有的学科都有前提，都有它服务的对象，但唯独哲学是为了自身而被追求的知识。哲学是自由人的学问。哲学应该是人的精神家园\n\n2. 哲学的理解\n\n哲学是希腊语philosophia : philos + sophia （哲学：爱智慧）。亚里士多德说，智慧这个词太大了，它只适合神而不适合人，我们只能爱智慧。哲学和科学一样讲理性，哲学又和宗教一样，起源于终极关怀的问题。看起来哲学相比宗教和科学，处在一个有利的位置，但恰恰是这个位置，让它看起来很尴尬，为什么？科学讲这个世界，宗教关注另一个世界。哲学想把这两个东西打通，它既不能靠理论说服宗教，又不能靠信仰阐述科学。哲学给我们提供了一条一条解决问题的道路，没有任何一条道路通达到了智慧的顶点，但是每条道路都是一个典型\n\n## 1.2、智慧的痛苦\n\n哲学既然没有解决问题，为什么还要追问问题？\n亚当是按照神的形象创造的，神把亚当安置在伊甸园，一个美丽的地方，哪里，到处都是结出甜美果实的树木。其中有两棵树，都有不同的作用，一棵是生命树，享受永生，一棵是知识树，里面充满着恶欲和邪淫。亚当唯一的命令是:“除了智慧树的果子，你可以吃任何你想吃的果子!”神在亚当陷入了沉睡，他取下他的一侧肋骨，形成夏娃。然后他把她带到亚当那里，亚当和他的新婚妻子感到了满足。亚当和夏娃被造的时候并没有邪恶的倾向，他们觉得不穿衣服没有什么不对。然而，这种情况很快就改变了。蛇是神所创造的所有野兽中最狡猾的，它靠近夏娃，慢慢地，淡定说服并迫使夏娃吃智慧树的果实。接着，她和丈夫亚分享了果实。亚当和夏娃立刻意识到自己是赤身露体的，便用无花果叶缝的带子束身。他们违背了神的命令的报应很快会到来:夏娃被诅咒要忍受怀孕、生产和抚养孩子的痛苦，还要屈从于她的丈夫。亚当的惩罚是：他必须在大地上劳作来生产粮食，人类的生命现在将以死亡结束。更重要的是，亚当和夏娃被驱逐出伊甸园。\n\n整个人类发端以来，所有的问题最终归结起来无非是生死的问题。宗教能以来生来世另一个世界，灵魂不朽的方式去面对这个话题，哲学不能。哲学要超越人自身有限性，去面对无限的问题\n\n## 1.3、怎么学哲学\n\n学哲学只能通过学哲学史来学习，无非是把前人走过的路都走一遍，然后去开创你的道路或者选择一条适合你的道路，学哲学史就是学哲学家的思想，但是读哲学家的书往往灰色难懂（列宁说读黑格尔的书是治疗失眠最好的药）。为什么？老子说，道可道，非常道，名可名，非常名。这个道是说不出来的，哲学家却一定要去说这个不可说的东西，而且他们都有自己的体会，通过他写的东西了解他的思想很难，哲学家要表达的东西在语言文字之外，所以要求我们必须了解他要解决什么问题？熟悉哲学家的术语，沿着哲学家的思路，理解哲学家的思想\n\n## 1.4、西方哲学的特点\n\n希腊人哲学思维的特点：（1）偏爱非个人性的，更关注带有普遍性的东西。（2）试图给事物的存在找出合理的原因\n\n# 2、哲学的诞生\n\n## 2.1、希腊思想的起源\n\n哲学诞生于古代希腊。古希腊哲学是西方哲学的发源地,希腊人堪称哲学的民族。他们不仅奠定了西方思想、概念和体系的基础,从而奠定了西方文明的基础,而且提出并讨论了几乎所有的哲学问题。正如恩格斯所说:“在希腊哲学的多种多样的形式中，差不多可以找到以后各种观点的胚胎、萌芽。”从时间上说,希腊哲学从公元前 6世纪左右开始形成，一直延续到公元6世纪初,前后一千多年。公元 529 年,皈依了基督教的东罗马帝国皇帝查士丁尼下令封闭了最后一所柏拉图学园,通常人们以这一年作为希腊哲学终结的标志。就其历史而言,希腊哲学经历了希腊古典时期、希腊化时期、罗马共和国时期和罗马帝国时期。人们有时也称这一时期的西方哲学为古希腊罗马哲学”,实际上这是不确切的。罗马人并没有给哲学贡献什么新的内容,所谓“罗马哲学”不过是希腊哲学的延续而已。\n\n一般说来，人类文明的发展必须克服来自外在的和内在的两方面的限制:外在的限制是人类生活于其中的自然环境,他必须通过认识自然和改造自然的实践活动求得生存,而人类克服外在自然之限制的根本方式就是以社会性的存在对付自然的挑战,这就形成了所谓内在的限制。为了在自然中生存下去,人类结成了社会,而宗教、神话、宗法、伦理等成文与不成文的规范就成了维系人类社会存在的纽带,这些东西既可以是一个社会保持其存在的支柱，同时也最终会成为社会进步和新思想产生的阻碍。由此可见,希腊理性的诞生的确在很大程度上得益于希腊文明的“中断”,这一中断使希腊人比较少地受传统的限制和束缚,使新思想的产生和传播有了一个比较自由的空间\n\n## 2.2、希腊哲学的基本特征\n\n1. 希腊哲学的主题是获得关于宇宙万物的必然性或规律的知识：在他们看来,宇宙万物的主宰不是宙斯,因为即使众神也要服从命运和必然性。人世间的战争源自诸神之间的争吵,而诸神之间的争吵则是连宙斯也控制不了的命运。尽管希腊人承认一切都是由命运和必然性所决定的,但是他们并不因此就对命运采取放任自流漠不关心的态度，而是义无反顾地逃避或抗争\n2. 希腊哲学的经验主义：希腊哲学的时代不是建构理论体系的时代,而是探索的时代,哲学家们从事哲学思考的目的不在于建立体系而在于解决问题。因此,希腊哲学在方法上就具有某种“经验主义”的特征\n\n# 3、苏格拉底的问题\n\n希腊哲学的繁荣时期是“雅典时期”,大体上指公元前 5 世纪到公元前4世纪40年代马其顿统一希腊以前的一百多年在这一时期希腊城邦制从繁荣走向衰落,而希腊哲学却达到了它的鼎盛。这一时期哲学的主要代表是具有师承关系的三位哲学家:苏格拉底、苏格拉底的学生柏拉图和柏拉图的学生亚里士多德\n\n苏格拉底(Socrates,公元前 469一公元前 399)出生在雅典做过阿那克萨戈拉的学生阿尔克劳的学生。阿那克萨戈拉有一项功绩就是将哲学从外邦带回了希腊本土,带到了雅典。苏格拉底与孔子、释牟尼和耶稣等人并称人类的导师,他虽然没有写过什么哲学著作,但却以他的言行对西方文明产生了至今难以估量的深刻影响。有人可能会问,既然苏格拉底没有写过哲学著作,我们如何能够了解他的哲学思想?主要通过苏格拉底的学生柏拉图和同时代人的回忆和记录。柏拉图的哲学写作采取了对话的形式,其中绝大多数对话的主角都是苏格拉底。当然,由此亦产生了另一个问题:在这些对话中,究竟哪些是苏格拉底的思想,哪些是柏拉图自己的思想?实际上,这是很难区分的。学术界一般将柏拉图早期的一些主要讨论伦理学问题的对话称之为“苏格拉底对话”,根据其他的一些证据例如亚里士多德的记述,梳理出苏格拉底本人的思想\n\n## 3.1、智者运动\n所谓“智者”,古希腊语为 sophistes,原本泛指有智有识有才之士,例如“七贤”,雅典最早的改革家梭伦和哲学始祖泰勒斯都名列七贤。但是到了公元前 5世纪时，“智者”一词则专指一批收费授徒、重点教授修辞学和论辩术并以此为职业的教师。智者的出现是雅典民主制的产物。城邦民主制度意味着话语具有压倒其他一切权力手段的特殊优势。话语成为重要的政治工具,国家一切权力的关键,指挥和统治他人的方式。于是,修辞学和论辩术便应运而生,并且得到了迅速的发展。从智者的角度说,他们关心的只是论的效果，至于真假、善恶，是非、曲直,他们是不管的。不但不管,为了赢得更多的学生,他们还有意模糊是非善恶的界限,声称世界上本来没有什么善恶是非,只要你掌握了论辩的技术,你就是是非善恶的标准。所以他们经常允诺说,他们在任何情况下都可以帮助你说服他人。这就是说,智者可以帮助你证明煤是黑的,雪是白的,也可以帮助你证明煤是白的,雪是黑的。当然,智者的确使雅典的政治生活越来越不正常,但是政治生活不正常的根本原因不在智者而在于民主制的衰落。不过,智者的泛滥的确进一步加速了民主制的衰落。\n\n这也就是为什么苏格拉底柏拉图和亚里士多德都把智者当作批判对象的原因。因此在相当长的历史时期内,智者们声名狼藉,俨然就是哲学的“敌人”,以至于“智者”这个概念一向都被看做是“诡”的同义语,直到黑格尔才恢复了智者的本来面目,开始比较客观地评价智者的地位\n\n## 3.2、苏格拉底之死\n公元前399年，苏格拉底以引进新神、毒害青年的罪名被雅典公民大会判决服毒自杀。苏格拉底之死，一般都认为是标榜典范民主的古希腊城邦文明的一大污点，甚至是批判者反对民主政治的头号素材 \n\n表面看来,苏格拉底提倡的原则即使不是反民主制的也是非民主制的,至少在雅典人看来是这样的。城邦民主制的基本原则是每一个公民都有参加政治生活的权利和义务,这就是说,他们用不着学习就天生票赋正义感,就知道怎样决定城邦的大事,这可以说是雅典民主制的根本原则。然而苏格拉底可不这么看。他认为雅典之所以衰落了,根本原因就在于民主制的原则出了问题。正如做鞋子的工匠必须懂得做鞋子的知识一样,管理城邦也需要专门的知识。如果让不懂得治国的民众决定城邦大事,不可能治理好城邦。所以,苏格拉底鼓吹专家治国论。但是,雅典人无论如何难以接受苏格拉底的理论,因为那完全违背了民主制的基本原则。显然,这种专家治国论与城邦民主制是相互矛盾的。\n\n苏格拉底属于那种实践哲学家,他一生探索真理,虽然没有留下任何著作,但却留下了许多故事。使生苏格拉底死,使死苏格拉底生的,就是他对知识的不懈追求。在城邦民主制度衰落的背景下,苏格拉底试图通过知识来挽救雅典。在他看来,对任何事物,我们只有具有了知识才能知道怎样做和做得更好。所以,他给自己安排的工作就是在任何一种公共场合与人交谈,刺激人们的求知欲,让人们知道自己是无知的。他自比牛虹（hong）,说雅典这匹马太迟钝了,需要有人时不时地刺激它一下。在某种意义上说,苏格拉底企图通过自己的死来唤醒雅典人的良知,雅典人后来也的确觉悟了,为苏格拉底平了反,也惩罚了起诉苏格拉底的人:按照雅典的法律规定,你起诉他人如果败诉,你就必须承担法律责任。换言之,你起诉别人,如果别人没有问题,那就是你有问题。可惜的是,即使雅典人觉悟了,也仍然无能为力。苏格拉底的思想集中表现在“德性即知识”的学说之中。\n\n## 3.3、德性即知识\n\n对苏格拉底而言,认识人自己就是认识心灵的内在原则,亦即认识“德性“。德性是人之为人的本性,由神平均分配给了每一个人,因而人人都具有德性。但是说人人都有“德性”,并非指现实地拥有,而是潜在地拥有。换言之,人并不是生来就符合人的本性,只有在理性指导下认识自己的德性,才能使之实现出来,成为现实的和真正的善。所以苏格拉底认为,未经理性审慎的生活是没有价值的，一个人只有真正认识了他自己,才能实现自己的本性,完成自己的使命,成为一个有德性的人。因此,他把德性与知识等同起来,得出了“知识即德性,无知即罪恶”“无人有意作恶”的结论。在苏格拉底看来,趋善避恶是人的本性,没有人志愿追求恶或他认为恶的东西,是行善还是作恶,关键取决于他的知识,因而每个人在他有知识的事情上是善的,在他无知识的事情上则是恶的。\n\n\n\n# 4、柏拉图的“洞穴”\n\n","source":"_posts/西方哲学史.md","raw":"---\ntitle: 西方哲学史\ndate: 2023/10/28\ncategories:\n  - 生活\ntags:\n  - 哲学\n  - 西方哲学\nabbrlink: 40984\n---\n\n\n\n# 1、智慧的痛苦\n\n## 1.1、什么是哲学\n\n1. 关于哲学错误的看法：\n\n（1）哲学是科学：它不具备一门科学知识应该具备的最基本特征：普遍性和必然性\n（2）哲学是让人聪明的学问：哲学的理论学说都处在众说纷纭，莫衷一事的处境中。那么你想想学哲学会让你聪明还是糊涂\n（3）哲学是讲道理的学问：哲学是讲大道理的，可是哲学这个大道理大到什么程度，大到没有办法去印证的程度。那么道理道理之间的冲突就变成没有道理\n\t哲学往往被看做是为意识形态服务的工具，今天是这样一种政策，理论家们就要给我论证它的理论基础，非常完善的一套逻辑，过一段时间政策变了，还是这群哲学家，仍然还可以给你论证那套基础。不恰当的讲，可以把煤球论证成黑的，也可以论证成白的。\n\t科学知识的对象 -> 现实性\n\t哲学的对象 -> 理想性，带有乌托邦的性质，它是人们不满足于这个世界，而为它建立的一个理想世界，但每个人不同的时代社会和所处的环境，使人们对这个理想的境界理解不同\n（4）哲学无用，无用只用，是为大用。所有学科都比哲学有用，但是是唯有哲学是自由的学问，因为所有的学科都有前提，都有它服务的对象，但唯独哲学是为了自身而被追求的知识。哲学是自由人的学问。哲学应该是人的精神家园\n\n2. 哲学的理解\n\n哲学是希腊语philosophia : philos + sophia （哲学：爱智慧）。亚里士多德说，智慧这个词太大了，它只适合神而不适合人，我们只能爱智慧。哲学和科学一样讲理性，哲学又和宗教一样，起源于终极关怀的问题。看起来哲学相比宗教和科学，处在一个有利的位置，但恰恰是这个位置，让它看起来很尴尬，为什么？科学讲这个世界，宗教关注另一个世界。哲学想把这两个东西打通，它既不能靠理论说服宗教，又不能靠信仰阐述科学。哲学给我们提供了一条一条解决问题的道路，没有任何一条道路通达到了智慧的顶点，但是每条道路都是一个典型\n\n## 1.2、智慧的痛苦\n\n哲学既然没有解决问题，为什么还要追问问题？\n亚当是按照神的形象创造的，神把亚当安置在伊甸园，一个美丽的地方，哪里，到处都是结出甜美果实的树木。其中有两棵树，都有不同的作用，一棵是生命树，享受永生，一棵是知识树，里面充满着恶欲和邪淫。亚当唯一的命令是:“除了智慧树的果子，你可以吃任何你想吃的果子!”神在亚当陷入了沉睡，他取下他的一侧肋骨，形成夏娃。然后他把她带到亚当那里，亚当和他的新婚妻子感到了满足。亚当和夏娃被造的时候并没有邪恶的倾向，他们觉得不穿衣服没有什么不对。然而，这种情况很快就改变了。蛇是神所创造的所有野兽中最狡猾的，它靠近夏娃，慢慢地，淡定说服并迫使夏娃吃智慧树的果实。接着，她和丈夫亚分享了果实。亚当和夏娃立刻意识到自己是赤身露体的，便用无花果叶缝的带子束身。他们违背了神的命令的报应很快会到来:夏娃被诅咒要忍受怀孕、生产和抚养孩子的痛苦，还要屈从于她的丈夫。亚当的惩罚是：他必须在大地上劳作来生产粮食，人类的生命现在将以死亡结束。更重要的是，亚当和夏娃被驱逐出伊甸园。\n\n整个人类发端以来，所有的问题最终归结起来无非是生死的问题。宗教能以来生来世另一个世界，灵魂不朽的方式去面对这个话题，哲学不能。哲学要超越人自身有限性，去面对无限的问题\n\n## 1.3、怎么学哲学\n\n学哲学只能通过学哲学史来学习，无非是把前人走过的路都走一遍，然后去开创你的道路或者选择一条适合你的道路，学哲学史就是学哲学家的思想，但是读哲学家的书往往灰色难懂（列宁说读黑格尔的书是治疗失眠最好的药）。为什么？老子说，道可道，非常道，名可名，非常名。这个道是说不出来的，哲学家却一定要去说这个不可说的东西，而且他们都有自己的体会，通过他写的东西了解他的思想很难，哲学家要表达的东西在语言文字之外，所以要求我们必须了解他要解决什么问题？熟悉哲学家的术语，沿着哲学家的思路，理解哲学家的思想\n\n## 1.4、西方哲学的特点\n\n希腊人哲学思维的特点：（1）偏爱非个人性的，更关注带有普遍性的东西。（2）试图给事物的存在找出合理的原因\n\n# 2、哲学的诞生\n\n## 2.1、希腊思想的起源\n\n哲学诞生于古代希腊。古希腊哲学是西方哲学的发源地,希腊人堪称哲学的民族。他们不仅奠定了西方思想、概念和体系的基础,从而奠定了西方文明的基础,而且提出并讨论了几乎所有的哲学问题。正如恩格斯所说:“在希腊哲学的多种多样的形式中，差不多可以找到以后各种观点的胚胎、萌芽。”从时间上说,希腊哲学从公元前 6世纪左右开始形成，一直延续到公元6世纪初,前后一千多年。公元 529 年,皈依了基督教的东罗马帝国皇帝查士丁尼下令封闭了最后一所柏拉图学园,通常人们以这一年作为希腊哲学终结的标志。就其历史而言,希腊哲学经历了希腊古典时期、希腊化时期、罗马共和国时期和罗马帝国时期。人们有时也称这一时期的西方哲学为古希腊罗马哲学”,实际上这是不确切的。罗马人并没有给哲学贡献什么新的内容,所谓“罗马哲学”不过是希腊哲学的延续而已。\n\n一般说来，人类文明的发展必须克服来自外在的和内在的两方面的限制:外在的限制是人类生活于其中的自然环境,他必须通过认识自然和改造自然的实践活动求得生存,而人类克服外在自然之限制的根本方式就是以社会性的存在对付自然的挑战,这就形成了所谓内在的限制。为了在自然中生存下去,人类结成了社会,而宗教、神话、宗法、伦理等成文与不成文的规范就成了维系人类社会存在的纽带,这些东西既可以是一个社会保持其存在的支柱，同时也最终会成为社会进步和新思想产生的阻碍。由此可见,希腊理性的诞生的确在很大程度上得益于希腊文明的“中断”,这一中断使希腊人比较少地受传统的限制和束缚,使新思想的产生和传播有了一个比较自由的空间\n\n## 2.2、希腊哲学的基本特征\n\n1. 希腊哲学的主题是获得关于宇宙万物的必然性或规律的知识：在他们看来,宇宙万物的主宰不是宙斯,因为即使众神也要服从命运和必然性。人世间的战争源自诸神之间的争吵,而诸神之间的争吵则是连宙斯也控制不了的命运。尽管希腊人承认一切都是由命运和必然性所决定的,但是他们并不因此就对命运采取放任自流漠不关心的态度，而是义无反顾地逃避或抗争\n2. 希腊哲学的经验主义：希腊哲学的时代不是建构理论体系的时代,而是探索的时代,哲学家们从事哲学思考的目的不在于建立体系而在于解决问题。因此,希腊哲学在方法上就具有某种“经验主义”的特征\n\n# 3、苏格拉底的问题\n\n希腊哲学的繁荣时期是“雅典时期”,大体上指公元前 5 世纪到公元前4世纪40年代马其顿统一希腊以前的一百多年在这一时期希腊城邦制从繁荣走向衰落,而希腊哲学却达到了它的鼎盛。这一时期哲学的主要代表是具有师承关系的三位哲学家:苏格拉底、苏格拉底的学生柏拉图和柏拉图的学生亚里士多德\n\n苏格拉底(Socrates,公元前 469一公元前 399)出生在雅典做过阿那克萨戈拉的学生阿尔克劳的学生。阿那克萨戈拉有一项功绩就是将哲学从外邦带回了希腊本土,带到了雅典。苏格拉底与孔子、释牟尼和耶稣等人并称人类的导师,他虽然没有写过什么哲学著作,但却以他的言行对西方文明产生了至今难以估量的深刻影响。有人可能会问,既然苏格拉底没有写过哲学著作,我们如何能够了解他的哲学思想?主要通过苏格拉底的学生柏拉图和同时代人的回忆和记录。柏拉图的哲学写作采取了对话的形式,其中绝大多数对话的主角都是苏格拉底。当然,由此亦产生了另一个问题:在这些对话中,究竟哪些是苏格拉底的思想,哪些是柏拉图自己的思想?实际上,这是很难区分的。学术界一般将柏拉图早期的一些主要讨论伦理学问题的对话称之为“苏格拉底对话”,根据其他的一些证据例如亚里士多德的记述,梳理出苏格拉底本人的思想\n\n## 3.1、智者运动\n所谓“智者”,古希腊语为 sophistes,原本泛指有智有识有才之士,例如“七贤”,雅典最早的改革家梭伦和哲学始祖泰勒斯都名列七贤。但是到了公元前 5世纪时，“智者”一词则专指一批收费授徒、重点教授修辞学和论辩术并以此为职业的教师。智者的出现是雅典民主制的产物。城邦民主制度意味着话语具有压倒其他一切权力手段的特殊优势。话语成为重要的政治工具,国家一切权力的关键,指挥和统治他人的方式。于是,修辞学和论辩术便应运而生,并且得到了迅速的发展。从智者的角度说,他们关心的只是论的效果，至于真假、善恶，是非、曲直,他们是不管的。不但不管,为了赢得更多的学生,他们还有意模糊是非善恶的界限,声称世界上本来没有什么善恶是非,只要你掌握了论辩的技术,你就是是非善恶的标准。所以他们经常允诺说,他们在任何情况下都可以帮助你说服他人。这就是说,智者可以帮助你证明煤是黑的,雪是白的,也可以帮助你证明煤是白的,雪是黑的。当然,智者的确使雅典的政治生活越来越不正常,但是政治生活不正常的根本原因不在智者而在于民主制的衰落。不过,智者的泛滥的确进一步加速了民主制的衰落。\n\n这也就是为什么苏格拉底柏拉图和亚里士多德都把智者当作批判对象的原因。因此在相当长的历史时期内,智者们声名狼藉,俨然就是哲学的“敌人”,以至于“智者”这个概念一向都被看做是“诡”的同义语,直到黑格尔才恢复了智者的本来面目,开始比较客观地评价智者的地位\n\n## 3.2、苏格拉底之死\n公元前399年，苏格拉底以引进新神、毒害青年的罪名被雅典公民大会判决服毒自杀。苏格拉底之死，一般都认为是标榜典范民主的古希腊城邦文明的一大污点，甚至是批判者反对民主政治的头号素材 \n\n表面看来,苏格拉底提倡的原则即使不是反民主制的也是非民主制的,至少在雅典人看来是这样的。城邦民主制的基本原则是每一个公民都有参加政治生活的权利和义务,这就是说,他们用不着学习就天生票赋正义感,就知道怎样决定城邦的大事,这可以说是雅典民主制的根本原则。然而苏格拉底可不这么看。他认为雅典之所以衰落了,根本原因就在于民主制的原则出了问题。正如做鞋子的工匠必须懂得做鞋子的知识一样,管理城邦也需要专门的知识。如果让不懂得治国的民众决定城邦大事,不可能治理好城邦。所以,苏格拉底鼓吹专家治国论。但是,雅典人无论如何难以接受苏格拉底的理论,因为那完全违背了民主制的基本原则。显然,这种专家治国论与城邦民主制是相互矛盾的。\n\n苏格拉底属于那种实践哲学家,他一生探索真理,虽然没有留下任何著作,但却留下了许多故事。使生苏格拉底死,使死苏格拉底生的,就是他对知识的不懈追求。在城邦民主制度衰落的背景下,苏格拉底试图通过知识来挽救雅典。在他看来,对任何事物,我们只有具有了知识才能知道怎样做和做得更好。所以,他给自己安排的工作就是在任何一种公共场合与人交谈,刺激人们的求知欲,让人们知道自己是无知的。他自比牛虹（hong）,说雅典这匹马太迟钝了,需要有人时不时地刺激它一下。在某种意义上说,苏格拉底企图通过自己的死来唤醒雅典人的良知,雅典人后来也的确觉悟了,为苏格拉底平了反,也惩罚了起诉苏格拉底的人:按照雅典的法律规定,你起诉他人如果败诉,你就必须承担法律责任。换言之,你起诉别人,如果别人没有问题,那就是你有问题。可惜的是,即使雅典人觉悟了,也仍然无能为力。苏格拉底的思想集中表现在“德性即知识”的学说之中。\n\n## 3.3、德性即知识\n\n对苏格拉底而言,认识人自己就是认识心灵的内在原则,亦即认识“德性“。德性是人之为人的本性,由神平均分配给了每一个人,因而人人都具有德性。但是说人人都有“德性”,并非指现实地拥有,而是潜在地拥有。换言之,人并不是生来就符合人的本性,只有在理性指导下认识自己的德性,才能使之实现出来,成为现实的和真正的善。所以苏格拉底认为,未经理性审慎的生活是没有价值的，一个人只有真正认识了他自己,才能实现自己的本性,完成自己的使命,成为一个有德性的人。因此,他把德性与知识等同起来,得出了“知识即德性,无知即罪恶”“无人有意作恶”的结论。在苏格拉底看来,趋善避恶是人的本性,没有人志愿追求恶或他认为恶的东西,是行善还是作恶,关键取决于他的知识,因而每个人在他有知识的事情上是善的,在他无知识的事情上则是恶的。\n\n\n\n# 4、柏拉图的“洞穴”\n\n","slug":"西方哲学史","published":1,"updated":"2023-10-30T12:51:22.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sra5002v00uj386b1s96","content":"<h1 id=\"1、智慧的痛苦\"><a href=\"#1、智慧的痛苦\" class=\"headerlink\" title=\"1、智慧的痛苦\"></a>1、智慧的痛苦</h1><h2 id=\"1-1、什么是哲学\"><a href=\"#1-1、什么是哲学\" class=\"headerlink\" title=\"1.1、什么是哲学\"></a>1.1、什么是哲学</h2><ol>\n<li>关于哲学错误的看法：</li>\n</ol>\n<p>（1）哲学是科学：它不具备一门科学知识应该具备的最基本特征：普遍性和必然性<br>（2）哲学是让人聪明的学问：哲学的理论学说都处在众说纷纭，莫衷一事的处境中。那么你想想学哲学会让你聪明还是糊涂<br>（3）哲学是讲道理的学问：哲学是讲大道理的，可是哲学这个大道理大到什么程度，大到没有办法去印证的程度。那么道理道理之间的冲突就变成没有道理<br>    哲学往往被看做是为意识形态服务的工具，今天是这样一种政策，理论家们就要给我论证它的理论基础，非常完善的一套逻辑，过一段时间政策变了，还是这群哲学家，仍然还可以给你论证那套基础。不恰当的讲，可以把煤球论证成黑的，也可以论证成白的。<br>    科学知识的对象 -&gt; 现实性<br>    哲学的对象 -&gt; 理想性，带有乌托邦的性质，它是人们不满足于这个世界，而为它建立的一个理想世界，但每个人不同的时代社会和所处的环境，使人们对这个理想的境界理解不同<br>（4）哲学无用，无用只用，是为大用。所有学科都比哲学有用，但是是唯有哲学是自由的学问，因为所有的学科都有前提，都有它服务的对象，但唯独哲学是为了自身而被追求的知识。哲学是自由人的学问。哲学应该是人的精神家园</p>\n<ol start=\"2\">\n<li>哲学的理解</li>\n</ol>\n<p>哲学是希腊语philosophia : philos + sophia （哲学：爱智慧）。亚里士多德说，智慧这个词太大了，它只适合神而不适合人，我们只能爱智慧。哲学和科学一样讲理性，哲学又和宗教一样，起源于终极关怀的问题。看起来哲学相比宗教和科学，处在一个有利的位置，但恰恰是这个位置，让它看起来很尴尬，为什么？科学讲这个世界，宗教关注另一个世界。哲学想把这两个东西打通，它既不能靠理论说服宗教，又不能靠信仰阐述科学。哲学给我们提供了一条一条解决问题的道路，没有任何一条道路通达到了智慧的顶点，但是每条道路都是一个典型</p>\n<h2 id=\"1-2、智慧的痛苦\"><a href=\"#1-2、智慧的痛苦\" class=\"headerlink\" title=\"1.2、智慧的痛苦\"></a>1.2、智慧的痛苦</h2><p>哲学既然没有解决问题，为什么还要追问问题？<br>亚当是按照神的形象创造的，神把亚当安置在伊甸园，一个美丽的地方，哪里，到处都是结出甜美果实的树木。其中有两棵树，都有不同的作用，一棵是生命树，享受永生，一棵是知识树，里面充满着恶欲和邪淫。亚当唯一的命令是:“除了智慧树的果子，你可以吃任何你想吃的果子!”神在亚当陷入了沉睡，他取下他的一侧肋骨，形成夏娃。然后他把她带到亚当那里，亚当和他的新婚妻子感到了满足。亚当和夏娃被造的时候并没有邪恶的倾向，他们觉得不穿衣服没有什么不对。然而，这种情况很快就改变了。蛇是神所创造的所有野兽中最狡猾的，它靠近夏娃，慢慢地，淡定说服并迫使夏娃吃智慧树的果实。接着，她和丈夫亚分享了果实。亚当和夏娃立刻意识到自己是赤身露体的，便用无花果叶缝的带子束身。他们违背了神的命令的报应很快会到来:夏娃被诅咒要忍受怀孕、生产和抚养孩子的痛苦，还要屈从于她的丈夫。亚当的惩罚是：他必须在大地上劳作来生产粮食，人类的生命现在将以死亡结束。更重要的是，亚当和夏娃被驱逐出伊甸园。</p>\n<p>整个人类发端以来，所有的问题最终归结起来无非是生死的问题。宗教能以来生来世另一个世界，灵魂不朽的方式去面对这个话题，哲学不能。哲学要超越人自身有限性，去面对无限的问题</p>\n<h2 id=\"1-3、怎么学哲学\"><a href=\"#1-3、怎么学哲学\" class=\"headerlink\" title=\"1.3、怎么学哲学\"></a>1.3、怎么学哲学</h2><p>学哲学只能通过学哲学史来学习，无非是把前人走过的路都走一遍，然后去开创你的道路或者选择一条适合你的道路，学哲学史就是学哲学家的思想，但是读哲学家的书往往灰色难懂（列宁说读黑格尔的书是治疗失眠最好的药）。为什么？老子说，道可道，非常道，名可名，非常名。这个道是说不出来的，哲学家却一定要去说这个不可说的东西，而且他们都有自己的体会，通过他写的东西了解他的思想很难，哲学家要表达的东西在语言文字之外，所以要求我们必须了解他要解决什么问题？熟悉哲学家的术语，沿着哲学家的思路，理解哲学家的思想</p>\n<h2 id=\"1-4、西方哲学的特点\"><a href=\"#1-4、西方哲学的特点\" class=\"headerlink\" title=\"1.4、西方哲学的特点\"></a>1.4、西方哲学的特点</h2><p>希腊人哲学思维的特点：（1）偏爱非个人性的，更关注带有普遍性的东西。（2）试图给事物的存在找出合理的原因</p>\n<h1 id=\"2、哲学的诞生\"><a href=\"#2、哲学的诞生\" class=\"headerlink\" title=\"2、哲学的诞生\"></a>2、哲学的诞生</h1><h2 id=\"2-1、希腊思想的起源\"><a href=\"#2-1、希腊思想的起源\" class=\"headerlink\" title=\"2.1、希腊思想的起源\"></a>2.1、希腊思想的起源</h2><p>哲学诞生于古代希腊。古希腊哲学是西方哲学的发源地,希腊人堪称哲学的民族。他们不仅奠定了西方思想、概念和体系的基础,从而奠定了西方文明的基础,而且提出并讨论了几乎所有的哲学问题。正如恩格斯所说:“在希腊哲学的多种多样的形式中，差不多可以找到以后各种观点的胚胎、萌芽。”从时间上说,希腊哲学从公元前 6世纪左右开始形成，一直延续到公元6世纪初,前后一千多年。公元 529 年,皈依了基督教的东罗马帝国皇帝查士丁尼下令封闭了最后一所柏拉图学园,通常人们以这一年作为希腊哲学终结的标志。就其历史而言,希腊哲学经历了希腊古典时期、希腊化时期、罗马共和国时期和罗马帝国时期。人们有时也称这一时期的西方哲学为古希腊罗马哲学”,实际上这是不确切的。罗马人并没有给哲学贡献什么新的内容,所谓“罗马哲学”不过是希腊哲学的延续而已。</p>\n<p>一般说来，人类文明的发展必须克服来自外在的和内在的两方面的限制:外在的限制是人类生活于其中的自然环境,他必须通过认识自然和改造自然的实践活动求得生存,而人类克服外在自然之限制的根本方式就是以社会性的存在对付自然的挑战,这就形成了所谓内在的限制。为了在自然中生存下去,人类结成了社会,而宗教、神话、宗法、伦理等成文与不成文的规范就成了维系人类社会存在的纽带,这些东西既可以是一个社会保持其存在的支柱，同时也最终会成为社会进步和新思想产生的阻碍。由此可见,希腊理性的诞生的确在很大程度上得益于希腊文明的“中断”,这一中断使希腊人比较少地受传统的限制和束缚,使新思想的产生和传播有了一个比较自由的空间</p>\n<h2 id=\"2-2、希腊哲学的基本特征\"><a href=\"#2-2、希腊哲学的基本特征\" class=\"headerlink\" title=\"2.2、希腊哲学的基本特征\"></a>2.2、希腊哲学的基本特征</h2><ol>\n<li>希腊哲学的主题是获得关于宇宙万物的必然性或规律的知识：在他们看来,宇宙万物的主宰不是宙斯,因为即使众神也要服从命运和必然性。人世间的战争源自诸神之间的争吵,而诸神之间的争吵则是连宙斯也控制不了的命运。尽管希腊人承认一切都是由命运和必然性所决定的,但是他们并不因此就对命运采取放任自流漠不关心的态度，而是义无反顾地逃避或抗争</li>\n<li>希腊哲学的经验主义：希腊哲学的时代不是建构理论体系的时代,而是探索的时代,哲学家们从事哲学思考的目的不在于建立体系而在于解决问题。因此,希腊哲学在方法上就具有某种“经验主义”的特征</li>\n</ol>\n<h1 id=\"3、苏格拉底的问题\"><a href=\"#3、苏格拉底的问题\" class=\"headerlink\" title=\"3、苏格拉底的问题\"></a>3、苏格拉底的问题</h1><p>希腊哲学的繁荣时期是“雅典时期”,大体上指公元前 5 世纪到公元前4世纪40年代马其顿统一希腊以前的一百多年在这一时期希腊城邦制从繁荣走向衰落,而希腊哲学却达到了它的鼎盛。这一时期哲学的主要代表是具有师承关系的三位哲学家:苏格拉底、苏格拉底的学生柏拉图和柏拉图的学生亚里士多德</p>\n<p>苏格拉底(Socrates,公元前 469一公元前 399)出生在雅典做过阿那克萨戈拉的学生阿尔克劳的学生。阿那克萨戈拉有一项功绩就是将哲学从外邦带回了希腊本土,带到了雅典。苏格拉底与孔子、释牟尼和耶稣等人并称人类的导师,他虽然没有写过什么哲学著作,但却以他的言行对西方文明产生了至今难以估量的深刻影响。有人可能会问,既然苏格拉底没有写过哲学著作,我们如何能够了解他的哲学思想?主要通过苏格拉底的学生柏拉图和同时代人的回忆和记录。柏拉图的哲学写作采取了对话的形式,其中绝大多数对话的主角都是苏格拉底。当然,由此亦产生了另一个问题:在这些对话中,究竟哪些是苏格拉底的思想,哪些是柏拉图自己的思想?实际上,这是很难区分的。学术界一般将柏拉图早期的一些主要讨论伦理学问题的对话称之为“苏格拉底对话”,根据其他的一些证据例如亚里士多德的记述,梳理出苏格拉底本人的思想</p>\n<h2 id=\"3-1、智者运动\"><a href=\"#3-1、智者运动\" class=\"headerlink\" title=\"3.1、智者运动\"></a>3.1、智者运动</h2><p>所谓“智者”,古希腊语为 sophistes,原本泛指有智有识有才之士,例如“七贤”,雅典最早的改革家梭伦和哲学始祖泰勒斯都名列七贤。但是到了公元前 5世纪时，“智者”一词则专指一批收费授徒、重点教授修辞学和论辩术并以此为职业的教师。智者的出现是雅典民主制的产物。城邦民主制度意味着话语具有压倒其他一切权力手段的特殊优势。话语成为重要的政治工具,国家一切权力的关键,指挥和统治他人的方式。于是,修辞学和论辩术便应运而生,并且得到了迅速的发展。从智者的角度说,他们关心的只是论的效果，至于真假、善恶，是非、曲直,他们是不管的。不但不管,为了赢得更多的学生,他们还有意模糊是非善恶的界限,声称世界上本来没有什么善恶是非,只要你掌握了论辩的技术,你就是是非善恶的标准。所以他们经常允诺说,他们在任何情况下都可以帮助你说服他人。这就是说,智者可以帮助你证明煤是黑的,雪是白的,也可以帮助你证明煤是白的,雪是黑的。当然,智者的确使雅典的政治生活越来越不正常,但是政治生活不正常的根本原因不在智者而在于民主制的衰落。不过,智者的泛滥的确进一步加速了民主制的衰落。</p>\n<p>这也就是为什么苏格拉底柏拉图和亚里士多德都把智者当作批判对象的原因。因此在相当长的历史时期内,智者们声名狼藉,俨然就是哲学的“敌人”,以至于“智者”这个概念一向都被看做是“诡”的同义语,直到黑格尔才恢复了智者的本来面目,开始比较客观地评价智者的地位</p>\n<h2 id=\"3-2、苏格拉底之死\"><a href=\"#3-2、苏格拉底之死\" class=\"headerlink\" title=\"3.2、苏格拉底之死\"></a>3.2、苏格拉底之死</h2><p>公元前399年，苏格拉底以引进新神、毒害青年的罪名被雅典公民大会判决服毒自杀。苏格拉底之死，一般都认为是标榜典范民主的古希腊城邦文明的一大污点，甚至是批判者反对民主政治的头号素材 </p>\n<p>表面看来,苏格拉底提倡的原则即使不是反民主制的也是非民主制的,至少在雅典人看来是这样的。城邦民主制的基本原则是每一个公民都有参加政治生活的权利和义务,这就是说,他们用不着学习就天生票赋正义感,就知道怎样决定城邦的大事,这可以说是雅典民主制的根本原则。然而苏格拉底可不这么看。他认为雅典之所以衰落了,根本原因就在于民主制的原则出了问题。正如做鞋子的工匠必须懂得做鞋子的知识一样,管理城邦也需要专门的知识。如果让不懂得治国的民众决定城邦大事,不可能治理好城邦。所以,苏格拉底鼓吹专家治国论。但是,雅典人无论如何难以接受苏格拉底的理论,因为那完全违背了民主制的基本原则。显然,这种专家治国论与城邦民主制是相互矛盾的。</p>\n<p>苏格拉底属于那种实践哲学家,他一生探索真理,虽然没有留下任何著作,但却留下了许多故事。使生苏格拉底死,使死苏格拉底生的,就是他对知识的不懈追求。在城邦民主制度衰落的背景下,苏格拉底试图通过知识来挽救雅典。在他看来,对任何事物,我们只有具有了知识才能知道怎样做和做得更好。所以,他给自己安排的工作就是在任何一种公共场合与人交谈,刺激人们的求知欲,让人们知道自己是无知的。他自比牛虹（hong）,说雅典这匹马太迟钝了,需要有人时不时地刺激它一下。在某种意义上说,苏格拉底企图通过自己的死来唤醒雅典人的良知,雅典人后来也的确觉悟了,为苏格拉底平了反,也惩罚了起诉苏格拉底的人:按照雅典的法律规定,你起诉他人如果败诉,你就必须承担法律责任。换言之,你起诉别人,如果别人没有问题,那就是你有问题。可惜的是,即使雅典人觉悟了,也仍然无能为力。苏格拉底的思想集中表现在“德性即知识”的学说之中。</p>\n<h2 id=\"3-3、德性即知识\"><a href=\"#3-3、德性即知识\" class=\"headerlink\" title=\"3.3、德性即知识\"></a>3.3、德性即知识</h2><p>对苏格拉底而言,认识人自己就是认识心灵的内在原则,亦即认识“德性“。德性是人之为人的本性,由神平均分配给了每一个人,因而人人都具有德性。但是说人人都有“德性”,并非指现实地拥有,而是潜在地拥有。换言之,人并不是生来就符合人的本性,只有在理性指导下认识自己的德性,才能使之实现出来,成为现实的和真正的善。所以苏格拉底认为,未经理性审慎的生活是没有价值的，一个人只有真正认识了他自己,才能实现自己的本性,完成自己的使命,成为一个有德性的人。因此,他把德性与知识等同起来,得出了“知识即德性,无知即罪恶”“无人有意作恶”的结论。在苏格拉底看来,趋善避恶是人的本性,没有人志愿追求恶或他认为恶的东西,是行善还是作恶,关键取决于他的知识,因而每个人在他有知识的事情上是善的,在他无知识的事情上则是恶的。</p>\n<h1 id=\"4、柏拉图的“洞穴”\"><a href=\"#4、柏拉图的“洞穴”\" class=\"headerlink\" title=\"4、柏拉图的“洞穴”\"></a>4、柏拉图的“洞穴”</h1>","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、智慧的痛苦\"><a href=\"#1、智慧的痛苦\" class=\"headerlink\" title=\"1、智慧的痛苦\"></a>1、智慧的痛苦</h1><h2 id=\"1-1、什么是哲学\"><a href=\"#1-1、什么是哲学\" class=\"headerlink\" title=\"1.1、什么是哲学\"></a>1.1、什么是哲学</h2><ol>\n<li>关于哲学错误的看法：</li>\n</ol>\n<p>（1）哲学是科学：它不具备一门科学知识应该具备的最基本特征：普遍性和必然性<br>（2）哲学是让人聪明的学问：哲学的理论学说都处在众说纷纭，莫衷一事的处境中。那么你想想学哲学会让你聪明还是糊涂<br>（3）哲学是讲道理的学问：哲学是讲大道理的，可是哲学这个大道理大到什么程度，大到没有办法去印证的程度。那么道理道理之间的冲突就变成没有道理<br>    哲学往往被看做是为意识形态服务的工具，今天是这样一种政策，理论家们就要给我论证它的理论基础，非常完善的一套逻辑，过一段时间政策变了，还是这群哲学家，仍然还可以给你论证那套基础。不恰当的讲，可以把煤球论证成黑的，也可以论证成白的。<br>    科学知识的对象 -&gt; 现实性<br>    哲学的对象 -&gt; 理想性，带有乌托邦的性质，它是人们不满足于这个世界，而为它建立的一个理想世界，但每个人不同的时代社会和所处的环境，使人们对这个理想的境界理解不同<br>（4）哲学无用，无用只用，是为大用。所有学科都比哲学有用，但是是唯有哲学是自由的学问，因为所有的学科都有前提，都有它服务的对象，但唯独哲学是为了自身而被追求的知识。哲学是自由人的学问。哲学应该是人的精神家园</p>\n<ol start=\"2\">\n<li>哲学的理解</li>\n</ol>\n<p>哲学是希腊语philosophia : philos + sophia （哲学：爱智慧）。亚里士多德说，智慧这个词太大了，它只适合神而不适合人，我们只能爱智慧。哲学和科学一样讲理性，哲学又和宗教一样，起源于终极关怀的问题。看起来哲学相比宗教和科学，处在一个有利的位置，但恰恰是这个位置，让它看起来很尴尬，为什么？科学讲这个世界，宗教关注另一个世界。哲学想把这两个东西打通，它既不能靠理论说服宗教，又不能靠信仰阐述科学。哲学给我们提供了一条一条解决问题的道路，没有任何一条道路通达到了智慧的顶点，但是每条道路都是一个典型</p>\n<h2 id=\"1-2、智慧的痛苦\"><a href=\"#1-2、智慧的痛苦\" class=\"headerlink\" title=\"1.2、智慧的痛苦\"></a>1.2、智慧的痛苦</h2><p>哲学既然没有解决问题，为什么还要追问问题？<br>亚当是按照神的形象创造的，神把亚当安置在伊甸园，一个美丽的地方，哪里，到处都是结出甜美果实的树木。其中有两棵树，都有不同的作用，一棵是生命树，享受永生，一棵是知识树，里面充满着恶欲和邪淫。亚当唯一的命令是:“除了智慧树的果子，你可以吃任何你想吃的果子!”神在亚当陷入了沉睡，他取下他的一侧肋骨，形成夏娃。然后他把她带到亚当那里，亚当和他的新婚妻子感到了满足。亚当和夏娃被造的时候并没有邪恶的倾向，他们觉得不穿衣服没有什么不对。然而，这种情况很快就改变了。蛇是神所创造的所有野兽中最狡猾的，它靠近夏娃，慢慢地，淡定说服并迫使夏娃吃智慧树的果实。接着，她和丈夫亚分享了果实。亚当和夏娃立刻意识到自己是赤身露体的，便用无花果叶缝的带子束身。他们违背了神的命令的报应很快会到来:夏娃被诅咒要忍受怀孕、生产和抚养孩子的痛苦，还要屈从于她的丈夫。亚当的惩罚是：他必须在大地上劳作来生产粮食，人类的生命现在将以死亡结束。更重要的是，亚当和夏娃被驱逐出伊甸园。</p>\n<p>整个人类发端以来，所有的问题最终归结起来无非是生死的问题。宗教能以来生来世另一个世界，灵魂不朽的方式去面对这个话题，哲学不能。哲学要超越人自身有限性，去面对无限的问题</p>\n<h2 id=\"1-3、怎么学哲学\"><a href=\"#1-3、怎么学哲学\" class=\"headerlink\" title=\"1.3、怎么学哲学\"></a>1.3、怎么学哲学</h2><p>学哲学只能通过学哲学史来学习，无非是把前人走过的路都走一遍，然后去开创你的道路或者选择一条适合你的道路，学哲学史就是学哲学家的思想，但是读哲学家的书往往灰色难懂（列宁说读黑格尔的书是治疗失眠最好的药）。为什么？老子说，道可道，非常道，名可名，非常名。这个道是说不出来的，哲学家却一定要去说这个不可说的东西，而且他们都有自己的体会，通过他写的东西了解他的思想很难，哲学家要表达的东西在语言文字之外，所以要求我们必须了解他要解决什么问题？熟悉哲学家的术语，沿着哲学家的思路，理解哲学家的思想</p>\n<h2 id=\"1-4、西方哲学的特点\"><a href=\"#1-4、西方哲学的特点\" class=\"headerlink\" title=\"1.4、西方哲学的特点\"></a>1.4、西方哲学的特点</h2><p>希腊人哲学思维的特点：（1）偏爱非个人性的，更关注带有普遍性的东西。（2）试图给事物的存在找出合理的原因</p>\n<h1 id=\"2、哲学的诞生\"><a href=\"#2、哲学的诞生\" class=\"headerlink\" title=\"2、哲学的诞生\"></a>2、哲学的诞生</h1><h2 id=\"2-1、希腊思想的起源\"><a href=\"#2-1、希腊思想的起源\" class=\"headerlink\" title=\"2.1、希腊思想的起源\"></a>2.1、希腊思想的起源</h2><p>哲学诞生于古代希腊。古希腊哲学是西方哲学的发源地,希腊人堪称哲学的民族。他们不仅奠定了西方思想、概念和体系的基础,从而奠定了西方文明的基础,而且提出并讨论了几乎所有的哲学问题。正如恩格斯所说:“在希腊哲学的多种多样的形式中，差不多可以找到以后各种观点的胚胎、萌芽。”从时间上说,希腊哲学从公元前 6世纪左右开始形成，一直延续到公元6世纪初,前后一千多年。公元 529 年,皈依了基督教的东罗马帝国皇帝查士丁尼下令封闭了最后一所柏拉图学园,通常人们以这一年作为希腊哲学终结的标志。就其历史而言,希腊哲学经历了希腊古典时期、希腊化时期、罗马共和国时期和罗马帝国时期。人们有时也称这一时期的西方哲学为古希腊罗马哲学”,实际上这是不确切的。罗马人并没有给哲学贡献什么新的内容,所谓“罗马哲学”不过是希腊哲学的延续而已。</p>\n<p>一般说来，人类文明的发展必须克服来自外在的和内在的两方面的限制:外在的限制是人类生活于其中的自然环境,他必须通过认识自然和改造自然的实践活动求得生存,而人类克服外在自然之限制的根本方式就是以社会性的存在对付自然的挑战,这就形成了所谓内在的限制。为了在自然中生存下去,人类结成了社会,而宗教、神话、宗法、伦理等成文与不成文的规范就成了维系人类社会存在的纽带,这些东西既可以是一个社会保持其存在的支柱，同时也最终会成为社会进步和新思想产生的阻碍。由此可见,希腊理性的诞生的确在很大程度上得益于希腊文明的“中断”,这一中断使希腊人比较少地受传统的限制和束缚,使新思想的产生和传播有了一个比较自由的空间</p>\n<h2 id=\"2-2、希腊哲学的基本特征\"><a href=\"#2-2、希腊哲学的基本特征\" class=\"headerlink\" title=\"2.2、希腊哲学的基本特征\"></a>2.2、希腊哲学的基本特征</h2><ol>\n<li>希腊哲学的主题是获得关于宇宙万物的必然性或规律的知识：在他们看来,宇宙万物的主宰不是宙斯,因为即使众神也要服从命运和必然性。人世间的战争源自诸神之间的争吵,而诸神之间的争吵则是连宙斯也控制不了的命运。尽管希腊人承认一切都是由命运和必然性所决定的,但是他们并不因此就对命运采取放任自流漠不关心的态度，而是义无反顾地逃避或抗争</li>\n<li>希腊哲学的经验主义：希腊哲学的时代不是建构理论体系的时代,而是探索的时代,哲学家们从事哲学思考的目的不在于建立体系而在于解决问题。因此,希腊哲学在方法上就具有某种“经验主义”的特征</li>\n</ol>\n<h1 id=\"3、苏格拉底的问题\"><a href=\"#3、苏格拉底的问题\" class=\"headerlink\" title=\"3、苏格拉底的问题\"></a>3、苏格拉底的问题</h1><p>希腊哲学的繁荣时期是“雅典时期”,大体上指公元前 5 世纪到公元前4世纪40年代马其顿统一希腊以前的一百多年在这一时期希腊城邦制从繁荣走向衰落,而希腊哲学却达到了它的鼎盛。这一时期哲学的主要代表是具有师承关系的三位哲学家:苏格拉底、苏格拉底的学生柏拉图和柏拉图的学生亚里士多德</p>\n<p>苏格拉底(Socrates,公元前 469一公元前 399)出生在雅典做过阿那克萨戈拉的学生阿尔克劳的学生。阿那克萨戈拉有一项功绩就是将哲学从外邦带回了希腊本土,带到了雅典。苏格拉底与孔子、释牟尼和耶稣等人并称人类的导师,他虽然没有写过什么哲学著作,但却以他的言行对西方文明产生了至今难以估量的深刻影响。有人可能会问,既然苏格拉底没有写过哲学著作,我们如何能够了解他的哲学思想?主要通过苏格拉底的学生柏拉图和同时代人的回忆和记录。柏拉图的哲学写作采取了对话的形式,其中绝大多数对话的主角都是苏格拉底。当然,由此亦产生了另一个问题:在这些对话中,究竟哪些是苏格拉底的思想,哪些是柏拉图自己的思想?实际上,这是很难区分的。学术界一般将柏拉图早期的一些主要讨论伦理学问题的对话称之为“苏格拉底对话”,根据其他的一些证据例如亚里士多德的记述,梳理出苏格拉底本人的思想</p>\n<h2 id=\"3-1、智者运动\"><a href=\"#3-1、智者运动\" class=\"headerlink\" title=\"3.1、智者运动\"></a>3.1、智者运动</h2><p>所谓“智者”,古希腊语为 sophistes,原本泛指有智有识有才之士,例如“七贤”,雅典最早的改革家梭伦和哲学始祖泰勒斯都名列七贤。但是到了公元前 5世纪时，“智者”一词则专指一批收费授徒、重点教授修辞学和论辩术并以此为职业的教师。智者的出现是雅典民主制的产物。城邦民主制度意味着话语具有压倒其他一切权力手段的特殊优势。话语成为重要的政治工具,国家一切权力的关键,指挥和统治他人的方式。于是,修辞学和论辩术便应运而生,并且得到了迅速的发展。从智者的角度说,他们关心的只是论的效果，至于真假、善恶，是非、曲直,他们是不管的。不但不管,为了赢得更多的学生,他们还有意模糊是非善恶的界限,声称世界上本来没有什么善恶是非,只要你掌握了论辩的技术,你就是是非善恶的标准。所以他们经常允诺说,他们在任何情况下都可以帮助你说服他人。这就是说,智者可以帮助你证明煤是黑的,雪是白的,也可以帮助你证明煤是白的,雪是黑的。当然,智者的确使雅典的政治生活越来越不正常,但是政治生活不正常的根本原因不在智者而在于民主制的衰落。不过,智者的泛滥的确进一步加速了民主制的衰落。</p>\n<p>这也就是为什么苏格拉底柏拉图和亚里士多德都把智者当作批判对象的原因。因此在相当长的历史时期内,智者们声名狼藉,俨然就是哲学的“敌人”,以至于“智者”这个概念一向都被看做是“诡”的同义语,直到黑格尔才恢复了智者的本来面目,开始比较客观地评价智者的地位</p>\n<h2 id=\"3-2、苏格拉底之死\"><a href=\"#3-2、苏格拉底之死\" class=\"headerlink\" title=\"3.2、苏格拉底之死\"></a>3.2、苏格拉底之死</h2><p>公元前399年，苏格拉底以引进新神、毒害青年的罪名被雅典公民大会判决服毒自杀。苏格拉底之死，一般都认为是标榜典范民主的古希腊城邦文明的一大污点，甚至是批判者反对民主政治的头号素材 </p>\n<p>表面看来,苏格拉底提倡的原则即使不是反民主制的也是非民主制的,至少在雅典人看来是这样的。城邦民主制的基本原则是每一个公民都有参加政治生活的权利和义务,这就是说,他们用不着学习就天生票赋正义感,就知道怎样决定城邦的大事,这可以说是雅典民主制的根本原则。然而苏格拉底可不这么看。他认为雅典之所以衰落了,根本原因就在于民主制的原则出了问题。正如做鞋子的工匠必须懂得做鞋子的知识一样,管理城邦也需要专门的知识。如果让不懂得治国的民众决定城邦大事,不可能治理好城邦。所以,苏格拉底鼓吹专家治国论。但是,雅典人无论如何难以接受苏格拉底的理论,因为那完全违背了民主制的基本原则。显然,这种专家治国论与城邦民主制是相互矛盾的。</p>\n<p>苏格拉底属于那种实践哲学家,他一生探索真理,虽然没有留下任何著作,但却留下了许多故事。使生苏格拉底死,使死苏格拉底生的,就是他对知识的不懈追求。在城邦民主制度衰落的背景下,苏格拉底试图通过知识来挽救雅典。在他看来,对任何事物,我们只有具有了知识才能知道怎样做和做得更好。所以,他给自己安排的工作就是在任何一种公共场合与人交谈,刺激人们的求知欲,让人们知道自己是无知的。他自比牛虹（hong）,说雅典这匹马太迟钝了,需要有人时不时地刺激它一下。在某种意义上说,苏格拉底企图通过自己的死来唤醒雅典人的良知,雅典人后来也的确觉悟了,为苏格拉底平了反,也惩罚了起诉苏格拉底的人:按照雅典的法律规定,你起诉他人如果败诉,你就必须承担法律责任。换言之,你起诉别人,如果别人没有问题,那就是你有问题。可惜的是,即使雅典人觉悟了,也仍然无能为力。苏格拉底的思想集中表现在“德性即知识”的学说之中。</p>\n<h2 id=\"3-3、德性即知识\"><a href=\"#3-3、德性即知识\" class=\"headerlink\" title=\"3.3、德性即知识\"></a>3.3、德性即知识</h2><p>对苏格拉底而言,认识人自己就是认识心灵的内在原则,亦即认识“德性“。德性是人之为人的本性,由神平均分配给了每一个人,因而人人都具有德性。但是说人人都有“德性”,并非指现实地拥有,而是潜在地拥有。换言之,人并不是生来就符合人的本性,只有在理性指导下认识自己的德性,才能使之实现出来,成为现实的和真正的善。所以苏格拉底认为,未经理性审慎的生活是没有价值的，一个人只有真正认识了他自己,才能实现自己的本性,完成自己的使命,成为一个有德性的人。因此,他把德性与知识等同起来,得出了“知识即德性,无知即罪恶”“无人有意作恶”的结论。在苏格拉底看来,趋善避恶是人的本性,没有人志愿追求恶或他认为恶的东西,是行善还是作恶,关键取决于他的知识,因而每个人在他有知识的事情上是善的,在他无知识的事情上则是恶的。</p>\n<h1 id=\"4、柏拉图的“洞穴”\"><a href=\"#4、柏拉图的“洞穴”\" class=\"headerlink\" title=\"4、柏拉图的“洞穴”\"></a>4、柏拉图的“洞穴”</h1>"},{"title":"中国古代史","date":"2023-08-09T16:00:00.000Z","updated":"2023-10-29T16:00:00.000Z","abbrlink":20848,"_content":"# 1、史前时期\n\n## 1.1、中国人种起源及生存环境\n\n人类进化链环的各个阶段，在中国境内大都可以找到对应的遗址。\n\n1. 直立人: 西侯度人(山西，180万年前)、元谋猿人(云南，170万年前)、蓝田人(陕西，115-70万年前)、北京猿人(70-23万年前)\n2. 早期智人 (古人)：长阳人(湖北，距今19.5万年)、丁村人(山西，距今20多万年）、大荔人（陕西，距今20-15万年前）\n3. 晚期智人（新人）：猿类特征已经退化，体质特征接近现代人。柳江人（距今5-4万年，广西），河套人（距今5-3.7万年，内蒙古），山顶洞人（距今3万年，北京）\n## 1.2、中国境内旧石器和新石器时代\n\n在考古学上，根据人类使用工具的进化程度不将历史划为:石器时代 (旧石器时代,新石器时代) -> 青铜时代 -> 铁器时代\n\n1. 旧石器时代：距今250万年-1万年，特点是使用粗糙的打制石器，过着采集和渔猎生活，相当于人类历史上的原始人阶段\n2. 新石器时代：距今1万-5000年，氏族公社时期，包括母系氏族公社和父系氏族公社，特点是使用磨制石器，能够制造陶和纺织，发明农业和畜牧业，有固定生活来源，不再依赖采集为生。（大汶口文化，红山文化，良渚文化，大溪文化，河姆渡文化，龙山文化）\n\n\n# 2、夏商周三代文明\n\n## 2.1、夏王朝\n\n### 2.1.1、夏朝年表\n\n夏朝（约前2070年－约前1600年，470年）是中国历史记载的第一个中原部族世袭制朝代\n\n|   序号   |   姓名      |   在位时长                 |   相关事件                            |\n|:-------|:----------|:-----------------------|:----------------------------------|\n|    1   |   禹       | 前2071-前2027（45年）     |   **涂山大会**，铸造九鼎，象征九州，第一次有了国家的概念   |\n|    2   |   启       | 前2026-前1988（39年）     |   由禅让制变为世袭制，击败了有扈氏的反抗             |\n|    3   |   太康      |     前1987-前1984（4年） |   不理朝政，被有穷氏后羿夺权，**太康失国**，实际在位2年   |\n|    4   |   仲康      |     前1983-前1977（7年） |   后羿专权，仲康反抗失败被软禁，抑郁而终             |\n|    5   |   相       |     前1976-前1949（28年） |   被寒浞的儿子浇攻破自刎，大臣寒浞杀后羿夺权           |\n|    6   |   少康/杜康   |     前1908-前1888（21年） |   相的遗腹子，攻杀寒浞，复国，**少康中兴**          |\n|    7   |   季杼      |     前1887-前1871（17年） |   参加过复兴夏朝的战争                      |\n|    8   |   槐/帝芬    |     前前1870-前1827（44年） |                                   |\n|    9   |   芒       |     前1826-前1769（58年） |                                   |\n|   10   |   泄/帝降    |     前1768-前1753（16年） |   正式赐封九夷各部诸侯爵位                    |\n|   11   |   不降      |     前1752-前1705（48年）  |                                   |\n|   12   |   扃       |     前1704-前1684（21年） |                                   |\n|   13   |   廑（jin）      |     前1683-前1676（8年） |   夏国开始衰落                          |\n|   14   |   孔甲      |     前1675-前1667（9年） |   胡作非为的残暴昏君                       |\n|   15   |   皋       |     前1666 -前1664（3年） |                                   |\n|   16   |   发       |     前1663-前1645（19年） |   各方诸侯已不来朝贺                       |\n|   17   |   桀       |     前1644-前1592（53年） |   暴君，被商汤灭，亡国                      | \n\n### 2.1.2、夏王朝的文献和史事\n\n目前关于夏王朝的主要文献资料来源于《史记·夏本纪》和《尚书》及《诗经》的部分记载。\n夏王朝始于禹。尧舜禹的禅让到禹时，发生了根本的变化。禹传位于其子启，确立了嫡子世袭制度。据《夏本纪》的材料，禹开始以天下授益\n就在传位于启不久，这个部落联盟中的有扈氏部族“不服”，向启提出了挑战。启伐之，大战于甘，有扈氏被灭。\n夏后帝启死后，子太康立。太康时失国，太康崩，弟中康立，是为帝中康。中康生子相。相时受到东夷族有穷氏(其首领为善射的羿)的压迫，在与有穷氏的战争中，夏王相被杀，但他的儿子少康最终取得胜利，这就是“少康复国。\n\n## 2.2、商王朝\n\n### 2.2.1、商朝年表\n\n商朝（约公元前1600年-约公元前1046年，554年）\n\n| 序号 | 姓名 | 别名 | 在位时长 | 相关事件 |\n| --- | --- | --- | --- | --- |\n| 1 | 商汤 | 天乙 | 前1600年-前1588年（13年） | 开国君主 鸣条之战 |\n| 2 | 商哀王 | 外丙 | 前1587年-前1586年（2年） |  |\n| 3 | 商懿王 | 仲壬 | 前1585年-前1582年（4年） |  |\n| 4 | 商太宗 | 太甲 | 前1582年-前1570年（13年） |  |\n| 5 | 商昭王 | 沃丁 | 前1570年-前1541年（29年） |  |\n| 6 | 商宣王 | 太庚 | 前1541年-前1516年（25年） |  |\n| 7 | 商敬王 | 小甲 | 前1516年-前1499年（17年） |  商朝始衰|\n| 8 | 商元王 | 雍己 | 前1487年-前1476年（12年） |  诸侯不来朝|\n| 9 | 商中宗 | 太戊 | 前1486年-前1412年（75年） | 小国又纷纷归顺，商朝中兴  |\n| 10 | 商孝成王 | 仲丁 | 前1418年-前1408年（13年） |  |\n| 11 | 商思王 | 外壬 | 前1407年-前1398年 （10年）| 九世之乱 |\n| 12 | 商前平王 | 河檀（dan）甲 | 前1397年-前1389年（9年） | 迁都河南内黄  |\n| 13 | 商穆王 | 祖乙 | 前1388年-前1370年（19年） |  |\n| 14 | 商桓王 | 祖辛 | 前1369年-前1356年（16年） |  |\n| 15 | 商僖（xi）王 | 沃甲 | 前1355年- 前1336年（20年） |  |\n| 16 | 商庄王 | 祖丁 | 前1335年- 前1327年（9年） |  |\n| 17 | 商顷王 | 南庚 | 前1326年-前1321年（6年） | 国都由庇（山东郓城）迁奄（山东曲阜） |\n| 18 | 商悼王 | 阳甲 | 前1321年- 前1314年（8年） |  |\n| 19 | 商世祖 | 盘庚 | 前1313年-前1286年（28年） | 迁都殷（河南安阳） |\n| 20 | 商章王 | 小辛 | 前1285年- 前1272年（14年） |  |\n| 21 | 商惠王 | 小乙 | 前1271年- 前1251年（21年） |  |\n| 22 | 商高宗 | 武丁 | 前1250年- 前1192年（59年） | 武丁中兴 |\n| 23 | 商后平王 | 祖庚 | 前1191年-前1180年（12年） |  |\n| 24 | 商世宗 | 祖甲 | 前1180年-前1160年（20年） |  |\n| 25 | 商甲宗 | 廪（lin）辛 | 前1159年-前1156年（4年） |  |\n| 26 | 商康祖 | 庚丁 | 前1155年- 前1147年（9年） |  |\n| 27 | 商武祖 | 武乙 | 前1147年-前1113年（35年） |  |\n| 28 | 商匡王 | 文丁 | 前1112年-前1102年（11年） |  |\n| 29 | 商德王 | 帝乙 | 前1101年- 前1076年（26年） |  |\n| 30 | 商纣王 | 帝辛 | 前1075年-前1046年（30年） |  |\n\n### 2.2.2、商朝建立及迁徙过程\n商朝兴起于夏朝的东方，即黄河中下游，为子姓。其始祖名契，契母简狄是属于有戎的后代。传说是吞玄鸟之蛋而生契，这就是《诗经·商颂· 玄鸟》中的菩名诗句:“天命玄鸟，降而生商。”无疑，商人是以鸟为图腾的。商人逐渐西迁，从契到成汤历十四代王，共移徙八次。到汤时西进逼近夏人所居，终于灭掉夏王朝而建立商朝，都于毫(其地理位置尚存争议，或说商丘，或说偃师)。据史载，商汤立国之后，商人仍“不常厥邑”，又有五次迁都，历史上有“前八后五”的说法。到第二十代王盘庚时，他说服并胁迫商贵族再次迁徙，最终将商朝的都城固定下来，这就是目前所知的殷墟(河南安阳)。\n\n\n### 2.2.3、商朝政治体制\n\n商周王朝都是世袭王权制，政权掌控在王手，商王在甲骨文中称为“余一人”。商代前期还处在兄终弟及的状态，后期转变为父死子继制度。商王朝的主要官员分为臣、将军和史官（包括巫人、贞人（占卜者）和祭司等）三大类\n## 2.3、周王朝\n\n周朝（前1046年—前256年，791年），是中国历史上最长的朝代 \n\n### 2.3.1、西周年表\n\n| 序号 | 谥号                           | 姓名           | 在位时间                                                                                              | 相关事件                                                         |\n| :--- | :----------------------------- | :------------- | :---------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------- |\n| 1    | 周文王                         | 姬昌           | 公元前 1110 年-前 1061 年为西伯（50 年）                                                              | 创《周易》  寿命 97                                     |\n| 2    | 周武王                         | 姬发           | 公元前 1060 年-前 1046 年为西伯（15 年）公元前 1046 年-前 1043 年为周王（4 年） | 孟津观兵   牧野之战  灭商建周，定都镐京（西安） |\n| 3    | 周成王                         | 姬诵           | 公元前 1042 年-前 1021 年（22 年）                                                                    | 成康之治 周公摄政 迁都洛邑（洛阳）                             |\n| 4    | 周康王                         | 姬钊           | 公元前 1020 年-前 996 年（25 年）                                                                     |                                                                  |\n| 5    | 周昭王                         | 姬瑕           | 公元前 995 年-前 977 年（18 年）                                                                      |                                                                  |\n| 6    | 周穆王                         | 姬满           | 公元前 976 年-前 922 年（55 年）                                                                      |                                                                  |\n| 7    | 周共王                         | 姬繄扈（yihu） | 公元前 922 年-前 900 年（23 年）                                                                      |                                                                  |\n| 8    | 周懿王                         | 姬囏（jian）   | 公元前 899 年-前 892 年（8 年）                                                                       | 迁都槐里（兴平市）                                    |\n| 9    | 周孝王                         | 姬辟方         | 公元前 891 年-前 886 年（6 年）                                                                       | 非子封秦                                          |\n| 10   | 周夷王                         | 姬燮（xie）    | 公元前 885 年-前 878 年（8 年）                                                                       | 煮杀齐哀公                                                       |\n| 11   | 周厉王                         | 姬胡           | 公元前 877 年-前 841 年（37 年）                                                                      | 贪图财利                                                         |\n|      | 共和（一说为共伯和摄行天子政） |                | 公元前 841 年-前 828 年（14 年）                                                                      |                                                                  |\n| 12   | 周宣王                         | 姬静           | 公元前 828 年-前 783 年（46 年）                                                                      |                                                                  |\n| 13   | 周幽王                         | 姬宫湦         | 公元前 782 年-前 771 年（12 年）                                                                      | 烽火戏诸侯（存疑）                                               |\n\n### 2.3.2、东周年表\n\n西周末年，周幽王因宠爱褒姒而废黜申后及太子宜臼，立褒姒为后，并立其子伯服为太子，引起申候的叛变。申候引犬戎政入关中，杀死幽王。于是公元前770年周平王被迫东迁至洛邑，开始了中国历史上的东周。\n\n| 序号 | 谥号           | 姓名   | 在位时间                                                                            | 相关事件                       |\n| :--- | :------------- | :----- | :---------------------------------------------------------------------------------- | :----------------------------- |\n| 1    | 周平王         | 姬宜臼 | 公元前 770 年-前 718 年（53 年）                                                    | 迁都洛邑列秦诸侯春秋之始       |\n| 2    | 周桓王         | 姬林   | 公元前 718 年-前 697 年（22 年）                                                    |                                |\n| 3    | 周庄王         | 姬佗   | 公元前 697 年-前 682 年（16 年）                                                    | 平定王子克之乱                 |\n| 4    | 周釐王         | 姬胡齐 | 公元前 682 年-前 677 年（6 年）                                                     | 齐桓称霸                       |\n| 5    | 周惠王         | 姬阆   | 公元前 677 年-前 675 年第一次在位（3 年）公元前 673 年-前 652 年第二次在位（22 年） | 五大夫作乱                     |\n| 6    | 周废王（篡位） | 姬颓   | 公元前 675 年-前 673 年（3 年）                                                     | 叛乱称王，后兵败遭杀           |\n| 7    | 周襄王         | 姬郑   | 公元前 652 年-前 619 年（34 年）                                                    |                                |\n| 8    | 周顷王         | 姬壬臣 | 公元前 619 年-前 613 年（7 年）                                                     |                                |\n| 9    | 周匡王         | 姬班   | 公元前 613 年-前 607 年（7 年）                                                     | 赵盾事件                       |\n| 10   | 周定王         | 姬瑜   | 公元前 607 年-前 586 年（22 年）                                                    | 赵氏孤儿                       |\n| 11   | 周简王         | 姬夷   | 公元前 586 年-前 572 年（15 年）                                                    |                                |\n| 12   | 周灵王         | 姬泄心 | 公元前 572 年-前 545 年（28 年）                                                    |                                |\n| 13   | 周景王         | 姬贵   | 公元前 545 年-前 520 年（26 年）                                                    | 数典忘祖                       |\n| 14   | 周悼王         | 姬猛   | 公元前 520 年-前 520 年（1 年）                                                     |                                |\n| 15   | 周敬王         | 姬匄   | 公元前 520 年-前 475 年（46 年）                                                    |                                |\n| 16   | 周元王         | 姬仁   | 公元前 475 年-前 473 年（3 年）                                                     | 周元王开始为战国时期           |\n| 17   | 周贞定王       | 姬介   | 公元前 473 年-前 441 年（33 年）                                                    |                                |\n| 18   | 周哀王         | 姬去疾 | 公元前 441 年-前 441 年（1 年）                                                     |                                |\n| 19   | 周思王         | 姬叔   | 公元前 441 年-前 441 年（1 年）                                                     | 在位仅五个月，即被弟弟姬嵬杀死 |\n| 20   | 周考王         | 姬嵬   | 公元前 441 年-前 426 年（16 年）                                                    | 叔弑兄篡位                     |\n| 21   | 周威烈王       | 姬午   | 公元前 426 年-前 402 年（25 年）                                                    | 三家分晋                       |\n| 22   | 周安王         | 姬骄   | 公元前 402 年-前 376 年（27 年）                                                    |                                |\n| 23   | 周烈王         | 姬喜   | 公元前 376 年-前 369 年（8 年）                                                     |                                |\n| 24   | 周显王         | 姬扁   | 公元前 369 年-前 321 年（49 年）                                                    | 桂陵之战 马陵之战 商鞅变法     |\n| 25   | 周慎靓王       | 姬定   | 公元前 321 年-前 315 年（7 年）                                                     |                                |\n| 26   | 周赧王         | 姬延   | 公元前 315 年-前 256 年（60 年）                                                    | 债台高筑 降秦昭襄王            |\n\n\n### 2.3.3、甲骨文和金文\n\n1. 甲骨文\n\n甲骨文是一种刻写在甲骨上的古文字。从出土实物来看，绝大多数为契刻,仅少数是书写的。甲骨文的“甲”指的是龟甲，多为腹甲:“骨”指的是兽骨，以牛肩脚骨为主，还有少量的牛肋骨、鹿头骨、牛头骨、人头骨、虎骨等\n殷墟甲骨文的出土，说明了商代历史的可靠性，成为了研究商代历史最主要的资料。金文的出现则大大拓展了周代历史的研究领域，丰富了对周代历史的认识。甲骨文和金文，是研究商周历史极其重要的第一手资料\n\n2. 金文 \n\n金文就是铭刻在青铜器上的文字，它与商代甲骨文之间有直接的承关系。西周金文的内容，包括战争、祭祀、外交、土地和人畜买卖等。金文主要铸造或镌刻在青铜器上。保守地估计，中国使用青铜的时间大约有1500多年，即从公元前2000年到公元前500，这段时期被称为中国历史上的“青铜时代”\n\n\n### 2.3.4、周朝政治体制\n\n周代的政治体制，与商人有某些共同之处。周王是最高的世袭统治者，他自称“天子”\n西周王朝的直接统治限于王畿内，也就是《诗经》的“王风”部分;其王畿外的统治则是通过分封制度来实现的，即《诗经》中的十五“国风”部分\n\n### 2.3.5、周代的几种制度\n周初灭商不久，对商人后裔实行一种由周人亲戚统领管理的相对自治统治，谓之“疆以周索”，又把商人中心区域分成邶（bei）、庸、卫三部分，分别派周武王弟弟管叔、蔡叔、霍叔去监管，这就是历史上的“三监”。但是周武王去世后，三监对周公摄政不满于是与殷人后裔联合起来反叛周王朝。周公便带兵东征，经过几年的战争之后，平服了这场叛乱，杀掉了武庚和管叔，并将蔡叔和霍叔加以流放。史称“周公东征”\n\n周公东征后，周人便实行分封制度，力图通过“封建亲戚”的办法，实现“以藩屏周”的政治效果。这场大规模的分封，受封的对象主要是三类:是同姓子弟，二是异姓的功臣，三是先王后裔\n\n# 3、春秋战国\n\n# 4、秦国\n\n## 4.1、秦朝年表\n\n| 序号 |  谥号               |  姓名           |  在位时间             |  相关事件                         |\n|:---|:------------------|:--------------|:------------------|:------------------------------|\n|  1 |  非子               |  嬴非           |  前900年-前858年（43年） |  因善于养马，得到周孝王的赏识，获封秦地，成为秦国始封君  |\n|  2 |  秦侯               |  嬴侯           |  前857年-前848年（10年） |                               |\n|  3 |  秦公伯              |  嬴伯           |  前847年-前845年（3年）  |                               |\n|  4 |  秦仲               |  嬴仲           |  前844年-前822年（23年） |  被周王任命为西我大夫，后战死               |\n|  5 |  秦庄公              |  嬴其           |  前821年-前778年（44年） |                               |\n|  6 |  秦襄公(立为诸侯)        |  嬴开           |  前777年-前766年（12年） |  看秋时期秦国第一任因君，辅平王东迁            |\n|  7 |  秦文公              |  嬴康           |  前765年-前716年（50年） |  迁都汧渭之会（千河和渭河交界）              |\n|  8 |  秦静公(秦竫公)         |  嬴鼎           |  未即位              |                               |\n|  9 |  秦宪公(秦宁公)         |  嬴立           |  前715年-前704年（12年） |                               |\n| 10 |  秦出子              |  嬴曼           |  前703年-前698年（6年）  |                               |\n| 11 |  秦武公              |  嬴说           |  前697年-前678年（20年） |                               |\n| 12 |  秦德公              |  嬴嘉           |  前677年-前676年（2年）  |  迁都雍城                         |\n| 13 |  秦宣公              |  嬴恬           |  前675年-前664年（12年） |                               |\n| 14 |  秦成公              |  嬴载           |  前663年-前660年（4年）  |                               |\n| 15 |  秦穆公              |  嬴任好          |  前659年-前621年（39年） |                               |\n| 16 |  秦康公              |  嬴罃           |  前620年-前609年（12年） |                               |\n| 17 |  秦共公              |  嬴稻/嬴貑        |  前608年-前605年（4年）  |                               |\n| 18 |  秦桓公              |  嬴荣           |  前604年-前577年（28年） |                               |\n| 19 |  秦景公              |  嬴石           |  前576年-前537年（40年） |  栎之战 迁延之役                     |\n| 20 |  秦哀公(秦毕公/秦㻫公)     |  嬴籍           |  前536年-前501年（36年） |                               |\n| 21 |  秦夷公              |  嬴扩           |  未即位              |                               |\n| 22 |  秦惠公              |  嬴宁           |  前500年-前492年（9年）  |                               |\n| 23 |  秦悼公              |  嬴盘           |  前491年-前477年（15年） |                               |\n| 24 |  秦厉共公(秦剌龚公/秦利龚公)  |  嬴刺           |  前476年-前443年（34年） |                               |\n| 25 |  秦躁公(秦趮公)         |  嬴欣           |  前442年-前429年（14年） |                               |\n| 26 |  秦怀公              |  嬴封           |  前428年-前425年（4年）  |                               |\n| 27 |  秦灵公(秦肃灵公)        |  嬴肃           |  前424年-前415年（10年） |                               |\n| 28 |  秦简公              |  嬴悼子          |  前414年-前400年（15年） |                               |\n| 29 |  秦惠公              |  嬴仁           |  前399年-前387年（13年） |                               |\n| 30 |  秦出公(秦少主)         |  嬴昌           |  前386年-前385年（2年）  |  母亲主持朝政，重用宦官外戚                |\n| 31 |  秦献公/秦元献公         |  嬴师隰/嬴连       |  前384年-前362年（23年） |  废止人殉制度                       |\n| 32 |  秦孝公              |  嬴渠梁          |  前361年-前338年（24年） |  启用商鞅变法，迁都咸阳，建立县制行政           |\n| 33 |  秦惠文王(秦惠王)        |  嬴驷           |  前337年-前311年（27年） |  改公称王，成为秦国第一王                 |\n| 34 |  秦武王(秦悼武王/秦武烈王)   |  嬴荡           |  前310年-前307年（4年）  |                               |\n| 35 |  秦昭襄王(秦昭王)        |  嬴则/嬴稷        |  前306年-前251年（56年） |  长平破赵，灭亡东周，奠基统一               |\n| 36 |  秦孝文王             |  嬴柱           |  前250年（3天）        |                               |\n| 37 |  秦庄襄王(秦庄王)        |  嬴异人/嬴子楚(嬴楚)  |  前249年-前247年（3年）  |                               |\n| 38 |  秦王政（秦始皇）         |  嬴政           |  前246年-前221年（25年） |  统一六国 建立皇帝制度 修筑万里长城           |\n| 39 |  秦二世（胡亥）          |  嬴胡亥          |  前210年―前207年（3年）  |                               |\n| 40 |  秦三世（子婴）          |  嬴子婴          |  前207年―前207年（46天） |  诛杀赵高                         |  \n\n# 5、汉朝\n\n汉朝（前202年-220年（405年））是继秦朝之后的大一统王朝，分为西汉、东汉时期\n\n## 5.1.1、西汉年表\n\n| 序号 |  别名   |  姓名       |  在位时间           |  主要事件                             |\n|:---|:------|:----------|:----------------|:----------------------------------|\n|  1 |  汉高祖  |  刘邦       |  前202-前195（8年）  |  建立汉朝                             |\n|  2 |  汉惠帝  |  刘盈       |  前195-前188（8年）  |  萧规曹随                             |\n|  3 |  前少帝  |  刘恭       |  前188-前184（5年）  |  吕雉称制                             |\n|  4 |  后少帝  |  刘弘       |  前184-前180（5年）  |                                   |\n|  5 |  汉文帝  |  刘恒       |  前180-前157（24年） |  文景之治 无为而治                        |\n|  6 |  汉景帝  |  刘启       |  前157-前141（17年） | 儿子中山靖王17代玄孙是刘备                    |\n|  7 |  汉武帝  |  刘彻       |  前141-前87（45年）  |  推恩令，通西域                          |\n|  8 |  汉昭帝  |  刘弗陵      |  前87-前74（14年）   |  昭宣中兴                             |\n|  9 |  汉废帝  |  刘贺       |  前74年7月-8月      |                                   |\n| 10 |  汉宣帝  |  刘询       |  前74-前48（27年）   |  昭宣中兴                             |\n| 11 |  汉元帝  |  刘奭（shi）  |  前48-前33（16年）   |  平灭北匈奴                            |\n| 12 |  汉成帝  |  刘骜       |  前33-前7（27年）    |                                   |\n| 13 |  汉哀帝  |  刘欣       |  前7-前1（7年）      |                                   |\n| 14 |  汉平帝  |  刘衎       |  前1-6年（1年）      |  王莽摄政（王政君侄子） <div>9岁被毒死<br></div> |\n| 15 |  孺子婴  |  刘婴       |     6年-8年（未称帝）  |                           21岁被杀   |  \n\n## 5.1.2、东汉年表\n\n| 序号 |  别名   |  姓名      |  在位时间       |  主要事件                           |\n|:---|:------|:---------|:------------|:--------------------------------|\n|  1 |  光武帝  |  刘秀      |    25年-57年（33年）  |  光武中兴                           |\n|  2 |  汉明帝  |  刘庄      |    57年-75年（19年）  |  明章之治                           |\n|  3 |  汉章帝  |  刘炟（da）  |    75年-88年（14年）  |                                 |\n|  4 |  汉殇帝  |  刘隆      |       106年  |  邓绥称制                           |\n|  5 |  汉安帝  |  刘祜      |  106年-125年（20年）  |                                 |\n|  6 |  少帝   |  刘懿      |       125年  |  阎皇后称制                          |\n|  7 |  汉顺帝  |  刘保      |  125年-144年（20年）  |                                 |\n|  8 |  汉冲帝  |  刘炳      |  144年-145年（2年）  |  梁妠称制                           |\n|  9 |  汉质帝  |  刘缵      |  145年-146年（2年）  |   9岁被毒死   |\n| 10 |  汉桓帝  |  刘志      |  146年-168年（23年）  |  夺回皇权                           |\n| 11 |  汉灵帝  |  刘宏      |  168年-189年（22年）  |  卖官鬻爵 十常侍作乱     |\n| 12 |  汉少帝  |  刘辩      |       189年  |  被董卓罢黜 15（18）岁自杀 |\n| 13 |  汉献帝  |  刘协      |  189年-220年（32年）  |  曹操摄政   |  \n\n\n## 5.1.3、三国相关人物表\n\n### 5.1.3.1、朝廷（东汉）& 群雄\n\n|  序号  | 人物          |  相关事件                                          |\n|:-----|:------------|:-----------------------------------------------|\n|    1  | 刘志（汉桓帝）     |  外戚专权                                          |\n|    2  | 刘宏（汉灵帝）     | 黄巾起义                                           |\n|    3  | 窦妙（窦太后）     | 刘志之母                                           |\n|    4  | 董太后（永乐太后）   | 刘宏之母                                           |\n|   5   | 十常侍         | 张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜             |\n|  6    |  何皇后        |  刘辩之母，汉灵帝刘宏第二任皇后                                        |  \n|   7   |  王荣（王美人）         |  刘协之母，汉灵帝刘宏妃子，被何皇后毒杀                             |  \n|   8   |  何进         |  何皇后哥哥，刘辩舅舅                                    | \n|    9  |  刘辩（汉少帝）         | 被董卓废掉，毒杀                                     | \n|   10   |  刘协 （汉献帝）       |   陈留王                                   | \n|   11   |  刘恢       |  代郡太守，刘备鞭都邮后投奔他，他保护刘备不被追查，并推荐他给刘虞                     | \n|   12     |  张角           | “天公将军”，创立太平道，提出“苍天已死，黄天当立”的口号以号召徒众，史称“黄巾军”   |\n|    13    |  张宝           | “地公将军”，张角之弟，后来被皇甫嵩、郭典击败，被杀                       |\n|   14     |  张梁           |  “人公将军”，张宝之弟，遭到遭皇甫嵩击败，被杀                         |\n|    15    |  董太后（永乐太后）    |  刘宏之母                                            |\n|    16    |  十常侍          |  张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜              |\n|   17     |  卢植           |  刘备老师，东汉名臣，参与平叛黄巾起义                                          |  \n|   18     |  袁绍           |  （1）四世三公，早年任中军校尉，曾指挥诛杀宦官，建议何进引董卓 （2）争夺天下的野心与曹操产生冲突，最终在赤壁之战中被曹操击败      |\n|    19    |  袁术           |  （1）袁绍的弟弟。（2）与袁绍、曹操等同时起兵，共讨董卓。其后因与袁绍对立，被袁绍、曹操击败，率余众奔九江，割据扬州 （3）奢侈荒淫，横征暴敛，使江淮地区残破不堪，民多饥死     |\n|     20   |  董卓           |  西凉刺史      | \n|    21    |  李儒           |  董卓谋士 毒死刘辩                | \n|   22     |  丁原           |  字建阳，并州刺史         | \n|    23    |  吕布           |  诛杀董卓          | \n|    24    |  樊稠           |  （1）原为董卓部将，董卓死后，伙同李傕、郭汜、张济等人合众十余万反扑长安，败吕布、杀王允，把持朝政 。后因内斗被李傕外甥胡封在会议上刺死 （2）大败马腾、韩遂      |\n|   25     |  李肃           |  董卓手下虎贲中郎将，主动请命以赤兔马说服吕布杀丁原来降                    |\n|    26    |  王允           |  设计诛杀董卓。后欲解散董卓的凉州兵旧部，使其人人自危，董卓部将李傕、郭汜乃合谋为乱，攻进长安，王允被杀                                   | \n|    27    |  公孙瓒           | 军阀，汉末群雄之一，卢植学生   | \n|   28     |  华雄           | 董卓帐下武将  | \n|    29    |  颜良           | 袁绍部将   白马之围 | \n|    30    |  文丑           | 袁绍部将    | \n|    31    |  蔡邕           | 东汉时期名臣，蔡文姬之父，被董卓重用，董卓死后被王允杀    | \n|    32    |  陶谦           | 徐州太守    | \n|    33   |  刘表           | 雄踞荆州，杀孙坚    | \n|    34    |  曹豹           | 东汉末年徐州牧陶谦部将，吕布的老丈人    | \n|     35   |  张绣           | 称雄宛城、在官渡之战力战有功，封邑最多    | \n|     36  |  潘凤           | 称雄宛城、在官渡之战力战有功，封邑最多冀州牧韩馥帐下的大将。当十八路诸侯讨伐董卓之时，他奉韩馥、袁绍之命前往汜水关前挑战董卓部下大将华雄，结果不多时就被斩    | \n|37     | 孔融 |  孔子的第二十世孙 （208年）因触怒丞相曹操而被杀  孔融让梨  |\n|38     | 沮授 |  东汉末年袁绍的监军 多次提出策略不被采纳  |\n|39    | 逢纪 |  袁绍谋士 辅佐袁绍平定河北  |\n| 40   | 田丰 |  袁绍谋士 助袁绍灭公孙瓒  |\n| 41   | 于吉 |  琅琊人 ，东汉末年道士，后为孙策所杀，代表作有《太平经》 |\n| 42   | 蔡瑁 |  协助刘表平定荆州 刘表后妻蔡夫人弟弟 |\n| 43   | 司马徽 |  东汉末年隐士，精通奇门、经学。有“水镜先生”之称 向刘备推荐了诸葛亮、庞统等人|\n| 44   | 马腾 |  东汉末年军事将领，军阀之一，马超，马铁之父 |\n| 45   | 孟获 |  三国时期南中地区的首领，公元225年起兵反叛蜀汉，被诸葛亮率领大军擒拿后被赦免，遂降服，此后不再叛乱，后孟获随诸葛亮回到成都，担任御史中丞 |\n### 5.1.3.2、魏\n\n|   序号   |  人物           |   相关事件                                           |\n|:-------|:--------------|:-------------------------------------------------|\n|    1    |  曹操          | （1）太尉曹嵩之子 （2）献七星宝刀  |\n|     2   |  乐进          | 斩淳于琼；斩严敬；每战先登；击退关羽；降伏蛮夷  |\n|    3    |  李典          | 曾在博望坡之战识破刘备的伪遁之计，救下了夏侯惇、于禁。又参与了逍遥津之战 |\n|    4    |  曹仁          | 破袁术、攻陶谦、擒吕布、败刘备，参加官渡之战  |\n|    5    |  夏侯惇          | 夏侯渊之族兄，汉朝开国功臣之一夏侯婴的后代  |\n|    6    |  夏侯渊          |  夏侯惇族弟, 官渡督粮、平定凉州, 被黄忠斩杀|\n|    7    |  曹洪          | （1）曹操从弟 （2） 早年随曹操起兵讨伐董卓。荥阳兵败，舍命献马，救驾于危难|\n|    8    |  贾诩|原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操|\n|   9     |  荀彧          |  早年被称为“王佐之才” 为曹操规划军事战略方针，堪称其统一北方的首席谋 |\n|    10    |  荀攸          |  是荀彧的堂侄，曹操的重要谋士 |\n|    11    |  程昱          |  本名程立，因梦中在泰山捧日，更名程昱 |\n|    12    |  郭嘉          |  经荀彧推荐，任曹军祭酒 |\n|    13    |  刘晔          |  光武帝刘秀之子阜陵王刘延的后代 |\n|    14    |  满宠          | 平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰  |\n|    15    |  典韦          | 濮阳之战击退吕布、宛城死战阻张绣  |\n|    16    |  于禁          | 讨伐黄巾余党、于张绣叛乱中坚守营垒，杀夏侯惇的青州军  |\n|    17    |  许诸          | 负责曹操的护卫工作，累迁武卫中郎将，赐号“虎侯”  |\n|    18    |  贾诩          |  曹魏开国功臣，原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操 |\n|    19    |  陈登          | 沛相陈珪之子，向曹操献灭吕布之策  |\n|    20    |  陈珪          | 陈登、陈应之父。官至沛相。助破袁术，策应曹操  |\n|    21    |  车胄          | 曹操灭吕布占有徐州之地后，任命车胄为徐州刺史。被关羽斩杀，全家也被张飞杀害  |\n|    22    |  曹昂          | 曹操长子。建安二年（197年）随曹操出征张绣，张绣降而复叛，曹昂为救曹操被杀  |\n|   23     |  张辽          | 雁门马邑（今山西省朔州市）人。先后跟随丁原、何进、董卓、吕布，恪尽职守，历尽坎坷。吕布败亡后，张辽归属曹操  |\n|    24    |  许攸          | 本为袁绍帐下谋士，官渡之战时其家人因犯法而被收捕，许攸因此背袁投曹，并为曹操设下偷袭袁绍军屯粮之所——乌巢的计策，袁绍因此而大败于官渡。后许攸随曹操平定冀州，因自恃其功而屡屡口出狂言，终因触怒曹操而被杀  |\n|    25    |  曹丕          | 曹操长子 建立曹魏；大破羌胡，复通西域  |\n|    26    |  司马懿          | 司马懿辅佐了魏国四代君主，见证了曹氏家族从兴盛走向衰亡，为稳定曹魏政权做出了贡献，也为其孙司马炎以晋代魏一统中国奠定了基础  |\n|    27   |  满宠          |  平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰 |\n|    28   |  曹真          |  曹操养子 大败羌胡联军 平定河西 大破吴国孙盛 击退蜀汉诸葛亮|\n|    29  |  曹睿       |  曹魏第二位皇帝。魏文帝曹丕长子 与曹操、曹丕并称魏氏“三祖”|\n|    30  |  钟会       |  平诸葛诞之叛、与邓艾分兵灭蜀|\n|    31  |  张郃       |  江陵破吴，街亭败蜀|\n|    32  |  曹芳       |  曹魏第三位皇帝，疑为魏武帝曹操曾孙|\n|    33  |  曹爽       |  曹魏权臣，大司马曹真长子|\n|    34  | 司马师     |  曹魏权臣，西晋王朝的奠基人之一，晋宣帝司马懿与宣穆皇后张春华的长子，晋文帝司马昭的同母兄，晋武帝司马炎的伯父|\n|    35  | 司马昭     |  司马炎之父，专揽国政，攻灭蜀汉；奠定西晋基础|\n|    36 | 郭淮     |  魏国名将，雁门郡太守郭缊之子 被姜维杀|\n|    37 | 曹髦     |  曹丕之孙，东海王曹霖之子，曹魏第四位皇帝 不满司马昭掌权反抗被杀|\n|    38 | 邓艾     |  治理魏国西方，与姜维多次对峙；率兵偷渡阴平，攻灭蜀汉|\n|    39 | 曹奂     |  三国时期曹魏末代皇帝（第五位）。魏武帝曹操之孙 司马炎篡夺魏国政权，建立西晋|\n|    40 | 诸葛瞻     |  诸葛亮之子 与邓艾决战，兵败被杀，绵竹失守。后主刘禅出降，蜀汉灭亡|\n|    41 | 刘禅     |  小名阿斗。蜀汉末代皇帝，刘备之子，母为昭烈皇后甘氏|\n### 5.1.3.3、蜀\n\n|   序号   |  人物           |   相关事件                                           |\n|:-------|:--------------|:-------------------------------------------------|\n|   1     |  刘备           | 汉景帝之子中山靖王刘胜之后   |\n|    2    |  关羽           |  山西运城人                      |\n|   3     |  张飞           |  今河北保定涿州市人                       |\n|   4     |  糜竺    |  麋竺原为徐州富商，后被徐州牧陶谦辟为别驾从事（官名）。陶谦病死后，奉其遗命迎接刘备          |\n|    5    |  简雍         |  刘备帐下谋士              |\n|   6    |  诸葛亮          |  蜀汉丞相，向刘备提出占据荆州、益州，联合孙权共同对抗曹操的隆中对  五次北伐                                       | \n|   7     |  赵云           |  （1）与关羽、张飞并称“燕南三士”   （2）先加入公孙瓒，后追随刘备                                          | \n|   8     |  孙乾           |     东汉末年刘备帐下幕僚                                     | \n|   9     |  廖化           |     攻破游奕，击杀王赟                                    | \n|   10     |  周仓           |     关羽身边的武将。在关羽镇守荆州对抗曹魏名将于禁与庞德的战斗中，于水中生擒庞德。最后周仓在关羽父子被斩之后自刎而死                                 | \n|   11     |  廖化           |     攻破游奕，击杀王赟                                    | \n|    12    |  徐庶        |   东汉末年刘备帐下谋士，后归曹操                                  | \n|    13    |  庞统        |   刘备帐下重要谋士，与诸葛亮同拜为军师中郎将   攻打益州刘璋时死于落凤坡                              | \n|    14    |  黄忠        |   本为刘表部下中郎将，后归刘备，并助刘备攻破益州刘璋    | \n|    15    |  魏延        |   镇守汉中，大破费瑶和郭淮，子午谷奇谋    | \n|    16   |  马超        |   马腾长子，马铁，马休兄长  辅助刘备建立蜀汉    | \n|    17  |  张苞      |   张飞的长子。英年早逝，留有一子张遵    | \n|    18  |  关兴      |   关羽次子，关平之弟    | \n|    19  |  马良      |   马良兄弟五人，都有才华名气，乡里为他们编有谚语说：“马家五常，白眉最良。”马良眉中有白毛，故此人们这样称呼他    | \n|   20  |  马谡      |  马良之弟，诸葛亮北伐时因作战失误失守街亭   | \n|   21 |  姜维      |  洮西大破王经，据守剑阁阻挡住钟会大军   | \n|   22 |  邓芝      | 出使吴国，与之修好 讨平涪陵叛乱   | \n|   23 |  王平      | 击退曹爽大举伐蜀   | \n|   24 |  杨仪      | 辅佐诸葛亮、击杀魏延   | \n|   25 |  蒋琬      | 继诸葛亮执政，安定众心   | \n|   26 |  李严      | 与诸葛亮同为刘备临终前的托孤之臣 参与制定《蜀科》   | \n|   27|  马岱      | 马超从弟，在诸葛亮病逝后受杨仪派遣斩杀了蜀将魏延   | \n|   28|  费祎      | 蜀汉四相之一 休养生息，增强蜀汉国力   | \n### 5.1.3.4、吴\n\n|   序号   |  人物           |   相关事件                                           |\n|:-------|:--------------|:-------------------------------------------------|\n|   1     |  孙坚           | （1）孙吴政权的奠基者 （2）洛阳城外击溃董卓  |\n|    2    |  程普           | 从孙坚讨黄巾、破董卓；救孙策，定江东；参与赤壁之战、南郡之战  |\n|   3     |  黄盖           |  在赤壁之战中诈降，献计火攻 |\n|   4     |  孙策           |  孙坚长子，字伯符 |\n|   5     |  孙权           | 孙坚次子，字仲谋  |\n|   6     |  孙尚香          | 孙权之妹，曾为刘备之妻，民间戏剧称之为孙尚香  |\n|    7    |  周瑜           | 辅平江东、开拓荆州、赤壁破曹、督灭黄祖、谏阻纳质、提出征伐益州战略 \n|    8    |  张昭           | 辅佐孙策、孙权安定江东，与孙邵、滕胤等撰定朝仪 |\n|    9    |  张紘           | 东汉末年文学家、官员，和张昭一起合称“二张” |\n|   10     |  大乔           | 东汉末年江东孙策的夫人，本姓“桥”，小说《三国演义》误作“乔”，因为同时还有一个妹妹嫁给周瑜，为了进行区分，姐姐习惯称作“大乔（桥）”|\n|   11   |  鲁肃           | 孙权部将、战略家、外交家 |\n|   12   |  甘宁           | 先投靠刘表，但未被重用，后归依孙权，孙权加以重用。曾随周瑜在乌林击败曹操在南郡攻打曹仁夺取夷陵 |\n|   13   |  陆逊       | 与吕蒙共同击败关羽、夺取荆州 夷陵之战破刘备 石亭之战败曹休 |\n|   14   |  吕蒙          | 攻皖城 取三郡 濡须之战 袭荆州 |\n|   15   |  诸葛恪          | 大将军诸葛瑾长子，蜀汉丞相诸葛亮之侄 在东兴堤大胜魏军 |\n|   16   |  丁奉          |   在东兴之战中大破魏军前屯|\n|   17 |  孙亮          |   孙吴第二位皇帝 计除权臣诸葛恪 后被孙琳废|\n|   18 |  孙峻          |   诛杀诸葛恪，专擅朝政|\n|   19 |  孙休        |   孙权第六子。中国三国时期孙吴国主|\n|   20 |  孙綝（chen）        |   孙亮即位后由孙峻辅政。 太平元年（公元256年）孙峻去世，孙綝接替堂兄掌控朝局 被孙休、丁奉等定计诛杀|\n|   21 |  陆抗        |   西陵之战大破晋军；维护吴国稳定|\n## 5.1.4、三国势力图\n\n1. 初期势力图\n\n![三国势力图|725](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031910885.png)\n\n\n2. 三足鼎立势力图\n\n![三足鼎立|975](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031918859.png)\n\n\n# 6、魏晋南北朝时期\n\n## 6.1、魏晋南北朝时期概览\n\n魏晋南北朝（220—589年，370年），又称三国两晋南北朝，是中国历史上政权更迭最频繁的时期，主要分为三国（曹魏、蜀汉、东吴）、西晋、东晋和南北朝时期，由于长期的封建割据和连绵不断的战争，使这一时期中国文化的发展受到特别的影响。其突出表现则是玄学的兴起、佛教的输入、道教的勃兴。三国至隋的**三百六十余年**，以及三十余个大小王朝交替兴灭过程\n\n![魏晋南北朝时期](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308051110202.png)\n\n\n# 7、隋朝\n\n## 7.1、隋朝年表\n\n隋朝（581年～619年,38年）是中国历史上承南北朝，下启唐朝的大统一朝代。定都大兴（西安）\n\n| 序号 | 谥号  | 姓名       | 在位时间            | 相关事件                                           |\n|:---|:----|:---------|:----------------|:-----------------------------------------------|\n|  1 | 隋文帝 | 杨坚       |  581年-604年（24年） | 三省六部制<div>开创科举</div><div>罢黜杨勇，立杨广</div>        |\n|  2 | 隋炀帝/隋明帝 | 杨广       |  604年-618年（15年） | 迁都洛阳 <div>穷奢极欲</div><div>隋朝大运河</div><div>江都兵变</div> |\n|  3 | 隋恭帝 | 杨侑       | 617年-618年（177天） | 被李渊拥立为帝，后被幽禁                                   |\n|  4 | 隋秦王 | 杨浩       |        618年（半年） | 被宇文化及拥立为帝，后被毒杀                                 |\n|  5 | 皇泰主 | 杨侗（dong） |   618年-619年（1年） | 被王世充拥立为帝，后被杀害                                  |  \n\n# 8、唐朝\n\n## 8.1、唐朝年表\n\n唐王李渊于618年逼隋恭帝禅位,推翻隋朝,改国号为“唐”(尊称“大唐”),建立了唐朝（618年－907年，289年）\n\n| 序号 |  别名   |  姓名        |  在位时间          |  主要事件                |\n|:---|:------|:-----------|:---------------|:---------------------|\n|  1 |  唐高祖  |  李渊        |   618-626（9年）  | 晋阳起兵，建立唐朝                     |\n|  2 |  唐太宗  |  李世民       |  627-649（23年）  |  玄武门之变，贞观之治          |\n|  3 |  唐高宗  |  李治        |  650-683（24年）  |                      |\n|  4 |  唐中宗  |  李显        |           684  |  被废                  |\n|  5 |  唐睿宗  |  李旦        |   684-690（6年）  |  被废                  |\n|  6 |  武则天  |  武曌（zhao）  |  690-705（16年）  |  武周开国君主（不属于唐）        |\n|  7 |  唐中宗  |  李显        |   705-710（5年）  |  神龙政变 被韦皇后毒死         |\n|  8 |  唐少帝  |  李重茂       |           710  |                      |\n|  9 |  唐睿宗  |  李旦        |   710-712（2年）  |  二次让位                |\n| 10 |  唐玄宗  |  李隆基       |  712-756（44年）  |  唐隆政变 唐明皇 安史之乱 开元之治  |\n| 11 |  唐肃宗  |  李亨        |   756-762（5年）  |                      |\n| 12 |  唐代宗  |  李豫        |  762-779（17年）  |                      |\n| 13 |  唐德宗  |  李适        |  779-805（26年）  |                      |\n| 14 |  唐顺宗  |  李诵        |       805（8月）  |                      |\n| 15 |  唐宪宗  |  李纯        |  806-820（15年）  |  元和中兴                |\n| 16 |  唐穆宗  |  李恒        |   821-824（4年）  |                      |\n| 17 |  唐敬宗  |  李湛        |   824-826（2年）  |                      |\n| 18 |  唐文宗  |  李昂        |  826-840（14年）  |                      |\n| 19 |  唐武宗  |  李炎        |   840-846（6年）  |                      |\n| 20 |  唐宣宗  |  李忱（chen）  |  846-859（13年）  |                      |\n| 21 |  唐懿宗  |  李漼（cui）   |  859-873（14年）  |                      |\n| 22 |  唐僖宗  |  李儇（xuan）  |  873-888（15年）  |  黄巢起义                |\n| 23 |  唐昭宗  |  李晔        |  888-904（16年）  |                      |\n| 24 |  唐哀帝  |  李柷（chu）   |   904-907（3年）  |                      |  \n\n# 9、五代十国\n\n# 10、宋朝\n\n## 10.1、宋朝年表\n\n宋朝（960年－1279年，319年）是中国历史上承五代十国下启元朝的中原王朝，分北宋和南宋两个阶段，共历十八帝\n\n| 序号 |  别名   |  姓名        |  在位时间          |  主要事件                |\n|:---|:------|:-----------|:---------------|:---------------------|\n|  1 |  宋太祖  |  赵匡胤        |  960-976（16年）  | 改革官帽 两次杯酒释兵权                    |\n|  2 |  宋太宗  |  赵炅       |  976-997（21年）  |  赵匡胤之弟 雪中送炭          |\n|  3 |  宋真宗  |  赵恒        |  997-1022（15年）  |  赵炅三子，澶渊之盟             |\n|  4 |  宋仁宗  |  赵祯        |  1022-1063（41年）  | 赵恒六子， 发行交子 狸猫换太子                |\n|  5 |  宋英宗  |  赵曙        |   1063-1067（4年）  |  赵祯堂兄赵允让第十三子     《资治通鉴》            |\n|  6 |  宋神宗  |  赵顼  |  1067-1085（18年）  |  赵曙长子，重用王安石变法        |\n|  7 |  宋哲宗  |  赵煦       |   1085-1100（15年）  |  赵顼六子         |\n|  8 |  宋徽宗  |  赵佶       |   1100-1126（26年）  |    赵顼十一子，书法绘画大师（瘦金体）  宋江起义 方腊起义    靖康之变  |\n|  9 | 宋钦宗 |  赵桓       |  1126-1127（1年）  | 赵佶长子，赵构异母兄弟 。1127年发生\"靖康之变\" 金朝南下攻取北宋首都东京，掳走徽、钦二帝，导致北宋灭亡的历史事件                  |\n|  10|  宋高宗  |  赵构      |  1127-1162（35年）  |  赵佶九子，南宋开国皇帝 ，重用秦桧         |\n|  11 |  宋孝宗  |  赵昚（shen） |  1162-1189（27年）  |  赵构养子 平反岳飞 隆兴和议 被认为南宋最有作为的皇帝          |\n|  12|  宋光宗 |  赵惇        |  1189-1194（5年）  | 绍熙内禅               |\n|  13 |  宋宁宗  |  赵扩      |    1194 -1224（30年）  |  赵惇次子         |\n|  14 |  宋理宗  |  赵昀（yun） |  1224-1264（40年）  |  赵扩远方堂侄 ，联蒙灭金     |\n|  15 |  宋度宗 |  赵禥（qi）       |  1264-1274（10年）  |  赵昀之侄，智力低于常人        |\n|  16 |  宋恭宗  |  赵㬎（xian）     |    1274-1276（2年）  |  赵禥次子 ，退位降元        |\n|  17 |  宋端宗  |  赵昰（shi） |  1276-1278（2年）  |  赵禥庶长子，九岁去世     |\n|  18 |  宋卫王 |  赵昺（昺）       |  1278-1279（1年）  |  赵禥三子，崖山海战，投海殉国      |\n\n# 11、元朝\n\n## 11.1、元朝年表\n\n元朝（1271年—1368年，98年），是中国历史上的朝代。铁木真于1206年建国；1271年忽必烈定国号为元，1279年灭南宋。 是首次由少数民族建立的大一统王朝，传五世十一帝\n\n| 序号 | 姓名 | 庙号 | 统治时间 | 事件 |\n| --- | --- | --- | --- | --- |\n| 1 | 孛儿只斤·铁木真 | 元太祖 | 1206-1227年（21年） | 大蒙古可汗，建立大蒙古国 |\n| 2 | 孛儿只斤·窝阔台 | 元太宗 | 1229-1241年（12年） | 蒙古帝国大汗，奠定元朝基础 |\n| 3 | 孛儿只斤·贵由 | 元定宗 | 1246-1248年（2年） | 蒙古帝国第三任大汗，西征欧洲 |\n| 4 | 孛儿只斤·蒙哥 | 元宪宗 | 1251-1259年（8年） | 大蒙古国可汗，招降吐蕃 |\n| 1 | 孛儿只斤·忽必烈 | 元世祖 | 1260-1294年 （34年）| 元朝开国皇帝，首创行省制度 |\n| 2 | 孛儿只斤·铁穆耳 | 元成宗 | 1294-1307年（13年） | 击败西北叛王 |\n| 3 | 孛儿只斤·海山 | 元武宗 | 1307-1311年（4年） | 设尚书省 |\n| 4 | 孛儿只斤·爱育黎拔力八达 | 元仁宗 | 1311-1320年（9年） | 实行科举制度 |\n| 5 | 孛儿只斤·硕德八剌 | 元英宗 | 1320-1323年（3年） |  |\n| 6 | 孛儿只斤·也孙铁木儿 | - | 1323-1328年（5年） | 史称泰定帝 |\n| 7 | 孛儿只斤·阿速吉八 | - | 1328年（27天） | 史称天顺帝 |\n| 8 | 孛儿只斤·图帖睦尔 | 元文宗 | 1329-1332年（3年） |  |\n| 9 | 孛儿只斤·和世㻋 | 元明宗 | 1329年（184天） |  |\n| 10 | 孛儿只斤·懿璘质班 | 元宁宗 | 1332年（52天） |  |\n| 11 | 孛儿只斤·懽帖睦尔 | 元惠宗 | 1333-1370年（37年） | 实施“至正新政”改革 |\n\n# 12、明朝\n\n## 12.1、明朝年表\n\n明朝（1368年―1644年，276年）明太祖朱元璋所建。初期建都南京，明成祖时期迁都北京。传十六帝\n\n|  序号  |  别名               |  姓名       |  年号     |  在位时间                 |  主要事件  |\n|:-----|:------------------|:----------|:--------|:----------------------|:-------|\n|   1  |  明太祖              |  朱元璋      |  洪武     |            1368-1398（20年）  |  洪武之治  |\n|   2  |  明惠宗              |  朱允炆      |  建文     |            1398-1402（4年）  |        |\n|   3  |  明成祖              |  朱棣       |  永乐     |            1402-1424（22年）  |  永乐盛世  |\n|   4  |  明仁宗              |  朱高炽      |  洪熙     |            1424-1425（1年）  |  仁宣之治  |\n|   5  |  明宣宗              |  朱瞻基      |  宣德     |            1425-1435（10年）  |        |\n|   6  |  明英宗              |  朱祁镇      |  正统 天顺  |  1435-1449 1457-1464  |  夺门之变  |\n|   7  |  明代宗              |  朱祁钰      |  景泰     |            1449-1457（8年）  |        |\n|   8  |  明宪宗              |  朱见深      |  成化     |            1464-1487（23年）  |        |\n|   9  |  明孝宗              |  朱祐樘      |  弘治     |            1487-1505（18年）  |  弘治中兴  |\n|  10  |  明武宗              |  朱厚照      |  正德     |            1505-1521（16年）  |        |\n|  11  |  明世宗              |  朱厚熜      |  嘉靖     |            1521-1566（45年）  |        |\n|  12  |  明穆宗              |  朱载坖      |  隆庆     |            1566-1572（6年）  |        |\n|  13  |  明神宗              |  朱翊（yi）钧  |  万历     |            1572-1620（48年）  |  万历中兴  |\n|  14  |  明光宗              |  朱常洛      |  泰昌     |                 1620  |        |\n|  15  |  明熹宗              |  朱由校      |  天启     |            1620-1627（7年）  |        |\n|  16  |  明思宗              |  朱由检      |  崇祯     |            1627-1644（17年）  |        |\n|      |  南明时期（1644-1662，18年）  |           |         |                       |        |\n|   1  |  明安宗              |  朱由崧      |  弘光     |            1644-1645（1年）  |        |\n|   2  |  明绍宗              |  朱聿键      |  隆武     |            1645-1646（1年）  |        |\n|   3  |                   |  朱聿鐭      |  绍武     |            1646年的1个月  |        |\n|   4  |  明昭宗              |  朱聿键      |  永历     |            1646-1662（16年）  |        |  \n\n\n# 13、清朝\n\n## 13.1、清朝年表\n\n清朝（1616年—1912年，296年），是中国历史上最后一个封建王朝，共传十二帝，初称后金。从努尔哈赤建国起，总计296年。从皇太极改国号为清起，国祚276年\n\n| 序号 | 姓名 | 年号 | 在位时间 | 主要事件 |\n| --- | --- | --- | --- | --- |\n| 1 | 努尔哈赤 | 天命 | 1616-1626（10年） | 统一女真 建立后金 反抗明朝 萨尔浒之战 |\n| 2 | 皇太极 | 天聪 崇德 | 1626-1643（17年） | 征服朝鲜和蒙古 松锦大捷 改国号大清和族名满洲 |\n| 3 | 福临 | 顺治 | 1643-1661（18年） | 李自成攻入北京 崇祯自缢而死 吴三桂引清军入关 大清迁都北京 |\n| 4 | 玄烨 | 康熙 | 1661-1722（61年） | 囚禁鳌拜 削三番 收复台湾 签订《尼布楚条约》 |\n| 5 | 胤禛 | 雍正 | 1722-1735（13年） | 设军机处 |\n| 6 | 弘历 | 乾隆 | 1736-1796（60年） | 编纂《四库全书》 大兴文字狱 实行闭关锁国 |\n| 7 | 永琰 | 嘉庆 | 1796-1820（24年） | 诛杀和珅 白莲教天理教起义 |\n| 8 | 旻宁 | 道光 | 1820-1850（30年） | 虎门销烟 第一次鸦片战争 《南京条约》，割香港给英国 |\n| 9 | 奕訢 | 咸丰 | 1850-1861（11年） | 太平天国起义 第二次鸦片战争 圆明园被毁  《天津条约》《北京条约》  洋务运动 |\n| 10 | 载淳 | 同治 | 1861-1874（13年） | 辛酉政变 慈溪垂帘听政 镇压太平天国 同治中兴 |\n| 11 | 载湉 | 光绪 | 1874-1908（34年） | 中法战争 中日甲午战争 戊戌变法 义和团 八国联军   《马关条约》《辛丑条约》 慈溪仍掌政 |\n| 12 | 溥仪 | 宣统 | 1908-1911（3年） | 辛亥革命 |","source":"_posts/中国古代史.md","raw":"---\ntitle: 中国古代史\ndate: 2023/08/10\nupdated: 2023/10/30\ncategories:\n  - 生活\ntags:\n  - 中国古代史\nabbrlink: 20848\n---\n# 1、史前时期\n\n## 1.1、中国人种起源及生存环境\n\n人类进化链环的各个阶段，在中国境内大都可以找到对应的遗址。\n\n1. 直立人: 西侯度人(山西，180万年前)、元谋猿人(云南，170万年前)、蓝田人(陕西，115-70万年前)、北京猿人(70-23万年前)\n2. 早期智人 (古人)：长阳人(湖北，距今19.5万年)、丁村人(山西，距今20多万年）、大荔人（陕西，距今20-15万年前）\n3. 晚期智人（新人）：猿类特征已经退化，体质特征接近现代人。柳江人（距今5-4万年，广西），河套人（距今5-3.7万年，内蒙古），山顶洞人（距今3万年，北京）\n## 1.2、中国境内旧石器和新石器时代\n\n在考古学上，根据人类使用工具的进化程度不将历史划为:石器时代 (旧石器时代,新石器时代) -> 青铜时代 -> 铁器时代\n\n1. 旧石器时代：距今250万年-1万年，特点是使用粗糙的打制石器，过着采集和渔猎生活，相当于人类历史上的原始人阶段\n2. 新石器时代：距今1万-5000年，氏族公社时期，包括母系氏族公社和父系氏族公社，特点是使用磨制石器，能够制造陶和纺织，发明农业和畜牧业，有固定生活来源，不再依赖采集为生。（大汶口文化，红山文化，良渚文化，大溪文化，河姆渡文化，龙山文化）\n\n\n# 2、夏商周三代文明\n\n## 2.1、夏王朝\n\n### 2.1.1、夏朝年表\n\n夏朝（约前2070年－约前1600年，470年）是中国历史记载的第一个中原部族世袭制朝代\n\n|   序号   |   姓名      |   在位时长                 |   相关事件                            |\n|:-------|:----------|:-----------------------|:----------------------------------|\n|    1   |   禹       | 前2071-前2027（45年）     |   **涂山大会**，铸造九鼎，象征九州，第一次有了国家的概念   |\n|    2   |   启       | 前2026-前1988（39年）     |   由禅让制变为世袭制，击败了有扈氏的反抗             |\n|    3   |   太康      |     前1987-前1984（4年） |   不理朝政，被有穷氏后羿夺权，**太康失国**，实际在位2年   |\n|    4   |   仲康      |     前1983-前1977（7年） |   后羿专权，仲康反抗失败被软禁，抑郁而终             |\n|    5   |   相       |     前1976-前1949（28年） |   被寒浞的儿子浇攻破自刎，大臣寒浞杀后羿夺权           |\n|    6   |   少康/杜康   |     前1908-前1888（21年） |   相的遗腹子，攻杀寒浞，复国，**少康中兴**          |\n|    7   |   季杼      |     前1887-前1871（17年） |   参加过复兴夏朝的战争                      |\n|    8   |   槐/帝芬    |     前前1870-前1827（44年） |                                   |\n|    9   |   芒       |     前1826-前1769（58年） |                                   |\n|   10   |   泄/帝降    |     前1768-前1753（16年） |   正式赐封九夷各部诸侯爵位                    |\n|   11   |   不降      |     前1752-前1705（48年）  |                                   |\n|   12   |   扃       |     前1704-前1684（21年） |                                   |\n|   13   |   廑（jin）      |     前1683-前1676（8年） |   夏国开始衰落                          |\n|   14   |   孔甲      |     前1675-前1667（9年） |   胡作非为的残暴昏君                       |\n|   15   |   皋       |     前1666 -前1664（3年） |                                   |\n|   16   |   发       |     前1663-前1645（19年） |   各方诸侯已不来朝贺                       |\n|   17   |   桀       |     前1644-前1592（53年） |   暴君，被商汤灭，亡国                      | \n\n### 2.1.2、夏王朝的文献和史事\n\n目前关于夏王朝的主要文献资料来源于《史记·夏本纪》和《尚书》及《诗经》的部分记载。\n夏王朝始于禹。尧舜禹的禅让到禹时，发生了根本的变化。禹传位于其子启，确立了嫡子世袭制度。据《夏本纪》的材料，禹开始以天下授益\n就在传位于启不久，这个部落联盟中的有扈氏部族“不服”，向启提出了挑战。启伐之，大战于甘，有扈氏被灭。\n夏后帝启死后，子太康立。太康时失国，太康崩，弟中康立，是为帝中康。中康生子相。相时受到东夷族有穷氏(其首领为善射的羿)的压迫，在与有穷氏的战争中，夏王相被杀，但他的儿子少康最终取得胜利，这就是“少康复国。\n\n## 2.2、商王朝\n\n### 2.2.1、商朝年表\n\n商朝（约公元前1600年-约公元前1046年，554年）\n\n| 序号 | 姓名 | 别名 | 在位时长 | 相关事件 |\n| --- | --- | --- | --- | --- |\n| 1 | 商汤 | 天乙 | 前1600年-前1588年（13年） | 开国君主 鸣条之战 |\n| 2 | 商哀王 | 外丙 | 前1587年-前1586年（2年） |  |\n| 3 | 商懿王 | 仲壬 | 前1585年-前1582年（4年） |  |\n| 4 | 商太宗 | 太甲 | 前1582年-前1570年（13年） |  |\n| 5 | 商昭王 | 沃丁 | 前1570年-前1541年（29年） |  |\n| 6 | 商宣王 | 太庚 | 前1541年-前1516年（25年） |  |\n| 7 | 商敬王 | 小甲 | 前1516年-前1499年（17年） |  商朝始衰|\n| 8 | 商元王 | 雍己 | 前1487年-前1476年（12年） |  诸侯不来朝|\n| 9 | 商中宗 | 太戊 | 前1486年-前1412年（75年） | 小国又纷纷归顺，商朝中兴  |\n| 10 | 商孝成王 | 仲丁 | 前1418年-前1408年（13年） |  |\n| 11 | 商思王 | 外壬 | 前1407年-前1398年 （10年）| 九世之乱 |\n| 12 | 商前平王 | 河檀（dan）甲 | 前1397年-前1389年（9年） | 迁都河南内黄  |\n| 13 | 商穆王 | 祖乙 | 前1388年-前1370年（19年） |  |\n| 14 | 商桓王 | 祖辛 | 前1369年-前1356年（16年） |  |\n| 15 | 商僖（xi）王 | 沃甲 | 前1355年- 前1336年（20年） |  |\n| 16 | 商庄王 | 祖丁 | 前1335年- 前1327年（9年） |  |\n| 17 | 商顷王 | 南庚 | 前1326年-前1321年（6年） | 国都由庇（山东郓城）迁奄（山东曲阜） |\n| 18 | 商悼王 | 阳甲 | 前1321年- 前1314年（8年） |  |\n| 19 | 商世祖 | 盘庚 | 前1313年-前1286年（28年） | 迁都殷（河南安阳） |\n| 20 | 商章王 | 小辛 | 前1285年- 前1272年（14年） |  |\n| 21 | 商惠王 | 小乙 | 前1271年- 前1251年（21年） |  |\n| 22 | 商高宗 | 武丁 | 前1250年- 前1192年（59年） | 武丁中兴 |\n| 23 | 商后平王 | 祖庚 | 前1191年-前1180年（12年） |  |\n| 24 | 商世宗 | 祖甲 | 前1180年-前1160年（20年） |  |\n| 25 | 商甲宗 | 廪（lin）辛 | 前1159年-前1156年（4年） |  |\n| 26 | 商康祖 | 庚丁 | 前1155年- 前1147年（9年） |  |\n| 27 | 商武祖 | 武乙 | 前1147年-前1113年（35年） |  |\n| 28 | 商匡王 | 文丁 | 前1112年-前1102年（11年） |  |\n| 29 | 商德王 | 帝乙 | 前1101年- 前1076年（26年） |  |\n| 30 | 商纣王 | 帝辛 | 前1075年-前1046年（30年） |  |\n\n### 2.2.2、商朝建立及迁徙过程\n商朝兴起于夏朝的东方，即黄河中下游，为子姓。其始祖名契，契母简狄是属于有戎的后代。传说是吞玄鸟之蛋而生契，这就是《诗经·商颂· 玄鸟》中的菩名诗句:“天命玄鸟，降而生商。”无疑，商人是以鸟为图腾的。商人逐渐西迁，从契到成汤历十四代王，共移徙八次。到汤时西进逼近夏人所居，终于灭掉夏王朝而建立商朝，都于毫(其地理位置尚存争议，或说商丘，或说偃师)。据史载，商汤立国之后，商人仍“不常厥邑”，又有五次迁都，历史上有“前八后五”的说法。到第二十代王盘庚时，他说服并胁迫商贵族再次迁徙，最终将商朝的都城固定下来，这就是目前所知的殷墟(河南安阳)。\n\n\n### 2.2.3、商朝政治体制\n\n商周王朝都是世袭王权制，政权掌控在王手，商王在甲骨文中称为“余一人”。商代前期还处在兄终弟及的状态，后期转变为父死子继制度。商王朝的主要官员分为臣、将军和史官（包括巫人、贞人（占卜者）和祭司等）三大类\n## 2.3、周王朝\n\n周朝（前1046年—前256年，791年），是中国历史上最长的朝代 \n\n### 2.3.1、西周年表\n\n| 序号 | 谥号                           | 姓名           | 在位时间                                                                                              | 相关事件                                                         |\n| :--- | :----------------------------- | :------------- | :---------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------- |\n| 1    | 周文王                         | 姬昌           | 公元前 1110 年-前 1061 年为西伯（50 年）                                                              | 创《周易》  寿命 97                                     |\n| 2    | 周武王                         | 姬发           | 公元前 1060 年-前 1046 年为西伯（15 年）公元前 1046 年-前 1043 年为周王（4 年） | 孟津观兵   牧野之战  灭商建周，定都镐京（西安） |\n| 3    | 周成王                         | 姬诵           | 公元前 1042 年-前 1021 年（22 年）                                                                    | 成康之治 周公摄政 迁都洛邑（洛阳）                             |\n| 4    | 周康王                         | 姬钊           | 公元前 1020 年-前 996 年（25 年）                                                                     |                                                                  |\n| 5    | 周昭王                         | 姬瑕           | 公元前 995 年-前 977 年（18 年）                                                                      |                                                                  |\n| 6    | 周穆王                         | 姬满           | 公元前 976 年-前 922 年（55 年）                                                                      |                                                                  |\n| 7    | 周共王                         | 姬繄扈（yihu） | 公元前 922 年-前 900 年（23 年）                                                                      |                                                                  |\n| 8    | 周懿王                         | 姬囏（jian）   | 公元前 899 年-前 892 年（8 年）                                                                       | 迁都槐里（兴平市）                                    |\n| 9    | 周孝王                         | 姬辟方         | 公元前 891 年-前 886 年（6 年）                                                                       | 非子封秦                                          |\n| 10   | 周夷王                         | 姬燮（xie）    | 公元前 885 年-前 878 年（8 年）                                                                       | 煮杀齐哀公                                                       |\n| 11   | 周厉王                         | 姬胡           | 公元前 877 年-前 841 年（37 年）                                                                      | 贪图财利                                                         |\n|      | 共和（一说为共伯和摄行天子政） |                | 公元前 841 年-前 828 年（14 年）                                                                      |                                                                  |\n| 12   | 周宣王                         | 姬静           | 公元前 828 年-前 783 年（46 年）                                                                      |                                                                  |\n| 13   | 周幽王                         | 姬宫湦         | 公元前 782 年-前 771 年（12 年）                                                                      | 烽火戏诸侯（存疑）                                               |\n\n### 2.3.2、东周年表\n\n西周末年，周幽王因宠爱褒姒而废黜申后及太子宜臼，立褒姒为后，并立其子伯服为太子，引起申候的叛变。申候引犬戎政入关中，杀死幽王。于是公元前770年周平王被迫东迁至洛邑，开始了中国历史上的东周。\n\n| 序号 | 谥号           | 姓名   | 在位时间                                                                            | 相关事件                       |\n| :--- | :------------- | :----- | :---------------------------------------------------------------------------------- | :----------------------------- |\n| 1    | 周平王         | 姬宜臼 | 公元前 770 年-前 718 年（53 年）                                                    | 迁都洛邑列秦诸侯春秋之始       |\n| 2    | 周桓王         | 姬林   | 公元前 718 年-前 697 年（22 年）                                                    |                                |\n| 3    | 周庄王         | 姬佗   | 公元前 697 年-前 682 年（16 年）                                                    | 平定王子克之乱                 |\n| 4    | 周釐王         | 姬胡齐 | 公元前 682 年-前 677 年（6 年）                                                     | 齐桓称霸                       |\n| 5    | 周惠王         | 姬阆   | 公元前 677 年-前 675 年第一次在位（3 年）公元前 673 年-前 652 年第二次在位（22 年） | 五大夫作乱                     |\n| 6    | 周废王（篡位） | 姬颓   | 公元前 675 年-前 673 年（3 年）                                                     | 叛乱称王，后兵败遭杀           |\n| 7    | 周襄王         | 姬郑   | 公元前 652 年-前 619 年（34 年）                                                    |                                |\n| 8    | 周顷王         | 姬壬臣 | 公元前 619 年-前 613 年（7 年）                                                     |                                |\n| 9    | 周匡王         | 姬班   | 公元前 613 年-前 607 年（7 年）                                                     | 赵盾事件                       |\n| 10   | 周定王         | 姬瑜   | 公元前 607 年-前 586 年（22 年）                                                    | 赵氏孤儿                       |\n| 11   | 周简王         | 姬夷   | 公元前 586 年-前 572 年（15 年）                                                    |                                |\n| 12   | 周灵王         | 姬泄心 | 公元前 572 年-前 545 年（28 年）                                                    |                                |\n| 13   | 周景王         | 姬贵   | 公元前 545 年-前 520 年（26 年）                                                    | 数典忘祖                       |\n| 14   | 周悼王         | 姬猛   | 公元前 520 年-前 520 年（1 年）                                                     |                                |\n| 15   | 周敬王         | 姬匄   | 公元前 520 年-前 475 年（46 年）                                                    |                                |\n| 16   | 周元王         | 姬仁   | 公元前 475 年-前 473 年（3 年）                                                     | 周元王开始为战国时期           |\n| 17   | 周贞定王       | 姬介   | 公元前 473 年-前 441 年（33 年）                                                    |                                |\n| 18   | 周哀王         | 姬去疾 | 公元前 441 年-前 441 年（1 年）                                                     |                                |\n| 19   | 周思王         | 姬叔   | 公元前 441 年-前 441 年（1 年）                                                     | 在位仅五个月，即被弟弟姬嵬杀死 |\n| 20   | 周考王         | 姬嵬   | 公元前 441 年-前 426 年（16 年）                                                    | 叔弑兄篡位                     |\n| 21   | 周威烈王       | 姬午   | 公元前 426 年-前 402 年（25 年）                                                    | 三家分晋                       |\n| 22   | 周安王         | 姬骄   | 公元前 402 年-前 376 年（27 年）                                                    |                                |\n| 23   | 周烈王         | 姬喜   | 公元前 376 年-前 369 年（8 年）                                                     |                                |\n| 24   | 周显王         | 姬扁   | 公元前 369 年-前 321 年（49 年）                                                    | 桂陵之战 马陵之战 商鞅变法     |\n| 25   | 周慎靓王       | 姬定   | 公元前 321 年-前 315 年（7 年）                                                     |                                |\n| 26   | 周赧王         | 姬延   | 公元前 315 年-前 256 年（60 年）                                                    | 债台高筑 降秦昭襄王            |\n\n\n### 2.3.3、甲骨文和金文\n\n1. 甲骨文\n\n甲骨文是一种刻写在甲骨上的古文字。从出土实物来看，绝大多数为契刻,仅少数是书写的。甲骨文的“甲”指的是龟甲，多为腹甲:“骨”指的是兽骨，以牛肩脚骨为主，还有少量的牛肋骨、鹿头骨、牛头骨、人头骨、虎骨等\n殷墟甲骨文的出土，说明了商代历史的可靠性，成为了研究商代历史最主要的资料。金文的出现则大大拓展了周代历史的研究领域，丰富了对周代历史的认识。甲骨文和金文，是研究商周历史极其重要的第一手资料\n\n2. 金文 \n\n金文就是铭刻在青铜器上的文字，它与商代甲骨文之间有直接的承关系。西周金文的内容，包括战争、祭祀、外交、土地和人畜买卖等。金文主要铸造或镌刻在青铜器上。保守地估计，中国使用青铜的时间大约有1500多年，即从公元前2000年到公元前500，这段时期被称为中国历史上的“青铜时代”\n\n\n### 2.3.4、周朝政治体制\n\n周代的政治体制，与商人有某些共同之处。周王是最高的世袭统治者，他自称“天子”\n西周王朝的直接统治限于王畿内，也就是《诗经》的“王风”部分;其王畿外的统治则是通过分封制度来实现的，即《诗经》中的十五“国风”部分\n\n### 2.3.5、周代的几种制度\n周初灭商不久，对商人后裔实行一种由周人亲戚统领管理的相对自治统治，谓之“疆以周索”，又把商人中心区域分成邶（bei）、庸、卫三部分，分别派周武王弟弟管叔、蔡叔、霍叔去监管，这就是历史上的“三监”。但是周武王去世后，三监对周公摄政不满于是与殷人后裔联合起来反叛周王朝。周公便带兵东征，经过几年的战争之后，平服了这场叛乱，杀掉了武庚和管叔，并将蔡叔和霍叔加以流放。史称“周公东征”\n\n周公东征后，周人便实行分封制度，力图通过“封建亲戚”的办法，实现“以藩屏周”的政治效果。这场大规模的分封，受封的对象主要是三类:是同姓子弟，二是异姓的功臣，三是先王后裔\n\n# 3、春秋战国\n\n# 4、秦国\n\n## 4.1、秦朝年表\n\n| 序号 |  谥号               |  姓名           |  在位时间             |  相关事件                         |\n|:---|:------------------|:--------------|:------------------|:------------------------------|\n|  1 |  非子               |  嬴非           |  前900年-前858年（43年） |  因善于养马，得到周孝王的赏识，获封秦地，成为秦国始封君  |\n|  2 |  秦侯               |  嬴侯           |  前857年-前848年（10年） |                               |\n|  3 |  秦公伯              |  嬴伯           |  前847年-前845年（3年）  |                               |\n|  4 |  秦仲               |  嬴仲           |  前844年-前822年（23年） |  被周王任命为西我大夫，后战死               |\n|  5 |  秦庄公              |  嬴其           |  前821年-前778年（44年） |                               |\n|  6 |  秦襄公(立为诸侯)        |  嬴开           |  前777年-前766年（12年） |  看秋时期秦国第一任因君，辅平王东迁            |\n|  7 |  秦文公              |  嬴康           |  前765年-前716年（50年） |  迁都汧渭之会（千河和渭河交界）              |\n|  8 |  秦静公(秦竫公)         |  嬴鼎           |  未即位              |                               |\n|  9 |  秦宪公(秦宁公)         |  嬴立           |  前715年-前704年（12年） |                               |\n| 10 |  秦出子              |  嬴曼           |  前703年-前698年（6年）  |                               |\n| 11 |  秦武公              |  嬴说           |  前697年-前678年（20年） |                               |\n| 12 |  秦德公              |  嬴嘉           |  前677年-前676年（2年）  |  迁都雍城                         |\n| 13 |  秦宣公              |  嬴恬           |  前675年-前664年（12年） |                               |\n| 14 |  秦成公              |  嬴载           |  前663年-前660年（4年）  |                               |\n| 15 |  秦穆公              |  嬴任好          |  前659年-前621年（39年） |                               |\n| 16 |  秦康公              |  嬴罃           |  前620年-前609年（12年） |                               |\n| 17 |  秦共公              |  嬴稻/嬴貑        |  前608年-前605年（4年）  |                               |\n| 18 |  秦桓公              |  嬴荣           |  前604年-前577年（28年） |                               |\n| 19 |  秦景公              |  嬴石           |  前576年-前537年（40年） |  栎之战 迁延之役                     |\n| 20 |  秦哀公(秦毕公/秦㻫公)     |  嬴籍           |  前536年-前501年（36年） |                               |\n| 21 |  秦夷公              |  嬴扩           |  未即位              |                               |\n| 22 |  秦惠公              |  嬴宁           |  前500年-前492年（9年）  |                               |\n| 23 |  秦悼公              |  嬴盘           |  前491年-前477年（15年） |                               |\n| 24 |  秦厉共公(秦剌龚公/秦利龚公)  |  嬴刺           |  前476年-前443年（34年） |                               |\n| 25 |  秦躁公(秦趮公)         |  嬴欣           |  前442年-前429年（14年） |                               |\n| 26 |  秦怀公              |  嬴封           |  前428年-前425年（4年）  |                               |\n| 27 |  秦灵公(秦肃灵公)        |  嬴肃           |  前424年-前415年（10年） |                               |\n| 28 |  秦简公              |  嬴悼子          |  前414年-前400年（15年） |                               |\n| 29 |  秦惠公              |  嬴仁           |  前399年-前387年（13年） |                               |\n| 30 |  秦出公(秦少主)         |  嬴昌           |  前386年-前385年（2年）  |  母亲主持朝政，重用宦官外戚                |\n| 31 |  秦献公/秦元献公         |  嬴师隰/嬴连       |  前384年-前362年（23年） |  废止人殉制度                       |\n| 32 |  秦孝公              |  嬴渠梁          |  前361年-前338年（24年） |  启用商鞅变法，迁都咸阳，建立县制行政           |\n| 33 |  秦惠文王(秦惠王)        |  嬴驷           |  前337年-前311年（27年） |  改公称王，成为秦国第一王                 |\n| 34 |  秦武王(秦悼武王/秦武烈王)   |  嬴荡           |  前310年-前307年（4年）  |                               |\n| 35 |  秦昭襄王(秦昭王)        |  嬴则/嬴稷        |  前306年-前251年（56年） |  长平破赵，灭亡东周，奠基统一               |\n| 36 |  秦孝文王             |  嬴柱           |  前250年（3天）        |                               |\n| 37 |  秦庄襄王(秦庄王)        |  嬴异人/嬴子楚(嬴楚)  |  前249年-前247年（3年）  |                               |\n| 38 |  秦王政（秦始皇）         |  嬴政           |  前246年-前221年（25年） |  统一六国 建立皇帝制度 修筑万里长城           |\n| 39 |  秦二世（胡亥）          |  嬴胡亥          |  前210年―前207年（3年）  |                               |\n| 40 |  秦三世（子婴）          |  嬴子婴          |  前207年―前207年（46天） |  诛杀赵高                         |  \n\n# 5、汉朝\n\n汉朝（前202年-220年（405年））是继秦朝之后的大一统王朝，分为西汉、东汉时期\n\n## 5.1.1、西汉年表\n\n| 序号 |  别名   |  姓名       |  在位时间           |  主要事件                             |\n|:---|:------|:----------|:----------------|:----------------------------------|\n|  1 |  汉高祖  |  刘邦       |  前202-前195（8年）  |  建立汉朝                             |\n|  2 |  汉惠帝  |  刘盈       |  前195-前188（8年）  |  萧规曹随                             |\n|  3 |  前少帝  |  刘恭       |  前188-前184（5年）  |  吕雉称制                             |\n|  4 |  后少帝  |  刘弘       |  前184-前180（5年）  |                                   |\n|  5 |  汉文帝  |  刘恒       |  前180-前157（24年） |  文景之治 无为而治                        |\n|  6 |  汉景帝  |  刘启       |  前157-前141（17年） | 儿子中山靖王17代玄孙是刘备                    |\n|  7 |  汉武帝  |  刘彻       |  前141-前87（45年）  |  推恩令，通西域                          |\n|  8 |  汉昭帝  |  刘弗陵      |  前87-前74（14年）   |  昭宣中兴                             |\n|  9 |  汉废帝  |  刘贺       |  前74年7月-8月      |                                   |\n| 10 |  汉宣帝  |  刘询       |  前74-前48（27年）   |  昭宣中兴                             |\n| 11 |  汉元帝  |  刘奭（shi）  |  前48-前33（16年）   |  平灭北匈奴                            |\n| 12 |  汉成帝  |  刘骜       |  前33-前7（27年）    |                                   |\n| 13 |  汉哀帝  |  刘欣       |  前7-前1（7年）      |                                   |\n| 14 |  汉平帝  |  刘衎       |  前1-6年（1年）      |  王莽摄政（王政君侄子） <div>9岁被毒死<br></div> |\n| 15 |  孺子婴  |  刘婴       |     6年-8年（未称帝）  |                           21岁被杀   |  \n\n## 5.1.2、东汉年表\n\n| 序号 |  别名   |  姓名      |  在位时间       |  主要事件                           |\n|:---|:------|:---------|:------------|:--------------------------------|\n|  1 |  光武帝  |  刘秀      |    25年-57年（33年）  |  光武中兴                           |\n|  2 |  汉明帝  |  刘庄      |    57年-75年（19年）  |  明章之治                           |\n|  3 |  汉章帝  |  刘炟（da）  |    75年-88年（14年）  |                                 |\n|  4 |  汉殇帝  |  刘隆      |       106年  |  邓绥称制                           |\n|  5 |  汉安帝  |  刘祜      |  106年-125年（20年）  |                                 |\n|  6 |  少帝   |  刘懿      |       125年  |  阎皇后称制                          |\n|  7 |  汉顺帝  |  刘保      |  125年-144年（20年）  |                                 |\n|  8 |  汉冲帝  |  刘炳      |  144年-145年（2年）  |  梁妠称制                           |\n|  9 |  汉质帝  |  刘缵      |  145年-146年（2年）  |   9岁被毒死   |\n| 10 |  汉桓帝  |  刘志      |  146年-168年（23年）  |  夺回皇权                           |\n| 11 |  汉灵帝  |  刘宏      |  168年-189年（22年）  |  卖官鬻爵 十常侍作乱     |\n| 12 |  汉少帝  |  刘辩      |       189年  |  被董卓罢黜 15（18）岁自杀 |\n| 13 |  汉献帝  |  刘协      |  189年-220年（32年）  |  曹操摄政   |  \n\n\n## 5.1.3、三国相关人物表\n\n### 5.1.3.1、朝廷（东汉）& 群雄\n\n|  序号  | 人物          |  相关事件                                          |\n|:-----|:------------|:-----------------------------------------------|\n|    1  | 刘志（汉桓帝）     |  外戚专权                                          |\n|    2  | 刘宏（汉灵帝）     | 黄巾起义                                           |\n|    3  | 窦妙（窦太后）     | 刘志之母                                           |\n|    4  | 董太后（永乐太后）   | 刘宏之母                                           |\n|   5   | 十常侍         | 张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜             |\n|  6    |  何皇后        |  刘辩之母，汉灵帝刘宏第二任皇后                                        |  \n|   7   |  王荣（王美人）         |  刘协之母，汉灵帝刘宏妃子，被何皇后毒杀                             |  \n|   8   |  何进         |  何皇后哥哥，刘辩舅舅                                    | \n|    9  |  刘辩（汉少帝）         | 被董卓废掉，毒杀                                     | \n|   10   |  刘协 （汉献帝）       |   陈留王                                   | \n|   11   |  刘恢       |  代郡太守，刘备鞭都邮后投奔他，他保护刘备不被追查，并推荐他给刘虞                     | \n|   12     |  张角           | “天公将军”，创立太平道，提出“苍天已死，黄天当立”的口号以号召徒众，史称“黄巾军”   |\n|    13    |  张宝           | “地公将军”，张角之弟，后来被皇甫嵩、郭典击败，被杀                       |\n|   14     |  张梁           |  “人公将军”，张宝之弟，遭到遭皇甫嵩击败，被杀                         |\n|    15    |  董太后（永乐太后）    |  刘宏之母                                            |\n|    16    |  十常侍          |  张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜              |\n|   17     |  卢植           |  刘备老师，东汉名臣，参与平叛黄巾起义                                          |  \n|   18     |  袁绍           |  （1）四世三公，早年任中军校尉，曾指挥诛杀宦官，建议何进引董卓 （2）争夺天下的野心与曹操产生冲突，最终在赤壁之战中被曹操击败      |\n|    19    |  袁术           |  （1）袁绍的弟弟。（2）与袁绍、曹操等同时起兵，共讨董卓。其后因与袁绍对立，被袁绍、曹操击败，率余众奔九江，割据扬州 （3）奢侈荒淫，横征暴敛，使江淮地区残破不堪，民多饥死     |\n|     20   |  董卓           |  西凉刺史      | \n|    21    |  李儒           |  董卓谋士 毒死刘辩                | \n|   22     |  丁原           |  字建阳，并州刺史         | \n|    23    |  吕布           |  诛杀董卓          | \n|    24    |  樊稠           |  （1）原为董卓部将，董卓死后，伙同李傕、郭汜、张济等人合众十余万反扑长安，败吕布、杀王允，把持朝政 。后因内斗被李傕外甥胡封在会议上刺死 （2）大败马腾、韩遂      |\n|   25     |  李肃           |  董卓手下虎贲中郎将，主动请命以赤兔马说服吕布杀丁原来降                    |\n|    26    |  王允           |  设计诛杀董卓。后欲解散董卓的凉州兵旧部，使其人人自危，董卓部将李傕、郭汜乃合谋为乱，攻进长安，王允被杀                                   | \n|    27    |  公孙瓒           | 军阀，汉末群雄之一，卢植学生   | \n|   28     |  华雄           | 董卓帐下武将  | \n|    29    |  颜良           | 袁绍部将   白马之围 | \n|    30    |  文丑           | 袁绍部将    | \n|    31    |  蔡邕           | 东汉时期名臣，蔡文姬之父，被董卓重用，董卓死后被王允杀    | \n|    32    |  陶谦           | 徐州太守    | \n|    33   |  刘表           | 雄踞荆州，杀孙坚    | \n|    34    |  曹豹           | 东汉末年徐州牧陶谦部将，吕布的老丈人    | \n|     35   |  张绣           | 称雄宛城、在官渡之战力战有功，封邑最多    | \n|     36  |  潘凤           | 称雄宛城、在官渡之战力战有功，封邑最多冀州牧韩馥帐下的大将。当十八路诸侯讨伐董卓之时，他奉韩馥、袁绍之命前往汜水关前挑战董卓部下大将华雄，结果不多时就被斩    | \n|37     | 孔融 |  孔子的第二十世孙 （208年）因触怒丞相曹操而被杀  孔融让梨  |\n|38     | 沮授 |  东汉末年袁绍的监军 多次提出策略不被采纳  |\n|39    | 逢纪 |  袁绍谋士 辅佐袁绍平定河北  |\n| 40   | 田丰 |  袁绍谋士 助袁绍灭公孙瓒  |\n| 41   | 于吉 |  琅琊人 ，东汉末年道士，后为孙策所杀，代表作有《太平经》 |\n| 42   | 蔡瑁 |  协助刘表平定荆州 刘表后妻蔡夫人弟弟 |\n| 43   | 司马徽 |  东汉末年隐士，精通奇门、经学。有“水镜先生”之称 向刘备推荐了诸葛亮、庞统等人|\n| 44   | 马腾 |  东汉末年军事将领，军阀之一，马超，马铁之父 |\n| 45   | 孟获 |  三国时期南中地区的首领，公元225年起兵反叛蜀汉，被诸葛亮率领大军擒拿后被赦免，遂降服，此后不再叛乱，后孟获随诸葛亮回到成都，担任御史中丞 |\n### 5.1.3.2、魏\n\n|   序号   |  人物           |   相关事件                                           |\n|:-------|:--------------|:-------------------------------------------------|\n|    1    |  曹操          | （1）太尉曹嵩之子 （2）献七星宝刀  |\n|     2   |  乐进          | 斩淳于琼；斩严敬；每战先登；击退关羽；降伏蛮夷  |\n|    3    |  李典          | 曾在博望坡之战识破刘备的伪遁之计，救下了夏侯惇、于禁。又参与了逍遥津之战 |\n|    4    |  曹仁          | 破袁术、攻陶谦、擒吕布、败刘备，参加官渡之战  |\n|    5    |  夏侯惇          | 夏侯渊之族兄，汉朝开国功臣之一夏侯婴的后代  |\n|    6    |  夏侯渊          |  夏侯惇族弟, 官渡督粮、平定凉州, 被黄忠斩杀|\n|    7    |  曹洪          | （1）曹操从弟 （2） 早年随曹操起兵讨伐董卓。荥阳兵败，舍命献马，救驾于危难|\n|    8    |  贾诩|原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操|\n|   9     |  荀彧          |  早年被称为“王佐之才” 为曹操规划军事战略方针，堪称其统一北方的首席谋 |\n|    10    |  荀攸          |  是荀彧的堂侄，曹操的重要谋士 |\n|    11    |  程昱          |  本名程立，因梦中在泰山捧日，更名程昱 |\n|    12    |  郭嘉          |  经荀彧推荐，任曹军祭酒 |\n|    13    |  刘晔          |  光武帝刘秀之子阜陵王刘延的后代 |\n|    14    |  满宠          | 平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰  |\n|    15    |  典韦          | 濮阳之战击退吕布、宛城死战阻张绣  |\n|    16    |  于禁          | 讨伐黄巾余党、于张绣叛乱中坚守营垒，杀夏侯惇的青州军  |\n|    17    |  许诸          | 负责曹操的护卫工作，累迁武卫中郎将，赐号“虎侯”  |\n|    18    |  贾诩          |  曹魏开国功臣，原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操 |\n|    19    |  陈登          | 沛相陈珪之子，向曹操献灭吕布之策  |\n|    20    |  陈珪          | 陈登、陈应之父。官至沛相。助破袁术，策应曹操  |\n|    21    |  车胄          | 曹操灭吕布占有徐州之地后，任命车胄为徐州刺史。被关羽斩杀，全家也被张飞杀害  |\n|    22    |  曹昂          | 曹操长子。建安二年（197年）随曹操出征张绣，张绣降而复叛，曹昂为救曹操被杀  |\n|   23     |  张辽          | 雁门马邑（今山西省朔州市）人。先后跟随丁原、何进、董卓、吕布，恪尽职守，历尽坎坷。吕布败亡后，张辽归属曹操  |\n|    24    |  许攸          | 本为袁绍帐下谋士，官渡之战时其家人因犯法而被收捕，许攸因此背袁投曹，并为曹操设下偷袭袁绍军屯粮之所——乌巢的计策，袁绍因此而大败于官渡。后许攸随曹操平定冀州，因自恃其功而屡屡口出狂言，终因触怒曹操而被杀  |\n|    25    |  曹丕          | 曹操长子 建立曹魏；大破羌胡，复通西域  |\n|    26    |  司马懿          | 司马懿辅佐了魏国四代君主，见证了曹氏家族从兴盛走向衰亡，为稳定曹魏政权做出了贡献，也为其孙司马炎以晋代魏一统中国奠定了基础  |\n|    27   |  满宠          |  平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰 |\n|    28   |  曹真          |  曹操养子 大败羌胡联军 平定河西 大破吴国孙盛 击退蜀汉诸葛亮|\n|    29  |  曹睿       |  曹魏第二位皇帝。魏文帝曹丕长子 与曹操、曹丕并称魏氏“三祖”|\n|    30  |  钟会       |  平诸葛诞之叛、与邓艾分兵灭蜀|\n|    31  |  张郃       |  江陵破吴，街亭败蜀|\n|    32  |  曹芳       |  曹魏第三位皇帝，疑为魏武帝曹操曾孙|\n|    33  |  曹爽       |  曹魏权臣，大司马曹真长子|\n|    34  | 司马师     |  曹魏权臣，西晋王朝的奠基人之一，晋宣帝司马懿与宣穆皇后张春华的长子，晋文帝司马昭的同母兄，晋武帝司马炎的伯父|\n|    35  | 司马昭     |  司马炎之父，专揽国政，攻灭蜀汉；奠定西晋基础|\n|    36 | 郭淮     |  魏国名将，雁门郡太守郭缊之子 被姜维杀|\n|    37 | 曹髦     |  曹丕之孙，东海王曹霖之子，曹魏第四位皇帝 不满司马昭掌权反抗被杀|\n|    38 | 邓艾     |  治理魏国西方，与姜维多次对峙；率兵偷渡阴平，攻灭蜀汉|\n|    39 | 曹奂     |  三国时期曹魏末代皇帝（第五位）。魏武帝曹操之孙 司马炎篡夺魏国政权，建立西晋|\n|    40 | 诸葛瞻     |  诸葛亮之子 与邓艾决战，兵败被杀，绵竹失守。后主刘禅出降，蜀汉灭亡|\n|    41 | 刘禅     |  小名阿斗。蜀汉末代皇帝，刘备之子，母为昭烈皇后甘氏|\n### 5.1.3.3、蜀\n\n|   序号   |  人物           |   相关事件                                           |\n|:-------|:--------------|:-------------------------------------------------|\n|   1     |  刘备           | 汉景帝之子中山靖王刘胜之后   |\n|    2    |  关羽           |  山西运城人                      |\n|   3     |  张飞           |  今河北保定涿州市人                       |\n|   4     |  糜竺    |  麋竺原为徐州富商，后被徐州牧陶谦辟为别驾从事（官名）。陶谦病死后，奉其遗命迎接刘备          |\n|    5    |  简雍         |  刘备帐下谋士              |\n|   6    |  诸葛亮          |  蜀汉丞相，向刘备提出占据荆州、益州，联合孙权共同对抗曹操的隆中对  五次北伐                                       | \n|   7     |  赵云           |  （1）与关羽、张飞并称“燕南三士”   （2）先加入公孙瓒，后追随刘备                                          | \n|   8     |  孙乾           |     东汉末年刘备帐下幕僚                                     | \n|   9     |  廖化           |     攻破游奕，击杀王赟                                    | \n|   10     |  周仓           |     关羽身边的武将。在关羽镇守荆州对抗曹魏名将于禁与庞德的战斗中，于水中生擒庞德。最后周仓在关羽父子被斩之后自刎而死                                 | \n|   11     |  廖化           |     攻破游奕，击杀王赟                                    | \n|    12    |  徐庶        |   东汉末年刘备帐下谋士，后归曹操                                  | \n|    13    |  庞统        |   刘备帐下重要谋士，与诸葛亮同拜为军师中郎将   攻打益州刘璋时死于落凤坡                              | \n|    14    |  黄忠        |   本为刘表部下中郎将，后归刘备，并助刘备攻破益州刘璋    | \n|    15    |  魏延        |   镇守汉中，大破费瑶和郭淮，子午谷奇谋    | \n|    16   |  马超        |   马腾长子，马铁，马休兄长  辅助刘备建立蜀汉    | \n|    17  |  张苞      |   张飞的长子。英年早逝，留有一子张遵    | \n|    18  |  关兴      |   关羽次子，关平之弟    | \n|    19  |  马良      |   马良兄弟五人，都有才华名气，乡里为他们编有谚语说：“马家五常，白眉最良。”马良眉中有白毛，故此人们这样称呼他    | \n|   20  |  马谡      |  马良之弟，诸葛亮北伐时因作战失误失守街亭   | \n|   21 |  姜维      |  洮西大破王经，据守剑阁阻挡住钟会大军   | \n|   22 |  邓芝      | 出使吴国，与之修好 讨平涪陵叛乱   | \n|   23 |  王平      | 击退曹爽大举伐蜀   | \n|   24 |  杨仪      | 辅佐诸葛亮、击杀魏延   | \n|   25 |  蒋琬      | 继诸葛亮执政，安定众心   | \n|   26 |  李严      | 与诸葛亮同为刘备临终前的托孤之臣 参与制定《蜀科》   | \n|   27|  马岱      | 马超从弟，在诸葛亮病逝后受杨仪派遣斩杀了蜀将魏延   | \n|   28|  费祎      | 蜀汉四相之一 休养生息，增强蜀汉国力   | \n### 5.1.3.4、吴\n\n|   序号   |  人物           |   相关事件                                           |\n|:-------|:--------------|:-------------------------------------------------|\n|   1     |  孙坚           | （1）孙吴政权的奠基者 （2）洛阳城外击溃董卓  |\n|    2    |  程普           | 从孙坚讨黄巾、破董卓；救孙策，定江东；参与赤壁之战、南郡之战  |\n|   3     |  黄盖           |  在赤壁之战中诈降，献计火攻 |\n|   4     |  孙策           |  孙坚长子，字伯符 |\n|   5     |  孙权           | 孙坚次子，字仲谋  |\n|   6     |  孙尚香          | 孙权之妹，曾为刘备之妻，民间戏剧称之为孙尚香  |\n|    7    |  周瑜           | 辅平江东、开拓荆州、赤壁破曹、督灭黄祖、谏阻纳质、提出征伐益州战略 \n|    8    |  张昭           | 辅佐孙策、孙权安定江东，与孙邵、滕胤等撰定朝仪 |\n|    9    |  张紘           | 东汉末年文学家、官员，和张昭一起合称“二张” |\n|   10     |  大乔           | 东汉末年江东孙策的夫人，本姓“桥”，小说《三国演义》误作“乔”，因为同时还有一个妹妹嫁给周瑜，为了进行区分，姐姐习惯称作“大乔（桥）”|\n|   11   |  鲁肃           | 孙权部将、战略家、外交家 |\n|   12   |  甘宁           | 先投靠刘表，但未被重用，后归依孙权，孙权加以重用。曾随周瑜在乌林击败曹操在南郡攻打曹仁夺取夷陵 |\n|   13   |  陆逊       | 与吕蒙共同击败关羽、夺取荆州 夷陵之战破刘备 石亭之战败曹休 |\n|   14   |  吕蒙          | 攻皖城 取三郡 濡须之战 袭荆州 |\n|   15   |  诸葛恪          | 大将军诸葛瑾长子，蜀汉丞相诸葛亮之侄 在东兴堤大胜魏军 |\n|   16   |  丁奉          |   在东兴之战中大破魏军前屯|\n|   17 |  孙亮          |   孙吴第二位皇帝 计除权臣诸葛恪 后被孙琳废|\n|   18 |  孙峻          |   诛杀诸葛恪，专擅朝政|\n|   19 |  孙休        |   孙权第六子。中国三国时期孙吴国主|\n|   20 |  孙綝（chen）        |   孙亮即位后由孙峻辅政。 太平元年（公元256年）孙峻去世，孙綝接替堂兄掌控朝局 被孙休、丁奉等定计诛杀|\n|   21 |  陆抗        |   西陵之战大破晋军；维护吴国稳定|\n## 5.1.4、三国势力图\n\n1. 初期势力图\n\n![三国势力图|725](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031910885.png)\n\n\n2. 三足鼎立势力图\n\n![三足鼎立|975](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031918859.png)\n\n\n# 6、魏晋南北朝时期\n\n## 6.1、魏晋南北朝时期概览\n\n魏晋南北朝（220—589年，370年），又称三国两晋南北朝，是中国历史上政权更迭最频繁的时期，主要分为三国（曹魏、蜀汉、东吴）、西晋、东晋和南北朝时期，由于长期的封建割据和连绵不断的战争，使这一时期中国文化的发展受到特别的影响。其突出表现则是玄学的兴起、佛教的输入、道教的勃兴。三国至隋的**三百六十余年**，以及三十余个大小王朝交替兴灭过程\n\n![魏晋南北朝时期](https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308051110202.png)\n\n\n# 7、隋朝\n\n## 7.1、隋朝年表\n\n隋朝（581年～619年,38年）是中国历史上承南北朝，下启唐朝的大统一朝代。定都大兴（西安）\n\n| 序号 | 谥号  | 姓名       | 在位时间            | 相关事件                                           |\n|:---|:----|:---------|:----------------|:-----------------------------------------------|\n|  1 | 隋文帝 | 杨坚       |  581年-604年（24年） | 三省六部制<div>开创科举</div><div>罢黜杨勇，立杨广</div>        |\n|  2 | 隋炀帝/隋明帝 | 杨广       |  604年-618年（15年） | 迁都洛阳 <div>穷奢极欲</div><div>隋朝大运河</div><div>江都兵变</div> |\n|  3 | 隋恭帝 | 杨侑       | 617年-618年（177天） | 被李渊拥立为帝，后被幽禁                                   |\n|  4 | 隋秦王 | 杨浩       |        618年（半年） | 被宇文化及拥立为帝，后被毒杀                                 |\n|  5 | 皇泰主 | 杨侗（dong） |   618年-619年（1年） | 被王世充拥立为帝，后被杀害                                  |  \n\n# 8、唐朝\n\n## 8.1、唐朝年表\n\n唐王李渊于618年逼隋恭帝禅位,推翻隋朝,改国号为“唐”(尊称“大唐”),建立了唐朝（618年－907年，289年）\n\n| 序号 |  别名   |  姓名        |  在位时间          |  主要事件                |\n|:---|:------|:-----------|:---------------|:---------------------|\n|  1 |  唐高祖  |  李渊        |   618-626（9年）  | 晋阳起兵，建立唐朝                     |\n|  2 |  唐太宗  |  李世民       |  627-649（23年）  |  玄武门之变，贞观之治          |\n|  3 |  唐高宗  |  李治        |  650-683（24年）  |                      |\n|  4 |  唐中宗  |  李显        |           684  |  被废                  |\n|  5 |  唐睿宗  |  李旦        |   684-690（6年）  |  被废                  |\n|  6 |  武则天  |  武曌（zhao）  |  690-705（16年）  |  武周开国君主（不属于唐）        |\n|  7 |  唐中宗  |  李显        |   705-710（5年）  |  神龙政变 被韦皇后毒死         |\n|  8 |  唐少帝  |  李重茂       |           710  |                      |\n|  9 |  唐睿宗  |  李旦        |   710-712（2年）  |  二次让位                |\n| 10 |  唐玄宗  |  李隆基       |  712-756（44年）  |  唐隆政变 唐明皇 安史之乱 开元之治  |\n| 11 |  唐肃宗  |  李亨        |   756-762（5年）  |                      |\n| 12 |  唐代宗  |  李豫        |  762-779（17年）  |                      |\n| 13 |  唐德宗  |  李适        |  779-805（26年）  |                      |\n| 14 |  唐顺宗  |  李诵        |       805（8月）  |                      |\n| 15 |  唐宪宗  |  李纯        |  806-820（15年）  |  元和中兴                |\n| 16 |  唐穆宗  |  李恒        |   821-824（4年）  |                      |\n| 17 |  唐敬宗  |  李湛        |   824-826（2年）  |                      |\n| 18 |  唐文宗  |  李昂        |  826-840（14年）  |                      |\n| 19 |  唐武宗  |  李炎        |   840-846（6年）  |                      |\n| 20 |  唐宣宗  |  李忱（chen）  |  846-859（13年）  |                      |\n| 21 |  唐懿宗  |  李漼（cui）   |  859-873（14年）  |                      |\n| 22 |  唐僖宗  |  李儇（xuan）  |  873-888（15年）  |  黄巢起义                |\n| 23 |  唐昭宗  |  李晔        |  888-904（16年）  |                      |\n| 24 |  唐哀帝  |  李柷（chu）   |   904-907（3年）  |                      |  \n\n# 9、五代十国\n\n# 10、宋朝\n\n## 10.1、宋朝年表\n\n宋朝（960年－1279年，319年）是中国历史上承五代十国下启元朝的中原王朝，分北宋和南宋两个阶段，共历十八帝\n\n| 序号 |  别名   |  姓名        |  在位时间          |  主要事件                |\n|:---|:------|:-----------|:---------------|:---------------------|\n|  1 |  宋太祖  |  赵匡胤        |  960-976（16年）  | 改革官帽 两次杯酒释兵权                    |\n|  2 |  宋太宗  |  赵炅       |  976-997（21年）  |  赵匡胤之弟 雪中送炭          |\n|  3 |  宋真宗  |  赵恒        |  997-1022（15年）  |  赵炅三子，澶渊之盟             |\n|  4 |  宋仁宗  |  赵祯        |  1022-1063（41年）  | 赵恒六子， 发行交子 狸猫换太子                |\n|  5 |  宋英宗  |  赵曙        |   1063-1067（4年）  |  赵祯堂兄赵允让第十三子     《资治通鉴》            |\n|  6 |  宋神宗  |  赵顼  |  1067-1085（18年）  |  赵曙长子，重用王安石变法        |\n|  7 |  宋哲宗  |  赵煦       |   1085-1100（15年）  |  赵顼六子         |\n|  8 |  宋徽宗  |  赵佶       |   1100-1126（26年）  |    赵顼十一子，书法绘画大师（瘦金体）  宋江起义 方腊起义    靖康之变  |\n|  9 | 宋钦宗 |  赵桓       |  1126-1127（1年）  | 赵佶长子，赵构异母兄弟 。1127年发生\"靖康之变\" 金朝南下攻取北宋首都东京，掳走徽、钦二帝，导致北宋灭亡的历史事件                  |\n|  10|  宋高宗  |  赵构      |  1127-1162（35年）  |  赵佶九子，南宋开国皇帝 ，重用秦桧         |\n|  11 |  宋孝宗  |  赵昚（shen） |  1162-1189（27年）  |  赵构养子 平反岳飞 隆兴和议 被认为南宋最有作为的皇帝          |\n|  12|  宋光宗 |  赵惇        |  1189-1194（5年）  | 绍熙内禅               |\n|  13 |  宋宁宗  |  赵扩      |    1194 -1224（30年）  |  赵惇次子         |\n|  14 |  宋理宗  |  赵昀（yun） |  1224-1264（40年）  |  赵扩远方堂侄 ，联蒙灭金     |\n|  15 |  宋度宗 |  赵禥（qi）       |  1264-1274（10年）  |  赵昀之侄，智力低于常人        |\n|  16 |  宋恭宗  |  赵㬎（xian）     |    1274-1276（2年）  |  赵禥次子 ，退位降元        |\n|  17 |  宋端宗  |  赵昰（shi） |  1276-1278（2年）  |  赵禥庶长子，九岁去世     |\n|  18 |  宋卫王 |  赵昺（昺）       |  1278-1279（1年）  |  赵禥三子，崖山海战，投海殉国      |\n\n# 11、元朝\n\n## 11.1、元朝年表\n\n元朝（1271年—1368年，98年），是中国历史上的朝代。铁木真于1206年建国；1271年忽必烈定国号为元，1279年灭南宋。 是首次由少数民族建立的大一统王朝，传五世十一帝\n\n| 序号 | 姓名 | 庙号 | 统治时间 | 事件 |\n| --- | --- | --- | --- | --- |\n| 1 | 孛儿只斤·铁木真 | 元太祖 | 1206-1227年（21年） | 大蒙古可汗，建立大蒙古国 |\n| 2 | 孛儿只斤·窝阔台 | 元太宗 | 1229-1241年（12年） | 蒙古帝国大汗，奠定元朝基础 |\n| 3 | 孛儿只斤·贵由 | 元定宗 | 1246-1248年（2年） | 蒙古帝国第三任大汗，西征欧洲 |\n| 4 | 孛儿只斤·蒙哥 | 元宪宗 | 1251-1259年（8年） | 大蒙古国可汗，招降吐蕃 |\n| 1 | 孛儿只斤·忽必烈 | 元世祖 | 1260-1294年 （34年）| 元朝开国皇帝，首创行省制度 |\n| 2 | 孛儿只斤·铁穆耳 | 元成宗 | 1294-1307年（13年） | 击败西北叛王 |\n| 3 | 孛儿只斤·海山 | 元武宗 | 1307-1311年（4年） | 设尚书省 |\n| 4 | 孛儿只斤·爱育黎拔力八达 | 元仁宗 | 1311-1320年（9年） | 实行科举制度 |\n| 5 | 孛儿只斤·硕德八剌 | 元英宗 | 1320-1323年（3年） |  |\n| 6 | 孛儿只斤·也孙铁木儿 | - | 1323-1328年（5年） | 史称泰定帝 |\n| 7 | 孛儿只斤·阿速吉八 | - | 1328年（27天） | 史称天顺帝 |\n| 8 | 孛儿只斤·图帖睦尔 | 元文宗 | 1329-1332年（3年） |  |\n| 9 | 孛儿只斤·和世㻋 | 元明宗 | 1329年（184天） |  |\n| 10 | 孛儿只斤·懿璘质班 | 元宁宗 | 1332年（52天） |  |\n| 11 | 孛儿只斤·懽帖睦尔 | 元惠宗 | 1333-1370年（37年） | 实施“至正新政”改革 |\n\n# 12、明朝\n\n## 12.1、明朝年表\n\n明朝（1368年―1644年，276年）明太祖朱元璋所建。初期建都南京，明成祖时期迁都北京。传十六帝\n\n|  序号  |  别名               |  姓名       |  年号     |  在位时间                 |  主要事件  |\n|:-----|:------------------|:----------|:--------|:----------------------|:-------|\n|   1  |  明太祖              |  朱元璋      |  洪武     |            1368-1398（20年）  |  洪武之治  |\n|   2  |  明惠宗              |  朱允炆      |  建文     |            1398-1402（4年）  |        |\n|   3  |  明成祖              |  朱棣       |  永乐     |            1402-1424（22年）  |  永乐盛世  |\n|   4  |  明仁宗              |  朱高炽      |  洪熙     |            1424-1425（1年）  |  仁宣之治  |\n|   5  |  明宣宗              |  朱瞻基      |  宣德     |            1425-1435（10年）  |        |\n|   6  |  明英宗              |  朱祁镇      |  正统 天顺  |  1435-1449 1457-1464  |  夺门之变  |\n|   7  |  明代宗              |  朱祁钰      |  景泰     |            1449-1457（8年）  |        |\n|   8  |  明宪宗              |  朱见深      |  成化     |            1464-1487（23年）  |        |\n|   9  |  明孝宗              |  朱祐樘      |  弘治     |            1487-1505（18年）  |  弘治中兴  |\n|  10  |  明武宗              |  朱厚照      |  正德     |            1505-1521（16年）  |        |\n|  11  |  明世宗              |  朱厚熜      |  嘉靖     |            1521-1566（45年）  |        |\n|  12  |  明穆宗              |  朱载坖      |  隆庆     |            1566-1572（6年）  |        |\n|  13  |  明神宗              |  朱翊（yi）钧  |  万历     |            1572-1620（48年）  |  万历中兴  |\n|  14  |  明光宗              |  朱常洛      |  泰昌     |                 1620  |        |\n|  15  |  明熹宗              |  朱由校      |  天启     |            1620-1627（7年）  |        |\n|  16  |  明思宗              |  朱由检      |  崇祯     |            1627-1644（17年）  |        |\n|      |  南明时期（1644-1662，18年）  |           |         |                       |        |\n|   1  |  明安宗              |  朱由崧      |  弘光     |            1644-1645（1年）  |        |\n|   2  |  明绍宗              |  朱聿键      |  隆武     |            1645-1646（1年）  |        |\n|   3  |                   |  朱聿鐭      |  绍武     |            1646年的1个月  |        |\n|   4  |  明昭宗              |  朱聿键      |  永历     |            1646-1662（16年）  |        |  \n\n\n# 13、清朝\n\n## 13.1、清朝年表\n\n清朝（1616年—1912年，296年），是中国历史上最后一个封建王朝，共传十二帝，初称后金。从努尔哈赤建国起，总计296年。从皇太极改国号为清起，国祚276年\n\n| 序号 | 姓名 | 年号 | 在位时间 | 主要事件 |\n| --- | --- | --- | --- | --- |\n| 1 | 努尔哈赤 | 天命 | 1616-1626（10年） | 统一女真 建立后金 反抗明朝 萨尔浒之战 |\n| 2 | 皇太极 | 天聪 崇德 | 1626-1643（17年） | 征服朝鲜和蒙古 松锦大捷 改国号大清和族名满洲 |\n| 3 | 福临 | 顺治 | 1643-1661（18年） | 李自成攻入北京 崇祯自缢而死 吴三桂引清军入关 大清迁都北京 |\n| 4 | 玄烨 | 康熙 | 1661-1722（61年） | 囚禁鳌拜 削三番 收复台湾 签订《尼布楚条约》 |\n| 5 | 胤禛 | 雍正 | 1722-1735（13年） | 设军机处 |\n| 6 | 弘历 | 乾隆 | 1736-1796（60年） | 编纂《四库全书》 大兴文字狱 实行闭关锁国 |\n| 7 | 永琰 | 嘉庆 | 1796-1820（24年） | 诛杀和珅 白莲教天理教起义 |\n| 8 | 旻宁 | 道光 | 1820-1850（30年） | 虎门销烟 第一次鸦片战争 《南京条约》，割香港给英国 |\n| 9 | 奕訢 | 咸丰 | 1850-1861（11年） | 太平天国起义 第二次鸦片战争 圆明园被毁  《天津条约》《北京条约》  洋务运动 |\n| 10 | 载淳 | 同治 | 1861-1874（13年） | 辛酉政变 慈溪垂帘听政 镇压太平天国 同治中兴 |\n| 11 | 载湉 | 光绪 | 1874-1908（34年） | 中法战争 中日甲午战争 戊戌变法 义和团 八国联军   《马关条约》《辛丑条约》 慈溪仍掌政 |\n| 12 | 溥仪 | 宣统 | 1908-1911（3年） | 辛亥革命 |","slug":"中国古代史","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sra7002x00ujdgog6ksg","content":"<h1 id=\"1、史前时期\"><a href=\"#1、史前时期\" class=\"headerlink\" title=\"1、史前时期\"></a>1、史前时期</h1><h2 id=\"1-1、中国人种起源及生存环境\"><a href=\"#1-1、中国人种起源及生存环境\" class=\"headerlink\" title=\"1.1、中国人种起源及生存环境\"></a>1.1、中国人种起源及生存环境</h2><p>人类进化链环的各个阶段，在中国境内大都可以找到对应的遗址。</p>\n<ol>\n<li>直立人: 西侯度人(山西，180万年前)、元谋猿人(云南，170万年前)、蓝田人(陕西，115-70万年前)、北京猿人(70-23万年前)</li>\n<li>早期智人 (古人)：长阳人(湖北，距今19.5万年)、丁村人(山西，距今20多万年）、大荔人（陕西，距今20-15万年前）</li>\n<li>晚期智人（新人）：猿类特征已经退化，体质特征接近现代人。柳江人（距今5-4万年，广西），河套人（距今5-3.7万年，内蒙古），山顶洞人（距今3万年，北京）</li>\n</ol>\n<h2 id=\"1-2、中国境内旧石器和新石器时代\"><a href=\"#1-2、中国境内旧石器和新石器时代\" class=\"headerlink\" title=\"1.2、中国境内旧石器和新石器时代\"></a>1.2、中国境内旧石器和新石器时代</h2><p>在考古学上，根据人类使用工具的进化程度不将历史划为:石器时代 (旧石器时代,新石器时代) -&gt; 青铜时代 -&gt; 铁器时代</p>\n<ol>\n<li>旧石器时代：距今250万年-1万年，特点是使用粗糙的打制石器，过着采集和渔猎生活，相当于人类历史上的原始人阶段</li>\n<li>新石器时代：距今1万-5000年，氏族公社时期，包括母系氏族公社和父系氏族公社，特点是使用磨制石器，能够制造陶和纺织，发明农业和畜牧业，有固定生活来源，不再依赖采集为生。（大汶口文化，红山文化，良渚文化，大溪文化，河姆渡文化，龙山文化）</li>\n</ol>\n<h1 id=\"2、夏商周三代文明\"><a href=\"#2、夏商周三代文明\" class=\"headerlink\" title=\"2、夏商周三代文明\"></a>2、夏商周三代文明</h1><h2 id=\"2-1、夏王朝\"><a href=\"#2-1、夏王朝\" class=\"headerlink\" title=\"2.1、夏王朝\"></a>2.1、夏王朝</h2><h3 id=\"2-1-1、夏朝年表\"><a href=\"#2-1-1、夏朝年表\" class=\"headerlink\" title=\"2.1.1、夏朝年表\"></a>2.1.1、夏朝年表</h3><p>夏朝（约前2070年－约前1600年，470年）是中国历史记载的第一个中原部族世袭制朝代</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时长</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">禹</td>\n<td align=\"left\">前2071-前2027（45年）</td>\n<td align=\"left\"><strong>涂山大会</strong>，铸造九鼎，象征九州，第一次有了国家的概念</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">启</td>\n<td align=\"left\">前2026-前1988（39年）</td>\n<td align=\"left\">由禅让制变为世袭制，击败了有扈氏的反抗</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">太康</td>\n<td align=\"left\">前1987-前1984（4年）</td>\n<td align=\"left\">不理朝政，被有穷氏后羿夺权，<strong>太康失国</strong>，实际在位2年</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">仲康</td>\n<td align=\"left\">前1983-前1977（7年）</td>\n<td align=\"left\">后羿专权，仲康反抗失败被软禁，抑郁而终</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">相</td>\n<td align=\"left\">前1976-前1949（28年）</td>\n<td align=\"left\">被寒浞的儿子浇攻破自刎，大臣寒浞杀后羿夺权</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">少康&#x2F;杜康</td>\n<td align=\"left\">前1908-前1888（21年）</td>\n<td align=\"left\">相的遗腹子，攻杀寒浞，复国，<strong>少康中兴</strong></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">季杼</td>\n<td align=\"left\">前1887-前1871（17年）</td>\n<td align=\"left\">参加过复兴夏朝的战争</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">槐&#x2F;帝芬</td>\n<td align=\"left\">前前1870-前1827（44年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">芒</td>\n<td align=\"left\">前1826-前1769（58年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">泄&#x2F;帝降</td>\n<td align=\"left\">前1768-前1753（16年）</td>\n<td align=\"left\">正式赐封九夷各部诸侯爵位</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">不降</td>\n<td align=\"left\">前1752-前1705（48年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">扃</td>\n<td align=\"left\">前1704-前1684（21年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">廑（jin）</td>\n<td align=\"left\">前1683-前1676（8年）</td>\n<td align=\"left\">夏国开始衰落</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">孔甲</td>\n<td align=\"left\">前1675-前1667（9年）</td>\n<td align=\"left\">胡作非为的残暴昏君</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">皋</td>\n<td align=\"left\">前1666 -前1664（3年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">发</td>\n<td align=\"left\">前1663-前1645（19年）</td>\n<td align=\"left\">各方诸侯已不来朝贺</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">桀</td>\n<td align=\"left\">前1644-前1592（53年）</td>\n<td align=\"left\">暴君，被商汤灭，亡国</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-1-2、夏王朝的文献和史事\"><a href=\"#2-1-2、夏王朝的文献和史事\" class=\"headerlink\" title=\"2.1.2、夏王朝的文献和史事\"></a>2.1.2、夏王朝的文献和史事</h3><p>目前关于夏王朝的主要文献资料来源于《史记·夏本纪》和《尚书》及《诗经》的部分记载。<br>夏王朝始于禹。尧舜禹的禅让到禹时，发生了根本的变化。禹传位于其子启，确立了嫡子世袭制度。据《夏本纪》的材料，禹开始以天下授益<br>就在传位于启不久，这个部落联盟中的有扈氏部族“不服”，向启提出了挑战。启伐之，大战于甘，有扈氏被灭。<br>夏后帝启死后，子太康立。太康时失国，太康崩，弟中康立，是为帝中康。中康生子相。相时受到东夷族有穷氏(其首领为善射的羿)的压迫，在与有穷氏的战争中，夏王相被杀，但他的儿子少康最终取得胜利，这就是“少康复国。</p>\n<h2 id=\"2-2、商王朝\"><a href=\"#2-2、商王朝\" class=\"headerlink\" title=\"2.2、商王朝\"></a>2.2、商王朝</h2><h3 id=\"2-2-1、商朝年表\"><a href=\"#2-2-1、商朝年表\" class=\"headerlink\" title=\"2.2.1、商朝年表\"></a>2.2.1、商朝年表</h3><p>商朝（约公元前1600年-约公元前1046年，554年）</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>姓名</th>\n<th>别名</th>\n<th>在位时长</th>\n<th>相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>商汤</td>\n<td>天乙</td>\n<td>前1600年-前1588年（13年）</td>\n<td>开国君主 鸣条之战</td>\n</tr>\n<tr>\n<td>2</td>\n<td>商哀王</td>\n<td>外丙</td>\n<td>前1587年-前1586年（2年）</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>商懿王</td>\n<td>仲壬</td>\n<td>前1585年-前1582年（4年）</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>商太宗</td>\n<td>太甲</td>\n<td>前1582年-前1570年（13年）</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>商昭王</td>\n<td>沃丁</td>\n<td>前1570年-前1541年（29年）</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>商宣王</td>\n<td>太庚</td>\n<td>前1541年-前1516年（25年）</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>商敬王</td>\n<td>小甲</td>\n<td>前1516年-前1499年（17年）</td>\n<td>商朝始衰</td>\n</tr>\n<tr>\n<td>8</td>\n<td>商元王</td>\n<td>雍己</td>\n<td>前1487年-前1476年（12年）</td>\n<td>诸侯不来朝</td>\n</tr>\n<tr>\n<td>9</td>\n<td>商中宗</td>\n<td>太戊</td>\n<td>前1486年-前1412年（75年）</td>\n<td>小国又纷纷归顺，商朝中兴</td>\n</tr>\n<tr>\n<td>10</td>\n<td>商孝成王</td>\n<td>仲丁</td>\n<td>前1418年-前1408年（13年）</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>商思王</td>\n<td>外壬</td>\n<td>前1407年-前1398年 （10年）</td>\n<td>九世之乱</td>\n</tr>\n<tr>\n<td>12</td>\n<td>商前平王</td>\n<td>河檀（dan）甲</td>\n<td>前1397年-前1389年（9年）</td>\n<td>迁都河南内黄</td>\n</tr>\n<tr>\n<td>13</td>\n<td>商穆王</td>\n<td>祖乙</td>\n<td>前1388年-前1370年（19年）</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>商桓王</td>\n<td>祖辛</td>\n<td>前1369年-前1356年（16年）</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>商僖（xi）王</td>\n<td>沃甲</td>\n<td>前1355年- 前1336年（20年）</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>商庄王</td>\n<td>祖丁</td>\n<td>前1335年- 前1327年（9年）</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>商顷王</td>\n<td>南庚</td>\n<td>前1326年-前1321年（6年）</td>\n<td>国都由庇（山东郓城）迁奄（山东曲阜）</td>\n</tr>\n<tr>\n<td>18</td>\n<td>商悼王</td>\n<td>阳甲</td>\n<td>前1321年- 前1314年（8年）</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>商世祖</td>\n<td>盘庚</td>\n<td>前1313年-前1286年（28年）</td>\n<td>迁都殷（河南安阳）</td>\n</tr>\n<tr>\n<td>20</td>\n<td>商章王</td>\n<td>小辛</td>\n<td>前1285年- 前1272年（14年）</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>商惠王</td>\n<td>小乙</td>\n<td>前1271年- 前1251年（21年）</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>商高宗</td>\n<td>武丁</td>\n<td>前1250年- 前1192年（59年）</td>\n<td>武丁中兴</td>\n</tr>\n<tr>\n<td>23</td>\n<td>商后平王</td>\n<td>祖庚</td>\n<td>前1191年-前1180年（12年）</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>商世宗</td>\n<td>祖甲</td>\n<td>前1180年-前1160年（20年）</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>商甲宗</td>\n<td>廪（lin）辛</td>\n<td>前1159年-前1156年（4年）</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>商康祖</td>\n<td>庚丁</td>\n<td>前1155年- 前1147年（9年）</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>商武祖</td>\n<td>武乙</td>\n<td>前1147年-前1113年（35年）</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>商匡王</td>\n<td>文丁</td>\n<td>前1112年-前1102年（11年）</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>商德王</td>\n<td>帝乙</td>\n<td>前1101年- 前1076年（26年）</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>商纣王</td>\n<td>帝辛</td>\n<td>前1075年-前1046年（30年）</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-2、商朝建立及迁徙过程\"><a href=\"#2-2-2、商朝建立及迁徙过程\" class=\"headerlink\" title=\"2.2.2、商朝建立及迁徙过程\"></a>2.2.2、商朝建立及迁徙过程</h3><p>商朝兴起于夏朝的东方，即黄河中下游，为子姓。其始祖名契，契母简狄是属于有戎的后代。传说是吞玄鸟之蛋而生契，这就是《诗经·商颂· 玄鸟》中的菩名诗句:“天命玄鸟，降而生商。”无疑，商人是以鸟为图腾的。商人逐渐西迁，从契到成汤历十四代王，共移徙八次。到汤时西进逼近夏人所居，终于灭掉夏王朝而建立商朝，都于毫(其地理位置尚存争议，或说商丘，或说偃师)。据史载，商汤立国之后，商人仍“不常厥邑”，又有五次迁都，历史上有“前八后五”的说法。到第二十代王盘庚时，他说服并胁迫商贵族再次迁徙，最终将商朝的都城固定下来，这就是目前所知的殷墟(河南安阳)。</p>\n<h3 id=\"2-2-3、商朝政治体制\"><a href=\"#2-2-3、商朝政治体制\" class=\"headerlink\" title=\"2.2.3、商朝政治体制\"></a>2.2.3、商朝政治体制</h3><p>商周王朝都是世袭王权制，政权掌控在王手，商王在甲骨文中称为“余一人”。商代前期还处在兄终弟及的状态，后期转变为父死子继制度。商王朝的主要官员分为臣、将军和史官（包括巫人、贞人（占卜者）和祭司等）三大类</p>\n<h2 id=\"2-3、周王朝\"><a href=\"#2-3、周王朝\" class=\"headerlink\" title=\"2.3、周王朝\"></a>2.3、周王朝</h2><p>周朝（前1046年—前256年，791年），是中国历史上最长的朝代 </p>\n<h3 id=\"2-3-1、西周年表\"><a href=\"#2-3-1、西周年表\" class=\"headerlink\" title=\"2.3.1、西周年表\"></a>2.3.1、西周年表</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">谥号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">周文王</td>\n<td align=\"left\">姬昌</td>\n<td align=\"left\">公元前 1110 年-前 1061 年为西伯（50 年）</td>\n<td align=\"left\">创《周易》  寿命 97</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">周武王</td>\n<td align=\"left\">姬发</td>\n<td align=\"left\">公元前 1060 年-前 1046 年为西伯（15 年）公元前 1046 年-前 1043 年为周王（4 年）</td>\n<td align=\"left\">孟津观兵   牧野之战  灭商建周，定都镐京（西安）</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">周成王</td>\n<td align=\"left\">姬诵</td>\n<td align=\"left\">公元前 1042 年-前 1021 年（22 年）</td>\n<td align=\"left\">成康之治 周公摄政 迁都洛邑（洛阳）</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">周康王</td>\n<td align=\"left\">姬钊</td>\n<td align=\"left\">公元前 1020 年-前 996 年（25 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">周昭王</td>\n<td align=\"left\">姬瑕</td>\n<td align=\"left\">公元前 995 年-前 977 年（18 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">周穆王</td>\n<td align=\"left\">姬满</td>\n<td align=\"left\">公元前 976 年-前 922 年（55 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">周共王</td>\n<td align=\"left\">姬繄扈（yihu）</td>\n<td align=\"left\">公元前 922 年-前 900 年（23 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">周懿王</td>\n<td align=\"left\">姬囏（jian）</td>\n<td align=\"left\">公元前 899 年-前 892 年（8 年）</td>\n<td align=\"left\">迁都槐里（兴平市）</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">周孝王</td>\n<td align=\"left\">姬辟方</td>\n<td align=\"left\">公元前 891 年-前 886 年（6 年）</td>\n<td align=\"left\">非子封秦</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">周夷王</td>\n<td align=\"left\">姬燮（xie）</td>\n<td align=\"left\">公元前 885 年-前 878 年（8 年）</td>\n<td align=\"left\">煮杀齐哀公</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">周厉王</td>\n<td align=\"left\">姬胡</td>\n<td align=\"left\">公元前 877 年-前 841 年（37 年）</td>\n<td align=\"left\">贪图财利</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">共和（一说为共伯和摄行天子政）</td>\n<td align=\"left\"></td>\n<td align=\"left\">公元前 841 年-前 828 年（14 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">周宣王</td>\n<td align=\"left\">姬静</td>\n<td align=\"left\">公元前 828 年-前 783 年（46 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">周幽王</td>\n<td align=\"left\">姬宫湦</td>\n<td align=\"left\">公元前 782 年-前 771 年（12 年）</td>\n<td align=\"left\">烽火戏诸侯（存疑）</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-2、东周年表\"><a href=\"#2-3-2、东周年表\" class=\"headerlink\" title=\"2.3.2、东周年表\"></a>2.3.2、东周年表</h3><p>西周末年，周幽王因宠爱褒姒而废黜申后及太子宜臼，立褒姒为后，并立其子伯服为太子，引起申候的叛变。申候引犬戎政入关中，杀死幽王。于是公元前770年周平王被迫东迁至洛邑，开始了中国历史上的东周。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">谥号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">周平王</td>\n<td align=\"left\">姬宜臼</td>\n<td align=\"left\">公元前 770 年-前 718 年（53 年）</td>\n<td align=\"left\">迁都洛邑列秦诸侯春秋之始</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">周桓王</td>\n<td align=\"left\">姬林</td>\n<td align=\"left\">公元前 718 年-前 697 年（22 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">周庄王</td>\n<td align=\"left\">姬佗</td>\n<td align=\"left\">公元前 697 年-前 682 年（16 年）</td>\n<td align=\"left\">平定王子克之乱</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">周釐王</td>\n<td align=\"left\">姬胡齐</td>\n<td align=\"left\">公元前 682 年-前 677 年（6 年）</td>\n<td align=\"left\">齐桓称霸</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">周惠王</td>\n<td align=\"left\">姬阆</td>\n<td align=\"left\">公元前 677 年-前 675 年第一次在位（3 年）公元前 673 年-前 652 年第二次在位（22 年）</td>\n<td align=\"left\">五大夫作乱</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">周废王（篡位）</td>\n<td align=\"left\">姬颓</td>\n<td align=\"left\">公元前 675 年-前 673 年（3 年）</td>\n<td align=\"left\">叛乱称王，后兵败遭杀</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">周襄王</td>\n<td align=\"left\">姬郑</td>\n<td align=\"left\">公元前 652 年-前 619 年（34 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">周顷王</td>\n<td align=\"left\">姬壬臣</td>\n<td align=\"left\">公元前 619 年-前 613 年（7 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">周匡王</td>\n<td align=\"left\">姬班</td>\n<td align=\"left\">公元前 613 年-前 607 年（7 年）</td>\n<td align=\"left\">赵盾事件</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">周定王</td>\n<td align=\"left\">姬瑜</td>\n<td align=\"left\">公元前 607 年-前 586 年（22 年）</td>\n<td align=\"left\">赵氏孤儿</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">周简王</td>\n<td align=\"left\">姬夷</td>\n<td align=\"left\">公元前 586 年-前 572 年（15 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">周灵王</td>\n<td align=\"left\">姬泄心</td>\n<td align=\"left\">公元前 572 年-前 545 年（28 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">周景王</td>\n<td align=\"left\">姬贵</td>\n<td align=\"left\">公元前 545 年-前 520 年（26 年）</td>\n<td align=\"left\">数典忘祖</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">周悼王</td>\n<td align=\"left\">姬猛</td>\n<td align=\"left\">公元前 520 年-前 520 年（1 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">周敬王</td>\n<td align=\"left\">姬匄</td>\n<td align=\"left\">公元前 520 年-前 475 年（46 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">周元王</td>\n<td align=\"left\">姬仁</td>\n<td align=\"left\">公元前 475 年-前 473 年（3 年）</td>\n<td align=\"left\">周元王开始为战国时期</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">周贞定王</td>\n<td align=\"left\">姬介</td>\n<td align=\"left\">公元前 473 年-前 441 年（33 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">周哀王</td>\n<td align=\"left\">姬去疾</td>\n<td align=\"left\">公元前 441 年-前 441 年（1 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">周思王</td>\n<td align=\"left\">姬叔</td>\n<td align=\"left\">公元前 441 年-前 441 年（1 年）</td>\n<td align=\"left\">在位仅五个月，即被弟弟姬嵬杀死</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">周考王</td>\n<td align=\"left\">姬嵬</td>\n<td align=\"left\">公元前 441 年-前 426 年（16 年）</td>\n<td align=\"left\">叔弑兄篡位</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">周威烈王</td>\n<td align=\"left\">姬午</td>\n<td align=\"left\">公元前 426 年-前 402 年（25 年）</td>\n<td align=\"left\">三家分晋</td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">周安王</td>\n<td align=\"left\">姬骄</td>\n<td align=\"left\">公元前 402 年-前 376 年（27 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">周烈王</td>\n<td align=\"left\">姬喜</td>\n<td align=\"left\">公元前 376 年-前 369 年（8 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">周显王</td>\n<td align=\"left\">姬扁</td>\n<td align=\"left\">公元前 369 年-前 321 年（49 年）</td>\n<td align=\"left\">桂陵之战 马陵之战 商鞅变法</td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">周慎靓王</td>\n<td align=\"left\">姬定</td>\n<td align=\"left\">公元前 321 年-前 315 年（7 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">周赧王</td>\n<td align=\"left\">姬延</td>\n<td align=\"left\">公元前 315 年-前 256 年（60 年）</td>\n<td align=\"left\">债台高筑 降秦昭襄王</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-3、甲骨文和金文\"><a href=\"#2-3-3、甲骨文和金文\" class=\"headerlink\" title=\"2.3.3、甲骨文和金文\"></a>2.3.3、甲骨文和金文</h3><ol>\n<li>甲骨文</li>\n</ol>\n<p>甲骨文是一种刻写在甲骨上的古文字。从出土实物来看，绝大多数为契刻,仅少数是书写的。甲骨文的“甲”指的是龟甲，多为腹甲:“骨”指的是兽骨，以牛肩脚骨为主，还有少量的牛肋骨、鹿头骨、牛头骨、人头骨、虎骨等<br>殷墟甲骨文的出土，说明了商代历史的可靠性，成为了研究商代历史最主要的资料。金文的出现则大大拓展了周代历史的研究领域，丰富了对周代历史的认识。甲骨文和金文，是研究商周历史极其重要的第一手资料</p>\n<ol start=\"2\">\n<li>金文</li>\n</ol>\n<p>金文就是铭刻在青铜器上的文字，它与商代甲骨文之间有直接的承关系。西周金文的内容，包括战争、祭祀、外交、土地和人畜买卖等。金文主要铸造或镌刻在青铜器上。保守地估计，中国使用青铜的时间大约有1500多年，即从公元前2000年到公元前500，这段时期被称为中国历史上的“青铜时代”</p>\n<h3 id=\"2-3-4、周朝政治体制\"><a href=\"#2-3-4、周朝政治体制\" class=\"headerlink\" title=\"2.3.4、周朝政治体制\"></a>2.3.4、周朝政治体制</h3><p>周代的政治体制，与商人有某些共同之处。周王是最高的世袭统治者，他自称“天子”<br>西周王朝的直接统治限于王畿内，也就是《诗经》的“王风”部分;其王畿外的统治则是通过分封制度来实现的，即《诗经》中的十五“国风”部分</p>\n<h3 id=\"2-3-5、周代的几种制度\"><a href=\"#2-3-5、周代的几种制度\" class=\"headerlink\" title=\"2.3.5、周代的几种制度\"></a>2.3.5、周代的几种制度</h3><p>周初灭商不久，对商人后裔实行一种由周人亲戚统领管理的相对自治统治，谓之“疆以周索”，又把商人中心区域分成邶（bei）、庸、卫三部分，分别派周武王弟弟管叔、蔡叔、霍叔去监管，这就是历史上的“三监”。但是周武王去世后，三监对周公摄政不满于是与殷人后裔联合起来反叛周王朝。周公便带兵东征，经过几年的战争之后，平服了这场叛乱，杀掉了武庚和管叔，并将蔡叔和霍叔加以流放。史称“周公东征”</p>\n<p>周公东征后，周人便实行分封制度，力图通过“封建亲戚”的办法，实现“以藩屏周”的政治效果。这场大规模的分封，受封的对象主要是三类:是同姓子弟，二是异姓的功臣，三是先王后裔</p>\n<h1 id=\"3、春秋战国\"><a href=\"#3、春秋战国\" class=\"headerlink\" title=\"3、春秋战国\"></a>3、春秋战国</h1><h1 id=\"4、秦国\"><a href=\"#4、秦国\" class=\"headerlink\" title=\"4、秦国\"></a>4、秦国</h1><h2 id=\"4-1、秦朝年表\"><a href=\"#4-1、秦朝年表\" class=\"headerlink\" title=\"4.1、秦朝年表\"></a>4.1、秦朝年表</h2><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">谥号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">非子</td>\n<td align=\"left\">嬴非</td>\n<td align=\"left\">前900年-前858年（43年）</td>\n<td align=\"left\">因善于养马，得到周孝王的赏识，获封秦地，成为秦国始封君</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">秦侯</td>\n<td align=\"left\">嬴侯</td>\n<td align=\"left\">前857年-前848年（10年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">秦公伯</td>\n<td align=\"left\">嬴伯</td>\n<td align=\"left\">前847年-前845年（3年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">秦仲</td>\n<td align=\"left\">嬴仲</td>\n<td align=\"left\">前844年-前822年（23年）</td>\n<td align=\"left\">被周王任命为西我大夫，后战死</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">秦庄公</td>\n<td align=\"left\">嬴其</td>\n<td align=\"left\">前821年-前778年（44年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">秦襄公(立为诸侯)</td>\n<td align=\"left\">嬴开</td>\n<td align=\"left\">前777年-前766年（12年）</td>\n<td align=\"left\">看秋时期秦国第一任因君，辅平王东迁</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">秦文公</td>\n<td align=\"left\">嬴康</td>\n<td align=\"left\">前765年-前716年（50年）</td>\n<td align=\"left\">迁都汧渭之会（千河和渭河交界）</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">秦静公(秦竫公)</td>\n<td align=\"left\">嬴鼎</td>\n<td align=\"left\">未即位</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">秦宪公(秦宁公)</td>\n<td align=\"left\">嬴立</td>\n<td align=\"left\">前715年-前704年（12年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">秦出子</td>\n<td align=\"left\">嬴曼</td>\n<td align=\"left\">前703年-前698年（6年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">秦武公</td>\n<td align=\"left\">嬴说</td>\n<td align=\"left\">前697年-前678年（20年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">秦德公</td>\n<td align=\"left\">嬴嘉</td>\n<td align=\"left\">前677年-前676年（2年）</td>\n<td align=\"left\">迁都雍城</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">秦宣公</td>\n<td align=\"left\">嬴恬</td>\n<td align=\"left\">前675年-前664年（12年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">秦成公</td>\n<td align=\"left\">嬴载</td>\n<td align=\"left\">前663年-前660年（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">秦穆公</td>\n<td align=\"left\">嬴任好</td>\n<td align=\"left\">前659年-前621年（39年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">秦康公</td>\n<td align=\"left\">嬴罃</td>\n<td align=\"left\">前620年-前609年（12年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">秦共公</td>\n<td align=\"left\">嬴稻&#x2F;嬴貑</td>\n<td align=\"left\">前608年-前605年（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">秦桓公</td>\n<td align=\"left\">嬴荣</td>\n<td align=\"left\">前604年-前577年（28年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">秦景公</td>\n<td align=\"left\">嬴石</td>\n<td align=\"left\">前576年-前537年（40年）</td>\n<td align=\"left\">栎之战 迁延之役</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">秦哀公(秦毕公&#x2F;秦㻫公)</td>\n<td align=\"left\">嬴籍</td>\n<td align=\"left\">前536年-前501年（36年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">秦夷公</td>\n<td align=\"left\">嬴扩</td>\n<td align=\"left\">未即位</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">秦惠公</td>\n<td align=\"left\">嬴宁</td>\n<td align=\"left\">前500年-前492年（9年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">秦悼公</td>\n<td align=\"left\">嬴盘</td>\n<td align=\"left\">前491年-前477年（15年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">秦厉共公(秦剌龚公&#x2F;秦利龚公)</td>\n<td align=\"left\">嬴刺</td>\n<td align=\"left\">前476年-前443年（34年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">秦躁公(秦趮公)</td>\n<td align=\"left\">嬴欣</td>\n<td align=\"left\">前442年-前429年（14年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">秦怀公</td>\n<td align=\"left\">嬴封</td>\n<td align=\"left\">前428年-前425年（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">27</td>\n<td align=\"left\">秦灵公(秦肃灵公)</td>\n<td align=\"left\">嬴肃</td>\n<td align=\"left\">前424年-前415年（10年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">28</td>\n<td align=\"left\">秦简公</td>\n<td align=\"left\">嬴悼子</td>\n<td align=\"left\">前414年-前400年（15年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">29</td>\n<td align=\"left\">秦惠公</td>\n<td align=\"left\">嬴仁</td>\n<td align=\"left\">前399年-前387年（13年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">30</td>\n<td align=\"left\">秦出公(秦少主)</td>\n<td align=\"left\">嬴昌</td>\n<td align=\"left\">前386年-前385年（2年）</td>\n<td align=\"left\">母亲主持朝政，重用宦官外戚</td>\n</tr>\n<tr>\n<td align=\"left\">31</td>\n<td align=\"left\">秦献公&#x2F;秦元献公</td>\n<td align=\"left\">嬴师隰&#x2F;嬴连</td>\n<td align=\"left\">前384年-前362年（23年）</td>\n<td align=\"left\">废止人殉制度</td>\n</tr>\n<tr>\n<td align=\"left\">32</td>\n<td align=\"left\">秦孝公</td>\n<td align=\"left\">嬴渠梁</td>\n<td align=\"left\">前361年-前338年（24年）</td>\n<td align=\"left\">启用商鞅变法，迁都咸阳，建立县制行政</td>\n</tr>\n<tr>\n<td align=\"left\">33</td>\n<td align=\"left\">秦惠文王(秦惠王)</td>\n<td align=\"left\">嬴驷</td>\n<td align=\"left\">前337年-前311年（27年）</td>\n<td align=\"left\">改公称王，成为秦国第一王</td>\n</tr>\n<tr>\n<td align=\"left\">34</td>\n<td align=\"left\">秦武王(秦悼武王&#x2F;秦武烈王)</td>\n<td align=\"left\">嬴荡</td>\n<td align=\"left\">前310年-前307年（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">35</td>\n<td align=\"left\">秦昭襄王(秦昭王)</td>\n<td align=\"left\">嬴则&#x2F;嬴稷</td>\n<td align=\"left\">前306年-前251年（56年）</td>\n<td align=\"left\">长平破赵，灭亡东周，奠基统一</td>\n</tr>\n<tr>\n<td align=\"left\">36</td>\n<td align=\"left\">秦孝文王</td>\n<td align=\"left\">嬴柱</td>\n<td align=\"left\">前250年（3天）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">37</td>\n<td align=\"left\">秦庄襄王(秦庄王)</td>\n<td align=\"left\">嬴异人&#x2F;嬴子楚(嬴楚)</td>\n<td align=\"left\">前249年-前247年（3年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">38</td>\n<td align=\"left\">秦王政（秦始皇）</td>\n<td align=\"left\">嬴政</td>\n<td align=\"left\">前246年-前221年（25年）</td>\n<td align=\"left\">统一六国 建立皇帝制度 修筑万里长城</td>\n</tr>\n<tr>\n<td align=\"left\">39</td>\n<td align=\"left\">秦二世（胡亥）</td>\n<td align=\"left\">嬴胡亥</td>\n<td align=\"left\">前210年―前207年（3年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">40</td>\n<td align=\"left\">秦三世（子婴）</td>\n<td align=\"left\">嬴子婴</td>\n<td align=\"left\">前207年―前207年（46天）</td>\n<td align=\"left\">诛杀赵高</td>\n</tr>\n</tbody></table>\n<h1 id=\"5、汉朝\"><a href=\"#5、汉朝\" class=\"headerlink\" title=\"5、汉朝\"></a>5、汉朝</h1><p>汉朝（前202年-220年（405年））是继秦朝之后的大一统王朝，分为西汉、东汉时期</p>\n<h2 id=\"5-1-1、西汉年表\"><a href=\"#5-1-1、西汉年表\" class=\"headerlink\" title=\"5.1.1、西汉年表\"></a>5.1.1、西汉年表</h2><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">汉高祖</td>\n<td align=\"left\">刘邦</td>\n<td align=\"left\">前202-前195（8年）</td>\n<td align=\"left\">建立汉朝</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">汉惠帝</td>\n<td align=\"left\">刘盈</td>\n<td align=\"left\">前195-前188（8年）</td>\n<td align=\"left\">萧规曹随</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">前少帝</td>\n<td align=\"left\">刘恭</td>\n<td align=\"left\">前188-前184（5年）</td>\n<td align=\"left\">吕雉称制</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">后少帝</td>\n<td align=\"left\">刘弘</td>\n<td align=\"left\">前184-前180（5年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">汉文帝</td>\n<td align=\"left\">刘恒</td>\n<td align=\"left\">前180-前157（24年）</td>\n<td align=\"left\">文景之治 无为而治</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">汉景帝</td>\n<td align=\"left\">刘启</td>\n<td align=\"left\">前157-前141（17年）</td>\n<td align=\"left\">儿子中山靖王17代玄孙是刘备</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">汉武帝</td>\n<td align=\"left\">刘彻</td>\n<td align=\"left\">前141-前87（45年）</td>\n<td align=\"left\">推恩令，通西域</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">汉昭帝</td>\n<td align=\"left\">刘弗陵</td>\n<td align=\"left\">前87-前74（14年）</td>\n<td align=\"left\">昭宣中兴</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">汉废帝</td>\n<td align=\"left\">刘贺</td>\n<td align=\"left\">前74年7月-8月</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">汉宣帝</td>\n<td align=\"left\">刘询</td>\n<td align=\"left\">前74-前48（27年）</td>\n<td align=\"left\">昭宣中兴</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">汉元帝</td>\n<td align=\"left\">刘奭（shi）</td>\n<td align=\"left\">前48-前33（16年）</td>\n<td align=\"left\">平灭北匈奴</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">汉成帝</td>\n<td align=\"left\">刘骜</td>\n<td align=\"left\">前33-前7（27年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">汉哀帝</td>\n<td align=\"left\">刘欣</td>\n<td align=\"left\">前7-前1（7年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">汉平帝</td>\n<td align=\"left\">刘衎</td>\n<td align=\"left\">前1-6年（1年）</td>\n<td align=\"left\">王莽摄政（王政君侄子） <div>9岁被毒死<br></div></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">孺子婴</td>\n<td align=\"left\">刘婴</td>\n<td align=\"left\">6年-8年（未称帝）</td>\n<td align=\"left\">21岁被杀</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-1-2、东汉年表\"><a href=\"#5-1-2、东汉年表\" class=\"headerlink\" title=\"5.1.2、东汉年表\"></a>5.1.2、东汉年表</h2><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">光武帝</td>\n<td align=\"left\">刘秀</td>\n<td align=\"left\">25年-57年（33年）</td>\n<td align=\"left\">光武中兴</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">汉明帝</td>\n<td align=\"left\">刘庄</td>\n<td align=\"left\">57年-75年（19年）</td>\n<td align=\"left\">明章之治</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">汉章帝</td>\n<td align=\"left\">刘炟（da）</td>\n<td align=\"left\">75年-88年（14年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">汉殇帝</td>\n<td align=\"left\">刘隆</td>\n<td align=\"left\">106年</td>\n<td align=\"left\">邓绥称制</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">汉安帝</td>\n<td align=\"left\">刘祜</td>\n<td align=\"left\">106年-125年（20年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">少帝</td>\n<td align=\"left\">刘懿</td>\n<td align=\"left\">125年</td>\n<td align=\"left\">阎皇后称制</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">汉顺帝</td>\n<td align=\"left\">刘保</td>\n<td align=\"left\">125年-144年（20年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">汉冲帝</td>\n<td align=\"left\">刘炳</td>\n<td align=\"left\">144年-145年（2年）</td>\n<td align=\"left\">梁妠称制</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">汉质帝</td>\n<td align=\"left\">刘缵</td>\n<td align=\"left\">145年-146年（2年）</td>\n<td align=\"left\">9岁被毒死</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">汉桓帝</td>\n<td align=\"left\">刘志</td>\n<td align=\"left\">146年-168年（23年）</td>\n<td align=\"left\">夺回皇权</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">汉灵帝</td>\n<td align=\"left\">刘宏</td>\n<td align=\"left\">168年-189年（22年）</td>\n<td align=\"left\">卖官鬻爵 十常侍作乱</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">汉少帝</td>\n<td align=\"left\">刘辩</td>\n<td align=\"left\">189年</td>\n<td align=\"left\">被董卓罢黜 15（18）岁自杀</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">汉献帝</td>\n<td align=\"left\">刘协</td>\n<td align=\"left\">189年-220年（32年）</td>\n<td align=\"left\">曹操摄政</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-1-3、三国相关人物表\"><a href=\"#5-1-3、三国相关人物表\" class=\"headerlink\" title=\"5.1.3、三国相关人物表\"></a>5.1.3、三国相关人物表</h2><h3 id=\"5-1-3-1、朝廷（东汉）-群雄\"><a href=\"#5-1-3-1、朝廷（东汉）-群雄\" class=\"headerlink\" title=\"5.1.3.1、朝廷（东汉）&amp; 群雄\"></a>5.1.3.1、朝廷（东汉）&amp; 群雄</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">人物</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">刘志（汉桓帝）</td>\n<td align=\"left\">外戚专权</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">刘宏（汉灵帝）</td>\n<td align=\"left\">黄巾起义</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">窦妙（窦太后）</td>\n<td align=\"left\">刘志之母</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">董太后（永乐太后）</td>\n<td align=\"left\">刘宏之母</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">十常侍</td>\n<td align=\"left\">张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">何皇后</td>\n<td align=\"left\">刘辩之母，汉灵帝刘宏第二任皇后</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">王荣（王美人）</td>\n<td align=\"left\">刘协之母，汉灵帝刘宏妃子，被何皇后毒杀</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">何进</td>\n<td align=\"left\">何皇后哥哥，刘辩舅舅</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">刘辩（汉少帝）</td>\n<td align=\"left\">被董卓废掉，毒杀</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">刘协 （汉献帝）</td>\n<td align=\"left\">陈留王</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">刘恢</td>\n<td align=\"left\">代郡太守，刘备鞭都邮后投奔他，他保护刘备不被追查，并推荐他给刘虞</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">张角</td>\n<td align=\"left\">“天公将军”，创立太平道，提出“苍天已死，黄天当立”的口号以号召徒众，史称“黄巾军”</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">张宝</td>\n<td align=\"left\">“地公将军”，张角之弟，后来被皇甫嵩、郭典击败，被杀</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">张梁</td>\n<td align=\"left\">“人公将军”，张宝之弟，遭到遭皇甫嵩击败，被杀</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">董太后（永乐太后）</td>\n<td align=\"left\">刘宏之母</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">十常侍</td>\n<td align=\"left\">张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">卢植</td>\n<td align=\"left\">刘备老师，东汉名臣，参与平叛黄巾起义</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">袁绍</td>\n<td align=\"left\">（1）四世三公，早年任中军校尉，曾指挥诛杀宦官，建议何进引董卓 （2）争夺天下的野心与曹操产生冲突，最终在赤壁之战中被曹操击败</td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">袁术</td>\n<td align=\"left\">（1）袁绍的弟弟。（2）与袁绍、曹操等同时起兵，共讨董卓。其后因与袁绍对立，被袁绍、曹操击败，率余众奔九江，割据扬州 （3）奢侈荒淫，横征暴敛，使江淮地区残破不堪，民多饥死</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">董卓</td>\n<td align=\"left\">西凉刺史</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">李儒</td>\n<td align=\"left\">董卓谋士 毒死刘辩</td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">丁原</td>\n<td align=\"left\">字建阳，并州刺史</td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">吕布</td>\n<td align=\"left\">诛杀董卓</td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">樊稠</td>\n<td align=\"left\">（1）原为董卓部将，董卓死后，伙同李傕、郭汜、张济等人合众十余万反扑长安，败吕布、杀王允，把持朝政 。后因内斗被李傕外甥胡封在会议上刺死 （2）大败马腾、韩遂</td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">李肃</td>\n<td align=\"left\">董卓手下虎贲中郎将，主动请命以赤兔马说服吕布杀丁原来降</td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">王允</td>\n<td align=\"left\">设计诛杀董卓。后欲解散董卓的凉州兵旧部，使其人人自危，董卓部将李傕、郭汜乃合谋为乱，攻进长安，王允被杀</td>\n</tr>\n<tr>\n<td align=\"left\">27</td>\n<td align=\"left\">公孙瓒</td>\n<td align=\"left\">军阀，汉末群雄之一，卢植学生</td>\n</tr>\n<tr>\n<td align=\"left\">28</td>\n<td align=\"left\">华雄</td>\n<td align=\"left\">董卓帐下武将</td>\n</tr>\n<tr>\n<td align=\"left\">29</td>\n<td align=\"left\">颜良</td>\n<td align=\"left\">袁绍部将   白马之围</td>\n</tr>\n<tr>\n<td align=\"left\">30</td>\n<td align=\"left\">文丑</td>\n<td align=\"left\">袁绍部将</td>\n</tr>\n<tr>\n<td align=\"left\">31</td>\n<td align=\"left\">蔡邕</td>\n<td align=\"left\">东汉时期名臣，蔡文姬之父，被董卓重用，董卓死后被王允杀</td>\n</tr>\n<tr>\n<td align=\"left\">32</td>\n<td align=\"left\">陶谦</td>\n<td align=\"left\">徐州太守</td>\n</tr>\n<tr>\n<td align=\"left\">33</td>\n<td align=\"left\">刘表</td>\n<td align=\"left\">雄踞荆州，杀孙坚</td>\n</tr>\n<tr>\n<td align=\"left\">34</td>\n<td align=\"left\">曹豹</td>\n<td align=\"left\">东汉末年徐州牧陶谦部将，吕布的老丈人</td>\n</tr>\n<tr>\n<td align=\"left\">35</td>\n<td align=\"left\">张绣</td>\n<td align=\"left\">称雄宛城、在官渡之战力战有功，封邑最多</td>\n</tr>\n<tr>\n<td align=\"left\">36</td>\n<td align=\"left\">潘凤</td>\n<td align=\"left\">称雄宛城、在官渡之战力战有功，封邑最多冀州牧韩馥帐下的大将。当十八路诸侯讨伐董卓之时，他奉韩馥、袁绍之命前往汜水关前挑战董卓部下大将华雄，结果不多时就被斩</td>\n</tr>\n<tr>\n<td align=\"left\">37</td>\n<td align=\"left\">孔融</td>\n<td align=\"left\">孔子的第二十世孙 （208年）因触怒丞相曹操而被杀  孔融让梨</td>\n</tr>\n<tr>\n<td align=\"left\">38</td>\n<td align=\"left\">沮授</td>\n<td align=\"left\">东汉末年袁绍的监军 多次提出策略不被采纳</td>\n</tr>\n<tr>\n<td align=\"left\">39</td>\n<td align=\"left\">逢纪</td>\n<td align=\"left\">袁绍谋士 辅佐袁绍平定河北</td>\n</tr>\n<tr>\n<td align=\"left\">40</td>\n<td align=\"left\">田丰</td>\n<td align=\"left\">袁绍谋士 助袁绍灭公孙瓒</td>\n</tr>\n<tr>\n<td align=\"left\">41</td>\n<td align=\"left\">于吉</td>\n<td align=\"left\">琅琊人 ，东汉末年道士，后为孙策所杀，代表作有《太平经》</td>\n</tr>\n<tr>\n<td align=\"left\">42</td>\n<td align=\"left\">蔡瑁</td>\n<td align=\"left\">协助刘表平定荆州 刘表后妻蔡夫人弟弟</td>\n</tr>\n<tr>\n<td align=\"left\">43</td>\n<td align=\"left\">司马徽</td>\n<td align=\"left\">东汉末年隐士，精通奇门、经学。有“水镜先生”之称 向刘备推荐了诸葛亮、庞统等人</td>\n</tr>\n<tr>\n<td align=\"left\">44</td>\n<td align=\"left\">马腾</td>\n<td align=\"left\">东汉末年军事将领，军阀之一，马超，马铁之父</td>\n</tr>\n<tr>\n<td align=\"left\">45</td>\n<td align=\"left\">孟获</td>\n<td align=\"left\">三国时期南中地区的首领，公元225年起兵反叛蜀汉，被诸葛亮率领大军擒拿后被赦免，遂降服，此后不再叛乱，后孟获随诸葛亮回到成都，担任御史中丞</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-1-3-2、魏\"><a href=\"#5-1-3-2、魏\" class=\"headerlink\" title=\"5.1.3.2、魏\"></a>5.1.3.2、魏</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">人物</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">曹操</td>\n<td align=\"left\">（1）太尉曹嵩之子 （2）献七星宝刀</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">乐进</td>\n<td align=\"left\">斩淳于琼；斩严敬；每战先登；击退关羽；降伏蛮夷</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">李典</td>\n<td align=\"left\">曾在博望坡之战识破刘备的伪遁之计，救下了夏侯惇、于禁。又参与了逍遥津之战</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">曹仁</td>\n<td align=\"left\">破袁术、攻陶谦、擒吕布、败刘备，参加官渡之战</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">夏侯惇</td>\n<td align=\"left\">夏侯渊之族兄，汉朝开国功臣之一夏侯婴的后代</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">夏侯渊</td>\n<td align=\"left\">夏侯惇族弟, 官渡督粮、平定凉州, 被黄忠斩杀</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">曹洪</td>\n<td align=\"left\">（1）曹操从弟 （2） 早年随曹操起兵讨伐董卓。荥阳兵败，舍命献马，救驾于危难</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">贾诩</td>\n<td align=\"left\">原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">荀彧</td>\n<td align=\"left\">早年被称为“王佐之才” 为曹操规划军事战略方针，堪称其统一北方的首席谋</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">荀攸</td>\n<td align=\"left\">是荀彧的堂侄，曹操的重要谋士</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">程昱</td>\n<td align=\"left\">本名程立，因梦中在泰山捧日，更名程昱</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">郭嘉</td>\n<td align=\"left\">经荀彧推荐，任曹军祭酒</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">刘晔</td>\n<td align=\"left\">光武帝刘秀之子阜陵王刘延的后代</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">满宠</td>\n<td align=\"left\">平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">典韦</td>\n<td align=\"left\">濮阳之战击退吕布、宛城死战阻张绣</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">于禁</td>\n<td align=\"left\">讨伐黄巾余党、于张绣叛乱中坚守营垒，杀夏侯惇的青州军</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">许诸</td>\n<td align=\"left\">负责曹操的护卫工作，累迁武卫中郎将，赐号“虎侯”</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">贾诩</td>\n<td align=\"left\">曹魏开国功臣，原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操</td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">陈登</td>\n<td align=\"left\">沛相陈珪之子，向曹操献灭吕布之策</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">陈珪</td>\n<td align=\"left\">陈登、陈应之父。官至沛相。助破袁术，策应曹操</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">车胄</td>\n<td align=\"left\">曹操灭吕布占有徐州之地后，任命车胄为徐州刺史。被关羽斩杀，全家也被张飞杀害</td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">曹昂</td>\n<td align=\"left\">曹操长子。建安二年（197年）随曹操出征张绣，张绣降而复叛，曹昂为救曹操被杀</td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">张辽</td>\n<td align=\"left\">雁门马邑（今山西省朔州市）人。先后跟随丁原、何进、董卓、吕布，恪尽职守，历尽坎坷。吕布败亡后，张辽归属曹操</td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">许攸</td>\n<td align=\"left\">本为袁绍帐下谋士，官渡之战时其家人因犯法而被收捕，许攸因此背袁投曹，并为曹操设下偷袭袁绍军屯粮之所——乌巢的计策，袁绍因此而大败于官渡。后许攸随曹操平定冀州，因自恃其功而屡屡口出狂言，终因触怒曹操而被杀</td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">曹丕</td>\n<td align=\"left\">曹操长子 建立曹魏；大破羌胡，复通西域</td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">司马懿</td>\n<td align=\"left\">司马懿辅佐了魏国四代君主，见证了曹氏家族从兴盛走向衰亡，为稳定曹魏政权做出了贡献，也为其孙司马炎以晋代魏一统中国奠定了基础</td>\n</tr>\n<tr>\n<td align=\"left\">27</td>\n<td align=\"left\">满宠</td>\n<td align=\"left\">平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰</td>\n</tr>\n<tr>\n<td align=\"left\">28</td>\n<td align=\"left\">曹真</td>\n<td align=\"left\">曹操养子 大败羌胡联军 平定河西 大破吴国孙盛 击退蜀汉诸葛亮</td>\n</tr>\n<tr>\n<td align=\"left\">29</td>\n<td align=\"left\">曹睿</td>\n<td align=\"left\">曹魏第二位皇帝。魏文帝曹丕长子 与曹操、曹丕并称魏氏“三祖”</td>\n</tr>\n<tr>\n<td align=\"left\">30</td>\n<td align=\"left\">钟会</td>\n<td align=\"left\">平诸葛诞之叛、与邓艾分兵灭蜀</td>\n</tr>\n<tr>\n<td align=\"left\">31</td>\n<td align=\"left\">张郃</td>\n<td align=\"left\">江陵破吴，街亭败蜀</td>\n</tr>\n<tr>\n<td align=\"left\">32</td>\n<td align=\"left\">曹芳</td>\n<td align=\"left\">曹魏第三位皇帝，疑为魏武帝曹操曾孙</td>\n</tr>\n<tr>\n<td align=\"left\">33</td>\n<td align=\"left\">曹爽</td>\n<td align=\"left\">曹魏权臣，大司马曹真长子</td>\n</tr>\n<tr>\n<td align=\"left\">34</td>\n<td align=\"left\">司马师</td>\n<td align=\"left\">曹魏权臣，西晋王朝的奠基人之一，晋宣帝司马懿与宣穆皇后张春华的长子，晋文帝司马昭的同母兄，晋武帝司马炎的伯父</td>\n</tr>\n<tr>\n<td align=\"left\">35</td>\n<td align=\"left\">司马昭</td>\n<td align=\"left\">司马炎之父，专揽国政，攻灭蜀汉；奠定西晋基础</td>\n</tr>\n<tr>\n<td align=\"left\">36</td>\n<td align=\"left\">郭淮</td>\n<td align=\"left\">魏国名将，雁门郡太守郭缊之子 被姜维杀</td>\n</tr>\n<tr>\n<td align=\"left\">37</td>\n<td align=\"left\">曹髦</td>\n<td align=\"left\">曹丕之孙，东海王曹霖之子，曹魏第四位皇帝 不满司马昭掌权反抗被杀</td>\n</tr>\n<tr>\n<td align=\"left\">38</td>\n<td align=\"left\">邓艾</td>\n<td align=\"left\">治理魏国西方，与姜维多次对峙；率兵偷渡阴平，攻灭蜀汉</td>\n</tr>\n<tr>\n<td align=\"left\">39</td>\n<td align=\"left\">曹奂</td>\n<td align=\"left\">三国时期曹魏末代皇帝（第五位）。魏武帝曹操之孙 司马炎篡夺魏国政权，建立西晋</td>\n</tr>\n<tr>\n<td align=\"left\">40</td>\n<td align=\"left\">诸葛瞻</td>\n<td align=\"left\">诸葛亮之子 与邓艾决战，兵败被杀，绵竹失守。后主刘禅出降，蜀汉灭亡</td>\n</tr>\n<tr>\n<td align=\"left\">41</td>\n<td align=\"left\">刘禅</td>\n<td align=\"left\">小名阿斗。蜀汉末代皇帝，刘备之子，母为昭烈皇后甘氏</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-1-3-3、蜀\"><a href=\"#5-1-3-3、蜀\" class=\"headerlink\" title=\"5.1.3.3、蜀\"></a>5.1.3.3、蜀</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">人物</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">刘备</td>\n<td align=\"left\">汉景帝之子中山靖王刘胜之后</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">关羽</td>\n<td align=\"left\">山西运城人</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">张飞</td>\n<td align=\"left\">今河北保定涿州市人</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">糜竺</td>\n<td align=\"left\">麋竺原为徐州富商，后被徐州牧陶谦辟为别驾从事（官名）。陶谦病死后，奉其遗命迎接刘备</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">简雍</td>\n<td align=\"left\">刘备帐下谋士</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">诸葛亮</td>\n<td align=\"left\">蜀汉丞相，向刘备提出占据荆州、益州，联合孙权共同对抗曹操的隆中对  五次北伐</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">赵云</td>\n<td align=\"left\">（1）与关羽、张飞并称“燕南三士”   （2）先加入公孙瓒，后追随刘备</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">孙乾</td>\n<td align=\"left\">东汉末年刘备帐下幕僚</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">廖化</td>\n<td align=\"left\">攻破游奕，击杀王赟</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">周仓</td>\n<td align=\"left\">关羽身边的武将。在关羽镇守荆州对抗曹魏名将于禁与庞德的战斗中，于水中生擒庞德。最后周仓在关羽父子被斩之后自刎而死</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">廖化</td>\n<td align=\"left\">攻破游奕，击杀王赟</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">徐庶</td>\n<td align=\"left\">东汉末年刘备帐下谋士，后归曹操</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">庞统</td>\n<td align=\"left\">刘备帐下重要谋士，与诸葛亮同拜为军师中郎将   攻打益州刘璋时死于落凤坡</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">黄忠</td>\n<td align=\"left\">本为刘表部下中郎将，后归刘备，并助刘备攻破益州刘璋</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">魏延</td>\n<td align=\"left\">镇守汉中，大破费瑶和郭淮，子午谷奇谋</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">马超</td>\n<td align=\"left\">马腾长子，马铁，马休兄长  辅助刘备建立蜀汉</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">张苞</td>\n<td align=\"left\">张飞的长子。英年早逝，留有一子张遵</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">关兴</td>\n<td align=\"left\">关羽次子，关平之弟</td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">马良</td>\n<td align=\"left\">马良兄弟五人，都有才华名气，乡里为他们编有谚语说：“马家五常，白眉最良。”马良眉中有白毛，故此人们这样称呼他</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">马谡</td>\n<td align=\"left\">马良之弟，诸葛亮北伐时因作战失误失守街亭</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">姜维</td>\n<td align=\"left\">洮西大破王经，据守剑阁阻挡住钟会大军</td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">邓芝</td>\n<td align=\"left\">出使吴国，与之修好 讨平涪陵叛乱</td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">王平</td>\n<td align=\"left\">击退曹爽大举伐蜀</td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">杨仪</td>\n<td align=\"left\">辅佐诸葛亮、击杀魏延</td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">蒋琬</td>\n<td align=\"left\">继诸葛亮执政，安定众心</td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">李严</td>\n<td align=\"left\">与诸葛亮同为刘备临终前的托孤之臣 参与制定《蜀科》</td>\n</tr>\n<tr>\n<td align=\"left\">27</td>\n<td align=\"left\">马岱</td>\n<td align=\"left\">马超从弟，在诸葛亮病逝后受杨仪派遣斩杀了蜀将魏延</td>\n</tr>\n<tr>\n<td align=\"left\">28</td>\n<td align=\"left\">费祎</td>\n<td align=\"left\">蜀汉四相之一 休养生息，增强蜀汉国力</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-1-3-4、吴\"><a href=\"#5-1-3-4、吴\" class=\"headerlink\" title=\"5.1.3.4、吴\"></a>5.1.3.4、吴</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">人物</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">孙坚</td>\n<td align=\"left\">（1）孙吴政权的奠基者 （2）洛阳城外击溃董卓</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">程普</td>\n<td align=\"left\">从孙坚讨黄巾、破董卓；救孙策，定江东；参与赤壁之战、南郡之战</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">黄盖</td>\n<td align=\"left\">在赤壁之战中诈降，献计火攻</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">孙策</td>\n<td align=\"left\">孙坚长子，字伯符</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">孙权</td>\n<td align=\"left\">孙坚次子，字仲谋</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">孙尚香</td>\n<td align=\"left\">孙权之妹，曾为刘备之妻，民间戏剧称之为孙尚香</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">周瑜</td>\n<td align=\"left\">辅平江东、开拓荆州、赤壁破曹、督灭黄祖、谏阻纳质、提出征伐益州战略</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">张昭</td>\n<td align=\"left\">辅佐孙策、孙权安定江东，与孙邵、滕胤等撰定朝仪</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">张紘</td>\n<td align=\"left\">东汉末年文学家、官员，和张昭一起合称“二张”</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">大乔</td>\n<td align=\"left\">东汉末年江东孙策的夫人，本姓“桥”，小说《三国演义》误作“乔”，因为同时还有一个妹妹嫁给周瑜，为了进行区分，姐姐习惯称作“大乔（桥）”</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">鲁肃</td>\n<td align=\"left\">孙权部将、战略家、外交家</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">甘宁</td>\n<td align=\"left\">先投靠刘表，但未被重用，后归依孙权，孙权加以重用。曾随周瑜在乌林击败曹操在南郡攻打曹仁夺取夷陵</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">陆逊</td>\n<td align=\"left\">与吕蒙共同击败关羽、夺取荆州 夷陵之战破刘备 石亭之战败曹休</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">吕蒙</td>\n<td align=\"left\">攻皖城 取三郡 濡须之战 袭荆州</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">诸葛恪</td>\n<td align=\"left\">大将军诸葛瑾长子，蜀汉丞相诸葛亮之侄 在东兴堤大胜魏军</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">丁奉</td>\n<td align=\"left\">在东兴之战中大破魏军前屯</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">孙亮</td>\n<td align=\"left\">孙吴第二位皇帝 计除权臣诸葛恪 后被孙琳废</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">孙峻</td>\n<td align=\"left\">诛杀诸葛恪，专擅朝政</td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">孙休</td>\n<td align=\"left\">孙权第六子。中国三国时期孙吴国主</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">孙綝（chen）</td>\n<td align=\"left\">孙亮即位后由孙峻辅政。 太平元年（公元256年）孙峻去世，孙綝接替堂兄掌控朝局 被孙休、丁奉等定计诛杀</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">陆抗</td>\n<td align=\"left\">西陵之战大破晋军；维护吴国稳定</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-1-4、三国势力图\"><a href=\"#5-1-4、三国势力图\" class=\"headerlink\" title=\"5.1.4、三国势力图\"></a>5.1.4、三国势力图</h2><ol>\n<li>初期势力图</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031910885.png\" alt=\"三国势力图|725\"></p>\n<ol start=\"2\">\n<li>三足鼎立势力图</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031918859.png\" alt=\"三足鼎立|975\"></p>\n<h1 id=\"6、魏晋南北朝时期\"><a href=\"#6、魏晋南北朝时期\" class=\"headerlink\" title=\"6、魏晋南北朝时期\"></a>6、魏晋南北朝时期</h1><h2 id=\"6-1、魏晋南北朝时期概览\"><a href=\"#6-1、魏晋南北朝时期概览\" class=\"headerlink\" title=\"6.1、魏晋南北朝时期概览\"></a>6.1、魏晋南北朝时期概览</h2><p>魏晋南北朝（220—589年，370年），又称三国两晋南北朝，是中国历史上政权更迭最频繁的时期，主要分为三国（曹魏、蜀汉、东吴）、西晋、东晋和南北朝时期，由于长期的封建割据和连绵不断的战争，使这一时期中国文化的发展受到特别的影响。其突出表现则是玄学的兴起、佛教的输入、道教的勃兴。三国至隋的<strong>三百六十余年</strong>，以及三十余个大小王朝交替兴灭过程</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308051110202.png\" alt=\"魏晋南北朝时期\"></p>\n<h1 id=\"7、隋朝\"><a href=\"#7、隋朝\" class=\"headerlink\" title=\"7、隋朝\"></a>7、隋朝</h1><h2 id=\"7-1、隋朝年表\"><a href=\"#7-1、隋朝年表\" class=\"headerlink\" title=\"7.1、隋朝年表\"></a>7.1、隋朝年表</h2><p>隋朝（581年～619年,38年）是中国历史上承南北朝，下启唐朝的大统一朝代。定都大兴（西安）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">谥号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">隋文帝</td>\n<td align=\"left\">杨坚</td>\n<td align=\"left\">581年-604年（24年）</td>\n<td align=\"left\">三省六部制<div>开创科举</div><div>罢黜杨勇，立杨广</div></td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">隋炀帝&#x2F;隋明帝</td>\n<td align=\"left\">杨广</td>\n<td align=\"left\">604年-618年（15年）</td>\n<td align=\"left\">迁都洛阳 <div>穷奢极欲</div><div>隋朝大运河</div><div>江都兵变</div></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">隋恭帝</td>\n<td align=\"left\">杨侑</td>\n<td align=\"left\">617年-618年（177天）</td>\n<td align=\"left\">被李渊拥立为帝，后被幽禁</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">隋秦王</td>\n<td align=\"left\">杨浩</td>\n<td align=\"left\">618年（半年）</td>\n<td align=\"left\">被宇文化及拥立为帝，后被毒杀</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">皇泰主</td>\n<td align=\"left\">杨侗（dong）</td>\n<td align=\"left\">618年-619年（1年）</td>\n<td align=\"left\">被王世充拥立为帝，后被杀害</td>\n</tr>\n</tbody></table>\n<h1 id=\"8、唐朝\"><a href=\"#8、唐朝\" class=\"headerlink\" title=\"8、唐朝\"></a>8、唐朝</h1><h2 id=\"8-1、唐朝年表\"><a href=\"#8-1、唐朝年表\" class=\"headerlink\" title=\"8.1、唐朝年表\"></a>8.1、唐朝年表</h2><p>唐王李渊于618年逼隋恭帝禅位,推翻隋朝,改国号为“唐”(尊称“大唐”),建立了唐朝（618年－907年，289年）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">唐高祖</td>\n<td align=\"left\">李渊</td>\n<td align=\"left\">618-626（9年）</td>\n<td align=\"left\">晋阳起兵，建立唐朝</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">唐太宗</td>\n<td align=\"left\">李世民</td>\n<td align=\"left\">627-649（23年）</td>\n<td align=\"left\">玄武门之变，贞观之治</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">唐高宗</td>\n<td align=\"left\">李治</td>\n<td align=\"left\">650-683（24年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">唐中宗</td>\n<td align=\"left\">李显</td>\n<td align=\"left\">684</td>\n<td align=\"left\">被废</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">唐睿宗</td>\n<td align=\"left\">李旦</td>\n<td align=\"left\">684-690（6年）</td>\n<td align=\"left\">被废</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">武则天</td>\n<td align=\"left\">武曌（zhao）</td>\n<td align=\"left\">690-705（16年）</td>\n<td align=\"left\">武周开国君主（不属于唐）</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">唐中宗</td>\n<td align=\"left\">李显</td>\n<td align=\"left\">705-710（5年）</td>\n<td align=\"left\">神龙政变 被韦皇后毒死</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">唐少帝</td>\n<td align=\"left\">李重茂</td>\n<td align=\"left\">710</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">唐睿宗</td>\n<td align=\"left\">李旦</td>\n<td align=\"left\">710-712（2年）</td>\n<td align=\"left\">二次让位</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">唐玄宗</td>\n<td align=\"left\">李隆基</td>\n<td align=\"left\">712-756（44年）</td>\n<td align=\"left\">唐隆政变 唐明皇 安史之乱 开元之治</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">唐肃宗</td>\n<td align=\"left\">李亨</td>\n<td align=\"left\">756-762（5年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">唐代宗</td>\n<td align=\"left\">李豫</td>\n<td align=\"left\">762-779（17年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">唐德宗</td>\n<td align=\"left\">李适</td>\n<td align=\"left\">779-805（26年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">唐顺宗</td>\n<td align=\"left\">李诵</td>\n<td align=\"left\">805（8月）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">唐宪宗</td>\n<td align=\"left\">李纯</td>\n<td align=\"left\">806-820（15年）</td>\n<td align=\"left\">元和中兴</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">唐穆宗</td>\n<td align=\"left\">李恒</td>\n<td align=\"left\">821-824（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">唐敬宗</td>\n<td align=\"left\">李湛</td>\n<td align=\"left\">824-826（2年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">唐文宗</td>\n<td align=\"left\">李昂</td>\n<td align=\"left\">826-840（14年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">唐武宗</td>\n<td align=\"left\">李炎</td>\n<td align=\"left\">840-846（6年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">唐宣宗</td>\n<td align=\"left\">李忱（chen）</td>\n<td align=\"left\">846-859（13年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">唐懿宗</td>\n<td align=\"left\">李漼（cui）</td>\n<td align=\"left\">859-873（14年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">唐僖宗</td>\n<td align=\"left\">李儇（xuan）</td>\n<td align=\"left\">873-888（15年）</td>\n<td align=\"left\">黄巢起义</td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">唐昭宗</td>\n<td align=\"left\">李晔</td>\n<td align=\"left\">888-904（16年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">唐哀帝</td>\n<td align=\"left\">李柷（chu）</td>\n<td align=\"left\">904-907（3年）</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"9、五代十国\"><a href=\"#9、五代十国\" class=\"headerlink\" title=\"9、五代十国\"></a>9、五代十国</h1><h1 id=\"10、宋朝\"><a href=\"#10、宋朝\" class=\"headerlink\" title=\"10、宋朝\"></a>10、宋朝</h1><h2 id=\"10-1、宋朝年表\"><a href=\"#10-1、宋朝年表\" class=\"headerlink\" title=\"10.1、宋朝年表\"></a>10.1、宋朝年表</h2><p>宋朝（960年－1279年，319年）是中国历史上承五代十国下启元朝的中原王朝，分北宋和南宋两个阶段，共历十八帝</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">宋太祖</td>\n<td align=\"left\">赵匡胤</td>\n<td align=\"left\">960-976（16年）</td>\n<td align=\"left\">改革官帽 两次杯酒释兵权</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">宋太宗</td>\n<td align=\"left\">赵炅</td>\n<td align=\"left\">976-997（21年）</td>\n<td align=\"left\">赵匡胤之弟 雪中送炭</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">宋真宗</td>\n<td align=\"left\">赵恒</td>\n<td align=\"left\">997-1022（15年）</td>\n<td align=\"left\">赵炅三子，澶渊之盟</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">宋仁宗</td>\n<td align=\"left\">赵祯</td>\n<td align=\"left\">1022-1063（41年）</td>\n<td align=\"left\">赵恒六子， 发行交子 狸猫换太子</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">宋英宗</td>\n<td align=\"left\">赵曙</td>\n<td align=\"left\">1063-1067（4年）</td>\n<td align=\"left\">赵祯堂兄赵允让第十三子     《资治通鉴》</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">宋神宗</td>\n<td align=\"left\">赵顼</td>\n<td align=\"left\">1067-1085（18年）</td>\n<td align=\"left\">赵曙长子，重用王安石变法</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">宋哲宗</td>\n<td align=\"left\">赵煦</td>\n<td align=\"left\">1085-1100（15年）</td>\n<td align=\"left\">赵顼六子</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">宋徽宗</td>\n<td align=\"left\">赵佶</td>\n<td align=\"left\">1100-1126（26年）</td>\n<td align=\"left\">赵顼十一子，书法绘画大师（瘦金体）  宋江起义 方腊起义    靖康之变</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">宋钦宗</td>\n<td align=\"left\">赵桓</td>\n<td align=\"left\">1126-1127（1年）</td>\n<td align=\"left\">赵佶长子，赵构异母兄弟 。1127年发生”靖康之变” 金朝南下攻取北宋首都东京，掳走徽、钦二帝，导致北宋灭亡的历史事件</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">宋高宗</td>\n<td align=\"left\">赵构</td>\n<td align=\"left\">1127-1162（35年）</td>\n<td align=\"left\">赵佶九子，南宋开国皇帝 ，重用秦桧</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">宋孝宗</td>\n<td align=\"left\">赵昚（shen）</td>\n<td align=\"left\">1162-1189（27年）</td>\n<td align=\"left\">赵构养子 平反岳飞 隆兴和议 被认为南宋最有作为的皇帝</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">宋光宗</td>\n<td align=\"left\">赵惇</td>\n<td align=\"left\">1189-1194（5年）</td>\n<td align=\"left\">绍熙内禅</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">宋宁宗</td>\n<td align=\"left\">赵扩</td>\n<td align=\"left\">1194 -1224（30年）</td>\n<td align=\"left\">赵惇次子</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">宋理宗</td>\n<td align=\"left\">赵昀（yun）</td>\n<td align=\"left\">1224-1264（40年）</td>\n<td align=\"left\">赵扩远方堂侄 ，联蒙灭金</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">宋度宗</td>\n<td align=\"left\">赵禥（qi）</td>\n<td align=\"left\">1264-1274（10年）</td>\n<td align=\"left\">赵昀之侄，智力低于常人</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">宋恭宗</td>\n<td align=\"left\">赵㬎（xian）</td>\n<td align=\"left\">1274-1276（2年）</td>\n<td align=\"left\">赵禥次子 ，退位降元</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">宋端宗</td>\n<td align=\"left\">赵昰（shi）</td>\n<td align=\"left\">1276-1278（2年）</td>\n<td align=\"left\">赵禥庶长子，九岁去世</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">宋卫王</td>\n<td align=\"left\">赵昺（昺）</td>\n<td align=\"left\">1278-1279（1年）</td>\n<td align=\"left\">赵禥三子，崖山海战，投海殉国</td>\n</tr>\n</tbody></table>\n<h1 id=\"11、元朝\"><a href=\"#11、元朝\" class=\"headerlink\" title=\"11、元朝\"></a>11、元朝</h1><h2 id=\"11-1、元朝年表\"><a href=\"#11-1、元朝年表\" class=\"headerlink\" title=\"11.1、元朝年表\"></a>11.1、元朝年表</h2><p>元朝（1271年—1368年，98年），是中国历史上的朝代。铁木真于1206年建国；1271年忽必烈定国号为元，1279年灭南宋。 是首次由少数民族建立的大一统王朝，传五世十一帝</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>姓名</th>\n<th>庙号</th>\n<th>统治时间</th>\n<th>事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>孛儿只斤·铁木真</td>\n<td>元太祖</td>\n<td>1206-1227年（21年）</td>\n<td>大蒙古可汗，建立大蒙古国</td>\n</tr>\n<tr>\n<td>2</td>\n<td>孛儿只斤·窝阔台</td>\n<td>元太宗</td>\n<td>1229-1241年（12年）</td>\n<td>蒙古帝国大汗，奠定元朝基础</td>\n</tr>\n<tr>\n<td>3</td>\n<td>孛儿只斤·贵由</td>\n<td>元定宗</td>\n<td>1246-1248年（2年）</td>\n<td>蒙古帝国第三任大汗，西征欧洲</td>\n</tr>\n<tr>\n<td>4</td>\n<td>孛儿只斤·蒙哥</td>\n<td>元宪宗</td>\n<td>1251-1259年（8年）</td>\n<td>大蒙古国可汗，招降吐蕃</td>\n</tr>\n<tr>\n<td>1</td>\n<td>孛儿只斤·忽必烈</td>\n<td>元世祖</td>\n<td>1260-1294年 （34年）</td>\n<td>元朝开国皇帝，首创行省制度</td>\n</tr>\n<tr>\n<td>2</td>\n<td>孛儿只斤·铁穆耳</td>\n<td>元成宗</td>\n<td>1294-1307年（13年）</td>\n<td>击败西北叛王</td>\n</tr>\n<tr>\n<td>3</td>\n<td>孛儿只斤·海山</td>\n<td>元武宗</td>\n<td>1307-1311年（4年）</td>\n<td>设尚书省</td>\n</tr>\n<tr>\n<td>4</td>\n<td>孛儿只斤·爱育黎拔力八达</td>\n<td>元仁宗</td>\n<td>1311-1320年（9年）</td>\n<td>实行科举制度</td>\n</tr>\n<tr>\n<td>5</td>\n<td>孛儿只斤·硕德八剌</td>\n<td>元英宗</td>\n<td>1320-1323年（3年）</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>孛儿只斤·也孙铁木儿</td>\n<td>-</td>\n<td>1323-1328年（5年）</td>\n<td>史称泰定帝</td>\n</tr>\n<tr>\n<td>7</td>\n<td>孛儿只斤·阿速吉八</td>\n<td>-</td>\n<td>1328年（27天）</td>\n<td>史称天顺帝</td>\n</tr>\n<tr>\n<td>8</td>\n<td>孛儿只斤·图帖睦尔</td>\n<td>元文宗</td>\n<td>1329-1332年（3年）</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>孛儿只斤·和世㻋</td>\n<td>元明宗</td>\n<td>1329年（184天）</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>孛儿只斤·懿璘质班</td>\n<td>元宁宗</td>\n<td>1332年（52天）</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>孛儿只斤·懽帖睦尔</td>\n<td>元惠宗</td>\n<td>1333-1370年（37年）</td>\n<td>实施“至正新政”改革</td>\n</tr>\n</tbody></table>\n<h1 id=\"12、明朝\"><a href=\"#12、明朝\" class=\"headerlink\" title=\"12、明朝\"></a>12、明朝</h1><h2 id=\"12-1、明朝年表\"><a href=\"#12-1、明朝年表\" class=\"headerlink\" title=\"12.1、明朝年表\"></a>12.1、明朝年表</h2><p>明朝（1368年―1644年，276年）明太祖朱元璋所建。初期建都南京，明成祖时期迁都北京。传十六帝</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">年号</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">明太祖</td>\n<td align=\"left\">朱元璋</td>\n<td align=\"left\">洪武</td>\n<td align=\"left\">1368-1398（20年）</td>\n<td align=\"left\">洪武之治</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">明惠宗</td>\n<td align=\"left\">朱允炆</td>\n<td align=\"left\">建文</td>\n<td align=\"left\">1398-1402（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">明成祖</td>\n<td align=\"left\">朱棣</td>\n<td align=\"left\">永乐</td>\n<td align=\"left\">1402-1424（22年）</td>\n<td align=\"left\">永乐盛世</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">明仁宗</td>\n<td align=\"left\">朱高炽</td>\n<td align=\"left\">洪熙</td>\n<td align=\"left\">1424-1425（1年）</td>\n<td align=\"left\">仁宣之治</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">明宣宗</td>\n<td align=\"left\">朱瞻基</td>\n<td align=\"left\">宣德</td>\n<td align=\"left\">1425-1435（10年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">明英宗</td>\n<td align=\"left\">朱祁镇</td>\n<td align=\"left\">正统 天顺</td>\n<td align=\"left\">1435-1449 1457-1464</td>\n<td align=\"left\">夺门之变</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">明代宗</td>\n<td align=\"left\">朱祁钰</td>\n<td align=\"left\">景泰</td>\n<td align=\"left\">1449-1457（8年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">明宪宗</td>\n<td align=\"left\">朱见深</td>\n<td align=\"left\">成化</td>\n<td align=\"left\">1464-1487（23年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">明孝宗</td>\n<td align=\"left\">朱祐樘</td>\n<td align=\"left\">弘治</td>\n<td align=\"left\">1487-1505（18年）</td>\n<td align=\"left\">弘治中兴</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">明武宗</td>\n<td align=\"left\">朱厚照</td>\n<td align=\"left\">正德</td>\n<td align=\"left\">1505-1521（16年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">明世宗</td>\n<td align=\"left\">朱厚熜</td>\n<td align=\"left\">嘉靖</td>\n<td align=\"left\">1521-1566（45年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">明穆宗</td>\n<td align=\"left\">朱载坖</td>\n<td align=\"left\">隆庆</td>\n<td align=\"left\">1566-1572（6年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">明神宗</td>\n<td align=\"left\">朱翊（yi）钧</td>\n<td align=\"left\">万历</td>\n<td align=\"left\">1572-1620（48年）</td>\n<td align=\"left\">万历中兴</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">明光宗</td>\n<td align=\"left\">朱常洛</td>\n<td align=\"left\">泰昌</td>\n<td align=\"left\">1620</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">明熹宗</td>\n<td align=\"left\">朱由校</td>\n<td align=\"left\">天启</td>\n<td align=\"left\">1620-1627（7年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">明思宗</td>\n<td align=\"left\">朱由检</td>\n<td align=\"left\">崇祯</td>\n<td align=\"left\">1627-1644（17年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">南明时期（1644-1662，18年）</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">明安宗</td>\n<td align=\"left\">朱由崧</td>\n<td align=\"left\">弘光</td>\n<td align=\"left\">1644-1645（1年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">明绍宗</td>\n<td align=\"left\">朱聿键</td>\n<td align=\"left\">隆武</td>\n<td align=\"left\">1645-1646（1年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"></td>\n<td align=\"left\">朱聿鐭</td>\n<td align=\"left\">绍武</td>\n<td align=\"left\">1646年的1个月</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">明昭宗</td>\n<td align=\"left\">朱聿键</td>\n<td align=\"left\">永历</td>\n<td align=\"left\">1646-1662（16年）</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"13、清朝\"><a href=\"#13、清朝\" class=\"headerlink\" title=\"13、清朝\"></a>13、清朝</h1><h2 id=\"13-1、清朝年表\"><a href=\"#13-1、清朝年表\" class=\"headerlink\" title=\"13.1、清朝年表\"></a>13.1、清朝年表</h2><p>清朝（1616年—1912年，296年），是中国历史上最后一个封建王朝，共传十二帝，初称后金。从努尔哈赤建国起，总计296年。从皇太极改国号为清起，国祚276年</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>姓名</th>\n<th>年号</th>\n<th>在位时间</th>\n<th>主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>努尔哈赤</td>\n<td>天命</td>\n<td>1616-1626（10年）</td>\n<td>统一女真 建立后金 反抗明朝 萨尔浒之战</td>\n</tr>\n<tr>\n<td>2</td>\n<td>皇太极</td>\n<td>天聪 崇德</td>\n<td>1626-1643（17年）</td>\n<td>征服朝鲜和蒙古 松锦大捷 改国号大清和族名满洲</td>\n</tr>\n<tr>\n<td>3</td>\n<td>福临</td>\n<td>顺治</td>\n<td>1643-1661（18年）</td>\n<td>李自成攻入北京 崇祯自缢而死 吴三桂引清军入关 大清迁都北京</td>\n</tr>\n<tr>\n<td>4</td>\n<td>玄烨</td>\n<td>康熙</td>\n<td>1661-1722（61年）</td>\n<td>囚禁鳌拜 削三番 收复台湾 签订《尼布楚条约》</td>\n</tr>\n<tr>\n<td>5</td>\n<td>胤禛</td>\n<td>雍正</td>\n<td>1722-1735（13年）</td>\n<td>设军机处</td>\n</tr>\n<tr>\n<td>6</td>\n<td>弘历</td>\n<td>乾隆</td>\n<td>1736-1796（60年）</td>\n<td>编纂《四库全书》 大兴文字狱 实行闭关锁国</td>\n</tr>\n<tr>\n<td>7</td>\n<td>永琰</td>\n<td>嘉庆</td>\n<td>1796-1820（24年）</td>\n<td>诛杀和珅 白莲教天理教起义</td>\n</tr>\n<tr>\n<td>8</td>\n<td>旻宁</td>\n<td>道光</td>\n<td>1820-1850（30年）</td>\n<td>虎门销烟 第一次鸦片战争 《南京条约》，割香港给英国</td>\n</tr>\n<tr>\n<td>9</td>\n<td>奕訢</td>\n<td>咸丰</td>\n<td>1850-1861（11年）</td>\n<td>太平天国起义 第二次鸦片战争 圆明园被毁  《天津条约》《北京条约》  洋务运动</td>\n</tr>\n<tr>\n<td>10</td>\n<td>载淳</td>\n<td>同治</td>\n<td>1861-1874（13年）</td>\n<td>辛酉政变 慈溪垂帘听政 镇压太平天国 同治中兴</td>\n</tr>\n<tr>\n<td>11</td>\n<td>载湉</td>\n<td>光绪</td>\n<td>1874-1908（34年）</td>\n<td>中法战争 中日甲午战争 戊戌变法 义和团 八国联军   《马关条约》《辛丑条约》 慈溪仍掌政</td>\n</tr>\n<tr>\n<td>12</td>\n<td>溥仪</td>\n<td>宣统</td>\n<td>1908-1911（3年）</td>\n<td>辛亥革命</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、史前时期\"><a href=\"#1、史前时期\" class=\"headerlink\" title=\"1、史前时期\"></a>1、史前时期</h1><h2 id=\"1-1、中国人种起源及生存环境\"><a href=\"#1-1、中国人种起源及生存环境\" class=\"headerlink\" title=\"1.1、中国人种起源及生存环境\"></a>1.1、中国人种起源及生存环境</h2><p>人类进化链环的各个阶段，在中国境内大都可以找到对应的遗址。</p>\n<ol>\n<li>直立人: 西侯度人(山西，180万年前)、元谋猿人(云南，170万年前)、蓝田人(陕西，115-70万年前)、北京猿人(70-23万年前)</li>\n<li>早期智人 (古人)：长阳人(湖北，距今19.5万年)、丁村人(山西，距今20多万年）、大荔人（陕西，距今20-15万年前）</li>\n<li>晚期智人（新人）：猿类特征已经退化，体质特征接近现代人。柳江人（距今5-4万年，广西），河套人（距今5-3.7万年，内蒙古），山顶洞人（距今3万年，北京）</li>\n</ol>\n<h2 id=\"1-2、中国境内旧石器和新石器时代\"><a href=\"#1-2、中国境内旧石器和新石器时代\" class=\"headerlink\" title=\"1.2、中国境内旧石器和新石器时代\"></a>1.2、中国境内旧石器和新石器时代</h2><p>在考古学上，根据人类使用工具的进化程度不将历史划为:石器时代 (旧石器时代,新石器时代) -&gt; 青铜时代 -&gt; 铁器时代</p>\n<ol>\n<li>旧石器时代：距今250万年-1万年，特点是使用粗糙的打制石器，过着采集和渔猎生活，相当于人类历史上的原始人阶段</li>\n<li>新石器时代：距今1万-5000年，氏族公社时期，包括母系氏族公社和父系氏族公社，特点是使用磨制石器，能够制造陶和纺织，发明农业和畜牧业，有固定生活来源，不再依赖采集为生。（大汶口文化，红山文化，良渚文化，大溪文化，河姆渡文化，龙山文化）</li>\n</ol>\n<h1 id=\"2、夏商周三代文明\"><a href=\"#2、夏商周三代文明\" class=\"headerlink\" title=\"2、夏商周三代文明\"></a>2、夏商周三代文明</h1><h2 id=\"2-1、夏王朝\"><a href=\"#2-1、夏王朝\" class=\"headerlink\" title=\"2.1、夏王朝\"></a>2.1、夏王朝</h2><h3 id=\"2-1-1、夏朝年表\"><a href=\"#2-1-1、夏朝年表\" class=\"headerlink\" title=\"2.1.1、夏朝年表\"></a>2.1.1、夏朝年表</h3><p>夏朝（约前2070年－约前1600年，470年）是中国历史记载的第一个中原部族世袭制朝代</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时长</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">禹</td>\n<td align=\"left\">前2071-前2027（45年）</td>\n<td align=\"left\"><strong>涂山大会</strong>，铸造九鼎，象征九州，第一次有了国家的概念</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">启</td>\n<td align=\"left\">前2026-前1988（39年）</td>\n<td align=\"left\">由禅让制变为世袭制，击败了有扈氏的反抗</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">太康</td>\n<td align=\"left\">前1987-前1984（4年）</td>\n<td align=\"left\">不理朝政，被有穷氏后羿夺权，<strong>太康失国</strong>，实际在位2年</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">仲康</td>\n<td align=\"left\">前1983-前1977（7年）</td>\n<td align=\"left\">后羿专权，仲康反抗失败被软禁，抑郁而终</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">相</td>\n<td align=\"left\">前1976-前1949（28年）</td>\n<td align=\"left\">被寒浞的儿子浇攻破自刎，大臣寒浞杀后羿夺权</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">少康&#x2F;杜康</td>\n<td align=\"left\">前1908-前1888（21年）</td>\n<td align=\"left\">相的遗腹子，攻杀寒浞，复国，<strong>少康中兴</strong></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">季杼</td>\n<td align=\"left\">前1887-前1871（17年）</td>\n<td align=\"left\">参加过复兴夏朝的战争</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">槐&#x2F;帝芬</td>\n<td align=\"left\">前前1870-前1827（44年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">芒</td>\n<td align=\"left\">前1826-前1769（58年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">泄&#x2F;帝降</td>\n<td align=\"left\">前1768-前1753（16年）</td>\n<td align=\"left\">正式赐封九夷各部诸侯爵位</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">不降</td>\n<td align=\"left\">前1752-前1705（48年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">扃</td>\n<td align=\"left\">前1704-前1684（21年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">廑（jin）</td>\n<td align=\"left\">前1683-前1676（8年）</td>\n<td align=\"left\">夏国开始衰落</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">孔甲</td>\n<td align=\"left\">前1675-前1667（9年）</td>\n<td align=\"left\">胡作非为的残暴昏君</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">皋</td>\n<td align=\"left\">前1666 -前1664（3年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">发</td>\n<td align=\"left\">前1663-前1645（19年）</td>\n<td align=\"left\">各方诸侯已不来朝贺</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">桀</td>\n<td align=\"left\">前1644-前1592（53年）</td>\n<td align=\"left\">暴君，被商汤灭，亡国</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-1-2、夏王朝的文献和史事\"><a href=\"#2-1-2、夏王朝的文献和史事\" class=\"headerlink\" title=\"2.1.2、夏王朝的文献和史事\"></a>2.1.2、夏王朝的文献和史事</h3><p>目前关于夏王朝的主要文献资料来源于《史记·夏本纪》和《尚书》及《诗经》的部分记载。<br>夏王朝始于禹。尧舜禹的禅让到禹时，发生了根本的变化。禹传位于其子启，确立了嫡子世袭制度。据《夏本纪》的材料，禹开始以天下授益<br>就在传位于启不久，这个部落联盟中的有扈氏部族“不服”，向启提出了挑战。启伐之，大战于甘，有扈氏被灭。<br>夏后帝启死后，子太康立。太康时失国，太康崩，弟中康立，是为帝中康。中康生子相。相时受到东夷族有穷氏(其首领为善射的羿)的压迫，在与有穷氏的战争中，夏王相被杀，但他的儿子少康最终取得胜利，这就是“少康复国。</p>\n<h2 id=\"2-2、商王朝\"><a href=\"#2-2、商王朝\" class=\"headerlink\" title=\"2.2、商王朝\"></a>2.2、商王朝</h2><h3 id=\"2-2-1、商朝年表\"><a href=\"#2-2-1、商朝年表\" class=\"headerlink\" title=\"2.2.1、商朝年表\"></a>2.2.1、商朝年表</h3><p>商朝（约公元前1600年-约公元前1046年，554年）</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>姓名</th>\n<th>别名</th>\n<th>在位时长</th>\n<th>相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>商汤</td>\n<td>天乙</td>\n<td>前1600年-前1588年（13年）</td>\n<td>开国君主 鸣条之战</td>\n</tr>\n<tr>\n<td>2</td>\n<td>商哀王</td>\n<td>外丙</td>\n<td>前1587年-前1586年（2年）</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>商懿王</td>\n<td>仲壬</td>\n<td>前1585年-前1582年（4年）</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>商太宗</td>\n<td>太甲</td>\n<td>前1582年-前1570年（13年）</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>商昭王</td>\n<td>沃丁</td>\n<td>前1570年-前1541年（29年）</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>商宣王</td>\n<td>太庚</td>\n<td>前1541年-前1516年（25年）</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>商敬王</td>\n<td>小甲</td>\n<td>前1516年-前1499年（17年）</td>\n<td>商朝始衰</td>\n</tr>\n<tr>\n<td>8</td>\n<td>商元王</td>\n<td>雍己</td>\n<td>前1487年-前1476年（12年）</td>\n<td>诸侯不来朝</td>\n</tr>\n<tr>\n<td>9</td>\n<td>商中宗</td>\n<td>太戊</td>\n<td>前1486年-前1412年（75年）</td>\n<td>小国又纷纷归顺，商朝中兴</td>\n</tr>\n<tr>\n<td>10</td>\n<td>商孝成王</td>\n<td>仲丁</td>\n<td>前1418年-前1408年（13年）</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>商思王</td>\n<td>外壬</td>\n<td>前1407年-前1398年 （10年）</td>\n<td>九世之乱</td>\n</tr>\n<tr>\n<td>12</td>\n<td>商前平王</td>\n<td>河檀（dan）甲</td>\n<td>前1397年-前1389年（9年）</td>\n<td>迁都河南内黄</td>\n</tr>\n<tr>\n<td>13</td>\n<td>商穆王</td>\n<td>祖乙</td>\n<td>前1388年-前1370年（19年）</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>商桓王</td>\n<td>祖辛</td>\n<td>前1369年-前1356年（16年）</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>商僖（xi）王</td>\n<td>沃甲</td>\n<td>前1355年- 前1336年（20年）</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>商庄王</td>\n<td>祖丁</td>\n<td>前1335年- 前1327年（9年）</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>商顷王</td>\n<td>南庚</td>\n<td>前1326年-前1321年（6年）</td>\n<td>国都由庇（山东郓城）迁奄（山东曲阜）</td>\n</tr>\n<tr>\n<td>18</td>\n<td>商悼王</td>\n<td>阳甲</td>\n<td>前1321年- 前1314年（8年）</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>商世祖</td>\n<td>盘庚</td>\n<td>前1313年-前1286年（28年）</td>\n<td>迁都殷（河南安阳）</td>\n</tr>\n<tr>\n<td>20</td>\n<td>商章王</td>\n<td>小辛</td>\n<td>前1285年- 前1272年（14年）</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>商惠王</td>\n<td>小乙</td>\n<td>前1271年- 前1251年（21年）</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>商高宗</td>\n<td>武丁</td>\n<td>前1250年- 前1192年（59年）</td>\n<td>武丁中兴</td>\n</tr>\n<tr>\n<td>23</td>\n<td>商后平王</td>\n<td>祖庚</td>\n<td>前1191年-前1180年（12年）</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>商世宗</td>\n<td>祖甲</td>\n<td>前1180年-前1160年（20年）</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>商甲宗</td>\n<td>廪（lin）辛</td>\n<td>前1159年-前1156年（4年）</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>商康祖</td>\n<td>庚丁</td>\n<td>前1155年- 前1147年（9年）</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>商武祖</td>\n<td>武乙</td>\n<td>前1147年-前1113年（35年）</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>商匡王</td>\n<td>文丁</td>\n<td>前1112年-前1102年（11年）</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>商德王</td>\n<td>帝乙</td>\n<td>前1101年- 前1076年（26年）</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>商纣王</td>\n<td>帝辛</td>\n<td>前1075年-前1046年（30年）</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"2-2-2、商朝建立及迁徙过程\"><a href=\"#2-2-2、商朝建立及迁徙过程\" class=\"headerlink\" title=\"2.2.2、商朝建立及迁徙过程\"></a>2.2.2、商朝建立及迁徙过程</h3><p>商朝兴起于夏朝的东方，即黄河中下游，为子姓。其始祖名契，契母简狄是属于有戎的后代。传说是吞玄鸟之蛋而生契，这就是《诗经·商颂· 玄鸟》中的菩名诗句:“天命玄鸟，降而生商。”无疑，商人是以鸟为图腾的。商人逐渐西迁，从契到成汤历十四代王，共移徙八次。到汤时西进逼近夏人所居，终于灭掉夏王朝而建立商朝，都于毫(其地理位置尚存争议，或说商丘，或说偃师)。据史载，商汤立国之后，商人仍“不常厥邑”，又有五次迁都，历史上有“前八后五”的说法。到第二十代王盘庚时，他说服并胁迫商贵族再次迁徙，最终将商朝的都城固定下来，这就是目前所知的殷墟(河南安阳)。</p>\n<h3 id=\"2-2-3、商朝政治体制\"><a href=\"#2-2-3、商朝政治体制\" class=\"headerlink\" title=\"2.2.3、商朝政治体制\"></a>2.2.3、商朝政治体制</h3><p>商周王朝都是世袭王权制，政权掌控在王手，商王在甲骨文中称为“余一人”。商代前期还处在兄终弟及的状态，后期转变为父死子继制度。商王朝的主要官员分为臣、将军和史官（包括巫人、贞人（占卜者）和祭司等）三大类</p>\n<h2 id=\"2-3、周王朝\"><a href=\"#2-3、周王朝\" class=\"headerlink\" title=\"2.3、周王朝\"></a>2.3、周王朝</h2><p>周朝（前1046年—前256年，791年），是中国历史上最长的朝代 </p>\n<h3 id=\"2-3-1、西周年表\"><a href=\"#2-3-1、西周年表\" class=\"headerlink\" title=\"2.3.1、西周年表\"></a>2.3.1、西周年表</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">谥号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">周文王</td>\n<td align=\"left\">姬昌</td>\n<td align=\"left\">公元前 1110 年-前 1061 年为西伯（50 年）</td>\n<td align=\"left\">创《周易》  寿命 97</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">周武王</td>\n<td align=\"left\">姬发</td>\n<td align=\"left\">公元前 1060 年-前 1046 年为西伯（15 年）公元前 1046 年-前 1043 年为周王（4 年）</td>\n<td align=\"left\">孟津观兵   牧野之战  灭商建周，定都镐京（西安）</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">周成王</td>\n<td align=\"left\">姬诵</td>\n<td align=\"left\">公元前 1042 年-前 1021 年（22 年）</td>\n<td align=\"left\">成康之治 周公摄政 迁都洛邑（洛阳）</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">周康王</td>\n<td align=\"left\">姬钊</td>\n<td align=\"left\">公元前 1020 年-前 996 年（25 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">周昭王</td>\n<td align=\"left\">姬瑕</td>\n<td align=\"left\">公元前 995 年-前 977 年（18 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">周穆王</td>\n<td align=\"left\">姬满</td>\n<td align=\"left\">公元前 976 年-前 922 年（55 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">周共王</td>\n<td align=\"left\">姬繄扈（yihu）</td>\n<td align=\"left\">公元前 922 年-前 900 年（23 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">周懿王</td>\n<td align=\"left\">姬囏（jian）</td>\n<td align=\"left\">公元前 899 年-前 892 年（8 年）</td>\n<td align=\"left\">迁都槐里（兴平市）</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">周孝王</td>\n<td align=\"left\">姬辟方</td>\n<td align=\"left\">公元前 891 年-前 886 年（6 年）</td>\n<td align=\"left\">非子封秦</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">周夷王</td>\n<td align=\"left\">姬燮（xie）</td>\n<td align=\"left\">公元前 885 年-前 878 年（8 年）</td>\n<td align=\"left\">煮杀齐哀公</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">周厉王</td>\n<td align=\"left\">姬胡</td>\n<td align=\"left\">公元前 877 年-前 841 年（37 年）</td>\n<td align=\"left\">贪图财利</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">共和（一说为共伯和摄行天子政）</td>\n<td align=\"left\"></td>\n<td align=\"left\">公元前 841 年-前 828 年（14 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">周宣王</td>\n<td align=\"left\">姬静</td>\n<td align=\"left\">公元前 828 年-前 783 年（46 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">周幽王</td>\n<td align=\"left\">姬宫湦</td>\n<td align=\"left\">公元前 782 年-前 771 年（12 年）</td>\n<td align=\"left\">烽火戏诸侯（存疑）</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-2、东周年表\"><a href=\"#2-3-2、东周年表\" class=\"headerlink\" title=\"2.3.2、东周年表\"></a>2.3.2、东周年表</h3><p>西周末年，周幽王因宠爱褒姒而废黜申后及太子宜臼，立褒姒为后，并立其子伯服为太子，引起申候的叛变。申候引犬戎政入关中，杀死幽王。于是公元前770年周平王被迫东迁至洛邑，开始了中国历史上的东周。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">谥号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">周平王</td>\n<td align=\"left\">姬宜臼</td>\n<td align=\"left\">公元前 770 年-前 718 年（53 年）</td>\n<td align=\"left\">迁都洛邑列秦诸侯春秋之始</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">周桓王</td>\n<td align=\"left\">姬林</td>\n<td align=\"left\">公元前 718 年-前 697 年（22 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">周庄王</td>\n<td align=\"left\">姬佗</td>\n<td align=\"left\">公元前 697 年-前 682 年（16 年）</td>\n<td align=\"left\">平定王子克之乱</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">周釐王</td>\n<td align=\"left\">姬胡齐</td>\n<td align=\"left\">公元前 682 年-前 677 年（6 年）</td>\n<td align=\"left\">齐桓称霸</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">周惠王</td>\n<td align=\"left\">姬阆</td>\n<td align=\"left\">公元前 677 年-前 675 年第一次在位（3 年）公元前 673 年-前 652 年第二次在位（22 年）</td>\n<td align=\"left\">五大夫作乱</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">周废王（篡位）</td>\n<td align=\"left\">姬颓</td>\n<td align=\"left\">公元前 675 年-前 673 年（3 年）</td>\n<td align=\"left\">叛乱称王，后兵败遭杀</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">周襄王</td>\n<td align=\"left\">姬郑</td>\n<td align=\"left\">公元前 652 年-前 619 年（34 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">周顷王</td>\n<td align=\"left\">姬壬臣</td>\n<td align=\"left\">公元前 619 年-前 613 年（7 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">周匡王</td>\n<td align=\"left\">姬班</td>\n<td align=\"left\">公元前 613 年-前 607 年（7 年）</td>\n<td align=\"left\">赵盾事件</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">周定王</td>\n<td align=\"left\">姬瑜</td>\n<td align=\"left\">公元前 607 年-前 586 年（22 年）</td>\n<td align=\"left\">赵氏孤儿</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">周简王</td>\n<td align=\"left\">姬夷</td>\n<td align=\"left\">公元前 586 年-前 572 年（15 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">周灵王</td>\n<td align=\"left\">姬泄心</td>\n<td align=\"left\">公元前 572 年-前 545 年（28 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">周景王</td>\n<td align=\"left\">姬贵</td>\n<td align=\"left\">公元前 545 年-前 520 年（26 年）</td>\n<td align=\"left\">数典忘祖</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">周悼王</td>\n<td align=\"left\">姬猛</td>\n<td align=\"left\">公元前 520 年-前 520 年（1 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">周敬王</td>\n<td align=\"left\">姬匄</td>\n<td align=\"left\">公元前 520 年-前 475 年（46 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">周元王</td>\n<td align=\"left\">姬仁</td>\n<td align=\"left\">公元前 475 年-前 473 年（3 年）</td>\n<td align=\"left\">周元王开始为战国时期</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">周贞定王</td>\n<td align=\"left\">姬介</td>\n<td align=\"left\">公元前 473 年-前 441 年（33 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">周哀王</td>\n<td align=\"left\">姬去疾</td>\n<td align=\"left\">公元前 441 年-前 441 年（1 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">周思王</td>\n<td align=\"left\">姬叔</td>\n<td align=\"left\">公元前 441 年-前 441 年（1 年）</td>\n<td align=\"left\">在位仅五个月，即被弟弟姬嵬杀死</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">周考王</td>\n<td align=\"left\">姬嵬</td>\n<td align=\"left\">公元前 441 年-前 426 年（16 年）</td>\n<td align=\"left\">叔弑兄篡位</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">周威烈王</td>\n<td align=\"left\">姬午</td>\n<td align=\"left\">公元前 426 年-前 402 年（25 年）</td>\n<td align=\"left\">三家分晋</td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">周安王</td>\n<td align=\"left\">姬骄</td>\n<td align=\"left\">公元前 402 年-前 376 年（27 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">周烈王</td>\n<td align=\"left\">姬喜</td>\n<td align=\"left\">公元前 376 年-前 369 年（8 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">周显王</td>\n<td align=\"left\">姬扁</td>\n<td align=\"left\">公元前 369 年-前 321 年（49 年）</td>\n<td align=\"left\">桂陵之战 马陵之战 商鞅变法</td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">周慎靓王</td>\n<td align=\"left\">姬定</td>\n<td align=\"left\">公元前 321 年-前 315 年（7 年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">周赧王</td>\n<td align=\"left\">姬延</td>\n<td align=\"left\">公元前 315 年-前 256 年（60 年）</td>\n<td align=\"left\">债台高筑 降秦昭襄王</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-3-3、甲骨文和金文\"><a href=\"#2-3-3、甲骨文和金文\" class=\"headerlink\" title=\"2.3.3、甲骨文和金文\"></a>2.3.3、甲骨文和金文</h3><ol>\n<li>甲骨文</li>\n</ol>\n<p>甲骨文是一种刻写在甲骨上的古文字。从出土实物来看，绝大多数为契刻,仅少数是书写的。甲骨文的“甲”指的是龟甲，多为腹甲:“骨”指的是兽骨，以牛肩脚骨为主，还有少量的牛肋骨、鹿头骨、牛头骨、人头骨、虎骨等<br>殷墟甲骨文的出土，说明了商代历史的可靠性，成为了研究商代历史最主要的资料。金文的出现则大大拓展了周代历史的研究领域，丰富了对周代历史的认识。甲骨文和金文，是研究商周历史极其重要的第一手资料</p>\n<ol start=\"2\">\n<li>金文</li>\n</ol>\n<p>金文就是铭刻在青铜器上的文字，它与商代甲骨文之间有直接的承关系。西周金文的内容，包括战争、祭祀、外交、土地和人畜买卖等。金文主要铸造或镌刻在青铜器上。保守地估计，中国使用青铜的时间大约有1500多年，即从公元前2000年到公元前500，这段时期被称为中国历史上的“青铜时代”</p>\n<h3 id=\"2-3-4、周朝政治体制\"><a href=\"#2-3-4、周朝政治体制\" class=\"headerlink\" title=\"2.3.4、周朝政治体制\"></a>2.3.4、周朝政治体制</h3><p>周代的政治体制，与商人有某些共同之处。周王是最高的世袭统治者，他自称“天子”<br>西周王朝的直接统治限于王畿内，也就是《诗经》的“王风”部分;其王畿外的统治则是通过分封制度来实现的，即《诗经》中的十五“国风”部分</p>\n<h3 id=\"2-3-5、周代的几种制度\"><a href=\"#2-3-5、周代的几种制度\" class=\"headerlink\" title=\"2.3.5、周代的几种制度\"></a>2.3.5、周代的几种制度</h3><p>周初灭商不久，对商人后裔实行一种由周人亲戚统领管理的相对自治统治，谓之“疆以周索”，又把商人中心区域分成邶（bei）、庸、卫三部分，分别派周武王弟弟管叔、蔡叔、霍叔去监管，这就是历史上的“三监”。但是周武王去世后，三监对周公摄政不满于是与殷人后裔联合起来反叛周王朝。周公便带兵东征，经过几年的战争之后，平服了这场叛乱，杀掉了武庚和管叔，并将蔡叔和霍叔加以流放。史称“周公东征”</p>\n<p>周公东征后，周人便实行分封制度，力图通过“封建亲戚”的办法，实现“以藩屏周”的政治效果。这场大规模的分封，受封的对象主要是三类:是同姓子弟，二是异姓的功臣，三是先王后裔</p>\n<h1 id=\"3、春秋战国\"><a href=\"#3、春秋战国\" class=\"headerlink\" title=\"3、春秋战国\"></a>3、春秋战国</h1><h1 id=\"4、秦国\"><a href=\"#4、秦国\" class=\"headerlink\" title=\"4、秦国\"></a>4、秦国</h1><h2 id=\"4-1、秦朝年表\"><a href=\"#4-1、秦朝年表\" class=\"headerlink\" title=\"4.1、秦朝年表\"></a>4.1、秦朝年表</h2><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">谥号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">非子</td>\n<td align=\"left\">嬴非</td>\n<td align=\"left\">前900年-前858年（43年）</td>\n<td align=\"left\">因善于养马，得到周孝王的赏识，获封秦地，成为秦国始封君</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">秦侯</td>\n<td align=\"left\">嬴侯</td>\n<td align=\"left\">前857年-前848年（10年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">秦公伯</td>\n<td align=\"left\">嬴伯</td>\n<td align=\"left\">前847年-前845年（3年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">秦仲</td>\n<td align=\"left\">嬴仲</td>\n<td align=\"left\">前844年-前822年（23年）</td>\n<td align=\"left\">被周王任命为西我大夫，后战死</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">秦庄公</td>\n<td align=\"left\">嬴其</td>\n<td align=\"left\">前821年-前778年（44年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">秦襄公(立为诸侯)</td>\n<td align=\"left\">嬴开</td>\n<td align=\"left\">前777年-前766年（12年）</td>\n<td align=\"left\">看秋时期秦国第一任因君，辅平王东迁</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">秦文公</td>\n<td align=\"left\">嬴康</td>\n<td align=\"left\">前765年-前716年（50年）</td>\n<td align=\"left\">迁都汧渭之会（千河和渭河交界）</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">秦静公(秦竫公)</td>\n<td align=\"left\">嬴鼎</td>\n<td align=\"left\">未即位</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">秦宪公(秦宁公)</td>\n<td align=\"left\">嬴立</td>\n<td align=\"left\">前715年-前704年（12年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">秦出子</td>\n<td align=\"left\">嬴曼</td>\n<td align=\"left\">前703年-前698年（6年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">秦武公</td>\n<td align=\"left\">嬴说</td>\n<td align=\"left\">前697年-前678年（20年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">秦德公</td>\n<td align=\"left\">嬴嘉</td>\n<td align=\"left\">前677年-前676年（2年）</td>\n<td align=\"left\">迁都雍城</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">秦宣公</td>\n<td align=\"left\">嬴恬</td>\n<td align=\"left\">前675年-前664年（12年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">秦成公</td>\n<td align=\"left\">嬴载</td>\n<td align=\"left\">前663年-前660年（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">秦穆公</td>\n<td align=\"left\">嬴任好</td>\n<td align=\"left\">前659年-前621年（39年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">秦康公</td>\n<td align=\"left\">嬴罃</td>\n<td align=\"left\">前620年-前609年（12年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">秦共公</td>\n<td align=\"left\">嬴稻&#x2F;嬴貑</td>\n<td align=\"left\">前608年-前605年（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">秦桓公</td>\n<td align=\"left\">嬴荣</td>\n<td align=\"left\">前604年-前577年（28年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">秦景公</td>\n<td align=\"left\">嬴石</td>\n<td align=\"left\">前576年-前537年（40年）</td>\n<td align=\"left\">栎之战 迁延之役</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">秦哀公(秦毕公&#x2F;秦㻫公)</td>\n<td align=\"left\">嬴籍</td>\n<td align=\"left\">前536年-前501年（36年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">秦夷公</td>\n<td align=\"left\">嬴扩</td>\n<td align=\"left\">未即位</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">秦惠公</td>\n<td align=\"left\">嬴宁</td>\n<td align=\"left\">前500年-前492年（9年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">秦悼公</td>\n<td align=\"left\">嬴盘</td>\n<td align=\"left\">前491年-前477年（15年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">秦厉共公(秦剌龚公&#x2F;秦利龚公)</td>\n<td align=\"left\">嬴刺</td>\n<td align=\"left\">前476年-前443年（34年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">秦躁公(秦趮公)</td>\n<td align=\"left\">嬴欣</td>\n<td align=\"left\">前442年-前429年（14年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">秦怀公</td>\n<td align=\"left\">嬴封</td>\n<td align=\"left\">前428年-前425年（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">27</td>\n<td align=\"left\">秦灵公(秦肃灵公)</td>\n<td align=\"left\">嬴肃</td>\n<td align=\"left\">前424年-前415年（10年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">28</td>\n<td align=\"left\">秦简公</td>\n<td align=\"left\">嬴悼子</td>\n<td align=\"left\">前414年-前400年（15年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">29</td>\n<td align=\"left\">秦惠公</td>\n<td align=\"left\">嬴仁</td>\n<td align=\"left\">前399年-前387年（13年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">30</td>\n<td align=\"left\">秦出公(秦少主)</td>\n<td align=\"left\">嬴昌</td>\n<td align=\"left\">前386年-前385年（2年）</td>\n<td align=\"left\">母亲主持朝政，重用宦官外戚</td>\n</tr>\n<tr>\n<td align=\"left\">31</td>\n<td align=\"left\">秦献公&#x2F;秦元献公</td>\n<td align=\"left\">嬴师隰&#x2F;嬴连</td>\n<td align=\"left\">前384年-前362年（23年）</td>\n<td align=\"left\">废止人殉制度</td>\n</tr>\n<tr>\n<td align=\"left\">32</td>\n<td align=\"left\">秦孝公</td>\n<td align=\"left\">嬴渠梁</td>\n<td align=\"left\">前361年-前338年（24年）</td>\n<td align=\"left\">启用商鞅变法，迁都咸阳，建立县制行政</td>\n</tr>\n<tr>\n<td align=\"left\">33</td>\n<td align=\"left\">秦惠文王(秦惠王)</td>\n<td align=\"left\">嬴驷</td>\n<td align=\"left\">前337年-前311年（27年）</td>\n<td align=\"left\">改公称王，成为秦国第一王</td>\n</tr>\n<tr>\n<td align=\"left\">34</td>\n<td align=\"left\">秦武王(秦悼武王&#x2F;秦武烈王)</td>\n<td align=\"left\">嬴荡</td>\n<td align=\"left\">前310年-前307年（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">35</td>\n<td align=\"left\">秦昭襄王(秦昭王)</td>\n<td align=\"left\">嬴则&#x2F;嬴稷</td>\n<td align=\"left\">前306年-前251年（56年）</td>\n<td align=\"left\">长平破赵，灭亡东周，奠基统一</td>\n</tr>\n<tr>\n<td align=\"left\">36</td>\n<td align=\"left\">秦孝文王</td>\n<td align=\"left\">嬴柱</td>\n<td align=\"left\">前250年（3天）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">37</td>\n<td align=\"left\">秦庄襄王(秦庄王)</td>\n<td align=\"left\">嬴异人&#x2F;嬴子楚(嬴楚)</td>\n<td align=\"left\">前249年-前247年（3年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">38</td>\n<td align=\"left\">秦王政（秦始皇）</td>\n<td align=\"left\">嬴政</td>\n<td align=\"left\">前246年-前221年（25年）</td>\n<td align=\"left\">统一六国 建立皇帝制度 修筑万里长城</td>\n</tr>\n<tr>\n<td align=\"left\">39</td>\n<td align=\"left\">秦二世（胡亥）</td>\n<td align=\"left\">嬴胡亥</td>\n<td align=\"left\">前210年―前207年（3年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">40</td>\n<td align=\"left\">秦三世（子婴）</td>\n<td align=\"left\">嬴子婴</td>\n<td align=\"left\">前207年―前207年（46天）</td>\n<td align=\"left\">诛杀赵高</td>\n</tr>\n</tbody></table>\n<h1 id=\"5、汉朝\"><a href=\"#5、汉朝\" class=\"headerlink\" title=\"5、汉朝\"></a>5、汉朝</h1><p>汉朝（前202年-220年（405年））是继秦朝之后的大一统王朝，分为西汉、东汉时期</p>\n<h2 id=\"5-1-1、西汉年表\"><a href=\"#5-1-1、西汉年表\" class=\"headerlink\" title=\"5.1.1、西汉年表\"></a>5.1.1、西汉年表</h2><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">汉高祖</td>\n<td align=\"left\">刘邦</td>\n<td align=\"left\">前202-前195（8年）</td>\n<td align=\"left\">建立汉朝</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">汉惠帝</td>\n<td align=\"left\">刘盈</td>\n<td align=\"left\">前195-前188（8年）</td>\n<td align=\"left\">萧规曹随</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">前少帝</td>\n<td align=\"left\">刘恭</td>\n<td align=\"left\">前188-前184（5年）</td>\n<td align=\"left\">吕雉称制</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">后少帝</td>\n<td align=\"left\">刘弘</td>\n<td align=\"left\">前184-前180（5年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">汉文帝</td>\n<td align=\"left\">刘恒</td>\n<td align=\"left\">前180-前157（24年）</td>\n<td align=\"left\">文景之治 无为而治</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">汉景帝</td>\n<td align=\"left\">刘启</td>\n<td align=\"left\">前157-前141（17年）</td>\n<td align=\"left\">儿子中山靖王17代玄孙是刘备</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">汉武帝</td>\n<td align=\"left\">刘彻</td>\n<td align=\"left\">前141-前87（45年）</td>\n<td align=\"left\">推恩令，通西域</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">汉昭帝</td>\n<td align=\"left\">刘弗陵</td>\n<td align=\"left\">前87-前74（14年）</td>\n<td align=\"left\">昭宣中兴</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">汉废帝</td>\n<td align=\"left\">刘贺</td>\n<td align=\"left\">前74年7月-8月</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">汉宣帝</td>\n<td align=\"left\">刘询</td>\n<td align=\"left\">前74-前48（27年）</td>\n<td align=\"left\">昭宣中兴</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">汉元帝</td>\n<td align=\"left\">刘奭（shi）</td>\n<td align=\"left\">前48-前33（16年）</td>\n<td align=\"left\">平灭北匈奴</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">汉成帝</td>\n<td align=\"left\">刘骜</td>\n<td align=\"left\">前33-前7（27年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">汉哀帝</td>\n<td align=\"left\">刘欣</td>\n<td align=\"left\">前7-前1（7年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">汉平帝</td>\n<td align=\"left\">刘衎</td>\n<td align=\"left\">前1-6年（1年）</td>\n<td align=\"left\">王莽摄政（王政君侄子） <div>9岁被毒死<br></div></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">孺子婴</td>\n<td align=\"left\">刘婴</td>\n<td align=\"left\">6年-8年（未称帝）</td>\n<td align=\"left\">21岁被杀</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-1-2、东汉年表\"><a href=\"#5-1-2、东汉年表\" class=\"headerlink\" title=\"5.1.2、东汉年表\"></a>5.1.2、东汉年表</h2><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">光武帝</td>\n<td align=\"left\">刘秀</td>\n<td align=\"left\">25年-57年（33年）</td>\n<td align=\"left\">光武中兴</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">汉明帝</td>\n<td align=\"left\">刘庄</td>\n<td align=\"left\">57年-75年（19年）</td>\n<td align=\"left\">明章之治</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">汉章帝</td>\n<td align=\"left\">刘炟（da）</td>\n<td align=\"left\">75年-88年（14年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">汉殇帝</td>\n<td align=\"left\">刘隆</td>\n<td align=\"left\">106年</td>\n<td align=\"left\">邓绥称制</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">汉安帝</td>\n<td align=\"left\">刘祜</td>\n<td align=\"left\">106年-125年（20年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">少帝</td>\n<td align=\"left\">刘懿</td>\n<td align=\"left\">125年</td>\n<td align=\"left\">阎皇后称制</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">汉顺帝</td>\n<td align=\"left\">刘保</td>\n<td align=\"left\">125年-144年（20年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">汉冲帝</td>\n<td align=\"left\">刘炳</td>\n<td align=\"left\">144年-145年（2年）</td>\n<td align=\"left\">梁妠称制</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">汉质帝</td>\n<td align=\"left\">刘缵</td>\n<td align=\"left\">145年-146年（2年）</td>\n<td align=\"left\">9岁被毒死</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">汉桓帝</td>\n<td align=\"left\">刘志</td>\n<td align=\"left\">146年-168年（23年）</td>\n<td align=\"left\">夺回皇权</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">汉灵帝</td>\n<td align=\"left\">刘宏</td>\n<td align=\"left\">168年-189年（22年）</td>\n<td align=\"left\">卖官鬻爵 十常侍作乱</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">汉少帝</td>\n<td align=\"left\">刘辩</td>\n<td align=\"left\">189年</td>\n<td align=\"left\">被董卓罢黜 15（18）岁自杀</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">汉献帝</td>\n<td align=\"left\">刘协</td>\n<td align=\"left\">189年-220年（32年）</td>\n<td align=\"left\">曹操摄政</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-1-3、三国相关人物表\"><a href=\"#5-1-3、三国相关人物表\" class=\"headerlink\" title=\"5.1.3、三国相关人物表\"></a>5.1.3、三国相关人物表</h2><h3 id=\"5-1-3-1、朝廷（东汉）-群雄\"><a href=\"#5-1-3-1、朝廷（东汉）-群雄\" class=\"headerlink\" title=\"5.1.3.1、朝廷（东汉）&amp; 群雄\"></a>5.1.3.1、朝廷（东汉）&amp; 群雄</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">人物</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">刘志（汉桓帝）</td>\n<td align=\"left\">外戚专权</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">刘宏（汉灵帝）</td>\n<td align=\"left\">黄巾起义</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">窦妙（窦太后）</td>\n<td align=\"left\">刘志之母</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">董太后（永乐太后）</td>\n<td align=\"left\">刘宏之母</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">十常侍</td>\n<td align=\"left\">张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">何皇后</td>\n<td align=\"left\">刘辩之母，汉灵帝刘宏第二任皇后</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">王荣（王美人）</td>\n<td align=\"left\">刘协之母，汉灵帝刘宏妃子，被何皇后毒杀</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">何进</td>\n<td align=\"left\">何皇后哥哥，刘辩舅舅</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">刘辩（汉少帝）</td>\n<td align=\"left\">被董卓废掉，毒杀</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">刘协 （汉献帝）</td>\n<td align=\"left\">陈留王</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">刘恢</td>\n<td align=\"left\">代郡太守，刘备鞭都邮后投奔他，他保护刘备不被追查，并推荐他给刘虞</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">张角</td>\n<td align=\"left\">“天公将军”，创立太平道，提出“苍天已死，黄天当立”的口号以号召徒众，史称“黄巾军”</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">张宝</td>\n<td align=\"left\">“地公将军”，张角之弟，后来被皇甫嵩、郭典击败，被杀</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">张梁</td>\n<td align=\"left\">“人公将军”，张宝之弟，遭到遭皇甫嵩击败，被杀</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">董太后（永乐太后）</td>\n<td align=\"left\">刘宏之母</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">十常侍</td>\n<td align=\"left\">张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">卢植</td>\n<td align=\"left\">刘备老师，东汉名臣，参与平叛黄巾起义</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">袁绍</td>\n<td align=\"left\">（1）四世三公，早年任中军校尉，曾指挥诛杀宦官，建议何进引董卓 （2）争夺天下的野心与曹操产生冲突，最终在赤壁之战中被曹操击败</td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">袁术</td>\n<td align=\"left\">（1）袁绍的弟弟。（2）与袁绍、曹操等同时起兵，共讨董卓。其后因与袁绍对立，被袁绍、曹操击败，率余众奔九江，割据扬州 （3）奢侈荒淫，横征暴敛，使江淮地区残破不堪，民多饥死</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">董卓</td>\n<td align=\"left\">西凉刺史</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">李儒</td>\n<td align=\"left\">董卓谋士 毒死刘辩</td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">丁原</td>\n<td align=\"left\">字建阳，并州刺史</td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">吕布</td>\n<td align=\"left\">诛杀董卓</td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">樊稠</td>\n<td align=\"left\">（1）原为董卓部将，董卓死后，伙同李傕、郭汜、张济等人合众十余万反扑长安，败吕布、杀王允，把持朝政 。后因内斗被李傕外甥胡封在会议上刺死 （2）大败马腾、韩遂</td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">李肃</td>\n<td align=\"left\">董卓手下虎贲中郎将，主动请命以赤兔马说服吕布杀丁原来降</td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">王允</td>\n<td align=\"left\">设计诛杀董卓。后欲解散董卓的凉州兵旧部，使其人人自危，董卓部将李傕、郭汜乃合谋为乱，攻进长安，王允被杀</td>\n</tr>\n<tr>\n<td align=\"left\">27</td>\n<td align=\"left\">公孙瓒</td>\n<td align=\"left\">军阀，汉末群雄之一，卢植学生</td>\n</tr>\n<tr>\n<td align=\"left\">28</td>\n<td align=\"left\">华雄</td>\n<td align=\"left\">董卓帐下武将</td>\n</tr>\n<tr>\n<td align=\"left\">29</td>\n<td align=\"left\">颜良</td>\n<td align=\"left\">袁绍部将   白马之围</td>\n</tr>\n<tr>\n<td align=\"left\">30</td>\n<td align=\"left\">文丑</td>\n<td align=\"left\">袁绍部将</td>\n</tr>\n<tr>\n<td align=\"left\">31</td>\n<td align=\"left\">蔡邕</td>\n<td align=\"left\">东汉时期名臣，蔡文姬之父，被董卓重用，董卓死后被王允杀</td>\n</tr>\n<tr>\n<td align=\"left\">32</td>\n<td align=\"left\">陶谦</td>\n<td align=\"left\">徐州太守</td>\n</tr>\n<tr>\n<td align=\"left\">33</td>\n<td align=\"left\">刘表</td>\n<td align=\"left\">雄踞荆州，杀孙坚</td>\n</tr>\n<tr>\n<td align=\"left\">34</td>\n<td align=\"left\">曹豹</td>\n<td align=\"left\">东汉末年徐州牧陶谦部将，吕布的老丈人</td>\n</tr>\n<tr>\n<td align=\"left\">35</td>\n<td align=\"left\">张绣</td>\n<td align=\"left\">称雄宛城、在官渡之战力战有功，封邑最多</td>\n</tr>\n<tr>\n<td align=\"left\">36</td>\n<td align=\"left\">潘凤</td>\n<td align=\"left\">称雄宛城、在官渡之战力战有功，封邑最多冀州牧韩馥帐下的大将。当十八路诸侯讨伐董卓之时，他奉韩馥、袁绍之命前往汜水关前挑战董卓部下大将华雄，结果不多时就被斩</td>\n</tr>\n<tr>\n<td align=\"left\">37</td>\n<td align=\"left\">孔融</td>\n<td align=\"left\">孔子的第二十世孙 （208年）因触怒丞相曹操而被杀  孔融让梨</td>\n</tr>\n<tr>\n<td align=\"left\">38</td>\n<td align=\"left\">沮授</td>\n<td align=\"left\">东汉末年袁绍的监军 多次提出策略不被采纳</td>\n</tr>\n<tr>\n<td align=\"left\">39</td>\n<td align=\"left\">逢纪</td>\n<td align=\"left\">袁绍谋士 辅佐袁绍平定河北</td>\n</tr>\n<tr>\n<td align=\"left\">40</td>\n<td align=\"left\">田丰</td>\n<td align=\"left\">袁绍谋士 助袁绍灭公孙瓒</td>\n</tr>\n<tr>\n<td align=\"left\">41</td>\n<td align=\"left\">于吉</td>\n<td align=\"left\">琅琊人 ，东汉末年道士，后为孙策所杀，代表作有《太平经》</td>\n</tr>\n<tr>\n<td align=\"left\">42</td>\n<td align=\"left\">蔡瑁</td>\n<td align=\"left\">协助刘表平定荆州 刘表后妻蔡夫人弟弟</td>\n</tr>\n<tr>\n<td align=\"left\">43</td>\n<td align=\"left\">司马徽</td>\n<td align=\"left\">东汉末年隐士，精通奇门、经学。有“水镜先生”之称 向刘备推荐了诸葛亮、庞统等人</td>\n</tr>\n<tr>\n<td align=\"left\">44</td>\n<td align=\"left\">马腾</td>\n<td align=\"left\">东汉末年军事将领，军阀之一，马超，马铁之父</td>\n</tr>\n<tr>\n<td align=\"left\">45</td>\n<td align=\"left\">孟获</td>\n<td align=\"left\">三国时期南中地区的首领，公元225年起兵反叛蜀汉，被诸葛亮率领大军擒拿后被赦免，遂降服，此后不再叛乱，后孟获随诸葛亮回到成都，担任御史中丞</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-1-3-2、魏\"><a href=\"#5-1-3-2、魏\" class=\"headerlink\" title=\"5.1.3.2、魏\"></a>5.1.3.2、魏</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">人物</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">曹操</td>\n<td align=\"left\">（1）太尉曹嵩之子 （2）献七星宝刀</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">乐进</td>\n<td align=\"left\">斩淳于琼；斩严敬；每战先登；击退关羽；降伏蛮夷</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">李典</td>\n<td align=\"left\">曾在博望坡之战识破刘备的伪遁之计，救下了夏侯惇、于禁。又参与了逍遥津之战</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">曹仁</td>\n<td align=\"left\">破袁术、攻陶谦、擒吕布、败刘备，参加官渡之战</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">夏侯惇</td>\n<td align=\"left\">夏侯渊之族兄，汉朝开国功臣之一夏侯婴的后代</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">夏侯渊</td>\n<td align=\"left\">夏侯惇族弟, 官渡督粮、平定凉州, 被黄忠斩杀</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">曹洪</td>\n<td align=\"left\">（1）曹操从弟 （2） 早年随曹操起兵讨伐董卓。荥阳兵败，舍命献马，救驾于危难</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">贾诩</td>\n<td align=\"left\">原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">荀彧</td>\n<td align=\"left\">早年被称为“王佐之才” 为曹操规划军事战略方针，堪称其统一北方的首席谋</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">荀攸</td>\n<td align=\"left\">是荀彧的堂侄，曹操的重要谋士</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">程昱</td>\n<td align=\"left\">本名程立，因梦中在泰山捧日，更名程昱</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">郭嘉</td>\n<td align=\"left\">经荀彧推荐，任曹军祭酒</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">刘晔</td>\n<td align=\"left\">光武帝刘秀之子阜陵王刘延的后代</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">满宠</td>\n<td align=\"left\">平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">典韦</td>\n<td align=\"left\">濮阳之战击退吕布、宛城死战阻张绣</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">于禁</td>\n<td align=\"left\">讨伐黄巾余党、于张绣叛乱中坚守营垒，杀夏侯惇的青州军</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">许诸</td>\n<td align=\"left\">负责曹操的护卫工作，累迁武卫中郎将，赐号“虎侯”</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">贾诩</td>\n<td align=\"left\">曹魏开国功臣，原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操</td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">陈登</td>\n<td align=\"left\">沛相陈珪之子，向曹操献灭吕布之策</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">陈珪</td>\n<td align=\"left\">陈登、陈应之父。官至沛相。助破袁术，策应曹操</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">车胄</td>\n<td align=\"left\">曹操灭吕布占有徐州之地后，任命车胄为徐州刺史。被关羽斩杀，全家也被张飞杀害</td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">曹昂</td>\n<td align=\"left\">曹操长子。建安二年（197年）随曹操出征张绣，张绣降而复叛，曹昂为救曹操被杀</td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">张辽</td>\n<td align=\"left\">雁门马邑（今山西省朔州市）人。先后跟随丁原、何进、董卓、吕布，恪尽职守，历尽坎坷。吕布败亡后，张辽归属曹操</td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">许攸</td>\n<td align=\"left\">本为袁绍帐下谋士，官渡之战时其家人因犯法而被收捕，许攸因此背袁投曹，并为曹操设下偷袭袁绍军屯粮之所——乌巢的计策，袁绍因此而大败于官渡。后许攸随曹操平定冀州，因自恃其功而屡屡口出狂言，终因触怒曹操而被杀</td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">曹丕</td>\n<td align=\"left\">曹操长子 建立曹魏；大破羌胡，复通西域</td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">司马懿</td>\n<td align=\"left\">司马懿辅佐了魏国四代君主，见证了曹氏家族从兴盛走向衰亡，为稳定曹魏政权做出了贡献，也为其孙司马炎以晋代魏一统中国奠定了基础</td>\n</tr>\n<tr>\n<td align=\"left\">27</td>\n<td align=\"left\">满宠</td>\n<td align=\"left\">平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰</td>\n</tr>\n<tr>\n<td align=\"left\">28</td>\n<td align=\"left\">曹真</td>\n<td align=\"left\">曹操养子 大败羌胡联军 平定河西 大破吴国孙盛 击退蜀汉诸葛亮</td>\n</tr>\n<tr>\n<td align=\"left\">29</td>\n<td align=\"left\">曹睿</td>\n<td align=\"left\">曹魏第二位皇帝。魏文帝曹丕长子 与曹操、曹丕并称魏氏“三祖”</td>\n</tr>\n<tr>\n<td align=\"left\">30</td>\n<td align=\"left\">钟会</td>\n<td align=\"left\">平诸葛诞之叛、与邓艾分兵灭蜀</td>\n</tr>\n<tr>\n<td align=\"left\">31</td>\n<td align=\"left\">张郃</td>\n<td align=\"left\">江陵破吴，街亭败蜀</td>\n</tr>\n<tr>\n<td align=\"left\">32</td>\n<td align=\"left\">曹芳</td>\n<td align=\"left\">曹魏第三位皇帝，疑为魏武帝曹操曾孙</td>\n</tr>\n<tr>\n<td align=\"left\">33</td>\n<td align=\"left\">曹爽</td>\n<td align=\"left\">曹魏权臣，大司马曹真长子</td>\n</tr>\n<tr>\n<td align=\"left\">34</td>\n<td align=\"left\">司马师</td>\n<td align=\"left\">曹魏权臣，西晋王朝的奠基人之一，晋宣帝司马懿与宣穆皇后张春华的长子，晋文帝司马昭的同母兄，晋武帝司马炎的伯父</td>\n</tr>\n<tr>\n<td align=\"left\">35</td>\n<td align=\"left\">司马昭</td>\n<td align=\"left\">司马炎之父，专揽国政，攻灭蜀汉；奠定西晋基础</td>\n</tr>\n<tr>\n<td align=\"left\">36</td>\n<td align=\"left\">郭淮</td>\n<td align=\"left\">魏国名将，雁门郡太守郭缊之子 被姜维杀</td>\n</tr>\n<tr>\n<td align=\"left\">37</td>\n<td align=\"left\">曹髦</td>\n<td align=\"left\">曹丕之孙，东海王曹霖之子，曹魏第四位皇帝 不满司马昭掌权反抗被杀</td>\n</tr>\n<tr>\n<td align=\"left\">38</td>\n<td align=\"left\">邓艾</td>\n<td align=\"left\">治理魏国西方，与姜维多次对峙；率兵偷渡阴平，攻灭蜀汉</td>\n</tr>\n<tr>\n<td align=\"left\">39</td>\n<td align=\"left\">曹奂</td>\n<td align=\"left\">三国时期曹魏末代皇帝（第五位）。魏武帝曹操之孙 司马炎篡夺魏国政权，建立西晋</td>\n</tr>\n<tr>\n<td align=\"left\">40</td>\n<td align=\"left\">诸葛瞻</td>\n<td align=\"left\">诸葛亮之子 与邓艾决战，兵败被杀，绵竹失守。后主刘禅出降，蜀汉灭亡</td>\n</tr>\n<tr>\n<td align=\"left\">41</td>\n<td align=\"left\">刘禅</td>\n<td align=\"left\">小名阿斗。蜀汉末代皇帝，刘备之子，母为昭烈皇后甘氏</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-1-3-3、蜀\"><a href=\"#5-1-3-3、蜀\" class=\"headerlink\" title=\"5.1.3.3、蜀\"></a>5.1.3.3、蜀</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">人物</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">刘备</td>\n<td align=\"left\">汉景帝之子中山靖王刘胜之后</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">关羽</td>\n<td align=\"left\">山西运城人</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">张飞</td>\n<td align=\"left\">今河北保定涿州市人</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">糜竺</td>\n<td align=\"left\">麋竺原为徐州富商，后被徐州牧陶谦辟为别驾从事（官名）。陶谦病死后，奉其遗命迎接刘备</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">简雍</td>\n<td align=\"left\">刘备帐下谋士</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">诸葛亮</td>\n<td align=\"left\">蜀汉丞相，向刘备提出占据荆州、益州，联合孙权共同对抗曹操的隆中对  五次北伐</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">赵云</td>\n<td align=\"left\">（1）与关羽、张飞并称“燕南三士”   （2）先加入公孙瓒，后追随刘备</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">孙乾</td>\n<td align=\"left\">东汉末年刘备帐下幕僚</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">廖化</td>\n<td align=\"left\">攻破游奕，击杀王赟</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">周仓</td>\n<td align=\"left\">关羽身边的武将。在关羽镇守荆州对抗曹魏名将于禁与庞德的战斗中，于水中生擒庞德。最后周仓在关羽父子被斩之后自刎而死</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">廖化</td>\n<td align=\"left\">攻破游奕，击杀王赟</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">徐庶</td>\n<td align=\"left\">东汉末年刘备帐下谋士，后归曹操</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">庞统</td>\n<td align=\"left\">刘备帐下重要谋士，与诸葛亮同拜为军师中郎将   攻打益州刘璋时死于落凤坡</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">黄忠</td>\n<td align=\"left\">本为刘表部下中郎将，后归刘备，并助刘备攻破益州刘璋</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">魏延</td>\n<td align=\"left\">镇守汉中，大破费瑶和郭淮，子午谷奇谋</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">马超</td>\n<td align=\"left\">马腾长子，马铁，马休兄长  辅助刘备建立蜀汉</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">张苞</td>\n<td align=\"left\">张飞的长子。英年早逝，留有一子张遵</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">关兴</td>\n<td align=\"left\">关羽次子，关平之弟</td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">马良</td>\n<td align=\"left\">马良兄弟五人，都有才华名气，乡里为他们编有谚语说：“马家五常，白眉最良。”马良眉中有白毛，故此人们这样称呼他</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">马谡</td>\n<td align=\"left\">马良之弟，诸葛亮北伐时因作战失误失守街亭</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">姜维</td>\n<td align=\"left\">洮西大破王经，据守剑阁阻挡住钟会大军</td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">邓芝</td>\n<td align=\"left\">出使吴国，与之修好 讨平涪陵叛乱</td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">王平</td>\n<td align=\"left\">击退曹爽大举伐蜀</td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">杨仪</td>\n<td align=\"left\">辅佐诸葛亮、击杀魏延</td>\n</tr>\n<tr>\n<td align=\"left\">25</td>\n<td align=\"left\">蒋琬</td>\n<td align=\"left\">继诸葛亮执政，安定众心</td>\n</tr>\n<tr>\n<td align=\"left\">26</td>\n<td align=\"left\">李严</td>\n<td align=\"left\">与诸葛亮同为刘备临终前的托孤之臣 参与制定《蜀科》</td>\n</tr>\n<tr>\n<td align=\"left\">27</td>\n<td align=\"left\">马岱</td>\n<td align=\"left\">马超从弟，在诸葛亮病逝后受杨仪派遣斩杀了蜀将魏延</td>\n</tr>\n<tr>\n<td align=\"left\">28</td>\n<td align=\"left\">费祎</td>\n<td align=\"left\">蜀汉四相之一 休养生息，增强蜀汉国力</td>\n</tr>\n</tbody></table>\n<h3 id=\"5-1-3-4、吴\"><a href=\"#5-1-3-4、吴\" class=\"headerlink\" title=\"5.1.3.4、吴\"></a>5.1.3.4、吴</h3><table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">人物</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">孙坚</td>\n<td align=\"left\">（1）孙吴政权的奠基者 （2）洛阳城外击溃董卓</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">程普</td>\n<td align=\"left\">从孙坚讨黄巾、破董卓；救孙策，定江东；参与赤壁之战、南郡之战</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">黄盖</td>\n<td align=\"left\">在赤壁之战中诈降，献计火攻</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">孙策</td>\n<td align=\"left\">孙坚长子，字伯符</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">孙权</td>\n<td align=\"left\">孙坚次子，字仲谋</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">孙尚香</td>\n<td align=\"left\">孙权之妹，曾为刘备之妻，民间戏剧称之为孙尚香</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">周瑜</td>\n<td align=\"left\">辅平江东、开拓荆州、赤壁破曹、督灭黄祖、谏阻纳质、提出征伐益州战略</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">张昭</td>\n<td align=\"left\">辅佐孙策、孙权安定江东，与孙邵、滕胤等撰定朝仪</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">张紘</td>\n<td align=\"left\">东汉末年文学家、官员，和张昭一起合称“二张”</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">大乔</td>\n<td align=\"left\">东汉末年江东孙策的夫人，本姓“桥”，小说《三国演义》误作“乔”，因为同时还有一个妹妹嫁给周瑜，为了进行区分，姐姐习惯称作“大乔（桥）”</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">鲁肃</td>\n<td align=\"left\">孙权部将、战略家、外交家</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">甘宁</td>\n<td align=\"left\">先投靠刘表，但未被重用，后归依孙权，孙权加以重用。曾随周瑜在乌林击败曹操在南郡攻打曹仁夺取夷陵</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">陆逊</td>\n<td align=\"left\">与吕蒙共同击败关羽、夺取荆州 夷陵之战破刘备 石亭之战败曹休</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">吕蒙</td>\n<td align=\"left\">攻皖城 取三郡 濡须之战 袭荆州</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">诸葛恪</td>\n<td align=\"left\">大将军诸葛瑾长子，蜀汉丞相诸葛亮之侄 在东兴堤大胜魏军</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">丁奉</td>\n<td align=\"left\">在东兴之战中大破魏军前屯</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">孙亮</td>\n<td align=\"left\">孙吴第二位皇帝 计除权臣诸葛恪 后被孙琳废</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">孙峻</td>\n<td align=\"left\">诛杀诸葛恪，专擅朝政</td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">孙休</td>\n<td align=\"left\">孙权第六子。中国三国时期孙吴国主</td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">孙綝（chen）</td>\n<td align=\"left\">孙亮即位后由孙峻辅政。 太平元年（公元256年）孙峻去世，孙綝接替堂兄掌控朝局 被孙休、丁奉等定计诛杀</td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">陆抗</td>\n<td align=\"left\">西陵之战大破晋军；维护吴国稳定</td>\n</tr>\n</tbody></table>\n<h2 id=\"5-1-4、三国势力图\"><a href=\"#5-1-4、三国势力图\" class=\"headerlink\" title=\"5.1.4、三国势力图\"></a>5.1.4、三国势力图</h2><ol>\n<li>初期势力图</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031910885.png\" alt=\"三国势力图|725\"></p>\n<ol start=\"2\">\n<li>三足鼎立势力图</li>\n</ol>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031918859.png\" alt=\"三足鼎立|975\"></p>\n<h1 id=\"6、魏晋南北朝时期\"><a href=\"#6、魏晋南北朝时期\" class=\"headerlink\" title=\"6、魏晋南北朝时期\"></a>6、魏晋南北朝时期</h1><h2 id=\"6-1、魏晋南北朝时期概览\"><a href=\"#6-1、魏晋南北朝时期概览\" class=\"headerlink\" title=\"6.1、魏晋南北朝时期概览\"></a>6.1、魏晋南北朝时期概览</h2><p>魏晋南北朝（220—589年，370年），又称三国两晋南北朝，是中国历史上政权更迭最频繁的时期，主要分为三国（曹魏、蜀汉、东吴）、西晋、东晋和南北朝时期，由于长期的封建割据和连绵不断的战争，使这一时期中国文化的发展受到特别的影响。其突出表现则是玄学的兴起、佛教的输入、道教的勃兴。三国至隋的<strong>三百六十余年</strong>，以及三十余个大小王朝交替兴灭过程</p>\n<p><img src=\"https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308051110202.png\" alt=\"魏晋南北朝时期\"></p>\n<h1 id=\"7、隋朝\"><a href=\"#7、隋朝\" class=\"headerlink\" title=\"7、隋朝\"></a>7、隋朝</h1><h2 id=\"7-1、隋朝年表\"><a href=\"#7-1、隋朝年表\" class=\"headerlink\" title=\"7.1、隋朝年表\"></a>7.1、隋朝年表</h2><p>隋朝（581年～619年,38年）是中国历史上承南北朝，下启唐朝的大统一朝代。定都大兴（西安）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">谥号</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">相关事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">隋文帝</td>\n<td align=\"left\">杨坚</td>\n<td align=\"left\">581年-604年（24年）</td>\n<td align=\"left\">三省六部制<div>开创科举</div><div>罢黜杨勇，立杨广</div></td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">隋炀帝&#x2F;隋明帝</td>\n<td align=\"left\">杨广</td>\n<td align=\"left\">604年-618年（15年）</td>\n<td align=\"left\">迁都洛阳 <div>穷奢极欲</div><div>隋朝大运河</div><div>江都兵变</div></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">隋恭帝</td>\n<td align=\"left\">杨侑</td>\n<td align=\"left\">617年-618年（177天）</td>\n<td align=\"left\">被李渊拥立为帝，后被幽禁</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">隋秦王</td>\n<td align=\"left\">杨浩</td>\n<td align=\"left\">618年（半年）</td>\n<td align=\"left\">被宇文化及拥立为帝，后被毒杀</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">皇泰主</td>\n<td align=\"left\">杨侗（dong）</td>\n<td align=\"left\">618年-619年（1年）</td>\n<td align=\"left\">被王世充拥立为帝，后被杀害</td>\n</tr>\n</tbody></table>\n<h1 id=\"8、唐朝\"><a href=\"#8、唐朝\" class=\"headerlink\" title=\"8、唐朝\"></a>8、唐朝</h1><h2 id=\"8-1、唐朝年表\"><a href=\"#8-1、唐朝年表\" class=\"headerlink\" title=\"8.1、唐朝年表\"></a>8.1、唐朝年表</h2><p>唐王李渊于618年逼隋恭帝禅位,推翻隋朝,改国号为“唐”(尊称“大唐”),建立了唐朝（618年－907年，289年）</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">唐高祖</td>\n<td align=\"left\">李渊</td>\n<td align=\"left\">618-626（9年）</td>\n<td align=\"left\">晋阳起兵，建立唐朝</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">唐太宗</td>\n<td align=\"left\">李世民</td>\n<td align=\"left\">627-649（23年）</td>\n<td align=\"left\">玄武门之变，贞观之治</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">唐高宗</td>\n<td align=\"left\">李治</td>\n<td align=\"left\">650-683（24年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">唐中宗</td>\n<td align=\"left\">李显</td>\n<td align=\"left\">684</td>\n<td align=\"left\">被废</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">唐睿宗</td>\n<td align=\"left\">李旦</td>\n<td align=\"left\">684-690（6年）</td>\n<td align=\"left\">被废</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">武则天</td>\n<td align=\"left\">武曌（zhao）</td>\n<td align=\"left\">690-705（16年）</td>\n<td align=\"left\">武周开国君主（不属于唐）</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">唐中宗</td>\n<td align=\"left\">李显</td>\n<td align=\"left\">705-710（5年）</td>\n<td align=\"left\">神龙政变 被韦皇后毒死</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">唐少帝</td>\n<td align=\"left\">李重茂</td>\n<td align=\"left\">710</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">唐睿宗</td>\n<td align=\"left\">李旦</td>\n<td align=\"left\">710-712（2年）</td>\n<td align=\"left\">二次让位</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">唐玄宗</td>\n<td align=\"left\">李隆基</td>\n<td align=\"left\">712-756（44年）</td>\n<td align=\"left\">唐隆政变 唐明皇 安史之乱 开元之治</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">唐肃宗</td>\n<td align=\"left\">李亨</td>\n<td align=\"left\">756-762（5年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">唐代宗</td>\n<td align=\"left\">李豫</td>\n<td align=\"left\">762-779（17年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">唐德宗</td>\n<td align=\"left\">李适</td>\n<td align=\"left\">779-805（26年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">唐顺宗</td>\n<td align=\"left\">李诵</td>\n<td align=\"left\">805（8月）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">唐宪宗</td>\n<td align=\"left\">李纯</td>\n<td align=\"left\">806-820（15年）</td>\n<td align=\"left\">元和中兴</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">唐穆宗</td>\n<td align=\"left\">李恒</td>\n<td align=\"left\">821-824（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">唐敬宗</td>\n<td align=\"left\">李湛</td>\n<td align=\"left\">824-826（2年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">唐文宗</td>\n<td align=\"left\">李昂</td>\n<td align=\"left\">826-840（14年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">19</td>\n<td align=\"left\">唐武宗</td>\n<td align=\"left\">李炎</td>\n<td align=\"left\">840-846（6年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">20</td>\n<td align=\"left\">唐宣宗</td>\n<td align=\"left\">李忱（chen）</td>\n<td align=\"left\">846-859（13年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">21</td>\n<td align=\"left\">唐懿宗</td>\n<td align=\"left\">李漼（cui）</td>\n<td align=\"left\">859-873（14年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">唐僖宗</td>\n<td align=\"left\">李儇（xuan）</td>\n<td align=\"left\">873-888（15年）</td>\n<td align=\"left\">黄巢起义</td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">唐昭宗</td>\n<td align=\"left\">李晔</td>\n<td align=\"left\">888-904（16年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">24</td>\n<td align=\"left\">唐哀帝</td>\n<td align=\"left\">李柷（chu）</td>\n<td align=\"left\">904-907（3年）</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"9、五代十国\"><a href=\"#9、五代十国\" class=\"headerlink\" title=\"9、五代十国\"></a>9、五代十国</h1><h1 id=\"10、宋朝\"><a href=\"#10、宋朝\" class=\"headerlink\" title=\"10、宋朝\"></a>10、宋朝</h1><h2 id=\"10-1、宋朝年表\"><a href=\"#10-1、宋朝年表\" class=\"headerlink\" title=\"10.1、宋朝年表\"></a>10.1、宋朝年表</h2><p>宋朝（960年－1279年，319年）是中国历史上承五代十国下启元朝的中原王朝，分北宋和南宋两个阶段，共历十八帝</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">宋太祖</td>\n<td align=\"left\">赵匡胤</td>\n<td align=\"left\">960-976（16年）</td>\n<td align=\"left\">改革官帽 两次杯酒释兵权</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">宋太宗</td>\n<td align=\"left\">赵炅</td>\n<td align=\"left\">976-997（21年）</td>\n<td align=\"left\">赵匡胤之弟 雪中送炭</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">宋真宗</td>\n<td align=\"left\">赵恒</td>\n<td align=\"left\">997-1022（15年）</td>\n<td align=\"left\">赵炅三子，澶渊之盟</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">宋仁宗</td>\n<td align=\"left\">赵祯</td>\n<td align=\"left\">1022-1063（41年）</td>\n<td align=\"left\">赵恒六子， 发行交子 狸猫换太子</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">宋英宗</td>\n<td align=\"left\">赵曙</td>\n<td align=\"left\">1063-1067（4年）</td>\n<td align=\"left\">赵祯堂兄赵允让第十三子     《资治通鉴》</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">宋神宗</td>\n<td align=\"left\">赵顼</td>\n<td align=\"left\">1067-1085（18年）</td>\n<td align=\"left\">赵曙长子，重用王安石变法</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">宋哲宗</td>\n<td align=\"left\">赵煦</td>\n<td align=\"left\">1085-1100（15年）</td>\n<td align=\"left\">赵顼六子</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">宋徽宗</td>\n<td align=\"left\">赵佶</td>\n<td align=\"left\">1100-1126（26年）</td>\n<td align=\"left\">赵顼十一子，书法绘画大师（瘦金体）  宋江起义 方腊起义    靖康之变</td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">宋钦宗</td>\n<td align=\"left\">赵桓</td>\n<td align=\"left\">1126-1127（1年）</td>\n<td align=\"left\">赵佶长子，赵构异母兄弟 。1127年发生”靖康之变” 金朝南下攻取北宋首都东京，掳走徽、钦二帝，导致北宋灭亡的历史事件</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">宋高宗</td>\n<td align=\"left\">赵构</td>\n<td align=\"left\">1127-1162（35年）</td>\n<td align=\"left\">赵佶九子，南宋开国皇帝 ，重用秦桧</td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">宋孝宗</td>\n<td align=\"left\">赵昚（shen）</td>\n<td align=\"left\">1162-1189（27年）</td>\n<td align=\"left\">赵构养子 平反岳飞 隆兴和议 被认为南宋最有作为的皇帝</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">宋光宗</td>\n<td align=\"left\">赵惇</td>\n<td align=\"left\">1189-1194（5年）</td>\n<td align=\"left\">绍熙内禅</td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">宋宁宗</td>\n<td align=\"left\">赵扩</td>\n<td align=\"left\">1194 -1224（30年）</td>\n<td align=\"left\">赵惇次子</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">宋理宗</td>\n<td align=\"left\">赵昀（yun）</td>\n<td align=\"left\">1224-1264（40年）</td>\n<td align=\"left\">赵扩远方堂侄 ，联蒙灭金</td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">宋度宗</td>\n<td align=\"left\">赵禥（qi）</td>\n<td align=\"left\">1264-1274（10年）</td>\n<td align=\"left\">赵昀之侄，智力低于常人</td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">宋恭宗</td>\n<td align=\"left\">赵㬎（xian）</td>\n<td align=\"left\">1274-1276（2年）</td>\n<td align=\"left\">赵禥次子 ，退位降元</td>\n</tr>\n<tr>\n<td align=\"left\">17</td>\n<td align=\"left\">宋端宗</td>\n<td align=\"left\">赵昰（shi）</td>\n<td align=\"left\">1276-1278（2年）</td>\n<td align=\"left\">赵禥庶长子，九岁去世</td>\n</tr>\n<tr>\n<td align=\"left\">18</td>\n<td align=\"left\">宋卫王</td>\n<td align=\"left\">赵昺（昺）</td>\n<td align=\"left\">1278-1279（1年）</td>\n<td align=\"left\">赵禥三子，崖山海战，投海殉国</td>\n</tr>\n</tbody></table>\n<h1 id=\"11、元朝\"><a href=\"#11、元朝\" class=\"headerlink\" title=\"11、元朝\"></a>11、元朝</h1><h2 id=\"11-1、元朝年表\"><a href=\"#11-1、元朝年表\" class=\"headerlink\" title=\"11.1、元朝年表\"></a>11.1、元朝年表</h2><p>元朝（1271年—1368年，98年），是中国历史上的朝代。铁木真于1206年建国；1271年忽必烈定国号为元，1279年灭南宋。 是首次由少数民族建立的大一统王朝，传五世十一帝</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>姓名</th>\n<th>庙号</th>\n<th>统治时间</th>\n<th>事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>孛儿只斤·铁木真</td>\n<td>元太祖</td>\n<td>1206-1227年（21年）</td>\n<td>大蒙古可汗，建立大蒙古国</td>\n</tr>\n<tr>\n<td>2</td>\n<td>孛儿只斤·窝阔台</td>\n<td>元太宗</td>\n<td>1229-1241年（12年）</td>\n<td>蒙古帝国大汗，奠定元朝基础</td>\n</tr>\n<tr>\n<td>3</td>\n<td>孛儿只斤·贵由</td>\n<td>元定宗</td>\n<td>1246-1248年（2年）</td>\n<td>蒙古帝国第三任大汗，西征欧洲</td>\n</tr>\n<tr>\n<td>4</td>\n<td>孛儿只斤·蒙哥</td>\n<td>元宪宗</td>\n<td>1251-1259年（8年）</td>\n<td>大蒙古国可汗，招降吐蕃</td>\n</tr>\n<tr>\n<td>1</td>\n<td>孛儿只斤·忽必烈</td>\n<td>元世祖</td>\n<td>1260-1294年 （34年）</td>\n<td>元朝开国皇帝，首创行省制度</td>\n</tr>\n<tr>\n<td>2</td>\n<td>孛儿只斤·铁穆耳</td>\n<td>元成宗</td>\n<td>1294-1307年（13年）</td>\n<td>击败西北叛王</td>\n</tr>\n<tr>\n<td>3</td>\n<td>孛儿只斤·海山</td>\n<td>元武宗</td>\n<td>1307-1311年（4年）</td>\n<td>设尚书省</td>\n</tr>\n<tr>\n<td>4</td>\n<td>孛儿只斤·爱育黎拔力八达</td>\n<td>元仁宗</td>\n<td>1311-1320年（9年）</td>\n<td>实行科举制度</td>\n</tr>\n<tr>\n<td>5</td>\n<td>孛儿只斤·硕德八剌</td>\n<td>元英宗</td>\n<td>1320-1323年（3年）</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>孛儿只斤·也孙铁木儿</td>\n<td>-</td>\n<td>1323-1328年（5年）</td>\n<td>史称泰定帝</td>\n</tr>\n<tr>\n<td>7</td>\n<td>孛儿只斤·阿速吉八</td>\n<td>-</td>\n<td>1328年（27天）</td>\n<td>史称天顺帝</td>\n</tr>\n<tr>\n<td>8</td>\n<td>孛儿只斤·图帖睦尔</td>\n<td>元文宗</td>\n<td>1329-1332年（3年）</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>孛儿只斤·和世㻋</td>\n<td>元明宗</td>\n<td>1329年（184天）</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>孛儿只斤·懿璘质班</td>\n<td>元宁宗</td>\n<td>1332年（52天）</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>孛儿只斤·懽帖睦尔</td>\n<td>元惠宗</td>\n<td>1333-1370年（37年）</td>\n<td>实施“至正新政”改革</td>\n</tr>\n</tbody></table>\n<h1 id=\"12、明朝\"><a href=\"#12、明朝\" class=\"headerlink\" title=\"12、明朝\"></a>12、明朝</h1><h2 id=\"12-1、明朝年表\"><a href=\"#12-1、明朝年表\" class=\"headerlink\" title=\"12.1、明朝年表\"></a>12.1、明朝年表</h2><p>明朝（1368年―1644年，276年）明太祖朱元璋所建。初期建都南京，明成祖时期迁都北京。传十六帝</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">序号</th>\n<th align=\"left\">别名</th>\n<th align=\"left\">姓名</th>\n<th align=\"left\">年号</th>\n<th align=\"left\">在位时间</th>\n<th align=\"left\">主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">明太祖</td>\n<td align=\"left\">朱元璋</td>\n<td align=\"left\">洪武</td>\n<td align=\"left\">1368-1398（20年）</td>\n<td align=\"left\">洪武之治</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">明惠宗</td>\n<td align=\"left\">朱允炆</td>\n<td align=\"left\">建文</td>\n<td align=\"left\">1398-1402（4年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">明成祖</td>\n<td align=\"left\">朱棣</td>\n<td align=\"left\">永乐</td>\n<td align=\"left\">1402-1424（22年）</td>\n<td align=\"left\">永乐盛世</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">明仁宗</td>\n<td align=\"left\">朱高炽</td>\n<td align=\"left\">洪熙</td>\n<td align=\"left\">1424-1425（1年）</td>\n<td align=\"left\">仁宣之治</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">明宣宗</td>\n<td align=\"left\">朱瞻基</td>\n<td align=\"left\">宣德</td>\n<td align=\"left\">1425-1435（10年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">明英宗</td>\n<td align=\"left\">朱祁镇</td>\n<td align=\"left\">正统 天顺</td>\n<td align=\"left\">1435-1449 1457-1464</td>\n<td align=\"left\">夺门之变</td>\n</tr>\n<tr>\n<td align=\"left\">7</td>\n<td align=\"left\">明代宗</td>\n<td align=\"left\">朱祁钰</td>\n<td align=\"left\">景泰</td>\n<td align=\"left\">1449-1457（8年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">明宪宗</td>\n<td align=\"left\">朱见深</td>\n<td align=\"left\">成化</td>\n<td align=\"left\">1464-1487（23年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">9</td>\n<td align=\"left\">明孝宗</td>\n<td align=\"left\">朱祐樘</td>\n<td align=\"left\">弘治</td>\n<td align=\"left\">1487-1505（18年）</td>\n<td align=\"left\">弘治中兴</td>\n</tr>\n<tr>\n<td align=\"left\">10</td>\n<td align=\"left\">明武宗</td>\n<td align=\"left\">朱厚照</td>\n<td align=\"left\">正德</td>\n<td align=\"left\">1505-1521（16年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">11</td>\n<td align=\"left\">明世宗</td>\n<td align=\"left\">朱厚熜</td>\n<td align=\"left\">嘉靖</td>\n<td align=\"left\">1521-1566（45年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">明穆宗</td>\n<td align=\"left\">朱载坖</td>\n<td align=\"left\">隆庆</td>\n<td align=\"left\">1566-1572（6年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">13</td>\n<td align=\"left\">明神宗</td>\n<td align=\"left\">朱翊（yi）钧</td>\n<td align=\"left\">万历</td>\n<td align=\"left\">1572-1620（48年）</td>\n<td align=\"left\">万历中兴</td>\n</tr>\n<tr>\n<td align=\"left\">14</td>\n<td align=\"left\">明光宗</td>\n<td align=\"left\">朱常洛</td>\n<td align=\"left\">泰昌</td>\n<td align=\"left\">1620</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">15</td>\n<td align=\"left\">明熹宗</td>\n<td align=\"left\">朱由校</td>\n<td align=\"left\">天启</td>\n<td align=\"left\">1620-1627（7年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">16</td>\n<td align=\"left\">明思宗</td>\n<td align=\"left\">朱由检</td>\n<td align=\"left\">崇祯</td>\n<td align=\"left\">1627-1644（17年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">南明时期（1644-1662，18年）</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">明安宗</td>\n<td align=\"left\">朱由崧</td>\n<td align=\"left\">弘光</td>\n<td align=\"left\">1644-1645（1年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">明绍宗</td>\n<td align=\"left\">朱聿键</td>\n<td align=\"left\">隆武</td>\n<td align=\"left\">1645-1646（1年）</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\"></td>\n<td align=\"left\">朱聿鐭</td>\n<td align=\"left\">绍武</td>\n<td align=\"left\">1646年的1个月</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">明昭宗</td>\n<td align=\"left\">朱聿键</td>\n<td align=\"left\">永历</td>\n<td align=\"left\">1646-1662（16年）</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<h1 id=\"13、清朝\"><a href=\"#13、清朝\" class=\"headerlink\" title=\"13、清朝\"></a>13、清朝</h1><h2 id=\"13-1、清朝年表\"><a href=\"#13-1、清朝年表\" class=\"headerlink\" title=\"13.1、清朝年表\"></a>13.1、清朝年表</h2><p>清朝（1616年—1912年，296年），是中国历史上最后一个封建王朝，共传十二帝，初称后金。从努尔哈赤建国起，总计296年。从皇太极改国号为清起，国祚276年</p>\n<table>\n<thead>\n<tr>\n<th>序号</th>\n<th>姓名</th>\n<th>年号</th>\n<th>在位时间</th>\n<th>主要事件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>努尔哈赤</td>\n<td>天命</td>\n<td>1616-1626（10年）</td>\n<td>统一女真 建立后金 反抗明朝 萨尔浒之战</td>\n</tr>\n<tr>\n<td>2</td>\n<td>皇太极</td>\n<td>天聪 崇德</td>\n<td>1626-1643（17年）</td>\n<td>征服朝鲜和蒙古 松锦大捷 改国号大清和族名满洲</td>\n</tr>\n<tr>\n<td>3</td>\n<td>福临</td>\n<td>顺治</td>\n<td>1643-1661（18年）</td>\n<td>李自成攻入北京 崇祯自缢而死 吴三桂引清军入关 大清迁都北京</td>\n</tr>\n<tr>\n<td>4</td>\n<td>玄烨</td>\n<td>康熙</td>\n<td>1661-1722（61年）</td>\n<td>囚禁鳌拜 削三番 收复台湾 签订《尼布楚条约》</td>\n</tr>\n<tr>\n<td>5</td>\n<td>胤禛</td>\n<td>雍正</td>\n<td>1722-1735（13年）</td>\n<td>设军机处</td>\n</tr>\n<tr>\n<td>6</td>\n<td>弘历</td>\n<td>乾隆</td>\n<td>1736-1796（60年）</td>\n<td>编纂《四库全书》 大兴文字狱 实行闭关锁国</td>\n</tr>\n<tr>\n<td>7</td>\n<td>永琰</td>\n<td>嘉庆</td>\n<td>1796-1820（24年）</td>\n<td>诛杀和珅 白莲教天理教起义</td>\n</tr>\n<tr>\n<td>8</td>\n<td>旻宁</td>\n<td>道光</td>\n<td>1820-1850（30年）</td>\n<td>虎门销烟 第一次鸦片战争 《南京条约》，割香港给英国</td>\n</tr>\n<tr>\n<td>9</td>\n<td>奕訢</td>\n<td>咸丰</td>\n<td>1850-1861（11年）</td>\n<td>太平天国起义 第二次鸦片战争 圆明园被毁  《天津条约》《北京条约》  洋务运动</td>\n</tr>\n<tr>\n<td>10</td>\n<td>载淳</td>\n<td>同治</td>\n<td>1861-1874（13年）</td>\n<td>辛酉政变 慈溪垂帘听政 镇压太平天国 同治中兴</td>\n</tr>\n<tr>\n<td>11</td>\n<td>载湉</td>\n<td>光绪</td>\n<td>1874-1908（34年）</td>\n<td>中法战争 中日甲午战争 戊戌变法 义和团 八国联军   《马关条约》《辛丑条约》 慈溪仍掌政</td>\n</tr>\n<tr>\n<td>12</td>\n<td>溥仪</td>\n<td>宣统</td>\n<td>1908-1911（3年）</td>\n<td>辛亥革命</td>\n</tr>\n</tbody></table>\n"},{"title":"认知","date":"2023-08-21T16:00:00.000Z","updated":"2023-09-02T16:00:00.000Z","abbrlink":31940,"_content":"\n\n# 1、硅基生命和碳基生命\n碳基生命：碳基生命是我们所熟知的地球上的生命形式，包括所有的生物，从微生物到植物和动物。碳是碳基生命的主要构建块，因为碳具有独特的化学性质，能够形成稳定的共价化学键。碳可以与其他元素，如氢、氧、氮和磷等，形成复杂的有机化合物，包括蛋白质、核酸、脂质等生物分子。碳基生命依赖于水作为生命体内的溶剂，并且其生物过程是基于碳的有机化学反应进行的。\n\n硅基生命：硅基生命是一种假设存在于宇宙中的生命形式，其基本结构和生物分子基于硅元素而非碳。硅与碳具有相似的化学性质，也能够形成稳定的共价键。因此，一些科学家认为在特定的条件下，硅也可能成为构建生命体的基本元素。硅基生命假设硅代替碳构建生命体的核酸、蛋白质和其他生物分子，使用其他溶剂代替水。硅基生命的研究仍然处于理论和推测阶段，尚未发现确凿的证据\n\n# 2、西西弗斯的惩罚\n\n希腊神话中，西西弗斯是科林斯的国王。作为统治者，他常常苦恼自己的王国没有充足的饮用水。\n\n有一天，事情迎来了转机。西西弗斯无意之中，看到了众神之王宙斯化作鹰的模样绑架河神的女儿伊琴娜的一幕。\n\n河神得知女儿失踪，感到悲伤不已。于是，西西弗斯便向河神提出一个交易：如果河神为他的王国创造一个四季常流的河川，他就告诉河神伊琴娜的行踪。河神答应了西西弗斯的请求。\n\n这一举动触怒了宙斯，他命令死神将西西弗斯打入阴森的地狱。然而西西弗斯是足智多谋的，他早预言死神会来到他身边。西西弗斯请求死神展示一下如何使用锁链，然后趁机捆住死神！这下子西西弗斯逃离了死神的魔爪，一如既往地过着舒适快乐的生活。\n\n一段时间过后，因为死神的消失，世间上再也没有人死去。直到冥王再也忍受不了地狱的荒凉寂寞，决定下命令让战神去解救死神。\n\n最终西西弗斯还是进了地狱，不过他早已在死前就想好了计谋。在冥王面前，他假惺惺地诉苦道：自己的妻子是个冷漠无情的人，现在尸体还像狗一样被扔到公共广场上，更何况举办盛大的葬礼呢。他请求冥王让他回到人间，了却这一桩心愿。于是冥王允许他处理完自己的葬礼之后回到地狱。西西弗斯窃喜不已，他如愿回到人间后，便违背了与冥王的约定。\n\n众神一怒之下，决定对西西弗斯实施最严厉的惩罚：要求他将一块巨石从平地推到山顶。但由于诅咒的力量，每当巨石抵达山顶的瞬间，就会变得异常沉重，一次又一次滚回起点。西西弗斯便在永无止境当中，不断循环往复推着巨石抵达山顶。\n\n\n\n# 3、日本偷袭珍珠港的原因\n\n1941年7月，希特勒的军队正在俄国平原上狂飙猛进，伦敦和华盛顿对此忧心忡忡。因为，一旦苏联崩溃，所有的压力将重新回到英伦三岛的头上。英国能否顶得住德军的全力一击，实属悲观；而英国的失败，将直接导致美国失去他在欧洲的唯一立脚点，美国将会永远失去介入战争的机会。日本陆军正在中国东北大量集结，对苏的进攻似乎箭在弦上。\n这让伦敦和华盛顿如芒在背，一旦日本配合德国进攻苏联，苏联的困境会呈几何级数地增加，苏联崩溃几乎就是眼前的事了。\n\n然而，没有国会的授权，没有舆论的支持，对日宣战是不可能的。这种情况下，此前一直在讨论并屡屡被搁置的对日石油禁运，这个时候就有了现实的意义，这也是总统职权范围内的事情，无须国会批准。日本90%石油靠美国，美国对日本采取石油禁运制裁之后，日本国内石油储备只剩下800万吨、仅够使用两年，如果不去东南亚抢夺石油，两年之后日本的军舰飞机就发动不了，但侵略东南亚会严重损害英美利益，日本军部权衡再三还是决定赌上国运、同时对英美开战，山本五十六反对开战无效，只能硬着头皮干下去，于是山本策划了偷袭珍珠港方案，力图开战之初就重创美国太平洋舰队，使其无法投入到东南亚战场，山本的计划成功了，日本得以在半年之内征服东南亚，获得了大量石油资源。\n\n# 4、西方的傲慢与偏见\n\n看外网的新闻总是宣称中国人被“洗脑”了。在他们看来，我们的形象可能类似朝鲜，做作和浮夸的表演。事实上，我们知道发生了什么，所以我们会抨击社会的问题，抨击腐败，抨击资本家的压榨。正因为我们不想再被“洗脑”，所以我们更加好奇，更愿意去探索这个世界。\n\n在我看来，任何媒体都是宣传工具，无论国内国外。幸运的是，大多数中国年轻人都知道这一点。不幸的是，一些西方人仍然相信他们所看到的就是全部真相\n\n# 5、中国六大茶类\n\n1. 绿茶，属于不发酵茶，茶性偏寒，主要代表茶有西湖龙井、太平猴魁、六安瓜片、碧螺春等。\n2. 红茶，属于全发酵茶，茶性偏温和，主要代表茶类有有门红茶、云南滇红、正山小种和金骏眉等。\n3. 白茶，属于微发酵茶，茶性偏温和，按照采摘标准和树种的不同，分为白牡丹、白毫银针、贡眉和寿眉等。\n4. 黑茶，属于后发酵茶，茶性温和，主要代表茶类有广西六堡茶、安化黑茶、普洱熟茶、茯茯茶等。\n5. 黄茶，属于轻发酵茶，性凉微寒，主要代表茶类有蒙顶黄芽、霍山黄芽、君山银针等。\n6. 青茶，属于半发酵茶，青茶是一种中性茶，适合大多数人饮用，主要代表茶类有大红袍、肉桂、铁观音、凤凰丹丛、水仙等\n\n> 六种茶的功效也各有不同:\n\t绿茶的主要功效能够降血脂减肥。\n\t白茶的功效是能够保护肝脏，而且还能够消炎、降火。\n\t黄茶的功效是有一定的杀毒作用，是可以帮助身体消化的，能够促进脂肪的代谢。\n\t青茶它具有降血脂抗衰老的作用，空腹、睡前和冷茶不宜饮。\n\t红茶的功效就是可以达到暖胃的效果，可以帮助身体消除疲劳。\n\t黑茶它可以降血脂，防止一些糖尿病的出现。","source":"_posts/认知.md","raw":"---\ntitle: 认知\ndate: 2023/08/22\nupdated: 2023/09/03\ncategories:\n  - 生活\ntags:\n  - 常识\n  - 思考\nabbrlink: 31940\n---\n\n\n# 1、硅基生命和碳基生命\n碳基生命：碳基生命是我们所熟知的地球上的生命形式，包括所有的生物，从微生物到植物和动物。碳是碳基生命的主要构建块，因为碳具有独特的化学性质，能够形成稳定的共价化学键。碳可以与其他元素，如氢、氧、氮和磷等，形成复杂的有机化合物，包括蛋白质、核酸、脂质等生物分子。碳基生命依赖于水作为生命体内的溶剂，并且其生物过程是基于碳的有机化学反应进行的。\n\n硅基生命：硅基生命是一种假设存在于宇宙中的生命形式，其基本结构和生物分子基于硅元素而非碳。硅与碳具有相似的化学性质，也能够形成稳定的共价键。因此，一些科学家认为在特定的条件下，硅也可能成为构建生命体的基本元素。硅基生命假设硅代替碳构建生命体的核酸、蛋白质和其他生物分子，使用其他溶剂代替水。硅基生命的研究仍然处于理论和推测阶段，尚未发现确凿的证据\n\n# 2、西西弗斯的惩罚\n\n希腊神话中，西西弗斯是科林斯的国王。作为统治者，他常常苦恼自己的王国没有充足的饮用水。\n\n有一天，事情迎来了转机。西西弗斯无意之中，看到了众神之王宙斯化作鹰的模样绑架河神的女儿伊琴娜的一幕。\n\n河神得知女儿失踪，感到悲伤不已。于是，西西弗斯便向河神提出一个交易：如果河神为他的王国创造一个四季常流的河川，他就告诉河神伊琴娜的行踪。河神答应了西西弗斯的请求。\n\n这一举动触怒了宙斯，他命令死神将西西弗斯打入阴森的地狱。然而西西弗斯是足智多谋的，他早预言死神会来到他身边。西西弗斯请求死神展示一下如何使用锁链，然后趁机捆住死神！这下子西西弗斯逃离了死神的魔爪，一如既往地过着舒适快乐的生活。\n\n一段时间过后，因为死神的消失，世间上再也没有人死去。直到冥王再也忍受不了地狱的荒凉寂寞，决定下命令让战神去解救死神。\n\n最终西西弗斯还是进了地狱，不过他早已在死前就想好了计谋。在冥王面前，他假惺惺地诉苦道：自己的妻子是个冷漠无情的人，现在尸体还像狗一样被扔到公共广场上，更何况举办盛大的葬礼呢。他请求冥王让他回到人间，了却这一桩心愿。于是冥王允许他处理完自己的葬礼之后回到地狱。西西弗斯窃喜不已，他如愿回到人间后，便违背了与冥王的约定。\n\n众神一怒之下，决定对西西弗斯实施最严厉的惩罚：要求他将一块巨石从平地推到山顶。但由于诅咒的力量，每当巨石抵达山顶的瞬间，就会变得异常沉重，一次又一次滚回起点。西西弗斯便在永无止境当中，不断循环往复推着巨石抵达山顶。\n\n\n\n# 3、日本偷袭珍珠港的原因\n\n1941年7月，希特勒的军队正在俄国平原上狂飙猛进，伦敦和华盛顿对此忧心忡忡。因为，一旦苏联崩溃，所有的压力将重新回到英伦三岛的头上。英国能否顶得住德军的全力一击，实属悲观；而英国的失败，将直接导致美国失去他在欧洲的唯一立脚点，美国将会永远失去介入战争的机会。日本陆军正在中国东北大量集结，对苏的进攻似乎箭在弦上。\n这让伦敦和华盛顿如芒在背，一旦日本配合德国进攻苏联，苏联的困境会呈几何级数地增加，苏联崩溃几乎就是眼前的事了。\n\n然而，没有国会的授权，没有舆论的支持，对日宣战是不可能的。这种情况下，此前一直在讨论并屡屡被搁置的对日石油禁运，这个时候就有了现实的意义，这也是总统职权范围内的事情，无须国会批准。日本90%石油靠美国，美国对日本采取石油禁运制裁之后，日本国内石油储备只剩下800万吨、仅够使用两年，如果不去东南亚抢夺石油，两年之后日本的军舰飞机就发动不了，但侵略东南亚会严重损害英美利益，日本军部权衡再三还是决定赌上国运、同时对英美开战，山本五十六反对开战无效，只能硬着头皮干下去，于是山本策划了偷袭珍珠港方案，力图开战之初就重创美国太平洋舰队，使其无法投入到东南亚战场，山本的计划成功了，日本得以在半年之内征服东南亚，获得了大量石油资源。\n\n# 4、西方的傲慢与偏见\n\n看外网的新闻总是宣称中国人被“洗脑”了。在他们看来，我们的形象可能类似朝鲜，做作和浮夸的表演。事实上，我们知道发生了什么，所以我们会抨击社会的问题，抨击腐败，抨击资本家的压榨。正因为我们不想再被“洗脑”，所以我们更加好奇，更愿意去探索这个世界。\n\n在我看来，任何媒体都是宣传工具，无论国内国外。幸运的是，大多数中国年轻人都知道这一点。不幸的是，一些西方人仍然相信他们所看到的就是全部真相\n\n# 5、中国六大茶类\n\n1. 绿茶，属于不发酵茶，茶性偏寒，主要代表茶有西湖龙井、太平猴魁、六安瓜片、碧螺春等。\n2. 红茶，属于全发酵茶，茶性偏温和，主要代表茶类有有门红茶、云南滇红、正山小种和金骏眉等。\n3. 白茶，属于微发酵茶，茶性偏温和，按照采摘标准和树种的不同，分为白牡丹、白毫银针、贡眉和寿眉等。\n4. 黑茶，属于后发酵茶，茶性温和，主要代表茶类有广西六堡茶、安化黑茶、普洱熟茶、茯茯茶等。\n5. 黄茶，属于轻发酵茶，性凉微寒，主要代表茶类有蒙顶黄芽、霍山黄芽、君山银针等。\n6. 青茶，属于半发酵茶，青茶是一种中性茶，适合大多数人饮用，主要代表茶类有大红袍、肉桂、铁观音、凤凰丹丛、水仙等\n\n> 六种茶的功效也各有不同:\n\t绿茶的主要功效能够降血脂减肥。\n\t白茶的功效是能够保护肝脏，而且还能够消炎、降火。\n\t黄茶的功效是有一定的杀毒作用，是可以帮助身体消化的，能够促进脂肪的代谢。\n\t青茶它具有降血脂抗衰老的作用，空腹、睡前和冷茶不宜饮。\n\t红茶的功效就是可以达到暖胃的效果，可以帮助身体消除疲劳。\n\t黑茶它可以降血脂，防止一些糖尿病的出现。","slug":"认知","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cloe5sra8002z00uj8sns371p","content":"<h1 id=\"1、硅基生命和碳基生命\"><a href=\"#1、硅基生命和碳基生命\" class=\"headerlink\" title=\"1、硅基生命和碳基生命\"></a>1、硅基生命和碳基生命</h1><p>碳基生命：碳基生命是我们所熟知的地球上的生命形式，包括所有的生物，从微生物到植物和动物。碳是碳基生命的主要构建块，因为碳具有独特的化学性质，能够形成稳定的共价化学键。碳可以与其他元素，如氢、氧、氮和磷等，形成复杂的有机化合物，包括蛋白质、核酸、脂质等生物分子。碳基生命依赖于水作为生命体内的溶剂，并且其生物过程是基于碳的有机化学反应进行的。</p>\n<p>硅基生命：硅基生命是一种假设存在于宇宙中的生命形式，其基本结构和生物分子基于硅元素而非碳。硅与碳具有相似的化学性质，也能够形成稳定的共价键。因此，一些科学家认为在特定的条件下，硅也可能成为构建生命体的基本元素。硅基生命假设硅代替碳构建生命体的核酸、蛋白质和其他生物分子，使用其他溶剂代替水。硅基生命的研究仍然处于理论和推测阶段，尚未发现确凿的证据</p>\n<h1 id=\"2、西西弗斯的惩罚\"><a href=\"#2、西西弗斯的惩罚\" class=\"headerlink\" title=\"2、西西弗斯的惩罚\"></a>2、西西弗斯的惩罚</h1><p>希腊神话中，西西弗斯是科林斯的国王。作为统治者，他常常苦恼自己的王国没有充足的饮用水。</p>\n<p>有一天，事情迎来了转机。西西弗斯无意之中，看到了众神之王宙斯化作鹰的模样绑架河神的女儿伊琴娜的一幕。</p>\n<p>河神得知女儿失踪，感到悲伤不已。于是，西西弗斯便向河神提出一个交易：如果河神为他的王国创造一个四季常流的河川，他就告诉河神伊琴娜的行踪。河神答应了西西弗斯的请求。</p>\n<p>这一举动触怒了宙斯，他命令死神将西西弗斯打入阴森的地狱。然而西西弗斯是足智多谋的，他早预言死神会来到他身边。西西弗斯请求死神展示一下如何使用锁链，然后趁机捆住死神！这下子西西弗斯逃离了死神的魔爪，一如既往地过着舒适快乐的生活。</p>\n<p>一段时间过后，因为死神的消失，世间上再也没有人死去。直到冥王再也忍受不了地狱的荒凉寂寞，决定下命令让战神去解救死神。</p>\n<p>最终西西弗斯还是进了地狱，不过他早已在死前就想好了计谋。在冥王面前，他假惺惺地诉苦道：自己的妻子是个冷漠无情的人，现在尸体还像狗一样被扔到公共广场上，更何况举办盛大的葬礼呢。他请求冥王让他回到人间，了却这一桩心愿。于是冥王允许他处理完自己的葬礼之后回到地狱。西西弗斯窃喜不已，他如愿回到人间后，便违背了与冥王的约定。</p>\n<p>众神一怒之下，决定对西西弗斯实施最严厉的惩罚：要求他将一块巨石从平地推到山顶。但由于诅咒的力量，每当巨石抵达山顶的瞬间，就会变得异常沉重，一次又一次滚回起点。西西弗斯便在永无止境当中，不断循环往复推着巨石抵达山顶。</p>\n<h1 id=\"3、日本偷袭珍珠港的原因\"><a href=\"#3、日本偷袭珍珠港的原因\" class=\"headerlink\" title=\"3、日本偷袭珍珠港的原因\"></a>3、日本偷袭珍珠港的原因</h1><p>1941年7月，希特勒的军队正在俄国平原上狂飙猛进，伦敦和华盛顿对此忧心忡忡。因为，一旦苏联崩溃，所有的压力将重新回到英伦三岛的头上。英国能否顶得住德军的全力一击，实属悲观；而英国的失败，将直接导致美国失去他在欧洲的唯一立脚点，美国将会永远失去介入战争的机会。日本陆军正在中国东北大量集结，对苏的进攻似乎箭在弦上。<br>这让伦敦和华盛顿如芒在背，一旦日本配合德国进攻苏联，苏联的困境会呈几何级数地增加，苏联崩溃几乎就是眼前的事了。</p>\n<p>然而，没有国会的授权，没有舆论的支持，对日宣战是不可能的。这种情况下，此前一直在讨论并屡屡被搁置的对日石油禁运，这个时候就有了现实的意义，这也是总统职权范围内的事情，无须国会批准。日本90%石油靠美国，美国对日本采取石油禁运制裁之后，日本国内石油储备只剩下800万吨、仅够使用两年，如果不去东南亚抢夺石油，两年之后日本的军舰飞机就发动不了，但侵略东南亚会严重损害英美利益，日本军部权衡再三还是决定赌上国运、同时对英美开战，山本五十六反对开战无效，只能硬着头皮干下去，于是山本策划了偷袭珍珠港方案，力图开战之初就重创美国太平洋舰队，使其无法投入到东南亚战场，山本的计划成功了，日本得以在半年之内征服东南亚，获得了大量石油资源。</p>\n<h1 id=\"4、西方的傲慢与偏见\"><a href=\"#4、西方的傲慢与偏见\" class=\"headerlink\" title=\"4、西方的傲慢与偏见\"></a>4、西方的傲慢与偏见</h1><p>看外网的新闻总是宣称中国人被“洗脑”了。在他们看来，我们的形象可能类似朝鲜，做作和浮夸的表演。事实上，我们知道发生了什么，所以我们会抨击社会的问题，抨击腐败，抨击资本家的压榨。正因为我们不想再被“洗脑”，所以我们更加好奇，更愿意去探索这个世界。</p>\n<p>在我看来，任何媒体都是宣传工具，无论国内国外。幸运的是，大多数中国年轻人都知道这一点。不幸的是，一些西方人仍然相信他们所看到的就是全部真相</p>\n<h1 id=\"5、中国六大茶类\"><a href=\"#5、中国六大茶类\" class=\"headerlink\" title=\"5、中国六大茶类\"></a>5、中国六大茶类</h1><ol>\n<li>绿茶，属于不发酵茶，茶性偏寒，主要代表茶有西湖龙井、太平猴魁、六安瓜片、碧螺春等。</li>\n<li>红茶，属于全发酵茶，茶性偏温和，主要代表茶类有有门红茶、云南滇红、正山小种和金骏眉等。</li>\n<li>白茶，属于微发酵茶，茶性偏温和，按照采摘标准和树种的不同，分为白牡丹、白毫银针、贡眉和寿眉等。</li>\n<li>黑茶，属于后发酵茶，茶性温和，主要代表茶类有广西六堡茶、安化黑茶、普洱熟茶、茯茯茶等。</li>\n<li>黄茶，属于轻发酵茶，性凉微寒，主要代表茶类有蒙顶黄芽、霍山黄芽、君山银针等。</li>\n<li>青茶，属于半发酵茶，青茶是一种中性茶，适合大多数人饮用，主要代表茶类有大红袍、肉桂、铁观音、凤凰丹丛、水仙等</li>\n</ol>\n<blockquote>\n<p>六种茶的功效也各有不同:<br>    绿茶的主要功效能够降血脂减肥。<br>    白茶的功效是能够保护肝脏，而且还能够消炎、降火。<br>    黄茶的功效是有一定的杀毒作用，是可以帮助身体消化的，能够促进脂肪的代谢。<br>    青茶它具有降血脂抗衰老的作用，空腹、睡前和冷茶不宜饮。<br>    红茶的功效就是可以达到暖胃的效果，可以帮助身体消除疲劳。<br>    黑茶它可以降血脂，防止一些糖尿病的出现。</p>\n</blockquote>\n","site":{"data":{}},"cover":false,"excerpt":"","more":"<h1 id=\"1、硅基生命和碳基生命\"><a href=\"#1、硅基生命和碳基生命\" class=\"headerlink\" title=\"1、硅基生命和碳基生命\"></a>1、硅基生命和碳基生命</h1><p>碳基生命：碳基生命是我们所熟知的地球上的生命形式，包括所有的生物，从微生物到植物和动物。碳是碳基生命的主要构建块，因为碳具有独特的化学性质，能够形成稳定的共价化学键。碳可以与其他元素，如氢、氧、氮和磷等，形成复杂的有机化合物，包括蛋白质、核酸、脂质等生物分子。碳基生命依赖于水作为生命体内的溶剂，并且其生物过程是基于碳的有机化学反应进行的。</p>\n<p>硅基生命：硅基生命是一种假设存在于宇宙中的生命形式，其基本结构和生物分子基于硅元素而非碳。硅与碳具有相似的化学性质，也能够形成稳定的共价键。因此，一些科学家认为在特定的条件下，硅也可能成为构建生命体的基本元素。硅基生命假设硅代替碳构建生命体的核酸、蛋白质和其他生物分子，使用其他溶剂代替水。硅基生命的研究仍然处于理论和推测阶段，尚未发现确凿的证据</p>\n<h1 id=\"2、西西弗斯的惩罚\"><a href=\"#2、西西弗斯的惩罚\" class=\"headerlink\" title=\"2、西西弗斯的惩罚\"></a>2、西西弗斯的惩罚</h1><p>希腊神话中，西西弗斯是科林斯的国王。作为统治者，他常常苦恼自己的王国没有充足的饮用水。</p>\n<p>有一天，事情迎来了转机。西西弗斯无意之中，看到了众神之王宙斯化作鹰的模样绑架河神的女儿伊琴娜的一幕。</p>\n<p>河神得知女儿失踪，感到悲伤不已。于是，西西弗斯便向河神提出一个交易：如果河神为他的王国创造一个四季常流的河川，他就告诉河神伊琴娜的行踪。河神答应了西西弗斯的请求。</p>\n<p>这一举动触怒了宙斯，他命令死神将西西弗斯打入阴森的地狱。然而西西弗斯是足智多谋的，他早预言死神会来到他身边。西西弗斯请求死神展示一下如何使用锁链，然后趁机捆住死神！这下子西西弗斯逃离了死神的魔爪，一如既往地过着舒适快乐的生活。</p>\n<p>一段时间过后，因为死神的消失，世间上再也没有人死去。直到冥王再也忍受不了地狱的荒凉寂寞，决定下命令让战神去解救死神。</p>\n<p>最终西西弗斯还是进了地狱，不过他早已在死前就想好了计谋。在冥王面前，他假惺惺地诉苦道：自己的妻子是个冷漠无情的人，现在尸体还像狗一样被扔到公共广场上，更何况举办盛大的葬礼呢。他请求冥王让他回到人间，了却这一桩心愿。于是冥王允许他处理完自己的葬礼之后回到地狱。西西弗斯窃喜不已，他如愿回到人间后，便违背了与冥王的约定。</p>\n<p>众神一怒之下，决定对西西弗斯实施最严厉的惩罚：要求他将一块巨石从平地推到山顶。但由于诅咒的力量，每当巨石抵达山顶的瞬间，就会变得异常沉重，一次又一次滚回起点。西西弗斯便在永无止境当中，不断循环往复推着巨石抵达山顶。</p>\n<h1 id=\"3、日本偷袭珍珠港的原因\"><a href=\"#3、日本偷袭珍珠港的原因\" class=\"headerlink\" title=\"3、日本偷袭珍珠港的原因\"></a>3、日本偷袭珍珠港的原因</h1><p>1941年7月，希特勒的军队正在俄国平原上狂飙猛进，伦敦和华盛顿对此忧心忡忡。因为，一旦苏联崩溃，所有的压力将重新回到英伦三岛的头上。英国能否顶得住德军的全力一击，实属悲观；而英国的失败，将直接导致美国失去他在欧洲的唯一立脚点，美国将会永远失去介入战争的机会。日本陆军正在中国东北大量集结，对苏的进攻似乎箭在弦上。<br>这让伦敦和华盛顿如芒在背，一旦日本配合德国进攻苏联，苏联的困境会呈几何级数地增加，苏联崩溃几乎就是眼前的事了。</p>\n<p>然而，没有国会的授权，没有舆论的支持，对日宣战是不可能的。这种情况下，此前一直在讨论并屡屡被搁置的对日石油禁运，这个时候就有了现实的意义，这也是总统职权范围内的事情，无须国会批准。日本90%石油靠美国，美国对日本采取石油禁运制裁之后，日本国内石油储备只剩下800万吨、仅够使用两年，如果不去东南亚抢夺石油，两年之后日本的军舰飞机就发动不了，但侵略东南亚会严重损害英美利益，日本军部权衡再三还是决定赌上国运、同时对英美开战，山本五十六反对开战无效，只能硬着头皮干下去，于是山本策划了偷袭珍珠港方案，力图开战之初就重创美国太平洋舰队，使其无法投入到东南亚战场，山本的计划成功了，日本得以在半年之内征服东南亚，获得了大量石油资源。</p>\n<h1 id=\"4、西方的傲慢与偏见\"><a href=\"#4、西方的傲慢与偏见\" class=\"headerlink\" title=\"4、西方的傲慢与偏见\"></a>4、西方的傲慢与偏见</h1><p>看外网的新闻总是宣称中国人被“洗脑”了。在他们看来，我们的形象可能类似朝鲜，做作和浮夸的表演。事实上，我们知道发生了什么，所以我们会抨击社会的问题，抨击腐败，抨击资本家的压榨。正因为我们不想再被“洗脑”，所以我们更加好奇，更愿意去探索这个世界。</p>\n<p>在我看来，任何媒体都是宣传工具，无论国内国外。幸运的是，大多数中国年轻人都知道这一点。不幸的是，一些西方人仍然相信他们所看到的就是全部真相</p>\n<h1 id=\"5、中国六大茶类\"><a href=\"#5、中国六大茶类\" class=\"headerlink\" title=\"5、中国六大茶类\"></a>5、中国六大茶类</h1><ol>\n<li>绿茶，属于不发酵茶，茶性偏寒，主要代表茶有西湖龙井、太平猴魁、六安瓜片、碧螺春等。</li>\n<li>红茶，属于全发酵茶，茶性偏温和，主要代表茶类有有门红茶、云南滇红、正山小种和金骏眉等。</li>\n<li>白茶，属于微发酵茶，茶性偏温和，按照采摘标准和树种的不同，分为白牡丹、白毫银针、贡眉和寿眉等。</li>\n<li>黑茶，属于后发酵茶，茶性温和，主要代表茶类有广西六堡茶、安化黑茶、普洱熟茶、茯茯茶等。</li>\n<li>黄茶，属于轻发酵茶，性凉微寒，主要代表茶类有蒙顶黄芽、霍山黄芽、君山银针等。</li>\n<li>青茶，属于半发酵茶，青茶是一种中性茶，适合大多数人饮用，主要代表茶类有大红袍、肉桂、铁观音、凤凰丹丛、水仙等</li>\n</ol>\n<blockquote>\n<p>六种茶的功效也各有不同:<br>    绿茶的主要功效能够降血脂减肥。<br>    白茶的功效是能够保护肝脏，而且还能够消炎、降火。<br>    黄茶的功效是有一定的杀毒作用，是可以帮助身体消化的，能够促进脂肪的代谢。<br>    青茶它具有降血脂抗衰老的作用，空腹、睡前和冷茶不宜饮。<br>    红茶的功效就是可以达到暖胃的效果，可以帮助身体消除疲劳。<br>    黑茶它可以降血脂，防止一些糖尿病的出现。</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cloe5sr9j000900uj9937dau1","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9m000g00uj4czy2dgw"},{"post_id":"cloe5sr9e000100ujeaxa5fn3","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9n000k00uj1o7afbtl"},{"post_id":"cloe5sr9k000b00uj4lob2sw4","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9o000m00ujangr8a59"},{"post_id":"cloe5sr9l000e00uj88xifwza","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9p000p00uj1vtdhytp"},{"post_id":"cloe5sr9g000300uj34a2gxpq","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9q000s00uj51vih0jc"},{"post_id":"cloe5sr9m000f00uj4nym77m0","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9q000w00uj871ohk9w"},{"post_id":"cloe5sr9m000j00ujajry99k1","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9r000z00ujb15hf6c6"},{"post_id":"cloe5sr9i000700ujhjckbl9w","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9r001200uj4dwwbgoc"},{"post_id":"cloe5sr9n000l00ujhgaeerdc","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9s001400ujd6a40rqx"},{"post_id":"cloe5sr9p000o00ujegltgsy9","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9s001500ujaxd5cwpq"},{"post_id":"cloe5sr9p000r00uj7yvrgjyd","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9s001700uj0jcw3lzp"},{"post_id":"cloe5sr9q000v00uj153x394f","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9s001900ujg8qi687d"},{"post_id":"cloe5sr9r000y00ujaawtdh8o","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9s001c00ujbxlv11sn"},{"post_id":"cloe5sr9r001100uj2o9w9aql","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sr9s001d00uj8jlucftq"},{"post_id":"cloe5sra3002s00uj1d03fmfh","category_id":"cloe5sr9h000400ujh3l54r69","_id":"cloe5sra8002y00uj9fhd1n7b"},{"post_id":"cloe5sra8002z00uj8sns371p","category_id":"cloe5sra6002w00uj1mna8iry","_id":"cloe5srab003400uj9cil6bp6"},{"post_id":"cloe5sra3002t00ujf1ojg2mb","category_id":"cloe5sra6002w00uj1mna8iry","_id":"cloe5srac003600uj4xou80ag"},{"post_id":"cloe5sra5002v00uj386b1s96","category_id":"cloe5sra6002w00uj1mna8iry","_id":"cloe5srac003800ujcrvn3lho"},{"post_id":"cloe5sra7002x00ujdgog6ksg","category_id":"cloe5sra6002w00uj1mna8iry","_id":"cloe5srac003c00ujcqvmg6eu"}],"PostTag":[{"post_id":"cloe5sr9e000100ujeaxa5fn3","tag_id":"cloe5sr9h000500uj87gwdskq","_id":"cloe5sr9p000q00ujeg48dkh9"},{"post_id":"cloe5sr9e000100ujeaxa5fn3","tag_id":"cloe5sr9k000d00ujcj4kacx0","_id":"cloe5sr9q000t00ujhgtg19i8"},{"post_id":"cloe5sr9e000100ujeaxa5fn3","tag_id":"cloe5sr9m000i00uj1mf57mhc","_id":"cloe5sr9q000x00uj0howb3yz"},{"post_id":"cloe5sr9g000300uj34a2gxpq","tag_id":"cloe5sr9o000n00uj7z6hgues","_id":"cloe5sr9r001000ujf99x1rii"},{"post_id":"cloe5sr9i000700ujhjckbl9w","tag_id":"cloe5sr9q000u00ujd02japwp","_id":"cloe5sr9s001800ujc54n5mj4"},{"post_id":"cloe5sr9i000700ujhjckbl9w","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sr9s001a00ujdm9zhsr8"},{"post_id":"cloe5sr9j000900uj9937dau1","tag_id":"cloe5sr9s001600uj3b7x88vz","_id":"cloe5sr9t001g00ujfhiwea17"},{"post_id":"cloe5sr9j000900uj9937dau1","tag_id":"cloe5sr9s001b00ujdorybwxj","_id":"cloe5sr9t001h00uj4xio52tu"},{"post_id":"cloe5sr9j000900uj9937dau1","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sr9t001j00uj2mb133o2"},{"post_id":"cloe5sr9k000b00uj4lob2sw4","tag_id":"cloe5sr9s001f00ujejzgdjez","_id":"cloe5sr9t001l00uj4n7dgvsr"},{"post_id":"cloe5sr9k000b00uj4lob2sw4","tag_id":"cloe5sr9t001i00ujgrj16h6u","_id":"cloe5sr9t001m00uj8zd49tcf"},{"post_id":"cloe5sr9l000e00uj88xifwza","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sr9t001p00uj7paqbrtz"},{"post_id":"cloe5sr9l000e00uj88xifwza","tag_id":"cloe5sr9t001n00ujcgva731q","_id":"cloe5sr9t001q00ujeleq3pho"},{"post_id":"cloe5sr9m000f00uj4nym77m0","tag_id":"cloe5sr9t001o00uj5dwn3vz3","_id":"cloe5sr9u001t00ujgess1qz3"},{"post_id":"cloe5sr9m000f00uj4nym77m0","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sr9u001u00uj0qgsbmii"},{"post_id":"cloe5sr9m000j00ujajry99k1","tag_id":"cloe5sr9u001s00ujgsor71k3","_id":"cloe5sr9u001y00uj4p6hg9hb"},{"post_id":"cloe5sr9m000j00ujajry99k1","tag_id":"cloe5sr9u001v00ujbo1ahkdh","_id":"cloe5sr9u001z00uj4lin31m2"},{"post_id":"cloe5sr9m000j00ujajry99k1","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sr9u002100uj9dbq82at"},{"post_id":"cloe5sr9n000l00ujhgaeerdc","tag_id":"cloe5sr9u001x00uj0ks87he5","_id":"cloe5sr9v002400uj5i031qss"},{"post_id":"cloe5sr9n000l00ujhgaeerdc","tag_id":"cloe5sr9u002000uj2nzpfm7v","_id":"cloe5sr9v002500ujczqr3wkj"},{"post_id":"cloe5sr9n000l00ujhgaeerdc","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sr9w002700uj07tz7g86"},{"post_id":"cloe5sr9p000o00ujegltgsy9","tag_id":"cloe5sr9v002300uj1r52359l","_id":"cloe5sr9w002900uja9y02jbq"},{"post_id":"cloe5sr9p000o00ujegltgsy9","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sr9w002a00ujcuk58rrw"},{"post_id":"cloe5sr9p000r00uj7yvrgjyd","tag_id":"cloe5sr9w002800ujdw820hpx","_id":"cloe5sr9x002d00ujhh7h8hcp"},{"post_id":"cloe5sr9p000r00uj7yvrgjyd","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sr9x002e00ujbm70delp"},{"post_id":"cloe5sr9q000v00uj153x394f","tag_id":"cloe5sr9w002800ujdw820hpx","_id":"cloe5sr9z002i00uj8vxz4q95"},{"post_id":"cloe5sr9q000v00uj153x394f","tag_id":"cloe5sr9x002f00uj68476qyp","_id":"cloe5sr9z002j00uj8ywl3bvm"},{"post_id":"cloe5sr9q000v00uj153x394f","tag_id":"cloe5sr9t001i00ujgrj16h6u","_id":"cloe5sr9z002l00ujajesaooc"},{"post_id":"cloe5sr9r000y00ujaawtdh8o","tag_id":"cloe5sr9y002h00uja9dbgpk7","_id":"cloe5sra0002n00ujbo5r8ibg"},{"post_id":"cloe5sr9r000y00ujaawtdh8o","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sra0002o00uj5n206o14"},{"post_id":"cloe5sr9r001100uj2o9w9aql","tag_id":"cloe5sr9z002m00ujac2e555u","_id":"cloe5sra0002q00ujd8gpb7pm"},{"post_id":"cloe5sr9r001100uj2o9w9aql","tag_id":"cloe5sr9r001300ujb3eb6fj1","_id":"cloe5sra0002r00ujedpq2xar"},{"post_id":"cloe5sra3002s00uj1d03fmfh","tag_id":"cloe5sra5002u00uj6layexey","_id":"cloe5sraa003100uje7o73b05"},{"post_id":"cloe5sra3002t00ujf1ojg2mb","tag_id":"cloe5sra9003000ujc98lan4q","_id":"cloe5srac003900uj29azfft8"},{"post_id":"cloe5sra3002t00ujf1ojg2mb","tag_id":"cloe5srab003300ujb1kpbmy7","_id":"cloe5srac003a00uj0hr795ps"},{"post_id":"cloe5sra5002v00uj386b1s96","tag_id":"cloe5srac003700uj47cvbz52","_id":"cloe5srad003e00ujcqztdula"},{"post_id":"cloe5sra5002v00uj386b1s96","tag_id":"cloe5srac003b00uj9v7j0rtl","_id":"cloe5srad003f00ujatnf4cb0"},{"post_id":"cloe5sra7002x00ujdgog6ksg","tag_id":"cloe5srac003d00ujat338e93","_id":"cloe5srad003h00uj8eq4cfmv"},{"post_id":"cloe5sra8002z00uj8sns371p","tag_id":"cloe5srad003g00uj4be55e21","_id":"cloe5srae003j00ujc9hy3272"},{"post_id":"cloe5sra8002z00uj8sns371p","tag_id":"cloe5srad003i00uj11be3sqk","_id":"cloe5srae003k00uj84bnh64m"}],"Tag":[{"name":"juc","_id":"cloe5sr9h000500uj87gwdskq"},{"name":"多线程","_id":"cloe5sr9k000d00ujcj4kacx0"},{"name":"并发编程","_id":"cloe5sr9m000i00uj1mf57mhc"},{"name":"nginx","_id":"cloe5sr9o000n00uj7z6hgues"},{"name":"java core","_id":"cloe5sr9q000u00ujd02japwp"},{"name":"编程基础","_id":"cloe5sr9r001300ujb3eb6fj1"},{"name":"RabbitMQ","_id":"cloe5sr9s001600uj3b7x88vz"},{"name":"消息队列","_id":"cloe5sr9s001b00ujdorybwxj"},{"name":"PBRTQC","_id":"cloe5sr9s001f00ujejzgdjez"},{"name":"技术文章","_id":"cloe5sr9t001i00ujgrj16h6u"},{"name":"jvm","_id":"cloe5sr9t001n00ujcgva731q"},{"name":"dubbo","_id":"cloe5sr9t001o00uj5dwn3vz3"},{"name":"redis","_id":"cloe5sr9u001s00ujgsor71k3"},{"name":"缓存中间件","_id":"cloe5sr9u001v00ujbo1ahkdh"},{"name":"mysql","_id":"cloe5sr9u001x00uj0ks87he5"},{"name":"数据库","_id":"cloe5sr9u002000uj2nzpfm7v"},{"name":"shiro","_id":"cloe5sr9v002300uj1r52359l"},{"name":"sharding-jdbc","_id":"cloe5sr9w002800ujdw820hpx"},{"name":"分库分表","_id":"cloe5sr9x002f00uj68476qyp"},{"name":"springCloud","_id":"cloe5sr9y002h00uja9dbgpk7"},{"name":"thymeleaf","_id":"cloe5sr9z002m00ujac2e555u"},{"name":"spring","_id":"cloe5sra5002u00uj6layexey"},{"name":"段子","_id":"cloe5sra9003000ujc98lan4q"},{"name":"沙雕图","_id":"cloe5srab003300ujb1kpbmy7"},{"name":"哲学","_id":"cloe5srac003700uj47cvbz52"},{"name":"西方哲学","_id":"cloe5srac003b00uj9v7j0rtl"},{"name":"中国古代史","_id":"cloe5srac003d00ujat338e93"},{"name":"常识","_id":"cloe5srad003g00uj4be55e21"},{"name":"思考","_id":"cloe5srad003i00uj11be3sqk"}]}}