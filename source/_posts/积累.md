---
abbrlink: 2
---



# 11、场景题



# 12、数据结构和算法
## 12.1、堆

1. 定义：堆通常可以被看做是一棵完全二叉树的数组对象
> [完全二叉树](https://so.csdn.net/so/search?q=%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&spm=1001.2101.3001.7020)，除了树的最后一层结点不需要是满的，其它的每一层从左到右都是满的，如果最后一层结点不是满的，那么要求节点都靠左


2. 特点

（1）它是完全二叉树
（2）它通常用数组来实现。具体方法就是将二叉树的结点按照层级顺序放入数组中
（3）堆中树的某个结点的父结点与左右子结点对应数组的索引关系：如果一个结点的位置为k，则它的父结点的位置为k/2,而它的两个子结点的位置则分别为2k和2k+1。这样，在不使用指针的情况下，我们也可以通过计算数组的索引在树中上下移动
（4）每个结点都大于等于它的两个子结点。这里要注意堆中仅仅规定了每个结点大于等于它的两个子结点，但这两个子结点的顺序并没有做规定，跟我们之前学习的二叉查找树是有区别的

3. 插入与删除的实现

插入：利用上浮算法进行数据插入，上浮算法就是将待上浮的结点与其父结点比较，如果待上浮的结点大于父结点，则交换位置，循环往复，直至待上浮的结点没有父结点。因此，将待插入的结点放到数组的最后一个元素，然后将插入的结点作为待上浮的结点，通过上浮算法将其放到合适的位置。
删除：下沉算法就是通过将待下沉的结点k，与其左子结点2k和右子结点2k+1中较大的结点进行比较，如果待下沉的结点小于左子结点和右子结点中较大的结点，则交换位置，循环往复，直至待下沉的结点没有左右子结点即叶子节点时完成下沉
#
# 14、Linux
## 14.1、防火墙常用命令
Firewalld和iptables都是Linux系统中常用的防火墙软件, Firewalld可以在运行时动态添加、删除和修改规则, 使用更加灵活
```shell
# 查看防火墙状态
systemctl status firewalld
# 查看所有开启的端口
firewall-cmd --list-ports
# 放行80端口
firewall-cmd --zone=public --add-port=80/tcp --permanent
# 移除80端口
firewall-cmd --remove-port=80/tcp --permanent
# 重启防火墙
firewall-cmd --reload
```

## 14.2、进程号&端口号查看
```shell
# 查看java项目的进程
jsp
# 根据名称查看进程
ps -ef|grep ims
# 根据端口号查看进程(-alnp:所有连接  -tlnp:tcp连接)
netstat -alnp|grep 8090
# 根据进程号查看项目端口号
netstat -alnp|grep 119343
```
# 15、项目
### 15.1、云+2.0系统


## 3.19、mybatis原理

1. 系统启动的时候，会去创建一个sqlSessionFactory（它是一个单例对象，因为创建开销大），其中它会去加载mybatis全局配置文件和映射文件，封装到Configuration对象中。用来创建sqlSession
> 两个属性分别为：
> DataSource dataSource
> Map<String, MappedStatement> mappedStatements：key为namespace.id， value的MappedStatement对象包括入参，出参，sql语句等信息

2. sqlsession中提供了增删改查等操作的方法，在执行方法时会调用对应Executor执行器执行
3. Executor处理，如果有配置缓存，它会先走二级缓存，再走一级缓存。如果缓存中都没有查到对应的数据，才走底层的JDBC操作，实际就是调用jdbc的statement/ preparedStatement，在调用之前涉及到参数封装，在调用之后处理返回（ResultSet转成ResultType设置的类型）

> 例如：preparedStatement执行前需要把sql中的#{} 替换为 ？
> 这些步骤都是在mapper动态代理类中进行


## 3.20、mybatis插件原理（PageHelper分页原理）
mybatis插件本质就是一个拦截器，就是对ParameterHandler、ResultSetHandler、StatementHandler、Executor这四个接口上的方法进行拦截，利用JDK动态代理机制，为这些接口的实现类创建代理对象，在执行方法时，会执行到代理对象的方法，从而执行自己编写的拦截逻辑。
具体实现：1.创建插件类，实现Interceptor接口。2. 在插件类中重写intercept()方法，实现插件功能。3. 在插件类中重写plugin()方法，返回目标对象的代理对象。4. 在插件类中重写setProperties()方法，读取配置文件中的属性。5. 在MyBatis配置文件中通过标签配置插件。
> PageHelper 的原理是通过拦截 Executor 的 query 方法，从而获取查询 SQL 语句和参数，并根据用户的分页配置信息，自动在查询语句中添加分页的 SQL 语句，最后将修改后的 SQL 语句和参数传递给 Executor 进行查询



# 8、网络
## 8.1、长连接和短连接的区别？
HTTP的长连接和短连接本质上是TCP长连接和短连接
**长连接：** 客户端和服务端建立连接后不进行断开，之后客户端再次访问这个服务器上的内容时，继续使用这一条连接通道。直到服务器超时自动断开链接，或者客户端主动断开链接
**短连接：** 客户端和服务端建立连接，发送完数据后立马断开连接。下次要取数据，需要再次建立连接。

> 在HTTP/1.0中，默认使用的是短连接。但从 HTTP/1.1起，默认使用长连接。
> Http长连接 和 TCP长连接的区别在于: TCP 的长连接需要自己去维护一套心跳策略。，而Http只需要在请求头加入keep-alive:true即可实现长连接


## 8.2、cookie和session的区别？

1. 存储位置：cookie存储在客户端浏览器中，session存储在服务器端。
2. 安全性：cookie可以被客户端修改和窃取，因此不适合存储敏感信息。而session存储在服务器端，只有服务器可以访问它，因此更加安全。
3. 存储容量：cookie的存储容量有限，通常只能存储少量的数据。而session可以存储大量的数据，因为它存储在服务器端。（具体容量看设置，cookie默认4kb，session几十兆）
4. 过期时间：cookie可以设置过期时间，当过期时，浏览器会自动删除cookie。而session在用户关闭浏览器时会自动过期。

总的来说，cookie适合用于存储少量的非敏感信息，如用户偏好设置、购物车信息等；而session适合用于存储大量的敏感信息，如用户登录状态、权限等