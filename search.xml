<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringCloud Alibaba</title>
      <link href="/posts/13792.html"/>
      <url>/posts/13792.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、服务注册与发现-nacos"><a href="#1、服务注册与发现-nacos" class="headerlink" title="1、服务注册与发现 - nacos"></a>1、服务注册与发现 - nacos</h1><h2 id="1-1、nacos注册中心部署"><a href="#1-1、nacos注册中心部署" class="headerlink" title="1.1、nacos注册中心部署"></a>1.1、nacos注册中心部署</h2><p>单机模式 - 用于测试和单机试用。<br>集群模式 - 用于生产环境，确保高可用。<br>多集群模式 - 用于多数据中心场景</p><h3 id="1-1-1、单机部署"><a href="#1-1-1、单机部署" class="headerlink" title="1.1.1、单机部署"></a>1.1.1、单机部署</h3><p>1、下载地址：<a href="https://nacos.io/%EF%BC%8C%E8%A7%A3%E5%8E%8B">https://nacos.io/，解压</a><br>2、修改配置conf&#x2F;spplication.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">db.user.0</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password.0</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><p>3、初始化数据库</p><p>执行conf下 mysql-schema.sql 初始化数据库</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405191517635.png" alt="image.png"></p><p>4、修改bin&#x2F;starup.cmd（linux下修改startup.sh）</p><p>set MODE&#x3D;”cluster”  改为 set MODE&#x3D;”standalone”</p><p>5、执行启动脚本</p><p>6、访问<a href="http://127.0.0.1:8848/nacos%EF%BC%8C%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D/%E5%AF%86%E7%A0%81%EF%BC%9Anacos/nacos%EF%BC%8C%E8%BF%9B%E5%85%A5%E4%B8%BB%E7%95%8C%E9%9D%A2">http://127.0.0.1:8848/nacos，输入用户名/密码：nacos/nacos，进入主界面</a></p><h3 id="1-1-2、集群部署"><a href="#1-1-2、集群部署" class="headerlink" title="1.1.2、集群部署"></a>1.1.2、集群部署</h3><p>本次部署 3个nacos节点，然后一个负载均衡器（nginx）代理3个Nacos</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405191529539.png" alt="image.png"></p><p>1、三个节点的IP和端口需要配置到cluster.conf文件中。 使用以Nacos自带的cluster.conf.example文件复制一份，作为cluster.conf文件。编辑cluster.conf文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#it is ip</span><br><span class="line">#example</span><br><span class="line">127.0.0.1:8845</span><br><span class="line">127.0.0.1.8846</span><br><span class="line">127.0.0.1.8847</span><br></pre></td></tr></table></figure><p>5、将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3，然后分别修改三个文件夹中的application.properties里的端口</p><p>6、配置nginx负载均衡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    sendfile        on;</span><br><span class="line">  upstream nacos-cluster&#123;</span><br><span class="line">        server 127.0.0.1:8845;</span><br><span class="line">        server 127.0.0.1:8846;</span><br><span class="line">        server 127.0.0.1:8847;</span><br><span class="line">  &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       88;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/sky;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">        # 反向代理,处理管理端发送的请求</span><br><span class="line">        location /nacos/ &#123;</span><br><span class="line">proxy_pass   http://nacos-cluster;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>7、在浏览器访问：<a href="http://localhost:88/nacos%E5%8D%B3%E5%8F%AF">http://localhost:88/nacos即可</a></p><blockquote><p>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.<br> Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></blockquote><h2 id="1-2、nacos注册中心工作流程"><a href="#1-2、nacos注册中心工作流程" class="headerlink" title="1.2、nacos注册中心工作流程"></a>1.2、nacos注册中心工作流程</h2><p><strong>服务注册</strong>:Nacos Client会通过发送REST请求的方式向Nacos Server注册自己的服务，提供自身的元数据，比如ip地址、端口等信息。Nacos Server接收到注册请求后，就会把这些元数据信息存储在一个双层的内存Map中（外层key是namespace，内层key是group:service）。</p><p><strong>服务心跳</strong>:在服务注册后，Nacos Client会维护一个定时心跳来持续通知Nacos Server，说明服务一直处于可用状态，防止被剔除。默认5s发送一次心跳。</p><p><strong>服务同步</strong>:Nacos Server集群之间会互相同步服务实例，用来保证服务信息的一致性。</p><p><strong>服务发现</strong>:服务消费者(Nacos Client)在调用服务提供者的服务时，会发送一个REST请求给NacosServer，获取上面注册的服务清单，并且缓存在Nacos Client本地，同时会在Nacos Client本地开启个定时任务（默认35s）定时拉取服务端最新的注册表信息更新到本地缓存</p><p><strong>服务健康检查</strong>:Nacos Server会开启一个定时任务用来检查注册服务实例的健康情况，对于超过15s没有收到客户端心跳的实例会将它的healthy属性置为false(客户端服务发现时不会发现)，如果某个实例超过30秒没有收到心跳，直接别除该实例(被剔除的实例如果恢复发送心跳则会重新注册)</p><h2 id="1-3、nacos领域模型"><a href="#1-3、nacos领域模型" class="headerlink" title="1.3、nacos领域模型"></a>1.3、nacos领域模型</h2><p>nacos的服务由三元组唯一确定（namespace、group、serviceName）<br>nacos的配置由三元组唯一确定（namespace、group、dataId）</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405191706470.png" alt="image.png|500"></p><table><thead><tr><th>模型名称</th><th>解释</th></tr></thead><tbody><tr><td>Namespace</td><td>实现环境隔离，默认值public（一般用于区分测试、生产环境等）</td></tr><tr><td>Group</td><td>不同的service可以组成一个Group，默认值Default-Group</td></tr><tr><td>Service</td><td>服务名称</td></tr><tr><td>Cluster</td><td>对指定的微服务虚拟划分，默认值Default</td></tr><tr><td>Instance</td><td>某个服务的具体实例（ip+端口）</td></tr></tbody></table><p>Nacos 服务发现使用的领域模型是命名空间-分组-服务-集群-实例这样的多层结构。服务 Service 和实例 Instance 是核心模型，命名空间 Namespace 、分组 Group、集群 Cluster 则是在不同粒度实现了服务的隔离</p><h1 id="2、远程调用-RestTemplate"><a href="#2、远程调用-RestTemplate" class="headerlink" title="2、远程调用 - RestTemplate"></a>2、远程调用 - RestTemplate</h1><p>RestTemplate是一款Spring框架中的HTTP客户端工具类库，它封装了大量的HTTP请求处理代码，使得我们可以方便地进行HTTP请求的发送与处理。RestTemplate支持多种HTTP请求方式，例如GET、POST、PUT、DELETE等，同时也支持参数的传递与响应结果的解析等功能</p><p>下面简单看一下它的三种使用方式：</p><h2 id="2-1、直接使用"><a href="#2-1、直接使用" class="headerlink" title="2.1、直接使用"></a>2.1、直接使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:8761/order&quot;</span>, String.class);</span><br></pre></td></tr></table></figure><h2 id="2-2、使用cloud的-LoadBalancerClient-获取服务地址"><a href="#2-2、使用cloud的-LoadBalancerClient-获取服务地址" class="headerlink" title="2.2、使用cloud的 LoadBalancerClient 获取服务地址"></a>2.2、使用cloud的 LoadBalancerClient 获取服务地址</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GetMapping</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getOrder</span><span class="params">()</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="type">RestTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line"><span class="comment">// ORDER为服务名</span></span><br><span class="line">      <span class="type">ServiceInstance</span> <span class="variable">instance</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;ORDER&quot;</span>);</span><br><span class="line">      <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> instance.getHost();</span><br><span class="line">      <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> instance.getPort();</span><br><span class="line"></span><br><span class="line">      <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> template.getForObject(url + <span class="string">&quot;:&quot;</span> + port + <span class="string">&quot;/order&quot;</span>, String.class);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="2-3、Ribbon-RestTemplate"><a href="#2-3、Ribbon-RestTemplate" class="headerlink" title="2.3、Ribbon + RestTemplate"></a>2.3、Ribbon + RestTemplate</h2><p>其实就是和cloud的Ribbon负载均衡器整合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RestTemplate 注解为bean， 并加上 @LoadBalanced</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line">RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注入 @Autowired</span></span><br><span class="line">RestTemplate template;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用(ORDER为服务名)</span></span><br><span class="line"><span class="meta">@GetMapping</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getOrder</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> template.getForObject(<span class="string">&quot;http://ORDER/order&quot;</span>, String.class);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、负载均衡器-Ribbon"><a href="#3、负载均衡器-Ribbon" class="headerlink" title="3、负载均衡器 - Ribbon"></a>3、负载均衡器 - Ribbon</h1><p>实际开发中一般不会让网址直接访问代码服务器(小项目除外),通常是通过nginx进行反向代理和负载均衡.而在Springcloud里我们用了另外2个组件来代替nginx的这两个功能,网关代替反向代理，Ribbon就是代替负载均衡的组件.通常在微服务架构中,业务都会被拆分成一个独立的服务,服务与服务的通讯是基于http restful的.Spring cloud有两种服务调用方式,一种是ribbon+restTemplate,另一种是feign</p><h2 id="3-1、Ribbon的工作流程"><a href="#3-1、Ribbon的工作流程" class="headerlink" title="3.1、Ribbon的工作流程"></a>3.1、Ribbon的工作流程</h2><p>1、restTemplate的bean添加了@LoadBalanced注解，这个注解就是一个标记，表示这个RestTemplate发起的请求要被Ribbon拦截和处理。<br>2、Ribbon解析url中的host，获取服务名，根据服务名获取实例列表（先从本地缓存获取，没有再从nacos server获取并缓存实例列表）<br>3、通过相应的负载均衡策略获取一个实例的ip+端口<br>4、发起远程调用</p><h2 id="3-2、Ribbon均衡策略"><a href="#3-2、Ribbon均衡策略" class="headerlink" title="3.2、Ribbon均衡策略"></a>3.2、Ribbon均衡策略</h2><p>Ribbon核心组件IRule：根据特定算法从服务列表中选取一个需要访问的服务；其中IRule是一个接口，有七个自带的落地实现类，可以实现不同的负载均衡算法规则。</p><p>负载均衡的实现主要有三种算法：轮询（默认方式）、随机、权值分配，其中轮询 ZoneAvoidanceRule 也是 @LoadBalanced 注解默认的分配策略，细节上可以分为以下几种</p><table><thead><tr><th>策略名</th><th>名称</th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>轮询策略</td><td>简单轮询服务列表来选择服务器。</td></tr><tr><td>RandomRule</td><td>随机策略</td><td>随机选择一个可用的服务器</td></tr><tr><td>RetryRule</td><td>重试策略</td><td>正常按轮询，失败后重试机制的选择逻辑</td></tr><tr><td>BestAvailableRule</td><td>最低并发策略</td><td>忽略那些短路的服务器，并选择并发数较低的服务器</td></tr><tr><td>WeightedResponseTimeRule</td><td>响应时间加权策略</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择</td></tr><tr><td>AvailabilityFilteringRule</td><td>可用过滤策略</td><td>对以下两种服务器进行忽略：<br><br> （1）在默认情况下，这台服务器如果3次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续30秒，如果再次连接失败，短路的持续时间就会几何级地增加。<br><br>（2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了AvailabilityFilteringRule规则的客户端也会将其忽略</td></tr><tr><td>ZoneAvoidanceRule（默认）</td><td>区域权衡策略</td><td>综合判断 Server 所在区域的性能和 Server 的可用性轮询选择 Server，并且判定一个 AWS Zone 的运行性能是否可用，剔除不可用的 Zone 中的所有 Server</td></tr></tbody></table><h2 id="3-3、切换负载均衡策略"><a href="#3-3、切换负载均衡策略" class="headerlink" title="3.3、切换负载均衡策略"></a>3.3、切换负载均衡策略</h2><p><strong>方法一：</strong></p><p>1、创建配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRibbonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> IRule <span class="title function_">ribbonRule</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//随机策略</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、启动类上加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RibbonClient(name = &quot;user-provider&quot;, configuration = MyRibbonConfig.class)</span></span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><p>application.yml文件中，添加新的配置也可以修改规则</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure><h1 id="4、服务调用-OpenFeign"><a href="#4、服务调用-OpenFeign" class="headerlink" title="4、服务调用 - OpenFeign"></a>4、服务调用 - OpenFeign</h1><p>RestTemplate发起远程调用的代码时会存在一些问题比如：代码可读性差，参数复杂URL难以维护<br>OpenFeign的设计宗旨式简化Java Http客户端的开发。用户只需创建一个接口并添加相应的注解，即可实现对远程服务的调用。OpenFeign 是 Spring Cloud 的一部分，它支持 Spring MVC 的注解，如 @RequestMapping，使得使用 HTTP 请求访问远程服务就像调用本地方法一样直观和易于维护。OpenFeign集成了Ribbon，实现了客户端负载均衡</p><h2 id="4-1、实现流程"><a href="#4-1、实现流程" class="headerlink" title="4.1、实现流程"></a>4.1、实现流程</h2><p>1、调用方添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、启动类添加注解@EnableFeignClients</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>  </span><br><span class="line"><span class="meta">@EnableFeignClients</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosConsumer8080</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        SpringApplication.run(NacosConsumer8080.class, args);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、调用方定义pai</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;depart-provider&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProviderServiceApi</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/provider/depart/list&quot;)</span>  </span><br><span class="line">    List&lt;Depart&gt; <span class="title function_">getInfo</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、调用方调用pai</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> List&lt;Depart&gt; <span class="title function_">listHandle</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="comment">//        String url = SERVICE_PROCIER + &quot;/list&quot;;  </span></span><br><span class="line"><span class="comment">//        return template.getForObject(url, List.class);  </span></span><br><span class="line">        <span class="keyword">return</span> providerServiceApi.getInfo();  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="5、配置中心-nacos"><a href="#5、配置中心-nacos" class="headerlink" title="5、配置中心 - nacos"></a>5、配置中心 - nacos</h1><h2 id="5-1、基本概念"><a href="#5-1、基本概念" class="headerlink" title="5.1、基本概念"></a>5.1、基本概念</h2><p>微服务下配置文件存在的问题：</p><p>1、配置文件分散在每个微服务中，并且每个服务都有不同的环境（开发，测试，生产等），手动维护很困难<br>2、配置文件无法实时更新，修改配置文件后必须重启微服务才能生效</p><p>配置中心的思路是：</p><p>首先把项目中各种配置全部都放到一个集中的地方进行统一管理，并提供一套标准的接口。  当各个服务需要获取配置的时候，就来配置中心的接口拉取自己的配置。当配置中心中的各种参数有更新的时候，也能通知到各个服务实时的过来同步最新的信息，使之动态更新</p><h2 id="5-2、使用"><a href="#5-2、使用" class="headerlink" title="5.2、使用"></a>5.2、使用</h2><p>1、创建namespace<br>2、在配置中心对应的namespace下创建配置</p><p>nacos中，dataId不能随便写，完整格式如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span><br></pre></td></tr></table></figure><p>prefix 默认为 spring.application.name 的值，也可以通过配置项 spring.cloud.nacos.config.prefix 来配置。<br>spring.profiles.active 即为当前环境对应的 profile<br>file-extension为配置内容的数据格式。可以通过配置项 spring.cloud.nacos.config.file-extension 来配置。目前只支持 properties 和 yaml 类型。</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405232230561.png" alt="image.png|575"></p><p>3、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4、不能使用原来的application.yml作为配置文件，而是新建一个bootstrap.yml作为配置文件</p><blockquote><p> 配置文件优先级(由高到低):<br>bootstrap.properties -&gt; bootstrap.yml -&gt; application.properties -&gt; application.yml</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">nacos:</span>  </span><br><span class="line">      <span class="attr">config:</span>  </span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span>  </span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span>  </span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">0f4ed5b7-9e5d-4319-90e5-69ede3d2a23f</span> <span class="comment">#配置文件命名空间要和服务实例的一致  </span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span>  <span class="comment">#配置文件的组要和服务实例的一致  </span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span>  </span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">depart-provider</span> <span class="comment">#服务的名称  </span></span><br><span class="line">  <span class="attr">profiles:</span>  </span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><blockquote><p>不同环境下配置文件只需要修改namespace和active即可</p></blockquote><p>注意：在SpringBoot 2.4.x的版本之后，默认禁用bootstrap，需要手动导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-bootstrap<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-3、配置动态刷新"><a href="#5-3、配置动态刷新" class="headerlink" title="5.3、配置动态刷新"></a>5.3、配置动态刷新</h2><p>上面的使用我们做到了远程存放，但是此时如果修改了配置，我们的程序是无法读取到 的，因此，我们需要开启配置的动态刷新功能<br>@RefreshScope</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span>  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RefreshScope</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;pic.url&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String picUrl;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/pic&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">picUrl</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> picUrl;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4、共享配置"><a href="#5-4、共享配置" class="headerlink" title="5.4、共享配置"></a>5.4、共享配置</h2><p>当配置越来越多的时候，我们就发现有很多配置是重复的，这时候就可以考虑将公共配置文件 提取出来，然后实现共享</p><h3 id="5-4-1、同一微服务不同环境之间共享配置"><a href="#5-4-1、同一微服务不同环境之间共享配置" class="headerlink" title="5.4.1、同一微服务不同环境之间共享配置"></a>5.4.1、同一微服务不同环境之间共享配置</h3><p>如果想在同一个微服务的不同环境之间实现配置共享，其实很简单。只需要提取一个以spring.application.name 命名的配置文件，然后将其所有环境的公共配置放在里面即可</p><h3 id="5-4-2、不同微服务中共享配置"><a href="#5-4-2、不同微服务中共享配置" class="headerlink" title="5.4.2、不同微服务中共享配置"></a>5.4.2、不同微服务中共享配置</h3><p>不同微服务之间实现配置共享的原理类似于文件引入，就是定义一个公共配置，然后在当前配置中引入。 1 在nacos中定义一个DataID为all-service.yaml（名字随意）的配置，用于所有微服务共享</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">nacos:</span>  </span><br><span class="line">      <span class="attr">config:</span>  </span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span>  </span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span>  </span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">cef6473d-6914-4cd9-968c-b98017fe6b37</span> <span class="comment">#配置文件命名空间要和服务实例的一致  </span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span>  <span class="comment">#配置文件的组要和服务实例的一致  </span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">nacos</span>  </span><br><span class="line">        <span class="attr">password:</span> <span class="string">nacos</span>  </span><br><span class="line">        <span class="attr">shared-configs:</span>  </span><br><span class="line">          <span class="bullet">-</span> <span class="string">common.yml</span>  </span><br><span class="line">          <span class="bullet">-</span> <span class="string">common2.yml</span>  </span><br><span class="line">        <span class="attr">refreshable-dataids:</span> <span class="string">common.yml,common2.yml</span>  <span class="comment"># 用于动态刷新</span></span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">depart-provider</span> <span class="comment">#服务的名称  </span></span><br><span class="line">  <span class="attr">profiles:</span>  </span><br><span class="line">    <span class="attr">active:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure><h1 id="6、流量治理-sentinel"><a href="#6、流量治理-sentinel" class="headerlink" title="6、流量治理 - sentinel"></a>6、流量治理 - sentinel</h1><p>Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性</p><h2 id="6-1、组成部分"><a href="#6-1、组成部分" class="headerlink" title="6.1、组成部分"></a>6.1、组成部分</h2><p>sentinel 的使用可以分为两个部分:</p><p>1、核心库（Java 客户端）：不依赖任何框架&#x2F;库，能够运行于 Java 8 及以上的版本的运行时环境，同时对 Dubbo &#x2F; Spring Cloud 等框架也有较好的支持。</p><p>2、控制台（Dashboard）：Dashboard 主要负责管理推送规则、监控、管理机器信息等。基于 Spring Boot 开发，打包后可以直接运行。</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405251219281.png" alt="image.png|475"></p><h2 id="6-2、工作流程"><a href="#6-2、工作流程" class="headerlink" title="6.2、工作流程"></a>6.2、工作流程</h2><p>在 Sentinel 里面，所有的资源都对应一个资源名称（resourceName），每次资源调用都会创建一个 Entry 对象。Entry可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 SphU API 显式创建。Entry 创建的时候，同时也会创建一系列功能插槽（slot chain），这些插槽有不同的职责，例如:</p><p>1、NodeSelectorSlot 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；<br>2、ClusterBuilderSlot 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；<br>3、StatisticSlot 则用于记录、统计不同纬度的 runtime 指标监控信息；<br>4、FlowSlot 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；<br>5、AuthoritySlot 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；<br>6、DegradeSlot 则通过统计信息以及预设的规则，来做熔断降级；<br>7、SystemSlot 则通过系统的状态，例如 load1 等，来控制总的入口流量；</p><h2 id="6-3、基本使用"><a href="#6-3、基本使用" class="headerlink" title="6.3、基本使用"></a>6.3、基本使用</h2><h3 id="6-3-1、dashboard搭建"><a href="#6-3-1、dashboard搭建" class="headerlink" title="6.3.1、dashboard搭建"></a>6.3.1、dashboard搭建</h3><p>1、<a href="https://github.com/alibaba/sentinel/releases">https://github.com/alibaba/sentinel/releases</a> 下载jar包<br>2、执行命令启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -jar sentinel-dashboard-1.8.7.jar --server.port=8888</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>3、访问localhost:8888  sentinel&#x2F;sentinel</p><h3 id="6-3-2、为服务打开0sentinel监控"><a href="#6-3-2、为服务打开0sentinel监控" class="headerlink" title="6.3.2、为服务打开0sentinel监控"></a>6.3.2、为服务打开0sentinel监控</h3><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-sentinel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、添加配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">sentinel:</span>  </span><br><span class="line">      <span class="attr">transport:</span>  </span><br><span class="line">        <span class="attr">port:</span> <span class="number">8179</span>  </span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8888</span>  </span><br><span class="line">      <span class="attr">eager:</span> <span class="literal">true</span> <span class="comment"># 默认懒加载，true为开机饥饿加载</span></span><br></pre></td></tr></table></figure><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405251214913.png" alt="image.png"></p><h2 id="6-4、流控规则"><a href="#6-4、流控规则" class="headerlink" title="6.4、流控规则"></a>6.4、流控规则</h2><h3 id="6-4-1、流控规则属性"><a href="#6-4-1、流控规则属性" class="headerlink" title="6.4.1、流控规则属性"></a>6.4.1、流控规则属性</h3><p>1、资源名： 唯一名称，默认请求路径，表示对该资源进行流控</p><p>2、针对来源： Sentinel可以针对调用者进行限流，填写微服务名，默认default（不区分来源）</p><p>3、阈值类型&#x2F;单击阈值：<br>    QPS：（每秒钟的请求数量）：当调用该api的QPS达到阈值时，进行限流<br>    线程数：当调用该线程数达到阈值的时候，进行限流</p><p>4、是否集群：不需要集群</p><p>5、流控模式：<br>    直接： api达到限流条件时，直接限流<br>    关联： 当关联的资源达到阈值时，就限流自己<br>    链路： 只记录指定链路上的流量（指定资源从入口资源进来的流量，如果达到阈值，就进行限流）【api级别的针对来源】</p><p>6、流控效果：<br>    快速失败： 直接失败，抛异常<br>    Warm Up： 根据codeFactor（冷加载因子，默认3）的值，从阈值&#x2F;codeFctor，经过预热时长，才达到设置的QPS阈值<br>    排队等待： 匀速排队，让请求以匀速的速度通过，阈值类型必须设置为QPS，否则无效</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405251516505.png" alt="image.png"></p><h3 id="6-4-2、自定义异常处理"><a href="#6-4-2、自定义异常处理" class="headerlink" title="6.4.2、自定义异常处理"></a>6.4.2、自定义异常处理</h3><p>@SentinelResource的属性<br>1、value：作用指定资源名称，必填</p><p>2、entryType：entry类型，标记流量的方向，指明是出口流量，还是入口流量；取值 IN&#x2F;OUT ,默认是OUT。非必填</p><p>3、blockHandler：处理BlockException的函数名称，函数要求为必须是public返回类型与原方法一致。参数类型需要和原方法相匹配，并在最后加上BlockException类型的参数。默认需和原方法在同一个类中，如果希望使用其他类的函数，可配置blockHandlerClass,并指定blockHandlerClass里面的方法</p><p>4、blockHandlerClass：存放blockHandler的类。对应的处理函数必须static修饰，否则无法解析。函数要求为：必须是public，返回类型与原方法一致，参数类型需要和原方法相匹配，并在最后加上BlockException类型的参数</p><p>5、fallback：用于在抛出异常的时候提供fallback处理逻辑。fallback函数可以针对所有类型的异常（除了execptionsToIgnore 里面排除掉的异常类型）进行处理，函数要求为：返回类型与原方法一致参数类型需要和原方法相匹配，Sentinel 1.6版本之后，也可在方法最后加上Throwable类型的参数。默认需和原方法在同一个类中，若希望使用其他类的函数，可配置fallbackClass，并指定fallbackClass里面的方法</p><p>6、fallbackClass：存放fallback的类。对应的处理函数必须static修饰，否则无法解析，其他要求：同fallback。</p><p>7、defaultFallback：用于通用的 fallback 逻辑。默认fallback函数可以针对所有类型的异常（除了 exceptionsToIgnore 里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，以fallback为准。函数要求：<br>返回类型与原方法一致<br>方法参数列表为空，或者有一个Throwable类型的参数<br>默认需要和原方法在同一个类中，若希望使用其他类的函数，可配置fallbackclass，并指定fallbackClass里面的方法。</p><p>8、exceptionsToIgnore：指定排除掉哪些异常。排除的异常不会计入异常统计，也不会进入fallback逻辑，而是原样抛出</p><p>9、exceptionsToTrace：需要trace的异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span>  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RefreshScope</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;  </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;love.name&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String love;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/love&quot;)</span>  </span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;love&quot;,blockHandler = &quot;loveBlockHandler&quot;,blockHandlerClass = DepartController.class)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">love</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> love;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">loveBlockHandler</span><span class="params">(BlockException exception)</span>&#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;不好意思，前方拥挤，请您稍后再试&quot;</span>;  </span><br><span class="line">        <span class="keyword">return</span> msg;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意dashboard加流控规则的位置：</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405251603875.png" alt="image.png"></p><h2 id="6-5、熔断处理"><a href="#6-5、熔断处理" class="headerlink" title="6.5、熔断处理"></a>6.5、熔断处理</h2><p>对于qps或并发这种外界因素导致的问题，通过流控可以解决问题。但对于故障（如网络故障）导致的阻塞，通过流控无法解决。这里考虑使用熔断中断服务，避免请求堆积造成更大的系统问题（雪崩）。</p><h3 id="6-5-1、熔断规则策略"><a href="#6-5-1、熔断规则策略" class="headerlink" title="6.5.1、熔断规则策略"></a>6.5.1、熔断规则策略</h3><p>1、慢调用比例 (SLOW_REQUEST_RATIO)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断</p><p>2、异常比例 (ERROR_RATIO)：当单位统计时长（statIntervalMs）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 [0.0, 1.0]，代表 0% - 100%</p><p>3、异常数 (ERROR_COUNT)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断</p><blockquote><p>断路器工作流程：<br>一旦熔断，断路器的状态是Open(所有的请求都不能进来)<br>当熔断时长结束，断路器的状态是half-Open(可以允许一个请求进来)<br>如果接下来的请求正常，断路器的状态是close(资源就自恢复)<br>如果接下来的请求不正常，断路器的状态是open</p></blockquote><h3 id="6-5-2、熔断自定义异常处理"><a href="#6-5-2、熔断自定义异常处理" class="headerlink" title="6.5.2、熔断自定义异常处理"></a>6.5.2、熔断自定义异常处理</h3><p>1、定义资源和处理逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span>  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RefreshScope</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span>  </span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;hello&quot;,fallback = &quot;helloHandler&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hot</span><span class="params">(String id)</span> <span class="keyword">throws</span> InterruptedException &#123;  </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello sentinel&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">helloHandler</span><span class="params">(Throwable throwable)</span>&#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;熔断中...&quot;</span>;  </span><br><span class="line">        <span class="keyword">return</span> msg;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、配置熔断规则</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405262242741.png" alt="image.png"></p><h2 id="6-6、热点key限制"><a href="#6-6、热点key限制" class="headerlink" title="6.6、热点key限制"></a>6.6、热点key限制</h2><p>热点即经常访问的数据。很多时候我们希望统计某个热点数据中访问频次最高的 TopK数据，并对其访问进行限制。比如:用户 ID 为参数，针对一段时间内频繁访问的用户ID 进行限制热点参数限流会统计传入参数中的热点参数，并根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。热点参数限流可以看做是一种特殊的流量控制，仅对包含热点参数的资源调用生效。</p><h3 id="6-6-1、基本使用"><a href="#6-6-1、基本使用" class="headerlink" title="6.6.1、基本使用"></a>6.6.1、基本使用</h3><p>1、对应链路增加热点key限制</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405251751346.png" alt="image.png"></p><p>2、接口声明资源名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/provider/depart&quot;)</span>  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RefreshScope</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepartController</span> &#123;  </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hot&quot;)</span>  </span><br><span class="line">    <span class="meta">@SentinelResource(value = &quot;hot&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hot</span><span class="params">(String id)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;热点key&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、请求时携带参数：<a href="http://localhost:9081/provider/depart/hot?id=1">http://localhost:9081/provider/depart/hot?id=1</a></p><h2 id="6-7、权限规则"><a href="#6-7、权限规则" class="headerlink" title="6.7、权限规则"></a>6.7、权限规则</h2><p>授权规则是对请求者的身份做一个判断。所有请求都要经过网关，网关去做身份的认证，查看访问权限，怎么sentinel还有身份判断呢？所有请求经过网关路由的微服务，这个时候网关当然可以对请求做身份的认证了。但是万一啊，你们公司里出了个内鬼，他把你们微服务的地址泄露给了外边的那些不怀好意的人。那就可以绕过网关直接访问微服务了。网关里做的安全校验失效所以呢，Sentinel的授权规则可以解决这个问题，因为它可以去验证你的请求是从哪来的。如果说你是从网关过来的，我让你走，如果你是从别的地方过来的拦截</p><h3 id="6-7-1、基本使用"><a href="#6-7-1、基本使用" class="headerlink" title="6.7.1、基本使用"></a>6.7.1、基本使用</h3><ul><li>白名单：来源（origin）在白名单内的调用者允许访问</li><li>黑名单：来源（origin）在黑名单内的调用者不允许访问</li></ul><p>1、新增授权规则</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405261112780.png" alt="image.png"></p><p>2、客户端添加来源解析器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRequestOriginParser</span> <span class="keyword">implements</span> <span class="title class_">RequestOriginParser</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">parseOrigin</span><span class="params">(HttpServletRequest request)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">origin</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;origin&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> StringUtils.isEmpty(origin) ? <span class="string">&quot;xxxx&quot;</span> : origin;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特别注意：origin获取为空时要么直接报错（强权没问题），或者给默认值如上”xxxx”。否则授权失效</p></blockquote><h2 id="6-8、全局自定义异常处理"><a href="#6-8、全局自定义异常处理" class="headerlink" title="6.8、全局自定义异常处理"></a>6.8、全局自定义异常处理</h2><p>上面熔断，流控等自定义异常处理要指定rollback，还是比较麻烦，这里考虑使用全局自定义异常处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">全局异常处理器的定义:</span></span><br><span class="line"><span class="comment">定义一个类  并且带有@RestControllerAdvice注解</span></span><br><span class="line"><span class="comment">@ExceptionHandler注解指定要捕获的异常的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalException</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">globalException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        String msg=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> FlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被限流了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ParamFlowException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被热点参数限流&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> DegradeException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;请求被降级了&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> AuthorityException) &#123;</span><br><span class="line">            msg = <span class="string">&quot;没有权限访问&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg+=<span class="string">&quot;   全局异常处理器判断得到&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-9、规则持久化"><a href="#6-9、规则持久化" class="headerlink" title="6.9、规则持久化"></a>6.9、规则持久化</h2><table><thead><tr><th>推送模式</th><th>说明</th><th>优点</th><th>缺点</th><th></th></tr></thead><tbody><tr><td>原始模式</td><td>API将规则推送至客户端并直接更新到内存中</td><td>简单，无任何依赖</td><td>不保证一致性；规则保存在内存中，重启即消失。严重不建议用于生产环境</td><td></td></tr><tr><td>Pull模式</td><td>扩展写数据源（WritableDataSource），客户端主动向某个规则管理中心定期轮询拉取规则，这个规则中心可以是RDBMS、文件等</td><td>简单</td><td>不保证一致性；实时性不保证，拉取过于频繁也可能会有性能问题。</td><td></td></tr><tr><td>Push模式</td><td>扩展读数据源（ReadableDataSource），规则中心统一推送，客户端通过注册监听器的方式时刻监听变化，比如使用Nacos、Zookeeper等配置中心。这种方式有更好的实时性和一致性保证。生产环境下一般采用push模式的数据源。</td><td>规则持久化；一致性；快速</td><td>引入第三方依赖</td><td></td></tr></tbody></table><h3 id="6-9-1、pull模式"><a href="#6-9-1、pull模式" class="headerlink" title="6.9.1、pull模式"></a>6.9.1、pull模式</h3><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405272253044.png" alt="image.png"></p><p>pull模式的数据源（如本地文件、RDBMS等）一般是可写入的。使用时需要在客户端注册数据源：将对应的读数据源注册至对应的 RuleManager，将写数据源注册至transport的WritableDataSourceRegistry中</p><p>1、引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-extension<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、实现InitFunc接口，在init中处理DataSource初始化逻辑，并利用spi机制实现加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileDataSourceInit</span> <span class="keyword">implements</span> <span class="title class_">InitFunc</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RULE_FILE_PATH</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>) + File.separator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FLOW_RULE_FILE_NAME</span> <span class="operator">=</span> <span class="string">&quot;FlowRule.json&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理流控规则逻辑</span></span><br><span class="line">        dealFlowRules();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dealFlowRules</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleFilePath</span> <span class="operator">=</span> RULE_FILE_PATH + FLOW_RULE_FILE_NAME;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建流控规则的可读数据源</span></span><br><span class="line">        <span class="type">FileRefreshableDataSource</span> <span class="variable">flowRuleRDS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileRefreshableDataSource</span>(</span><br><span class="line">                ruleFilePath, source -&gt; JSON.parseObject((String) source,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TypeReference</span>&lt;List&lt;FlowRule&gt;&gt;() &#123;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将可读数据源注册至FlowRuleManager 这样当规则文件发生变化时，就会更新规则到内存</span></span><br><span class="line">        FlowRuleManager.register2Property(flowRuleRDS.getProperty());</span><br><span class="line"></span><br><span class="line">        WritableDataSource&lt;List&lt;FlowRule&gt;&gt; flowRuleWDS = <span class="keyword">new</span> <span class="title class_">FileWritableDataSource</span>&lt;&gt;(</span><br><span class="line">                ruleFilePath, <span class="built_in">this</span>::encodeJson</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将可写数据源注册至 transport 模块的 WritableDataSourceRegistry 中.</span></span><br><span class="line">        <span class="comment">// 这样收到控制台推送的规则时，Sentinel 会先更新到内存，然后将规则写入到文件中.</span></span><br><span class="line">        WritableDataSourceRegistry.registerFlowDataSource(flowRuleWDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; String <span class="title function_">encodeJson</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、在META-INF&#x2F;services目录下创建com.alibaba.csp.sentinel.init.InitFunc，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.morris.user.config.FileDataSourceInit</span><br></pre></td></tr></table></figure><p>这样当在Dashboard中修改了配置后，Dashboard会调用客户端的接口修改客户端内存中的值，同时将配置写入文件FlowRule.json中，这样操作的话规则是实时生效的，如果是直接修改FlowRule.json的内容，这样需要等定时任务3秒后执行才能读到最新的规则</p><h3 id="6-9-2、push模式"><a href="#6-9-2、push模式" class="headerlink" title="6.9.2、push模式"></a>6.9.2、push模式</h3><p>生产环境下一般更常用的是push模式的数据源。对于push模式的数据源，如远程配置中心（ZooKeeper, Nacos, Apollo等等），推送的操作不应由Sentinel客户端进行，而应该经控制台统一进行管理，直接进行推送，数据源仅负责获取配置中心推送的配置并更新到本地。因此推送规则正确做法应该是配置中心控制台&#x2F;Sentinel控制台 → 配置中心 → Sentinel数据源 → Sentinel，而不是经Sentinel数据源推送至配置中心。这样的流程就非常清晰了</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405272253061.png" alt="image.png"></p><p>1、引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-datasource-nacos<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、配置文件增加nacos数据源</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">sentinel:</span></span><br><span class="line">      <span class="attr">transport:</span></span><br><span class="line">        <span class="attr">dashboard:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8080</span></span><br><span class="line">      <span class="attr">web-context-unify:</span> <span class="literal">false</span> <span class="comment"># 默认将调用链路收敛，需要打开才可以进行链路流控</span></span><br><span class="line">      <span class="attr">datasource:</span></span><br><span class="line">        <span class="attr">flow-ds:</span></span><br><span class="line">          <span class="attr">nacos:</span></span><br><span class="line">            <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">            <span class="attr">dataId:</span> <span class="string">$&#123;spring.application.name&#125;-flow</span></span><br><span class="line">            <span class="attr">groupId:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">            <span class="attr">data-type:</span> <span class="string">json</span></span><br><span class="line">            <span class="attr">rule-type:</span> <span class="string">flow</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、最后在Nacos控制台新建一个<code>user-service-flow</code>的json配置，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/sentinel/chainB&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;controlBehavior&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;grade&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;limitApp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strategy&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>这样直接在Nacos控制台修改规则就能实时生效了，缺点是直接在Sentinel Dashboard中修改规则配置，配置中心的配置不会发生变化</p><p>原理简述<br>1、控制台推送规则：将规则推送到Nacos或其他远程配置中心；<br>2、Sentinel客户端链接Nacos，获取规则配置；并监听Nacos配置变化，如发生变化，就更新本地缓存（从而让本地缓存总是和Nacos一致）；<br>3、控制台监听Nacos配置变化，如发生变化就更新本地缓存（从而让控制台本地缓存总是和Nacos一致）</p><h1 id="7、网关-gateWay"><a href="#7、网关-gateWay" class="headerlink" title="7、网关 - gateWay"></a>7、网关 - gateWay</h1><p> 在微服务架构中，一个系统会被拆分为很多个微服务。那么作为客户端要如何去调用这么多的微服务呢？如果没有网关的存在，我们只能在客户端记录每个微服务的地址，然后分别去调用。这样肯定是不合理的。<br>为解决上面的问题所以引入了网关的概念：所谓的<strong>API网关</strong>，就是指系统的统一入口，提供内部服务的路由中转，为客户端提供统一服务，一些与业务本身功能无关的公共逻辑可以在这里实现，诸如认证、鉴权、监控、路由转发等</p><blockquote><p>你可能考虑到了nginx，使用nginx在配置文件中配置其实还是有硬编码的问题</p></blockquote><h2 id="7-1、gateWay核心概念"><a href="#7-1、gateWay核心概念" class="headerlink" title="7.1、gateWay核心概念"></a>7.1、gateWay核心概念</h2><p>Route（路由）：路由是构建网关的基础模块，它由ID，目标URI，包括一些列的断言和过滤器组成，如果断言为true则匹配该路由</p><p>Predicate（断言）：参考的是Java8的java.util.function.Predicate，开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），请求与断言匹配则进行路由</p><p>Filter（过滤）：指的是Spring框架中GateWayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改</p><blockquote><p>1、客户端向spring cloud gateway发出请求，然后在gateway handler mapping中找到与请求相匹配的路由<br>2、将其发送到gateway web handler<br>3、Handler再通过指定过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回</p></blockquote><h2 id="7-2、routes基本使用"><a href="#7-2、routes基本使用" class="headerlink" title="7.2、routes基本使用"></a>7.2、routes基本使用</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--naocs服务发现依赖--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!--使用nacos + ribbon做负载均衡时添加的loadbalancer依赖--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="comment">&lt;!--gateway网关依赖--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1、路由到指定URL</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">kaka-gateway</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">gateway:</span>  </span><br><span class="line">      <span class="attr">routes:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">baidu</span>  </span><br><span class="line">          <span class="attr">uri:</span> <span class="string">http://www.baidu.com</span>  </span><br><span class="line">          <span class="attr">predicates:</span>  </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/**</span></span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8040/">http://localhost:8040/</a>** 跳转到<a href="https://www.baidu.com/">https://www.baidu.com/</a>**</p><p>2、路由到微服务</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">kaka-gateway</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">gateway:</span>  </span><br><span class="line">      <span class="attr">routes:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">provider-8081</span>  </span><br><span class="line">          <span class="comment"># uri: http://localhost:9081/ </span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://depart-provider</span> </span><br><span class="line">          <span class="attr">predicates:</span>  </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/provider/depart/**</span></span><br></pre></td></tr></table></figure><h2 id="7-3、谓词断言工厂-predicates"><a href="#7-3、谓词断言工厂-predicates" class="headerlink" title="7.3、谓词断言工厂 - predicates"></a>7.3、谓词断言工厂 - predicates</h2><p>Route Predicate Factories（路由断言工厂）是Spring Cloud Gateway中的一种机制，用于定义路由规则中的断言条件。在Spring Cloud Gateway中，路由断言工厂允许基于HTTP请求的各种属性（例如路径、主机、请求方法、请求头等）来匹配和过滤路由。这些断言条件决定了请求是否会被路由到特定的目标服务</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202406052100706.png" alt="image.png"></p><p>1、The After Route Predicate Factory</p><p>After路由谓词工厂采用一个日期时间参数（java ZonedDateTime）。此谓词匹配指定日期时间之后发生的请求。以下示例配置后路由谓词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: after_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - After=2024-06-01T08:42:47.789+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure><p>该配置匹配北京时间2024-06-01 08:42:47.789以后的任何请求。</p><p>2、The Before Route Predicate Factory</p><p>与1类似，Before谓词匹配指定日期时间之前的任何请求，示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: before_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Before=2017-01-21T08:42:47.789+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure><p>该配置匹配北京时间2017-01-21 08:42:47.789以前的任何请求。</p><p>3、The Between Route Predicate Factory<br>Between路由谓词工厂有两个参数，与1)和2)相似，都是java ZonedDateTime对象。匹配两个时间之间的请求，参数2必须在参数1之后。以下示例配置了 Between 路由谓词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: between_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Between=2017-01-21T08:42:47.789+08:00[Asia/Shanghai], 2017-01-25T08:42:47.789+08:00[Asia/Shanghai]</span><br></pre></td></tr></table></figure><p>该谓词匹配北京时间2017-01-21 08:42:47.789到2017-01-25 08:42:47.789之间的请求。</p><p>4、The Cookie Route Predicate Factory<br>Cookie路由谓词工厂采用两个参数：name和regexp（Java 正则表达式）。此谓词匹配cookie中具有给定名称（key）且其值（value）与正则表达式匹配的请求。以下示例配置 cookie 路由谓词工厂：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: cookie_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Cookie=chocolate, ch.p</span><br></pre></td></tr></table></figure><p>在这个例子中，chocolate表示cookie中key为chocolate，而ch.p表示value为ch+任意一个字符+p，例如chip，chap，ch1p等，但是不能匹配chp、chiip。</p><p>5、The Header Route Predicate Factory<br>Header路由谓词工厂采用两个参数：header和 regexp（Java 正则表达式）。与Cookie路由谓词工厂类似，只是将键值对从cookie中转移到了header中。以下示例配置Header路由谓词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: header_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Header=X-Request-Id, \d+</span><br></pre></td></tr></table></figure><p>该谓词匹配header中有key为X-Request-Id、value匹配”\d+”即多个数字的请求。</p><p>6、The Host Route Predicate Factory</p><p>Host路由谓词工厂包含一个参数：主机名列表 patterns。该模式是 Ant 风格的模式，以.为分隔符。该谓词匹配Host与模式匹配的标头。以下示例配置主机路由谓词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: host_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Host=**.somehost.org,**.anotherhost.org</span><br></pre></td></tr></table></figure><p>该谓词匹配例如<a href="http://www.somehost.org、image.somehost.org的请求,即任意开头+"somehost.org"或者"anotherhost.org"结尾的主机的请求./">www.somehost.org、image.somehost.org的请求，即任意开头+&quot;somehost.org&quot;或者&quot;anotherhost.org&quot;结尾的主机的请求。</a></p><p>7、The Method Route Predicate Factory<br>Method路由谓词工厂包含methods参数，该参数可能是一个或多个参数，如POST、GET等。以下示例配置method路由谓词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: method_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Method=GET,POST</span><br></pre></td></tr></table></figure><p>该谓词匹配所有GET、POST请求。</p><p>8、The Path Route Predicate Factory<br>Path路由谓词工厂包含两个参数：一个 Spring 列表PathMatcher patterns和一个名为 matchTrailingSlash 的可选标志（默认为true）。以下示例配置路径路由谓词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: path_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Path=/red/&#123;segment&#125;,/blue/&#123;segment&#125;,matchTrailingSlash=false</span><br></pre></td></tr></table></figure><p>该谓词匹配&#x2F;red或者&#x2F;blue开头，且后面还有路径段的请求，如&#x2F;red&#x2F;apple，&#x2F;red&#x2F;apple&#x2F;banana等，参数matchTrailingSlash&#x3D;false表示忽略段尾的&#x2F;，即将&#x2F;red&#x2F;apple和&#x2F;red&#x2F;apple&#x2F;视为相同的请求，如果设置为true，则会根据规则区分这两种路径段。</p><p>9、The Query Route Predicate Factory<br>Query路由谓词工厂有两个参数：一个必需参数param和一个可选参数regexp（ Java 正则表达式）。以下示例配置Query路由谓词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: query_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Query=green</span><br></pre></td></tr></table></figure><p>该谓词匹配查询参数中包含green的请求，如<a href="http://www.example.org/get?green=1%E3%80%82">www.example.org/get?green=1。</a></p><p>10、The RemoteAddr Route Predicate Factory</p><p>RemoteAddr路由谓词工厂的参数为一个列表（sources，最小大小为 1），它们是 CIDR 表示法（IPv4 或 IPv6）字符串，例如192.168.0.1&#x2F;16（其中192.168.0.1是 IP 地址，16是子网掩码）。以下示例配置 RemoteAddr 路由谓词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: remoteaddr_route</span><br><span class="line">        uri: https://example.org</span><br><span class="line">        predicates:</span><br><span class="line">        - RemoteAddr=192.168.1.1/24</span><br></pre></td></tr></table></figure><p>该谓词匹配请求来源的ip与子网掩码为192.168.1.1&#x2F;24的请求。</p><p>11、The Weight Route Predicate Factory</p><p>Weight路由谓词工厂有两个参数：group和weight。权重分组计算。以下示例配置Weight路由谓词：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">      - id: weight_high</span><br><span class="line">        uri: https://weighthigh1111.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Weight=group1, 8</span><br><span class="line">      - id: weight_low</span><br><span class="line">        uri: https://weightlow2222.org</span><br><span class="line">        predicates:</span><br><span class="line">        - Weight=group1, 2</span><br></pre></td></tr></table></figure><p>该配置表示大约80%的请求会发送到<a href="https://weighthigh1111.org，20%的请求会发送到https://weightlow2222.org。">https://weighthigh1111.org，20%的请求会发送到https://weightlow2222.org。</a></p><h2 id="7-4、过滤器-filters"><a href="#7-4、过滤器-filters" class="headerlink" title="7.4、过滤器 - filters"></a>7.4、过滤器 - filters</h2><p>Gateway过滤器是Spring Cloud Gateway提供的一种机制，用于对进入网关的请求和返回进行处理和转换。它可以用于实现各种功能，如请求鉴权、请求转发、请求限流、请求重试等</p><h3 id="7-4-1、内置过滤器"><a href="#7-4-1、内置过滤器" class="headerlink" title="7.4.1、内置过滤器"></a>7.4.1、内置过滤器</h3><p>Spring官网给我们提供了很多很多中不同的过滤器，这里就简单列举几个</p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">AddRequestHeader</td><td align="left">给当前请求添加一个请求头</td></tr><tr><td align="left"><span style="color: rgb(209, 209, 209);">RemoveRequestHeader</span></td><td align="left">移除请求中的一个请求头</td></tr><tr><td align="left">AddResponseHeader</td><td align="left">给响应结果添加一个响应头</td></tr><tr><td align="left">RemoveResponseHeader</td><td align="left">从响应结果中移除一个响应头</td></tr><tr><td align="left">RequestRateLimiter</td><td align="left">限制请求的流量</td></tr></tbody></table><p><strong>局部路由生效</strong>：可以将过滤器配置设置在yml文件中路由id的下一级，如下所示：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">kaka-gateway</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">gateway:</span>  </span><br><span class="line">      <span class="attr">routes:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">provider-8081</span>  </span><br><span class="line"><span class="comment">#          uri: http://localhost:9081  </span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://depart-provider</span>  </span><br><span class="line">          <span class="attr">predicates:</span>  </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/provider/depart/**</span>  </span><br><span class="line">          <span class="attr">filters:</span>  </span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=token,kaka</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/love&quot;)</span>  </span><br><span class="line"><span class="meta">@SentinelResource(value = &quot;love&quot;,blockHandler = &quot;loveBlockHandler&quot;,blockHandlerClass = DepartController.class)</span>  </span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">love</span><span class="params">(<span class="meta">@RequestHeader(&quot;token&quot;)</span> String token)</span> &#123;  </span><br><span class="line">    System.out.println(token);  </span><br><span class="line">    <span class="keyword">return</span> love;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-2、自定义过滤器"><a href="#7-4-2、自定义过滤器" class="headerlink" title="7.4.2、自定义过滤器"></a>7.4.2、自定义过滤器</h3><p>命名规范：过滤器工厂类名必须以GatewayFilterFactory为后缀</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalTimeGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;MyConfig&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CalTimeGatewayFilterFactory</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(MyConfig.class);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> GatewayFilter <span class="title function_">apply</span><span class="params">(MyConfig config)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GatewayFilter</span>() &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;  </span><br><span class="line">                <span class="comment">// 此处传来的config没用，这里只做打印显示测试  </span></span><br><span class="line">                System.out.println(config.getKey());  </span><br><span class="line">                System.out.println(config.getValue());  </span><br><span class="line">                <span class="comment">// 记录开始时间  </span></span><br><span class="line">                <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">                <span class="comment">// 放行  </span></span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange).then(  </span><br><span class="line">                        Mono.fromRunnable(() -&gt; &#123;  </span><br><span class="line">                            <span class="comment">// filter后处理  </span></span><br><span class="line">                            <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">                            System.out.println(<span class="string">&quot;total:&quot;</span> + (endTime - startTime));  </span><br><span class="line">                        &#125;)  </span><br><span class="line">                );  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">shortcutFieldOrder</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置文件进行配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span>  </span><br><span class="line">  <span class="attr">application:</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">kaka-gateway</span>  </span><br><span class="line">  <span class="attr">cloud:</span>  </span><br><span class="line">    <span class="attr">gateway:</span>  </span><br><span class="line">      <span class="attr">routes:</span>  </span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">provider-8081</span>  </span><br><span class="line"><span class="comment">#          uri: http://localhost:9081  </span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://depart-provider</span>  </span><br><span class="line">          <span class="attr">predicates:</span>  </span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/provider/depart/**</span>  </span><br><span class="line">          <span class="attr">filters:</span>  </span><br><span class="line">            <span class="bullet">-</span> <span class="string">CalTime=a,b</span></span><br></pre></td></tr></table></figure><h2 id="7-4-3、全局过滤器"><a href="#7-4-3、全局过滤器" class="headerlink" title="7.4.3、全局过滤器"></a>7.4.3、全局过滤器</h2><p>全局过滤器不和具体的路由关联，作用在所有路由上，不需要配置。通过全局过滤器可以实现对权限的统一校验，安全性校验等</p><p>实现方法：实现GlobalFilter接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局打印请求路径</span></span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;  </span><br><span class="line">    Logger log=  LoggerFactory.getLogger(<span class="built_in">this</span>.getClass());  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;  </span><br><span class="line">        log.info(exchange.getRequest().getPath().value());  </span><br><span class="line">        <span class="keyword">return</span> chain.filter(exchange);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** 数字越小越先执行 */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> springCloud </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/posts/49176.html"/>
      <url>/posts/49176.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><h2 id="1-1、基本概念"><a href="#1-1、基本概念" class="headerlink" title="1.1、基本概念"></a>1.1、基本概念</h2><p>Docker本身是一个容器运行载体或称之为管理引擎。我们把引用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例</p><blockquote><p>比较Docker和传统虚拟化方式的不同之处：<br> 1.传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需要应用进程；<br> 2.容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便；<br> 3.每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源</p></blockquote><h2 id="1-2、Docker组成"><a href="#1-2、Docker组成" class="headerlink" title="1.2、Docker组成"></a>1.2、Docker组成</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/20240515145403.png" alt="image.png"></p><p>们发现在安装docker时，不仅会安装docker engine与docker cli工具，而且还会安装containerd，这是为什么呢？</p><p>Docker最初是一个单体引擎，主要负责容器镜像的制作、上传、拉取及容器的运行及管理。随着容器技术的繁荣发展，为了促进容器技术相关的规范生成和Docker自身项目的发展，Docker将单体引擎拆分为三部分，分别为runC、containerd和dockerd</p><p>其中：</p><ul><li>runC主要负责容器的运行和生命周期的管理（即低层运行时）</li><li>containerd主要负责容器镜像的下载和解压等镜像管理功能（即高层运行时）</li><li>dockerd主要负责提供镜像制作、上传等功能同时提供容器存储和网络的映射功能，同时也是Docker服务器端的守护进程，用来响应Docker客户端（命令行CLI工具）发来的各种容器、镜像管理的任务。</li></ul><p>Docker公司将runC捐献给了OCI，将containerd捐献给了CNCF，剩下的dockerd作为Docker运行时由Docker公司自己维护。</p><h1 id="2、Docker的安装"><a href="#2、Docker的安装" class="headerlink" title="2、Docker的安装"></a>2、Docker的安装</h1><blockquote><p>关于Docker版本：<br>Docker-ce Docker社区版，主要用于个人开发者测试使用，免费版本<br>Docker-ee Docker企业版，主要用于为企业开发及应用部署使用，收费版本，免费试用一个月，2020年因国际政治原因曾一度限制中国企业使用。</p></blockquote><p>安装环境：CentOS 7.3+</p><p>1、如果之前安装了旧版docker，请先删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p>2、安装仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>3、安装docker engine</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure><p>4、启动docker，运行hello world，查看是否成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>5、配置国内镜像仓库地址<br>新建&#x2F;etc&#x2F;docker&#x2F;daemon.json文件，输入如下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://fsp2sfpr.mirror.aliyuncs.com/&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>6、然后重启，配置开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br><span class="line">systemctl enable docker</span><br><span class="line">systemctl enable containerd</span><br></pre></td></tr></table></figure><h1 id="3、docker-run开箱即用"><a href="#3、docker-run开箱即用" class="headerlink" title="3、docker run开箱即用"></a>3、docker run开箱即用</h1><h2 id="3-1、docker架构"><a href="#3-1、docker架构" class="headerlink" title="3.1、docker架构"></a>3.1、docker架构</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/20240517143534.png" alt="image.png"></p><p><strong>registry 镜像仓库</strong></p><p>registry可以理解为镜像仓库，用于保存docker image。</p><p>Docker Hub 是docker官方的镜像仓库，docker命令默认从docker hub中拉取镜像。我们也可以搭建自己的镜像仓库。</p><p><strong>image 镜像</strong></p><p>image可以理解为一个只读的应用模板。image包含了应用程序及其所需要的依赖环境，例如可执行文件、环境变量、初始化脚本、启动命令等。</p><p><strong>container 容器</strong></p><p>容器是image的一个运行实例。当我们运行一个image，就创建了一个容器。</p><h2 id="3-2、docker-pull拉取镜像"><a href="#3-2、docker-pull拉取镜像" class="headerlink" title="3.2、docker pull拉取镜像"></a>3.2、docker pull拉取镜像</h2><p>从镜像仓库拉取镜像到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx 不写默认是latest</span><br><span class="line">docker pull nginx:latest</span><br><span class="line">docker pull nginx:1.22</span><br><span class="line">docker pull nginx:1.22.0-alpine</span><br></pre></td></tr></table></figure><p>一般不建议使用latest，因为最新的镜像是滚动更新的，过一段时间，可能跟你本地的不是同一个。<br>使用docker images命令查看本地镜像</p><h2 id="3-3、docker-run命令"><a href="#3-3、docker-run命令" class="headerlink" title="3.3、docker run命令"></a>3.3、docker run命令</h2><p>docker run [可选参数] 镜像名:版本 []</p><p>1、公开端口（-P）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-nginx -d -p 8080:80 nginx:1.22</span><br><span class="line">默认情况下，容器无法通过外部网络访问。</span><br><span class="line">需要使用-p参数将容器的80端口映射到宿主机8080端口，才可以通过宿主机IP进行访问。</span><br><span class="line">浏览器打开 http://192.168.56.106:8080</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、后台运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name db-mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br></pre></td></tr></table></figure><blockquote><p>使用run命令，部署mysql，docker先去本地查找镜像，如果找不到，就去docker hub中拉取镜像<br>–name 定义容器的名称<br>-e 声明环境变量<br>-d容器在后台运行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看运行ip</span></span><br><span class="line">docker inspect \</span><br><span class="line">--format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; db-mysql</span><br></pre></td></tr></table></figure><p>3、前台交互运行</p><p>创建一个新的容器，使用mysql客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm mysql:5.7 mysql -h172.17.0.2 -uroot -p</span><br></pre></td></tr></table></figure><blockquote></blockquote><p>-it 使用交互模式，可以在控制台里输入、输出<br>–rm在容器退出时自动删除容器。一般在使用客户端程序时使用此参数。<br>如果每次使用客户端都创建一个新的容器，这样将占用大量的系统空间。<br>mysql -h172.17.0.2 -uroot -p表示启动容器时执行的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span>在运行的容器中执行命令，一般配合-it参数使用交互模式</span></span><br><span class="line">docker exec -it db-mysql /bin/bash</span><br></pre></td></tr></table></figure><h2 id="3-4、常用命令"><a href="#3-4、常用命令" class="headerlink" title="3.4、常用命令"></a>3.4、常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看正在运行的容器</span></span><br><span class="line">docker ps </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有容器，包括正在运行和停止的</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器信息</span></span><br><span class="line">docker inspect</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看日志</span></span><br><span class="line">docker logs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在容器和宿主机间复制文件</span></span><br><span class="line">docker cp ./some_file 容器名:/work</span><br><span class="line">docker cp 容器名:/var/logs/ /tmp/app_logs</span><br></pre></td></tr></table></figure><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/20240515161620.png" alt="image.png|625"></p><h1 id="4、Docker网络"><a href="#4、Docker网络" class="headerlink" title="4、Docker网络"></a>4、Docker网络</h1><h2 id="4-1、默认网络"><a href="#4-1、默认网络" class="headerlink" title="4.1、默认网络"></a>4.1、默认网络</h2><p>docker会自动创建三个网络，bridge,host,none</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/20240517150727.png" alt="image.png"></p><p>1、bridge桥接网络</p><p>如果不指定，新创建的容器默认将连接到bridge网络。<br>默认情况下，使用bridge网络，宿主机可以ping通容器ip，容器中也能ping通宿主机。<br>容器之间只能通过 IP 地址相互访问，由于容器的ip会随着启动顺序发生变化，因此不推荐使用ip访问。</p><p>2、host</p><p>慎用，可能会有安全问题。<br>容器与宿主机共享网络，不需要映射端口即可通过宿主机IP访问。（-p选项会被忽略）<br>主机模式网络可用于优化性能，在容器需要处理大量端口的情况下，它不需要网络地址转换 （NAT），并且不会为每个端口创建“用户空间代理”。</p><p>3、none</p><p>禁用容器中所用网络，在启动容器时使用</p><h2 id="4-2、用户自定义网络"><a href="#4-2、用户自定义网络" class="headerlink" title="4.2、用户自定义网络"></a>4.2、用户自定义网络</h2><p>创建用户自定义网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create my-net</span><br></pre></td></tr></table></figure><p>将已有容器连接到此网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect my-net db-mysql</span><br></pre></td></tr></table></figure><p>创建容器时指定网络</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --network my-net mysql:5.7 mysql -h**db-mysql** -uroot -p</span><br></pre></td></tr></table></figure><p>在用户自定义网络上，容器之间可以通过容器名进行访问。</p><p>用户自定义网络使用 Docker 的嵌入式 DNS 服务器将容器名解析成 IP。</p><h1 id="5、docker存储"><a href="#5、docker存储" class="headerlink" title="5、docker存储"></a>5、docker存储</h1><p>将数据存储在容器中，一旦容器被删除，数据也会被删除。同时也会使容器变得越来越大，不方便恢复和迁移。</p><p>将数据存储到容器之外，这样删除容器也不会丢失数据。一旦容器故障，我们可以重新创建一个容器，将数据挂载到容器里，就可以快速的恢复</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/20240517153044.png" alt="image.png"></p><h2 id="5-1、挂载绑定（bind-mount）"><a href="#5-1、挂载绑定（bind-mount）" class="headerlink" title="5.1、挂载绑定（bind mount）"></a>5.1、挂载绑定（bind mount）</h2><p>绑定挂载可以将主机文件系统上目录或文件装载到容器中，但是主机上的非 Docker 进程可以修改它们，同时在容器中也可以更改主机文件系统，包括创建、修改或删除文件或目录，使用不当，可能会带来安全隐患</p><p>绑定挂载适用以下场景：</p><ul><li>将配置文件从主机共享到容器。</li><li>在 Docker 主机上的开发环境和容器之间共享源代码或编译目录。</li><li>例如，可以将 Maven 的<code>target/</code>目录挂载到容器中，每次在主机上用 Maven打包项目时，容器内都可以使用新编译的程序包</li></ul><p>1、-V</p><p>绑定挂载将主机上的目录或者文件装载到容器中。绑定挂载会覆盖容器中的目录或文件<br>如果宿主机目录不存在，docker会自动创建这个目录。但是docker只自动创建文件夹，不会创建文件。<br>例如，mysql的配置文件和数据存储目录使用主机的目录。可以将配置文件设置为只读（read-only）防止容器更改主机中的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">           -v /home/mysql/mysql.cnf:/etc/mysql/conf.d/mysql.cnf:ro  \</span><br><span class="line">           -v /home/mysql/data:/var/lib/mysql  \</span><br><span class="line">           -d mysql:5.7 </span><br></pre></td></tr></table></figure><p>2、–tmpfs临时挂载<br>临时挂载将数据保留在主机内存中，当容器停止时，文件将被删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -it --tmpfs /tmp nginx:1.22-alpine</span><br></pre></td></tr></table></figure><h2 id="5-2、volume卷"><a href="#5-2、volume卷" class="headerlink" title="5.2、volume卷"></a>5.2、volume卷</h2><p>卷 是docker 容器存储数据的首选方式，卷有以下优势：</p><ul><li>卷可以在多个正在运行的容器之间共享数据。仅当显式删除卷时，才会删除卷。</li><li>当你想要将容器数据存储在外部网络存储上或云提供商上，而不是本地时。</li><li>卷更容易备份或迁移，当您需要备份、还原数据或将数据从一个 Docker 主机迁移到另一个 Docker 主机时，卷是更好的选择。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">docker volume create my-data</span><br><span class="line"></span><br><span class="line">docker run -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">           -v /home/mysql/conf.d/my.cnf:/etc/mysql/conf.d/my.cnf:ro  \</span><br><span class="line">           -v my-data:/var/lib/mysql  \</span><br><span class="line">           -d mysql:5.7 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建nfs卷</span></span><br><span class="line">docker volume create --driver local \</span><br><span class="line">    --opt type=nfs \</span><br><span class="line">    --opt o=addr=192.168.1.1,rw \</span><br><span class="line">    --opt device=:/path/to/dir \</span><br><span class="line">    vol-nfs</span><br></pre></td></tr></table></figure><h1 id="6、部署自己的应用"><a href="#6、部署自己的应用" class="headerlink" title="6、部署自己的应用"></a>6、部署自己的应用</h1><p>本例子我们使用docker来部署一个RuoYi应用系统<br>将源码编译打包成ruoyi-admin.jar文件，放到宿主机&#x2F;home&#x2F;app目录下，&#x2F;home&#x2F;app&#x2F;sql目录下是数据库初始化脚本</p><p>1、准备工作：创建网络和存储卷</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create ruoyi-data</span><br><span class="line">docker network create ruoyi-net</span><br></pre></td></tr></table></figure><p>2、部署mysql并初始化数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">           -e MYSQL_DATABASE=ry \</span><br><span class="line"> -v /home/app/sql:/docker-entrypoint-initdb.d \</span><br><span class="line">           -v ruoyi-data:/var/lib/mysql  \</span><br><span class="line">         --network ruoyi-net \</span><br><span class="line">           --name ruoyi-db \</span><br><span class="line">           -d mysql:5.7 \</span><br><span class="line">           --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure><p>3、部署应用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8080:8080 \</span><br><span class="line"> -v /home/app/ruoyi-admin.jar:/usr/local/src/ruoyi-admin.jar \</span><br><span class="line">         --network ruoyi-net \</span><br><span class="line">           --name ruoyi-java \</span><br><span class="line"> -d openjdk:8u342-jre \</span><br><span class="line">           java -jar /usr/local/src/ruoyi-admin.jar</span><br></pre></td></tr></table></figure><h1 id="7、Docker-compose容器编排"><a href="#7、Docker-compose容器编排" class="headerlink" title="7、Docker compose容器编排"></a>7、Docker compose容器编排</h1><p>在实际工作中，部署一个应用可能需要部署多个容器，一个一个部署非常不方便。docker compose可以一键部署和启动多个容器，它使用yaml文件来编排服务。</p><p>github和docker hub很多项目都提供了docker-compose.yaml文件，我们可以一键部署项目，非常方便</p><h2 id="7-1、compose文件结构"><a href="#7-1、compose文件结构" class="headerlink" title="7.1、compose文件结构"></a>7.1、compose文件结构</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span>  <span class="comment"># 指定Compose文件的版本</span></span><br><span class="line"><span class="attr">services:</span>     <span class="comment"># 定义应用程序服务</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nginx</span>  <span class="comment"># 指定服务的Docker镜像</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span>  <span class="comment"># 映射端口</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./html:/usr/share/nginx/html</span>  <span class="comment"># 挂载卷</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">example</span>  <span class="comment"># 设置环境变量</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">networks:</span>   <span class="comment"># 定义网络</span></span><br><span class="line">  <span class="attr">front-tier:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">volumes:</span>    <span class="comment"># 定义卷</span></span><br><span class="line">  <span class="attr">db-data:</span></span><br></pre></td></tr></table></figure><h2 id="7-2、一键部署wordpress"><a href="#7-2、一键部署wordpress" class="headerlink" title="7.2、一键部署wordpress"></a>7.2、一键部署wordpress</h2><p>wordpress是一个著名的开源博客系统。<br>将以下内容保存到本地的docker-compose.yml文件中。<br>docker compose命令启动时，默认在当前目录下寻找compose.yaml或compose.yml，<br>为了兼容之前的版本，也会查找docker-compose.yaml或docker-compose.yml。<br>也可以使用-f参数手动指定文件docker compose -f docker-compose-dev.yml up -d</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span> </span><br><span class="line"></span><br><span class="line">  <span class="attr">ruoyi-app:</span></span><br><span class="line">    <span class="comment">#  docker run --name ruoyi-app      \</span></span><br><span class="line">    <span class="comment">#             -p 8080:8080        \</span></span><br><span class="line">    <span class="comment">#             --network ruoyi-net      \</span></span><br><span class="line">    <span class="comment">#             -v /home/app/ruoyi-admin.jar:/usr/local/src/ruoyi-admin.jar   \</span></span><br><span class="line">    <span class="comment">#             -d openjdk:8u342-jre    \</span></span><br><span class="line">    <span class="comment">#             java -jar /usr/local/src/ruoyi-admin.jar</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">openjdk:8u342-jre</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ruoyi-net</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/app/ruoyi-admin.jar:/usr/local/src/ruoyi-admin.jar</span></span><br><span class="line">    <span class="attr">command:</span> [ <span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/usr/local/src/ruoyi-admin.jar&quot;</span> ]</span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost:8080&quot;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="attr">ruoyi-db:</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">service_healthy</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">ruoyi-db:</span></span><br><span class="line">    <span class="comment">#  docker run --name ruoyi-db -p 3303:3306 \</span></span><br><span class="line">    <span class="comment">#             --network ruoyi-net        \</span></span><br><span class="line">    <span class="comment">#             -v ruoyi-data:/var/lib/mysql  \</span></span><br><span class="line">    <span class="comment">#             -v /home/app/sql:/docker-entrypoint-initdb.d   \</span></span><br><span class="line">    <span class="comment">#             -e MYSQL_DATABASE=ry         \</span></span><br><span class="line">    <span class="comment">#             -e MYSQL_ROOT_PASSWORD=123456    \</span></span><br><span class="line">    <span class="comment">#             -d mysql:5.7      \</span></span><br><span class="line">    <span class="comment">#             --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci --skip-character-set-client-handshake</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_DATABASE=ry</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">MYSQL_ROOT_PASSWORD=123456</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ruoyi-data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/home/app/sql:/docker-entrypoint-initdb.d</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ruoyi-net</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      [</span><br><span class="line">        <span class="string">&quot;--character-set-server=utf8mb4&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--collation-server=utf8mb4_unicode_ci&quot;</span>,</span><br><span class="line">        <span class="string">&quot;--skip-character-set-client-handshake&quot;</span></span><br><span class="line">      ]</span><br><span class="line">    <span class="attr">healthcheck:</span></span><br><span class="line">      <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&#x27;mysqladmin&#x27;</span>, <span class="string">&#x27;ping&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>, <span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;-p$$MYSQL_ROOT_PASSWORD&#x27;</span>]</span><br><span class="line">      <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">      <span class="attr">timeout:</span> <span class="string">5s</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">start_period:</span> <span class="string">10s</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">ruoyi-data:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">ruoyi-net:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相关命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">一键部署启动</span></span><br><span class="line">docker compose up -d </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动/停止服务</span></span><br><span class="line">docker compose start/stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止并删除容器，不会删除存储卷volume</span></span><br><span class="line">docker compose down </span><br></pre></td></tr></table></figure><h1 id="8、Dockerfile镜像制作"><a href="#8、Dockerfile镜像制作" class="headerlink" title="8、Dockerfile镜像制作"></a>8、Dockerfile镜像制作</h1><p>dockerfile通常包含以下几个常用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY . .</span><br><span class="line">RUN make .</span><br><span class="line">CMD python app.py</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure><p><code>FROM</code> 打包使用的基础镜像<br><code>WORKDIR</code>相当于<code>cd</code>命令，进入工作目录<br><code>COPY</code> 将宿主机的文件复制到容器内<br><code>RUN</code>打包时执行的命令，相当于打包过程中在容器中执行shell脚本，通常用来安装应用程序所需要的依赖、设置权限、初始化配置文件等<br><code>CMD</code>运行镜像时执行的命令<br><code>EXPOSE</code>指定容器在运行时监听的网络端口，它并不会公开端口，仅起到声明的作用，公开端口需要容器运行时使用-p参数指定。</p><h2 id="8-1、制作自己的镜像"><a href="#8-1、制作自己的镜像" class="headerlink" title="8.1、制作自己的镜像"></a>8.1、制作自己的镜像</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8u342-jre</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY ./ruoyi-admin.jar .</span><br><span class="line">CMD [ &quot;java&quot;, &quot;-jar&quot;, &quot;ruoyi-admin.jar&quot; ]</span><br><span class="line">EXPOSE 8080</span><br></pre></td></tr></table></figure><p>docker build . 打包</p><h2 id="8-2、image镜像与layer层"><a href="#8-2、image镜像与layer层" class="headerlink" title="8.2、image镜像与layer层"></a>8.2、image镜像与layer层</h2><p>image文件由一系列层构建而成，dockerfile每一个命令都会生成一个层，每一层都是只读的<br>可以使用：docker image history + 镜像名 命令查看</p><p>创建容器时，会创建一个新的可写层，通常称为“容器层”，对正在运行的容器所做的所有更改（如写入新文件，修改现有文件或删除文件）都将写入容器层而不会修改镜像</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202405181122438.png" alt="image.png"></p><h2 id="8-3、多阶段构建"><a href="#8-3、多阶段构建" class="headerlink" title="8.3、多阶段构建"></a>8.3、多阶段构建</h2><p>在构建基于java应用时，需要一个JDK将源码编译为java字节码，但是在生产环境中不需要该JDK。多阶段构建可以将生成时依赖和运行时依赖分开，减少整个image文件大小</p><p>以maven&#x2F;tomcat为例。使用 Maven来构建应用，在最终的image中不需要包含maven。我们可以使用多阶段构建，每一个阶段从<code>FROM</code>开始，最终的image只会从最后一个阶段构建，不会包含前面阶段产生的层，因此可以减少镜像体积</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM maven AS build</span><br><span class="line">WORKDIR /source</span><br><span class="line">COPY . .</span><br><span class="line">RUN mvn package</span><br><span class="line"></span><br><span class="line">FROM  openjdk:8u342-jre</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY --from=build /source/ruoyi-admin/target/ruoyi-admin.jar .</span><br><span class="line">EXPOSE 80</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;ruoyi-admin.jar&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>ENTRYPOINT和CMD的区别：<br>dockerfile至少应包含一个ENTRYPONIT和CMD<br>ENTRYPOINT指定容器启动时执行的默认程序，一般运行容器时不会被替换或覆盖，除非使用–entrypoint进行指定<br>cmd可以在容器启动时被替换或覆盖</p></blockquote><h1 id="9、私有仓库"><a href="#9、私有仓库" class="headerlink" title="9、私有仓库"></a>9、私有仓库</h1><p>我们可以使用docker push将自己的image推送到docker hub中进行共享，但是在实际工作中，很多公司的代码不能上传到公开的仓库中，因此我们可以创建自己的镜像仓库。<br>docker 官网提供了一个docker registry的私有仓库项目，可以方便的通过docker部署。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart always --name registry registry:2 </span><br><span class="line">docker image tag ruoyi-java:4.7.4 localhost:5000/ruoyi-java:4.7.4</span><br><span class="line">docker push localhost:5000/ruoyi-java:4.7.4</span><br><span class="line">docker pull localhost:5000/ruoyi-java:4.7.4</span><br></pre></td></tr></table></figure><h1 id="10、镜像导入导出"><a href="#10、镜像导入导出" class="headerlink" title="10、镜像导入导出"></a>10、镜像导入导出</h1><p>当我们处于离线状态，比如在很多内网上不能访问互联网，这时候不能通过镜像仓库的方式共享image，我们可以使用导出和导入功能，手动拷贝镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker save会包含所有层，以及所有标签 + 版本信息</span></span><br><span class="line">docker save alpine:3.15 &gt; alpine-3.15.tar</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载image</span></span><br><span class="line">docker load &lt; alpine-3.15.tar </span><br></pre></td></tr></table></figure><blockquote><p>注意：<br> 不要跟export和import命令混淆<br> docker save&#x2F;load IMAGE save和load操作的是镜像<br> docker export&#x2F;import CONTAINER export和import操作对象是容器<br> image包含多个层，每一层都不可变，save保存的信息包含每个层和所有标签 + 版本信息。<br> 容器运行的时候会创建一个可写入的容器层，所有的更改都写入容器层，export导出的只有容器层，不包含父层和标签信息。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> docker </tag>
            
            <tag> 容器化技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PBRTQC</title>
      <link href="/posts/22105.html"/>
      <url>/posts/22105.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h1><h2 id="1-1、PBRTQC"><a href="#1-1、PBRTQC" class="headerlink" title="1.1、PBRTQC"></a>1.1、PBRTQC</h2><p>基于患者样本的实时质量控制（patient-based real-time quality control，PBRTQC）系统是一种基于统计学以及数学模型的质量控制方法，是根据患者样本检测结果，利用统计学模型建立的一套以实时监测实验室检测质量的模型或者规则，是医学检验实验室提高质量控制体系的重要发展方向，最早由Hoffmann和Waid于1965年提出</p><h2 id="1-2、PBRTQC模型"><a href="#1-2、PBRTQC模型" class="headerlink" title="1.2、PBRTQC模型"></a>1.2、PBRTQC模型</h2><ol><li>五个关键参数：上截断值（UTL）、下截断值（LTL）、浮动窗口大小（N）、上控制限（UCL）、下控制限（LCL）</li><li>排除规则：对于偏态分布以及存在极端值的分布数据，应选择一个适宜的截断值区间，将在截断值区间外的数据进行缩尾或者去除</li><li>SPC算法：浮动均值（MA）、浮动分位数（MQ）、指数加权移动平均值（EWMA）用于监测定值误差（CE）和百分比误差（PE）；浮动标准差（MovSD）、浮动非正常值患者数（MovSO）用于监测随机误差（RE）</li><li>控制限：1. 分布法：通过分析历史数据生成的PBRTQC计算值，得出计算值的均值与标准差，根据正态分布或其它分布特征计算出对应的控制限<br>    2. 百分位点法：根据目标假阳性报警率（DFAR），如0.1%，考虑双边的情况下，那么控制限则为历史数据PBRTQC计算值的0.05%和99.95%百分位数点</li></ol><h2 id="1-3、模型评估指标"><a href="#1-3、模型评估指标" class="headerlink" title="1.3、模型评估指标"></a>1.3、模型评估指标</h2><ol><li>假阳性报警率（FAR）：指误报次数与样本数的比值，文献中通常要求该值≤0.1%，即每进行1000例患者样本的实时质控，最多允许1次误报，表征模型的特异性，FAR越小，模型特异性越好</li><li>误差检出前平均患者样本数（ANPed）：误差出现时至模型检测出误差所经历的患者样本例数，表征模型的灵敏度，例数越少，模型灵敏度越高</li><li>二者关系：二者之间存在矛盾关系，FAR越低，ANPed越大，实际应用中应综合考虑，能满足当前项目的需求即可</li></ol><h1 id="2、实现简要流程"><a href="#2、实现简要流程" class="headerlink" title="2、实现简要流程"></a>2、实现简要流程</h1><ol><li>数据类型为信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换</li><li>根据条件查询数据集合(仪器+批号+项目+时间)</li><li>定量定性项目过滤，定量项目过滤掉单位为S&#x2F;CO，定性项目液体类型为C（校准）或单位为S&#x2F;CO</li><li>cut-off过滤（不包括校准点数据）</li><li>根据washStatus判断是否需要排除修改前后信号值不一致的数据</li><li>得到两份数据。allDataList：经过上述步骤剩余的数据。list：经过上述步骤再过滤掉校准点（液体类型C）数据</li><li>list为空、list大于20000，list大小小于训练数据集样本容量n。直接返回</li><li>寻找定标线。液体类型为c（校准）,连续12个点确定一个定标线（不连续的舍弃）</li><li>暂存list</li><li>遍历函数模型集合，一个模型出一个图</li><li>暂存全量数据list</li><li>计算控制线</li><li>每次移动训练数据集个数个数据。计算截断限LTL和UTL（通过移动分位数mq计算）</li><li>根据LTL和UTL截断sublist数据。数据被截断并且是定标点，将前一个点设置为定标点</li><li>数据转换sublist，使数据更符合正态性(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)</li><li>记录最优lambda，加权失控报警0.5N和2N最优lambda用N计算出的lambda</li><li>计算本次控制线（LCL,UCL）</li><li>判断控制线的合理性：根据控制线偏差和Moving-Slope斜率最大值，最小值判断（斜率判断最新版本已废除）</li><li>满足合理性判断时，暂存N转换后的数据,用作失控报警中的加权失控计算（0.5N，2N）</li><li>未找到合适控制线时，直接返回并提示用户</li><li>使用计算控制线得到的LTL和UTL截断全量数据，得到list</li><li>list数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)</li><li>暂存转换后的数据,用作失控报警中的加权失控计算</li><li>list统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)</li><li>Moving-Slope计算系统误差点（最新版本废弃）</li><li>失控报警：失控点计算(0-单点失控,1-连续X点失控,2-加权失控，3-加权连续失控)</li><li>找到所有定标线</li><li>响应封装</li></ol><h1 id="3、代码实现"><a href="#3、代码实现" class="headerlink" title="3、代码实现"></a>3、代码实现</h1><h2 id="3-1、基本流程框架"><a href="#3-1、基本流程框架" class="headerlink" title="3.1、基本流程框架"></a>3.1、基本流程框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AjaxResult <span class="title function_">pbrtqcLineData</span><span class="params">(PbrtqcDTO dto)</span> &#123;  </span><br><span class="line">    <span class="type">PBRTQCResultVO</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBRTQCResultVO</span>();  </span><br><span class="line">    <span class="comment">// 请求转换  </span></span><br><span class="line">    <span class="keyword">if</span> (dto.getDataType() == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="comment">// 数据类型位信号量，函数模型修改为mq，mq分位数设置为50,转换方式修改为不转换  </span></span><br><span class="line">        dto.setFuncModel(<span class="number">1</span>);  </span><br><span class="line">        dto.setMqQuantile(<span class="number">50.0</span>);  </span><br><span class="line">        dto.setTransType(<span class="literal">null</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 根据条件查询数据集合(仪器+批号+项目+时间)  </span></span><br><span class="line">    List&lt;PbrtqcWashed&gt; allDataList = iPbrtqcWashedService.selectLineData(dto);  </span><br><span class="line">    <span class="comment">// 定量项目&amp;定性项目过滤  </span></span><br><span class="line">    <span class="keyword">if</span> (dto.getProjectType() == <span class="number">0</span>)&#123;  </span><br><span class="line">        allDataList = allDataList.stream().filter(item -&gt; !<span class="string">&quot;S/CO&quot;</span>.equals(item.getUnit())).collect(Collectors.toList());  </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;  </span><br><span class="line">        allDataList = allDataList.stream().filter(item -&gt; <span class="string">&quot;C&quot;</span>.equals(item.getLiquidType()) || <span class="string">&quot;S/CO&quot;</span>.equals(item.getUnit())).collect(Collectors.toList());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// cut-off过滤(不包括校准点数据)  </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == dto.getCutOffCondition())&#123;  </span><br><span class="line">        allDataList = allDataList.stream().filter(item -&gt; <span class="string">&quot;C&quot;</span>.equals(item.getLiquidType()) ||  item.getValue() &lt; dto.getCutOffValue()).collect(Collectors.toList());  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">2</span> == dto.getCutOffCondition())&#123;  </span><br><span class="line">        allDataList = allDataList.stream().filter(item -&gt; <span class="string">&quot;C&quot;</span>.equals(item.getLiquidType()) ||  BigDecimal.valueOf(item.getValue()).compareTo(BigDecimal.valueOf(dto.getCutOffValue())) &gt;= <span class="number">0</span>).collect(Collectors.toList());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 不包含液体类型为C的数据 根据washStatus判断是否需要排除修改前后信号值不一致的数据，排除时不对C（校准点）排除  </span></span><br><span class="line">    <span class="keyword">if</span> (dto.getWashStatus() == <span class="number">0</span>)&#123;  </span><br><span class="line">        allDataList = allDataList.stream().filter(item -&gt; <span class="string">&quot;C&quot;</span>.equals(item.getLiquidType()) || item.getModifiedSignal().equals(item.getOriginalSignal())).collect(Collectors.toList());  </span><br><span class="line">    &#125;  </span><br><span class="line">    List&lt;PbrtqcWashed&gt; list = allDataList.stream().filter(item -&gt; !<span class="string">&quot;C&quot;</span>.equals(item.getLiquidType())).collect(Collectors.toList());  </span><br><span class="line">    <span class="comment">// 数据为空  </span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> AjaxResult.error(<span class="string">&quot;查询数据为空&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 数据量过大不进行计算  </span></span><br><span class="line">    <span class="keyword">if</span> (list.size() &gt; <span class="number">20000</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> AjaxResult.error(<span class="string">&quot;数据量过大（超过20000条），请调整查询条件&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 训练数据集样本大于集合数量，调整数量  </span></span><br><span class="line">    <span class="keyword">if</span> (dto.getN() &gt; list.size()) &#123;  </span><br><span class="line">        <span class="keyword">return</span> AjaxResult.error(<span class="string">&quot;总数据量为：&quot;</span> + list.size() + <span class="string">&quot;,小于训练数据集样本N，请调整N大小!&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 寻找定标线  </span></span><br><span class="line">    List&lt;CalibrationPoint&gt; calibrationDetailList = findCalibrationLine(allDataList); <span class="comment">// 定标点集合  </span></span><br><span class="line">    <span class="comment">// 暂存全量数据list  </span></span><br><span class="line">    List&lt;PbrtqcWashed&gt; tempList = saveDataList(list);  </span><br><span class="line">    <span class="comment">// 单位记录  </span></span><br><span class="line">    <span class="type">String</span> <span class="variable">unit</span> <span class="operator">=</span> list.get(<span class="number">0</span>).getUnit();  </span><br><span class="line">    List&lt;PBRTQCData&gt; pbrtqcDataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; funcModels = Arrays.stream(dto.getFuncModels().split(<span class="string">&quot;,&quot;</span>)).map(Integer::parseInt).collect(Collectors.toList());  </span><br><span class="line">    <span class="comment">// 把movsd放到集合最后一个元素  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt; funcModels.size(); i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span> (funcModels.get(i) == <span class="number">3</span>)&#123;  </span><br><span class="line">            funcModels.remove(i);  </span><br><span class="line">            funcModels.add(<span class="number">3</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 序号  </span></span><br><span class="line">    dto.setIndex(<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">for</span> (Integer funcModel : funcModels) &#123;  </span><br><span class="line">        List&lt;PbrtqcWashed&gt; modelDataList = saveDataList(list);  </span><br><span class="line">        <span class="comment">// 函数模型  </span></span><br><span class="line">        dto.setFuncModel(funcModel);  </span><br><span class="line">        <span class="comment">// 控制限偏差设置  </span></span><br><span class="line">        <span class="keyword">if</span> (funcModel == <span class="number">3</span>) &#123;  </span><br><span class="line">            dto.setLimitQuantile(dto.getSdLimitQuantile());  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            dto.setLimitQuantile(dto.getMqLimitQuantile());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 计算N控制限  </span></span><br><span class="line">        <span class="type">ControlLineData</span> <span class="variable">controlLine</span> <span class="operator">=</span> calculateControlLine(dto, tempList, <span class="number">1</span>, <span class="number">0</span>, dto.getIndex());  </span><br><span class="line">        <span class="comment">// 控制限判断  </span></span><br><span class="line">        <span class="keyword">if</span> ((dto.getIndex() ==  <span class="number">0</span> &amp;&amp; controlLine.getUcl() == <span class="literal">null</span>) || (dto.getIndex() &gt; <span class="number">0</span> &amp;&amp; dto.getFindControlLine() == <span class="literal">null</span>))&#123;  </span><br><span class="line">            <span class="keyword">return</span> AjaxResult.error(<span class="string">&quot;未找到合适的控制线,请设置合理的控制限偏差&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        List&lt;PbrtqcWashed&gt; cutDataList = modelDataList;  </span><br><span class="line">        <span class="keyword">if</span> (dto.getCutType() != <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// LTL（下截断限值）和UTL（上截断限值）  </span></span><br><span class="line">            <span class="type">QuantileData</span> <span class="variable">quantileData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuantileData</span>(dto.getLtl(),dto.getUtl());  </span><br><span class="line">            <span class="comment">// 根据截断方式截断数据  </span></span><br><span class="line">            cutDataList = cutData(dto, quantileData, modelDataList);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  </span></span><br><span class="line">        dataTrans(dto, cutDataList, <span class="number">0</span>);  </span><br><span class="line">        <span class="comment">// 暂存转换后的数据,用作失控报警中的加权失控计算  </span></span><br><span class="line">        List&lt;PbrtqcWashed&gt; transData = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="keyword">if</span> (dto.getAlarmMode() == <span class="number">2</span> || dto.getAlarmMode() == <span class="number">3</span>)&#123;  </span><br><span class="line">            transData = saveDataList(cutDataList);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 统计值计算(0-MA、1-MQ、2-EWMA、3-MovSD、4-MR)  </span></span><br><span class="line">        List&lt;PBRTQCLineVO&gt; dataList = funcModelCalculate(dto, cutDataList,<span class="number">1</span>);  </span><br><span class="line">        <span class="comment">// Moving-Slope计算系统误差失控点  </span></span><br><span class="line">        List&lt;PBRTQCLineVO&gt; systemErrorDataList = systemErrorPoint(dto, dataList);  </span><br><span class="line">        <span class="comment">// 失控报警  </span></span><br><span class="line">        List&lt;PBRTQCLineVO&gt; alarmDataList = outOfControlAlarm(dto, tempList, dataList, controlLine, transData);  </span><br><span class="line">        <span class="comment">// 批号计算  </span></span><br><span class="line">        List&lt;String&gt; lots = dataList.stream().map(PBRTQCLineVO::getName).distinct().collect(Collectors.toList());  </span><br><span class="line">        lots.add(<span class="number">0</span>, <span class="string">&quot;失控点&quot;</span>);  </span><br><span class="line">        lots.add(<span class="number">1</span>, <span class="string">&quot;系统误差点&quot;</span>);  </span><br><span class="line">        <span class="comment">// 设置失控点  </span></span><br><span class="line">        alarmDataList.forEach(item -&gt; dataList.get(item.getId()).setName(<span class="string">&quot;失控点&quot;</span>));  </span><br><span class="line">        <span class="comment">// 找到所有的定标线  </span></span><br><span class="line">        List&lt;PBRTQCLineVO&gt; calibrationPointList = dataList.stream().filter(item -&gt;  </span><br><span class="line">                item.getIsCalibration() != <span class="literal">null</span> &amp;&amp; item.getIsCalibration().equals(<span class="number">1</span>)).collect(Collectors.toList());  </span><br><span class="line">        List&lt;Integer&gt; calibrationList = calibrationPointList.stream().map(PBRTQCLineVO::getId).collect(Collectors.toList());  </span><br><span class="line">        <span class="comment">// 寻找失控点中的所有系统误差点  </span></span><br><span class="line">        List&lt;PBRTQCLineVO&gt; systemErrorData = alarmDataList.stream().filter(item -&gt; systemErrorDataList.stream().anyMatch(obj -&gt; obj.getId().equals(item.getId()))).collect(Collectors.toList());  </span><br><span class="line">        systemErrorData.forEach(item -&gt; dataList.get(item.getId()).setName(<span class="string">&quot;系统误差点&quot;</span>));  </span><br><span class="line">        <span class="comment">// 响应封装  </span></span><br><span class="line">        <span class="type">PBRTQCData</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBRTQCData</span>();  </span><br><span class="line">        data.setList(dataList);  </span><br><span class="line">        data.setLots(lots);  </span><br><span class="line">        data.setUnit(unit);  </span><br><span class="line">        data.setMethodName(DictUtils.getDictLabel(<span class="string">&quot;ims_pbrtqc_func_model&quot;</span>, dto.getFuncModel().toString()));  </span><br><span class="line">        data.setAlarmList(alarmDataList);  </span><br><span class="line">        data.setSystemErrorList(systemErrorData);  </span><br><span class="line">        data.setLcl(controlLine.getLcl());  </span><br><span class="line">        data.setUcl(controlLine.getUcl());  </span><br><span class="line">        data.setOriginLcl(controlLine.getOriginLcl());  </span><br><span class="line">        data.setOriginUcl(controlLine.getOriginUcl());  </span><br><span class="line">        data.setCalibrationList(calibrationList);  </span><br><span class="line">        pbrtqcDataList.add(data);  </span><br><span class="line">        dto.setIndex(dto.getIndex() + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    response.setList(pbrtqcDataList);  </span><br><span class="line">    response.setLtl(dto.getLtl());  </span><br><span class="line">    response.setUtl(dto.getUtl());  </span><br><span class="line">    response.setCalibrationPointList(calibrationDetailList);  </span><br><span class="line">    <span class="keyword">return</span> AjaxResult.success(response);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2、控制线计算流程"><a href="#3-2、控制线计算流程" class="headerlink" title="3.2、控制线计算流程"></a>3.2、控制线计算流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ControlLineData <span class="title function_">calculateControlLine</span><span class="params">(PbrtqcDTO dto, List&lt;PbrtqcWashed&gt; list, Integer transFlag, Integer alarmFlag, Integer index)</span> &#123;  </span><br><span class="line"><span class="comment">//        List&lt;PbrtqcWashed&gt; list = saveDataList(originlist);  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();  </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">offset</span> <span class="operator">=</span> dto.getLimitOffset();  </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> dto.getN();  </span><br><span class="line">        <span class="type">Double</span> <span class="variable">limitQuantile</span> <span class="operator">=</span> dto.getLimitQuantile();  </span><br><span class="line">        <span class="type">ControlLineData</span> <span class="variable">controlLineData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ControlLineData</span>();  </span><br><span class="line">        <span class="comment">// 第二次计算控制线用第一次的截断转换数据  </span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="number">0</span>)&#123;  </span><br><span class="line">            <span class="comment">// 计算控制线  </span></span><br><span class="line">            <span class="type">ControlLineData</span> <span class="variable">controlLine</span> <span class="operator">=</span>  calculateCurrentControlLine(dto.getTransDataList(), dto);  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">ucl</span> <span class="operator">=</span> controlLine.getUcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">lcl</span> <span class="operator">=</span> controlLine.getLcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">originLcl</span> <span class="operator">=</span> controlLine.getOriginLcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">originUcl</span> <span class="operator">=</span> controlLine.getOriginUcl();  </span><br><span class="line">            <span class="comment">// 新增控制线判断条件Moving-Slope  </span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">msFlag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (dto.getMinSlope() != <span class="literal">null</span> &amp;&amp; dto.getMaxSlope() != <span class="literal">null</span>)&#123;  </span><br><span class="line">                msFlag = movingSlope(dto, dto.getStatisticList2());  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 判断合理性  </span></span><br><span class="line">            <span class="keyword">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class="number">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class="line">                dto.setFindControlLine(<span class="number">1</span>);  </span><br><span class="line">                controlLineData.setLcl(lcl);  </span><br><span class="line">                controlLineData.setUcl(ucl);  </span><br><span class="line">                controlLineData.setOriginUcl(originUcl);  </span><br><span class="line">                controlLineData.setOriginLcl(originLcl);  </span><br><span class="line">                dto.setBestMean2(dto.getUseMean2());  </span><br><span class="line">                dto.setBestSD2(dto.getUseSD2());  </span><br><span class="line">                <span class="keyword">return</span> controlLineData;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - offset; i++) &#123;  </span><br><span class="line">            <span class="comment">// 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  </span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">100</span>) &#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            List&lt;PbrtqcWashed&gt; subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  </span><br><span class="line">            subList = saveDataList(subList);  </span><br><span class="line">            <span class="keyword">if</span> (subList.size() &lt; n) &#123;  </span><br><span class="line">                <span class="keyword">return</span> controlLineData;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">QuantileData</span> <span class="variable">quantileData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuantileData</span>();  </span><br><span class="line">            <span class="keyword">if</span> (dto.getCutType() != <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="comment">// 计算LTL（下截断限值）和UTL（上截断限值）  </span></span><br><span class="line">                quantileData = calculateQuantile(subList, dto);  </span><br><span class="line">                <span class="comment">// 训练数据集截断后数据  </span></span><br><span class="line">                subList = cutData(dto, quantileData, subList);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  </span></span><br><span class="line">            List&lt;PbrtqcWashed&gt; transDatas = dataTrans(dto, subList, transFlag);  </span><br><span class="line">            <span class="comment">// 暂存N转换后的数据，用来计算加权失控0.5N，2N  </span></span><br><span class="line">            List&lt;PbrtqcWashed&gt; tempTransDataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">            <span class="keyword">if</span> (dto.getAlarmMode() == <span class="number">2</span> || dto.getAlarmMode() == <span class="number">3</span>) &#123;  </span><br><span class="line">                tempTransDataList = saveDataList(transDatas);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 计算本次控制线  </span></span><br><span class="line">            <span class="type">ControlLineData</span> <span class="variable">currentControlLine</span> <span class="operator">=</span>  calculateCurrentControlLine(transDatas, dto);  </span><br><span class="line">            <span class="comment">// 计算合理性  </span></span><br><span class="line">            <span class="type">Double</span> <span class="variable">ucl</span> <span class="operator">=</span> currentControlLine.getUcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">lcl</span> <span class="operator">=</span> currentControlLine.getLcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">originLcl</span> <span class="operator">=</span> currentControlLine.getOriginLcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">originUcl</span> <span class="operator">=</span> currentControlLine.getOriginUcl();  </span><br><span class="line">            <span class="comment">// 新增控制线判断条件Moving-Slope  </span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">msFlag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (dto.getMinSlope() != <span class="literal">null</span> &amp;&amp; dto.getMaxSlope() != <span class="literal">null</span>)&#123;  </span><br><span class="line">                msFlag = movingSlope(dto, dto.getStatisticList());  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class="number">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;  </span><br><span class="line">                    <span class="comment">// 记录截断限，用于第二次全量数据的截断  </span></span><br><span class="line">                    dto.setLtl(quantileData.getLtl());  </span><br><span class="line">                    dto.setUtl(quantileData.getUtl());  </span><br><span class="line">                    <span class="comment">// 记录该次转换后的数据,用于第二次统计量的计算  </span></span><br><span class="line">                    dto.setTransDataList(transDatas);  </span><br><span class="line">                    dto.setBestMean(dto.getUseMean());  </span><br><span class="line">                    dto.setBestSD(dto.getUseSD());  </span><br><span class="line">                &#125;  </span><br><span class="line">                controlLineData.setLcl(lcl);  </span><br><span class="line">                controlLineData.setUcl(ucl);  </span><br><span class="line">                controlLineData.setOriginUcl(originUcl);  </span><br><span class="line">                controlLineData.setOriginLcl(originLcl);  </span><br><span class="line">                <span class="comment">// N转换后的数据，用于加权失控计算  </span></span><br><span class="line">                dto.setTransDataN(tempTransDataList);  </span><br><span class="line">                <span class="keyword">break</span>;            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> controlLineData;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="3-3、数据转换box-cox转换"><a href="#3-3、数据转换box-cox转换" class="headerlink" title="3.3、数据转换box-cox转换"></a>3.3、数据转换box-cox转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ControlLineData <span class="title function_">calculateControlLine</span><span class="params">(PbrtqcDTO dto, List&lt;PbrtqcWashed&gt; list, Integer transFlag, Integer alarmFlag, Integer index)</span> &#123;  </span><br><span class="line"><span class="comment">//        List&lt;PbrtqcWashed&gt; list = saveDataList(originlist);  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();  </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">offset</span> <span class="operator">=</span> dto.getLimitOffset();  </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> dto.getN();  </span><br><span class="line">        <span class="type">Double</span> <span class="variable">limitQuantile</span> <span class="operator">=</span> dto.getLimitQuantile();  </span><br><span class="line">        <span class="type">ControlLineData</span> <span class="variable">controlLineData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ControlLineData</span>();  </span><br><span class="line">        <span class="comment">// 第二次计算控制线用第一次的截断转换数据  </span></span><br><span class="line">        <span class="keyword">if</span>(index &gt; <span class="number">0</span>)&#123;  </span><br><span class="line">            <span class="comment">// 计算控制线  </span></span><br><span class="line">            <span class="type">ControlLineData</span> <span class="variable">controlLine</span> <span class="operator">=</span>  calculateCurrentControlLine(dto.getTransDataList(), dto);  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">ucl</span> <span class="operator">=</span> controlLine.getUcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">lcl</span> <span class="operator">=</span> controlLine.getLcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">originLcl</span> <span class="operator">=</span> controlLine.getOriginLcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">originUcl</span> <span class="operator">=</span> controlLine.getOriginUcl();  </span><br><span class="line">            <span class="comment">// 新增控制线判断条件Moving-Slope  </span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">msFlag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (dto.getMinSlope() != <span class="literal">null</span> &amp;&amp; dto.getMaxSlope() != <span class="literal">null</span>)&#123;  </span><br><span class="line">                msFlag = movingSlope(dto, dto.getStatisticList2());  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 判断合理性  </span></span><br><span class="line">            <span class="keyword">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class="number">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class="line">                dto.setFindControlLine(<span class="number">1</span>);  </span><br><span class="line">                controlLineData.setLcl(lcl);  </span><br><span class="line">                controlLineData.setUcl(ucl);  </span><br><span class="line">                controlLineData.setOriginUcl(originUcl);  </span><br><span class="line">                controlLineData.setOriginLcl(originLcl);  </span><br><span class="line">                dto.setBestMean2(dto.getUseMean2());  </span><br><span class="line">                dto.setBestSD2(dto.getUseSD2());  </span><br><span class="line">                <span class="keyword">return</span> controlLineData;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - offset; i++) &#123;  </span><br><span class="line">            <span class="comment">// 偏移次数超过100次，说明偏差限制选择的不合理，直接跳出  </span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">100</span>) &#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            List&lt;PbrtqcWashed&gt; subList = list.stream().skip(offset * i).limit(n).collect(Collectors.toList());  </span><br><span class="line">            subList = saveDataList(subList);  </span><br><span class="line">            <span class="keyword">if</span> (subList.size() &lt; n) &#123;  </span><br><span class="line">                <span class="keyword">return</span> controlLineData;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="type">QuantileData</span> <span class="variable">quantileData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QuantileData</span>();  </span><br><span class="line">            <span class="keyword">if</span> (dto.getCutType() != <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="comment">// 计算LTL（下截断限值）和UTL（上截断限值）  </span></span><br><span class="line">                quantileData = calculateQuantile(subList, dto);  </span><br><span class="line">                <span class="comment">// 训练数据集截断后数据  </span></span><br><span class="line">                subList = cutData(dto, quantileData, subList);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 数据转换(0-Box-Cox变换、1-对数变换、2-倒数变换、3-平方根变换)  </span></span><br><span class="line">            List&lt;PbrtqcWashed&gt; transDatas = dataTrans(dto, subList, transFlag);  </span><br><span class="line">            <span class="comment">// 暂存N转换后的数据，用来计算加权失控0.5N，2N  </span></span><br><span class="line">            List&lt;PbrtqcWashed&gt; tempTransDataList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">            <span class="keyword">if</span> (dto.getAlarmMode() == <span class="number">2</span> || dto.getAlarmMode() == <span class="number">3</span>) &#123;  </span><br><span class="line">                tempTransDataList = saveDataList(transDatas);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 计算本次控制线  </span></span><br><span class="line">            <span class="type">ControlLineData</span> <span class="variable">currentControlLine</span> <span class="operator">=</span>  calculateCurrentControlLine(transDatas, dto);  </span><br><span class="line">            <span class="comment">// 计算合理性  </span></span><br><span class="line">            <span class="type">Double</span> <span class="variable">ucl</span> <span class="operator">=</span> currentControlLine.getUcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">lcl</span> <span class="operator">=</span> currentControlLine.getLcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">originLcl</span> <span class="operator">=</span> currentControlLine.getOriginLcl();  </span><br><span class="line">            <span class="type">Double</span> <span class="variable">originUcl</span> <span class="operator">=</span> currentControlLine.getOriginUcl();  </span><br><span class="line">            <span class="comment">// 新增控制线判断条件Moving-Slope  </span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">msFlag</span> <span class="operator">=</span> <span class="literal">true</span>;  </span><br><span class="line">            <span class="keyword">if</span> (dto.getMinSlope() != <span class="literal">null</span> &amp;&amp; dto.getMaxSlope() != <span class="literal">null</span>)&#123;  </span><br><span class="line">                msFlag = movingSlope(dto, dto.getStatisticList());  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> ((originUcl - originLcl) / (originLcl + originUcl) &lt;= limitQuantile / <span class="number">100</span> &amp;&amp; msFlag) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (index == <span class="number">0</span>)&#123;  </span><br><span class="line">                    <span class="comment">// 记录截断限，用于第二次全量数据的截断  </span></span><br><span class="line">                    dto.setLtl(quantileData.getLtl());  </span><br><span class="line">                    dto.setUtl(quantileData.getUtl());  </span><br><span class="line">                    <span class="comment">// 记录该次转换后的数据,用于第二次统计量的计算  </span></span><br><span class="line">                    dto.setTransDataList(transDatas);  </span><br><span class="line">                    dto.setBestMean(dto.getUseMean());  </span><br><span class="line">                    dto.setBestSD(dto.getUseSD());  </span><br><span class="line">                &#125;  </span><br><span class="line">                controlLineData.setLcl(lcl);  </span><br><span class="line">                controlLineData.setUcl(ucl);  </span><br><span class="line">                controlLineData.setOriginUcl(originUcl);  </span><br><span class="line">                controlLineData.setOriginLcl(originLcl);  </span><br><span class="line">                <span class="comment">// N转换后的数据，用于加权失控计算  </span></span><br><span class="line">                dto.setTransDataN(tempTransDataList);  </span><br><span class="line">                <span class="keyword">break</span>;            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> controlLineData;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 计算最优的lambda值  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data 数据  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 最优的lambda值  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">findBestLambda</span><span class="params">(<span class="type">double</span>[] data)</span> &#123;  </span><br><span class="line">    <span class="comment">// 定义lambda的范围和步长  </span></span><br><span class="line">    <span class="type">double</span> <span class="variable">lambdaStart</span> <span class="operator">=</span> -<span class="number">5.0</span>;  </span><br><span class="line">    <span class="type">double</span> <span class="variable">lambdaEnd</span> <span class="operator">=</span> <span class="number">5.0</span>;  </span><br><span class="line">    <span class="type">double</span> <span class="variable">lambdaStep</span> <span class="operator">=</span> <span class="number">0.01</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算原始数据的几何均值G  </span></span><br><span class="line">    <span class="type">double</span> <span class="variable">G</span> <span class="operator">=</span> <span class="number">1.0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> x : data) &#123;  </span><br><span class="line">        G *= Math.pow(x, <span class="number">1.0</span> / data.length);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 计算最优lambda  </span></span><br><span class="line">    <span class="type">double</span> <span class="variable">minSD</span> <span class="operator">=</span> Double.MAX_VALUE;  </span><br><span class="line">    <span class="type">double</span> <span class="variable">minLambda</span> <span class="operator">=</span> -<span class="number">5</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">double</span> <span class="variable">lambda</span> <span class="operator">=</span> lambdaStart; lambda &lt;= lambdaEnd; lambda += lambdaStep) &#123;  </span><br><span class="line">        <span class="type">double</span>[] transformedData = boxCoxTransform(data, lambda, G);  </span><br><span class="line">        <span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> calculateAverage(transformedData);  </span><br><span class="line">        <span class="type">double</span> <span class="variable">sd</span> <span class="operator">=</span> calculateStandardDeviation(transformedData, avg);  </span><br><span class="line">        <span class="keyword">if</span> (sd &lt; minSD) &#123;  </span><br><span class="line">            minSD = sd;  </span><br><span class="line">            minLambda = lambda;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> minLambda;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 计算Box-Cox变换后的数据  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> data   数据  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lambda lambda值  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Box-Cox变换后的数据  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span>[] boxCoxTransform(<span class="type">double</span>[] data, <span class="type">double</span> lambda, <span class="type">double</span> G) &#123;  </span><br><span class="line">    <span class="type">double</span>[] transformedData = <span class="keyword">new</span> <span class="title class_">double</span>[data.length];  </span><br><span class="line">    <span class="keyword">if</span> (lambda == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;  </span><br><span class="line">            transformedData[i] = G * Math.log(data[i]);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.length; i++) &#123;  </span><br><span class="line">            transformedData[i] = (Math.pow(data[i], lambda) - <span class="number">1</span>) / (lambda * Math.pow(G, lambda - <span class="number">1</span>));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> transformedData;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4、统计值计算之mq"><a href="#3-4、统计值计算之mq" class="headerlink" title="3.4、统计值计算之mq"></a>3.4、统计值计算之mq</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 移动分位数（MQ）  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> N 窗口大小  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> X mq分位数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;PBRTQCLineVO&gt; <span class="title function_">MQ</span><span class="params">(Integer N, Double X, List&lt;PbrtqcWashed&gt; list)</span> &#123;  </span><br><span class="line">    List&lt;PBRTQCLineVO&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() -N + <span class="number">1</span>; i++) &#123;  </span><br><span class="line">        <span class="type">double</span> <span class="variable">val1</span> <span class="operator">=</span> (N + <span class="number">1</span>) * X / <span class="number">100</span>;  </span><br><span class="line">        <span class="comment">// 整数部分  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (<span class="type">int</span>) val1;  </span><br><span class="line">        <span class="comment">// 小数部分  </span></span><br><span class="line">        <span class="type">double</span> <span class="variable">g</span> <span class="operator">=</span> val1 - j;  </span><br><span class="line">        List&lt;Integer&gt; subIndex = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">double</span> calValue;  </span><br><span class="line">        <span class="comment">// list从小到大排序  </span></span><br><span class="line">        List&lt;PbrtqcWashed&gt; subList = list.stream().skip(i).limit(N).collect(Collectors.toList());  </span><br><span class="line">        List&lt;PbrtqcWashed&gt; collect = subList.stream().sorted(Comparator.comparing(PbrtqcWashed::getValue)).collect(Collectors.toList());  </span><br><span class="line">        <span class="keyword">if</span> (g == <span class="number">0</span>) &#123;  </span><br><span class="line">            calValue = collect.get(j - <span class="number">1</span>).getValue();  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            calValue = (<span class="number">1</span> - g) * collect.get(j - <span class="number">1</span>).getValue() + g * collect.get(j).getValue();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">PBRTQCLineVO</span> <span class="variable">vo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBRTQCLineVO</span>();  </span><br><span class="line">        vo.setId(i);  </span><br><span class="line">        vo.setName(list.get(i+N-<span class="number">1</span>).getReagentBatch());  </span><br><span class="line">        vo.setValue(calValue);  </span><br><span class="line">        vo.setIsCalibration(list.get(i+N-<span class="number">1</span>).getIsCalibration());  </span><br><span class="line">        vo.setReadyTime(list.get(i+N-<span class="number">1</span>).getReadyTime());  </span><br><span class="line">        result.add(vo);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、效果图"><a href="#4、效果图" class="headerlink" title="4、效果图"></a>4、效果图</h1><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310081549987.png" alt="PBRTQC"></p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PBRTQC </tag>
            
            <tag> 技术文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spring（Boot）扩展点整理</title>
      <link href="/posts/43143.html"/>
      <url>/posts/43143.html</url>
      
        <content type="html"><![CDATA[<p>SpringBoot的主要功能都是依靠它内部很多的扩展点来完成的，今天来做个总结和记录</p><h1 id="1、SpringApplicationRunListener"><a href="#1、SpringApplicationRunListener" class="headerlink" title="1、SpringApplicationRunListener"></a>1、SpringApplicationRunListener</h1><h2 id="1-1、基本概念"><a href="#1-1、基本概念" class="headerlink" title="1.1、基本概念"></a>1.1、基本概念</h2><p>从命名我们就可以知道它是一个监听者，分析springboot启动流程我们会发现，它其实是用来在整个启动流程中接收不同执行点事件通知的监听者，SpringApplicationRunListener接口规定了SpringBoot的生命周期，在各个生命周期广播相应的事件，调用实际的ApplicationListener类。对于开发者来说，基本没有什么常见的场景要求我们必须实现一个自定义的SpringApplicationRunListener</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SpringApplicationRunListener</span> &#123;</span><br><span class="line">     <span class="comment">//刚执行run方法时</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">started</span><span class="params">()</span>;</span><br><span class="line">     <span class="comment">//环境建立好时候</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span>;</span><br><span class="line">     <span class="comment">//上下文建立好的时候</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span>;</span><br><span class="line">    <span class="comment">//上下文载入配置时候</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span>;</span><br><span class="line">    <span class="comment">//上下文刷新完成后，run方法执行完之前</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-2、具体使用"><a href="#1-2、具体使用" class="headerlink" title="1.2、具体使用"></a>1.2、具体使用</h2><p>1、新建类实现SpringApplicationRunListener,需要构造方法,里面两个参数SpringApplication sa, String[] args;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationRunListener</span> <span class="keyword">implements</span> <span class="title class_">SpringApplicationRunListener</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SpringApplication application;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] args;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyApplicationRunListener</span><span class="params">(SpringApplication sa, String[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.application = sa;</span><br><span class="line">    <span class="built_in">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务启动RunnerTest  SpringApplicationRunListener的starting方法...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务启动RunnerTest  SpringApplicationRunListener的environmentPrepared方法...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务启动RunnerTest  SpringApplicationRunListener的contextPrepared方法...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务启动RunnerTest  SpringApplicationRunListener的contextLoaded方法...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">running</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务启动RunnerTest  SpringApplicationRunListener的running方法...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(ConfigurableApplicationContext context, Throwable exception)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务启动RunnerTest  SpringApplicationRunListener的failed方法...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">started</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;服务启动RunnerTest  SpringApplicationRunListener的started方法...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在resources下新建META-INF\spring.factories文件,文件里面将新建的实现类的类路径配置进去:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.SpringApplicationRunListener</span>=<span class="string">com.study.springbootplus.config.MyApplicationRunListener</span></span><br></pre></td></tr></table></figure><h1 id="2、ApplicationListener"><a href="#2、ApplicationListener" class="headerlink" title="2、ApplicationListener"></a>2、ApplicationListener</h1><h2 id="2-1、基本概念"><a href="#2-1、基本概念" class="headerlink" title="2.1、基本概念"></a>2.1、基本概念</h2><p>ApplicationListener属于Spring框架对Java中实现的监听者模式的一种框架实现，这里需要注意的是：对于刚接触SpringBoot，但是对于Spring框架本身又没有过多地接触的开发人员来说，可能会将这个名字与SpringApplicationRunListener弄混。</p><p>ApplicationListener通过监听容器中发布的一些事件，事件发布就会触发监听器的回调，就完成了事件驱动开发。原理是观察者设计模式，设计初衷也是为了系统业务逻辑之间的解耦，提高可扩展性以及可维护性。spring定义了一些内置事件，当然我们也可以自定义事件</p><p><strong>内置事件：</strong></p><table><thead><tr><th>序号</th><th>Spring 内置事件</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>ContextRefreshedEvent</td><td>ApplicationContext 被初始化或刷新时，该事件被发布。所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，ApplicationContext容器已就绪可用</td></tr><tr><td>2</td><td>ContextStartedEvent</td><td>当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</td></tr><tr><td>3</td><td>ContextStoppedEvent</td><td>当使用 ConfigurableApplicationContext （ApplicationContext子接口）接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</td></tr><tr><td>4</td><td>ContextClosedEvent</td><td>当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</td></tr><tr><td>5</td><td>RequestHandledEvent</td><td>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件。</td></tr></tbody></table><h2 id="2-2、自定义事件具体使用"><a href="#2-2、自定义事件具体使用" class="headerlink" title="2.2、自定义事件具体使用"></a>2.2、自定义事件具体使用</h2><p>场景：下单后调用短信发送</p><p>1、定义订单事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCreateEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String orderInfo;<span class="comment">//订单信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCreateEvent</span><span class="params">(Object source,String orderInfo)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.orderInfo = orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderInfo</span><span class="params">(String orderInfo)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderInfo = orderInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>2、定义短信发送的监听器（ApplicationListener）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmsListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;OrderCreateEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(OrderCreateEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">//. 发送短信: 调用短信服务，给手机号发送短信信息.</span></span><br><span class="line">        System.out.println(<span class="string">&quot;发送短信 - 调用短信服务，给手机号发送短信信息;订单信息：&quot;</span>+event.getOrderInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、发布事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建订单.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建订单: 生成订单信息，然后保存到数据库.</span></span><br><span class="line">        System.out.println(<span class="string">&quot;创建订单 - 生成订单信息，然后保存到数据库&quot;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">//2. 发布事件</span></span><br><span class="line">        <span class="type">OrderCreateEvent</span> <span class="variable">orderCreateEvent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCreateEvent</span>(<span class="built_in">this</span>,<span class="string">&quot;orderNo:20230815&quot;</span>);</span><br><span class="line">        applicationEventPublisher.publishEvent(orderCreateEvent);<span class="comment">//也可以</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用事件模式可以将代码解耦，使得代码更加灵活和可扩展。如果直接调用处理发短信的方法，那么每次需要添加新的功能或者修改现有功能时，都需要修改这个方法，这样会导致代码的耦合度很高，难以维护和扩展。</p><p>而使用事件模式，可以将发短信事件和下单的方法分离开来，当有新的功能需要添加时，只需要添加一个新的事件处理器即可，不需要修改原有的代码，这样可以大大提高代码的可维护性和可扩展性。</p><p>比如要增加一个发邮件功能，业务代码不用动，直接增加一个邮件的Listener即可。</p><h2 id="2-3、和SpringApplicationRunListener的联系"><a href="#2-3、和SpringApplicationRunListener的联系" class="headerlink" title="2.3、和SpringApplicationRunListener的联系"></a>2.3、和SpringApplicationRunListener的联系</h2><p>SpringApplicationRunListener类是SpringBoot中新增的类。ApplicationListener是spring中框架的类<br>在SpringBoot（SpringApplication类）中，使用SpringApplicationRunListener来间接调用ApplicationListener，<strong>所以</strong>SpringApplicationRunListener就是一个ApplicationListener的代理，算是对SpringApplication的一个扩展</p><h1 id="3、ApplicationContextInitializer"><a href="#3、ApplicationContextInitializer" class="headerlink" title="3、ApplicationContextInitializer"></a>3、ApplicationContextInitializer</h1><h2 id="3-1、基本概念"><a href="#3-1、基本概念" class="headerlink" title="3.1、基本概念"></a>3.1、基本概念</h2><p>ApplicationContextInitializer 接口用于在 Spring 容器刷新之前执行的一个回调函数，通常用于向 SpringBoot 容器中注入属性</p><h2 id="3-2、具体使用"><a href="#3-2、具体使用" class="headerlink" title="3.2、具体使用"></a>3.2、具体使用</h2><p>1、自定义ApplicationContextInitializer接口实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Order(2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyApplicationContextInitializer</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextInitializer</span>&lt;ConfigurableApplicationContext&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 声明要添加的属性</span></span><br><span class="line">        Map&lt;String, Object&gt; mysqlMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        mysqlMap.put(<span class="string">&quot;mysql-host&quot;</span>, <span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        <span class="comment">// 将属性添加到Application Context中</span></span><br><span class="line">        applicationContext.getEnvironment().getPropertySources()</span><br><span class="line">                .addLast(<span class="keyword">new</span> <span class="title class_">MapPropertySource</span>(<span class="string">&quot;mysqlMap&quot;</span>, mysqlMap));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加要激活的配置文件</span></span><br><span class="line">        <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> applicationContext.getEnvironment();</span><br><span class="line">        environment.addActiveProfile(<span class="string">&quot;extend&quot;</span>);</span><br><span class="line">        ConfigDataEnvironmentPostProcessor.applyTo(environment);</span><br><span class="line">        log.info(<span class="string">&quot;MyApplicationContextInitializer initialize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、SpringApplicaiton启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化SpringApplication</span></span><br><span class="line">        <span class="type">SpringApplication</span> <span class="variable">application</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(Application.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加初始化器</span></span><br><span class="line">        application.addInitializers(<span class="keyword">new</span> <span class="title class_">MyApplicationContextInitializer</span>());</span><br><span class="line">        application.addInitializers(<span class="keyword">new</span> <span class="title class_">OtherApplicationContextInitializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动SpringApplication</span></span><br><span class="line">        application.run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4、CommandLineRunner"><a href="#4、CommandLineRunner" class="headerlink" title="4、CommandLineRunner"></a>4、CommandLineRunner</h1><h2 id="4-1、基本概念"><a href="#4-1、基本概念" class="headerlink" title="4.1、基本概念"></a>4.1、基本概念</h2><p>Spring Boot中的CommandLineRunner接口允许你在Spring Boot应用程序启动后执行一些代码。通过实现CommandLineRunner接口，你可以编写自定义的CommandLineRunner实现类，以在应用程序启动时执行特定的操作</p><h2 id="4-2、具体使用"><a href="#4-2、具体使用" class="headerlink" title="4.2、具体使用"></a>4.2、具体使用</h2><p>场景：springboot启动后将数据库某些热点数据加载到redis</p><p>1、自定义类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Order(value=1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStartupRunner</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProvinceCityDistrictSerivce provinceCityDistrictSerivce;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       provinceCityDistrictSerivce.initProvinceCityDistrictDtoList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、具体业务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProvinceCityDistrictServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProvinceCityDistrictSerivce</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ProvinceCityDistrictMapper provinceCityDistrictMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">initProvinceCityDistrictDtoList</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ProvinceCityDistrict</span> <span class="variable">provinceCityDistrict</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProvinceCityDistrict</span>();</span><br><span class="line">        List&lt;ProvinceCityDistrictDto&gt; provinceCityDistrictDtos = provinceCityDistrictMapper.selectDtoList(provinceCityDistrict);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> JSON.toJSONString(provinceCityDistrictDtos);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;开始缓存省市区信息到redis&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        redisService.set(<span class="string">&quot;PROVINCE_CITY_DISCTRICT_KEY&quot;</span>,s);</span><br><span class="line">        log.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;缓存省市区信息到redis完毕&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文章 </tag>
            
            <tag> springBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪花算法（Snowflake）原理分析</title>
      <link href="/posts/11001.html"/>
      <url>/posts/11001.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><p>雪花算法（Snowflake）是一种生成分布式全局唯一ID的算法，生成的ID称为Snowflake IDs或snowflakes。这种算法由Twitter创建，并用于推文的ID</p><p>雪花算法几个特性</p><ul><li>生成的ID分布式唯一和按照时间递增有序，毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li><li>不依赖数据库等三方系统，稳定性更高，性能非常高的。</li><li>可以根据自身业务特性分配bit位，非常灵活。</li></ul><h1 id="2、snowflake算法实现细节"><a href="#2、snowflake算法实现细节" class="headerlink" title="2、snowflake算法实现细节"></a>2、snowflake算法实现细节</h1><h2 id="2-1、拆解64bit位"><a href="#2-1、拆解64bit位" class="headerlink" title="2.1、拆解64bit位"></a>2.1、拆解64bit位</h2><p>snowflake生成的id通常是一个64bit数字，java中用long类型。</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202403031225315.png" alt="image.png"></p><p>1、1bit-不用,因为二进制中最高位是符号位,1表示负数,0表示正数,生成的id一般都是用整数,所以最高位固定为0.<br>2、41bit-用来记录时间戳（毫秒）.41位可以表示2^41−1个数字，如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 2^41-1，减1是因为可表示的数值范围是从0开始算的，而不是1。也就是说41位可以表示2^41-1个毫秒的值，转化成单位年则是:(2^41−1)&#x2F;(1000∗60∗60∗24∗365)&#x3D;69年 ，也就是说这个时间戳可以使用69年不重复（69年后换个服务器部署）<br>3、10bit-用来记录工作机器id。可以部署在2^10&#x3D;1024个节点，包括5位datacenterId和5位workerId,可以部署在2^10&#x3D;1024个节点<br>4、12bit-序列号，用来记录同毫秒内产生的不同id。12位（bit）可以表示的最大正整数是2^12−1&#x3D;4095，即可以用0、1、2、3、….4095这4096个数字，来表示同一机器同一时间截（毫秒）内产生的4096个ID序号</p><blockquote><p> 同一毫秒的ID数量 &#x3D; 1024 X 4096 &#x3D; 4194304，所以最大可以支持单应用差不多四百万的并发量，这个妥妥的够用了</p></blockquote><h1 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h1><h2 id="3-1、引入依赖"><a href="#3-1、引入依赖" class="headerlink" title="3.1、引入依赖"></a>3.1、引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.beyondfengyu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snowflake-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2、在配置文件中配置雪花算法参数"><a href="#3-2、在配置文件中配置雪花算法参数" class="headerlink" title="3.2、在配置文件中配置雪花算法参数"></a>3.2、在配置文件中配置雪花算法参数</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">snowflake:</span></span><br><span class="line">  <span class="attr">data-center-id:</span> <span class="number">1</span> <span class="comment"># 数据中心ID，可以使用机器IP地址最后一段数字，范围为0-31</span></span><br><span class="line">  <span class="attr">machine-id:</span> <span class="number">1</span> <span class="comment"># 机器ID，可以使用服务器编号，范围为0-31</span></span><br></pre></td></tr></table></figure><h2 id="3-3、注入SnowflakeIdWorker"><a href="#3-3、注入SnowflakeIdWorker" class="headerlink" title="3.3、注入SnowflakeIdWorker"></a>3.3、注入SnowflakeIdWorker</h2><p>使用snowflakeIdWorker.nextId()方法既可以获取生成的雪花ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SnowflakeIdWorker snowflakeIdWorker;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">generateUserId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> snowflakeIdWorker.nextId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、几个问题"><a href="#4、几个问题" class="headerlink" title="4、几个问题"></a>4、几个问题</h1><h2 id="4-1、时钟倒拨问题"><a href="#4-1、时钟倒拨问题" class="headerlink" title="4.1、时钟倒拨问题"></a>4.1、时钟倒拨问题</h2><p>时间倒拨，也就是跑了一段时间之后，系统时间回到过去。显然，时间戳上有很大几率产生相同毫秒数，在机器码workerId相同的情况下，有较大几率出现重复雪花Id。原标准实现代码中是直接抛异常，短暂停止对外服务，这样在实际生产中是无法忍受的。所以要尽量避免时钟回拨带来的影响，解决思路就是不依赖机器时钟驱动，就没时钟回拨的事儿了。即定义一个初始时间戳，在初始时间戳上自增，不跟随机器时钟增加。时间戳何时自增？当序列号增加到最大时，此时时间戳+1，这样完全不会浪费序列号，适合流量较大的场景，如果流量较小，可能出现时间断层滞后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">startTimestamp</span> <span class="operator">=</span> <span class="number">1623947387000L</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span>  <span class="type">long</span> <span class="title function_">nextId2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">sequenceTmp</span> <span class="operator">=</span> sequence;</span><br><span class="line">    sequence = (sequence + <span class="number">1</span>) &amp; SEQUENCE_MASK;</span><br><span class="line">    <span class="comment">// sequence =0 有可能是初始+1=0，也可能是超过了最大值等于0</span></span><br><span class="line">    <span class="comment">// 所以把 初始+1=0排除掉</span></span><br><span class="line">    <span class="keyword">if</span> (sequence == <span class="number">0</span> &amp;&amp; sequenceTmp &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// sequence自增到最大了，时间戳自增1</span></span><br><span class="line">        startTimestamp += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成id</span></span><br><span class="line">    <span class="keyword">return</span> allocate(startTimestamp - twepoch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>起始时间可以构造器里指定，也可以用默认的，而sequence初始为-1，是为了不想浪费sequence+1&#x3D;0这一序列号。</p><p>sequence &#x3D; 0排除掉初始sequence&#x3D;-1 +1 &#x3D; 0的情况就是sequence超过最大值了，此时时间戳startTimestamp自增。</p><p>代码和思路都很简单，就是完全脱离机器时钟，彻底解决了时钟回拨问题。显而易见的优点，每一毫秒4096个序列号（[0,4095]）没有浪费，同时因为时间自增由程序自己掌控，所以可以利用未来时间，预先生成一些ID放在缓存里，外界从缓存中直接获取ID，快消费完了再生产，这样就形成了永动的生产-消费者模式，获取ID省去了生成的过程，性能也会大大提升。</p><p>但是时间戳完全自控，也有很明显的缺点，ID生成的时间，并不是真实的时间，如果流量较小，时间可能会滞后很多。如果对从ID解析出来的时间戳没有什么利用意义，这个缺点也不需要关心</p><h2 id="4-2、机器ID重复的问题"><a href="#4-2、机器ID重复的问题" class="headerlink" title="4.2、机器ID重复的问题"></a>4.2、机器ID重复的问题</h2><p>机器 ID（5 位）和数据中心 ID（5 位）配置没有解决，分布式部署的时候会使用相同的配置，仍然有 ID 重复的风险。如果是在单节点中，这种固定的配置没有问题的，但是在分布式部署中，需要由dataCenterID和workerID组成唯一的机器码，否则在同毫秒内，在机器码workerId相同的情况下，有较大几率出现重复雪花Id。那么这个时候，dataCenterID和workerID的配置就不能写死。而且必须保证唯一。解决思路可以考虑redis保证workid不容。工作机器id：10bit，表示工作机器id，用于处理分布式部署id不重复问题，可支持2^10 &#x3D; 1024个节点，我们只需要给同一个微服务分配不同的工作机器ID即可，在redis中存储一个当前workerId的最大值。每次生成workerId时，从redis中获取到当前workerId最大值，并+1作为当前workerId，并存入redis。如果workerId为1023，自增为1024，则重置0，作为当前workerId，并存入redis。</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文章 </tag>
            
            <tag> 雪花算法 </tag>
            
            <tag> snowflake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stream 流式编程：并行流</title>
      <link href="/posts/52392.html"/>
      <url>/posts/52392.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h1><p>Stream是工作中经常用到的集合操作工具，Stream将要处理的元素集合看作一种流，在流的过程中，借助Stream API对流中的元素进行操作，比如：筛选、排序、聚合等。同时它提供的parallelStream方法能够充分利用多核CPU的优势，使用多线程加快对集合数据的处理速度</p><p>相对于顺序流而言，并行流在执行某些中间操作时，会自动将数据分成若干个小块，并在多个线程中进行处理，最终将结果合并起来。可以通过调用<code>parallel()</code>方法将顺序流转换为并行流</p><p>例如，我们可以使用以下代码使用并行流对一个整数列表进行求和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>); </span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.parallelStream() .mapToInt(Integer::intValue) .sum();</span><br></pre></td></tr></table></figure><p>这里，parallelStream()方法创建一个并行流，mapToInt()方法将Stream中的元素转换为int类型，sum()方法对所有元素求和。</p><p>需要注意的是，并行流并不是适用于所有情况的，如果数据量较小或者处理操作复杂度较低，使用并行流反而会使程序变慢。此外，使用并行流时，需要考虑并发安全问题，确保多个并行操作之间不会发生冲突。所以，在开发中需要根据具体的数据量和操作复杂度来决定是否使用并行流。</p><h1 id="2、使用并行流提高性能"><a href="#2、使用并行流提高性能" class="headerlink" title="2、使用并行流提高性能"></a>2、使用并行流提高性能</h1><p>1、创建并行流：要创建一个并行流，只需在普通流上调用 parallel() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line">Stream&lt;Integer&gt; parallelStream = numbers.parallelStream();</span><br></pre></td></tr></table></figure><p>2、利用任务并行性：并行流会将数据分成多个小块，并在多个线程上并行处理这些小块。这样可以充分利用多核处理器的优势。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); </span><br><span class="line">numbers.parallelStream() .map(n -&gt; compute(n)) <span class="comment">// 在多个线程上并行处理计算 </span></span><br><span class="line">.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>在这个示例中，使用 map 方法对流中的每个元素进行计算。由于并行流的特性，计算操作会在多个线程上并行执行，提高了计算的效率。</p><p>3、避免共享可变状态：在并行流中，多个线程会同时操作数据。如果共享可变状态（如全局变量）可能导致数据竞争和不确定的结果。因此，避免在并行流中使用共享可变状态，或者采取适当的同步措施来确保线程安全。</p><p>4、使用合适的操作：一些操作在并行流中的性能表现更好，而另一些操作则可能导致性能下降。一般来说，在并行流中使用基于聚合的操作（如 reduce、collect）和无状态转换操作（如 map、filter）的性能较好，而有状态转换操作（如 sorted）可能会导致性能下降。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// good performance</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers.parallelStream()</span><br><span class="line">                 .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// good performance</span></span><br><span class="line">List&lt;Integer&gt; evenNumbers = numbers.parallelStream()</span><br><span class="line">                                   .filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                                   .collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line"><span class="comment">// potential performance degradation</span></span><br><span class="line">List&lt;Integer&gt; sortedNumbers = numbers.parallelStream()</span><br><span class="line">                                     .sorted()</span><br><span class="line">                                     .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>在这个示例中，reduce 和 filter 的操作在并行流中具有良好的性能，而 sorted 操作可能导致性能下降。</p><p>除了上述方法，还应根据具体情况进行评估和测试，并行流是否能够提高性能。有时候，并行流的开销（如线程的创建和销毁、数据切割和合并等）可能超过了其带来的性能提升。因此，在选择使用并行流时，应该根据数据量和操作复杂度等因素进行综合考虑，以确保获得最佳的性能提升。</p><h1 id="3、并行流的适用场景"><a href="#3、并行流的适用场景" class="headerlink" title="3、并行流的适用场景"></a>3、并行流的适用场景</h1><p>1、大规模数据集：当需要处理大规模数据集时，使用并行流可以充分利用多核处理器的优势，提高程序的执行效率。并行流将数据切分成多个小块，并在多个线程上并行处理这些小块，从而缩短了处理时间。</p><p>2、复杂的计算操作：对于复杂的计算操作，使用并行流可以加速计算过程。由于并行流能够将计算操作分配到多个线程上并行执行，因此可以有效地利用多核处理器的计算能力，提高计算的速度。</p><p>3、无状态转换操作：并行流在执行无状态转换操作（如 map、filter）时表现较好。这类操作不依赖于其他元素的状态，每个元素的处理是相互独立的，可以很容易地进行并行处理。</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文章 </tag>
            
            <tag> stream </tag>
            
            <tag> 并行流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>西方哲学史</title>
      <link href="/posts/40984.html"/>
      <url>/posts/40984.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、智慧的痛苦"><a href="#1、智慧的痛苦" class="headerlink" title="1、智慧的痛苦"></a>1、智慧的痛苦</h1><h2 id="1-1、什么是哲学"><a href="#1-1、什么是哲学" class="headerlink" title="1.1、什么是哲学"></a>1.1、什么是哲学</h2><p>关于哲学错误的看法：</p><p>（1）哲学是科学：它不具备一门科学知识应该具备的最基本特征：普遍性和必然性<br>（2）哲学是让人聪明的学问：哲学的理论学说都处在众说纷纭，莫衷一事的处境中。那么你想想学哲学会让你聪明还是糊涂<br>（3）哲学是讲道理的学问：哲学是讲大道理的，可是哲学这个大道理大到什么程度，大到没有办法去印证的程度。那么道理道理之间的冲突就变成没有道理<br>    哲学往往被看做是为意识形态服务的工具，今天是这样一种政策，理论家们就要给我论证它的理论基础，非常完善的一套逻辑，过一段时间政策变了，还是这群哲学家，仍然还可以给你论证那套基础。不恰当的讲，可以把煤球论证成黑的，也可以论证成白的。<br>    科学知识的对象 -&gt; 现实性<br>    哲学的对象 -&gt; 理想性，带有乌托邦的性质，它是人们不满足于这个世界，而为它建立的一个理想世界，但每个人不同的时代社会和所处的环境，使人们对这个理想的境界理解不同<br>（4）哲学无用，无用只用，是为大用。所有学科都比哲学有用，但是是唯有哲学是自由的学问，因为所有的学科都有前提，都有它服务的对象，但唯独哲学是为了自身而被追求的知识。哲学是自由人的学问。哲学应该是人的精神家园</p><p>哲学的理解</p><p>哲学是希腊语philosophia : philos + sophia （哲学：爱智慧）。亚里士多德说，智慧这个词太大了，它只适合神而不适合人，我们只能爱智慧。哲学和科学一样讲理性，哲学又和宗教一样，起源于终极关怀的问题。看起来哲学相比宗教和科学，处在一个有利的位置，但恰恰是这个位置，让它看起来很尴尬，为什么？科学讲这个世界，宗教关注另一个世界。哲学想把这两个东西打通，它既不能靠理论说服宗教，又不能靠信仰阐述科学。哲学给我们提供了一条一条解决问题的道路，没有任何一条道路通达到了智慧的顶点，但是每条道路都是一个典型</p><h2 id="1-2、智慧的痛苦"><a href="#1-2、智慧的痛苦" class="headerlink" title="1.2、智慧的痛苦"></a>1.2、智慧的痛苦</h2><p>哲学既然没有解决问题，为什么还要追问问题？<br>亚当是按照神的形象创造的，神把亚当安置在伊甸园，一个美丽的地方，哪里，到处都是结出甜美果实的树木。其中有两棵树，都有不同的作用，一棵是生命树，享受永生，一棵是知识树，里面充满着恶欲和邪淫。亚当唯一的命令是:“除了智慧树的果子，你可以吃任何你想吃的果子!”神在亚当陷入了沉睡，他取下他的一侧肋骨，形成夏娃。然后他把她带到亚当那里，亚当和他的新婚妻子感到了满足。亚当和夏娃被造的时候并没有邪恶的倾向，他们觉得不穿衣服没有什么不对。然而，这种情况很快就改变了。蛇是神所创造的所有野兽中最狡猾的，它靠近夏娃，慢慢地，淡定说服并迫使夏娃吃智慧树的果实。接着，她和丈夫亚分享了果实。亚当和夏娃立刻意识到自己是赤身露体的，便用无花果叶缝的带子束身。他们违背了神的命令的报应很快会到来:夏娃被诅咒要忍受怀孕、生产和抚养孩子的痛苦，还要屈从于她的丈夫。亚当的惩罚是：他必须在大地上劳作来生产粮食，人类的生命现在将以死亡结束。更重要的是，亚当和夏娃被驱逐出伊甸园。</p><p>整个人类发端以来，所有的问题最终归结起来无非是生死的问题。宗教能以来生来世另一个世界，灵魂不朽的方式去面对这个话题，哲学不能。哲学要超越人自身有限性，去面对无限的问题</p><h2 id="1-3、怎么学哲学"><a href="#1-3、怎么学哲学" class="headerlink" title="1.3、怎么学哲学"></a>1.3、怎么学哲学</h2><p>学哲学只能通过学哲学史来学习，无非是把前人走过的路都走一遍，然后去开创你的道路或者选择一条适合你的道路，学哲学史就是学哲学家的思想，但是读哲学家的书往往灰色难懂（列宁说读黑格尔的书是治疗失眠最好的药）。为什么？老子说，道可道，非常道，名可名，非常名。这个道是说不出来的，哲学家却一定要去说这个不可说的东西，而且他们都有自己的体会，通过他写的东西了解他的思想很难，哲学家要表达的东西在语言文字之外，所以要求我们必须了解他要解决什么问题？熟悉哲学家的术语，沿着哲学家的思路，理解哲学家的思想</p><h2 id="1-4、西方哲学的特点"><a href="#1-4、西方哲学的特点" class="headerlink" title="1.4、西方哲学的特点"></a>1.4、西方哲学的特点</h2><p>希腊人哲学思维的特点：（1）偏爱非个人性的，更关注带有普遍性的东西。（2）试图给事物的存在找出合理的原因</p><h1 id="2、哲学的诞生"><a href="#2、哲学的诞生" class="headerlink" title="2、哲学的诞生"></a>2、哲学的诞生</h1><h2 id="2-1、希腊思想的起源"><a href="#2-1、希腊思想的起源" class="headerlink" title="2.1、希腊思想的起源"></a>2.1、希腊思想的起源</h2><p>哲学诞生于古代希腊。古希腊哲学是西方哲学的发源地,希腊人堪称哲学的民族。他们不仅奠定了西方思想、概念和体系的基础,从而奠定了西方文明的基础,而且提出并讨论了几乎所有的哲学问题。正如恩格斯所说:“在希腊哲学的多种多样的形式中，差不多可以找到以后各种观点的胚胎、萌芽。”从时间上说,希腊哲学从公元前 6世纪左右开始形成，一直延续到公元6世纪初,前后一千多年。公元 529 年,皈依了基督教的东罗马帝国皇帝查士丁尼下令封闭了最后一所柏拉图学园,通常人们以这一年作为希腊哲学终结的标志。就其历史而言,希腊哲学经历了希腊古典时期、希腊化时期、罗马共和国时期和罗马帝国时期。人们有时也称这一时期的西方哲学为古希腊罗马哲学”,实际上这是不确切的。罗马人并没有给哲学贡献什么新的内容,所谓“罗马哲学”不过是希腊哲学的延续而已。</p><p>一般说来，人类文明的发展必须克服来自外在的和内在的两方面的限制:外在的限制是人类生活于其中的自然环境,他必须通过认识自然和改造自然的实践活动求得生存,而人类克服外在自然之限制的根本方式就是以社会性的存在对付自然的挑战,这就形成了所谓内在的限制。为了在自然中生存下去,人类结成了社会,而宗教、神话、宗法、伦理等成文与不成文的规范就成了维系人类社会存在的纽带,这些东西既可以是一个社会保持其存在的支柱，同时也最终会成为社会进步和新思想产生的阻碍。由此可见,希腊理性的诞生的确在很大程度上得益于希腊文明的“中断”,这一中断使希腊人比较少地受传统的限制和束缚,使新思想的产生和传播有了一个比较自由的空间</p><h2 id="2-2、希腊哲学的基本特征"><a href="#2-2、希腊哲学的基本特征" class="headerlink" title="2.2、希腊哲学的基本特征"></a>2.2、希腊哲学的基本特征</h2><p>希腊哲学的主题是获得关于宇宙万物的必然性或规律的知识：在他们看来,宇宙万物的主宰不是宙斯,因为即使众神也要服从命运和必然性。人世间的战争源自诸神之间的争吵,而诸神之间的争吵则是连宙斯也控制不了的命运。尽管希腊人承认一切都是由命运和必然性所决定的,但是他们并不因此就对命运采取放任自流漠不关心的态度，而是义无反顾地逃避或抗争</p><p>希腊哲学的经验主义：希腊哲学的时代不是建构理论体系的时代,而是探索的时代,哲学家们从事哲学思考的目的不在于建立体系而在于解决问题。因此,希腊哲学在方法上就具有某种“经验主义”的特征</p><h1 id="3、苏格拉底的问题"><a href="#3、苏格拉底的问题" class="headerlink" title="3、苏格拉底的问题"></a>3、苏格拉底的问题</h1><p>希腊哲学的繁荣时期是“雅典时期”,大体上指公元前 5 世纪到公元前4世纪40年代马其顿统一希腊以前的一百多年在这一时期希腊城邦制从繁荣走向衰落,而希腊哲学却达到了它的鼎盛。这一时期哲学的主要代表是具有师承关系的三位哲学家:苏格拉底、苏格拉底的学生柏拉图和柏拉图的学生亚里士多德</p><p>苏格拉底(Socrates,公元前 469一公元前 399)出生在雅典做过阿那克萨戈拉的学生阿尔克劳的学生。阿那克萨戈拉有一项功绩就是将哲学从外邦带回了希腊本土,带到了雅典。苏格拉底与孔子、释牟尼和耶稣等人并称人类的导师,他虽然没有写过什么哲学著作,但却以他的言行对西方文明产生了至今难以估量的深刻影响。有人可能会问,既然苏格拉底没有写过哲学著作,我们如何能够了解他的哲学思想?主要通过苏格拉底的学生柏拉图和同时代人的回忆和记录。柏拉图的哲学写作采取了对话的形式,其中绝大多数对话的主角都是苏格拉底。当然,由此亦产生了另一个问题:在这些对话中,究竟哪些是苏格拉底的思想,哪些是柏拉图自己的思想?实际上,这是很难区分的。学术界一般将柏拉图早期的一些主要讨论伦理学问题的对话称之为“苏格拉底对话”,根据其他的一些证据例如亚里士多德的记述,梳理出苏格拉底本人的思想</p><h2 id="3-1、智者运动"><a href="#3-1、智者运动" class="headerlink" title="3.1、智者运动"></a>3.1、智者运动</h2><p>所谓“智者”,古希腊语为 sophistes,原本泛指有智有识有才之士,例如“七贤”,雅典最早的改革家梭伦和哲学始祖泰勒斯都名列七贤。但是到了公元前 5世纪时，“智者”一词则专指一批收费授徒、重点教授修辞学和论辩术并以此为职业的教师。智者的出现是雅典民主制的产物。城邦民主制度意味着话语具有压倒其他一切权力手段的特殊优势。话语成为重要的政治工具,国家一切权力的关键,指挥和统治他人的方式。于是,修辞学和论辩术便应运而生,并且得到了迅速的发展。从智者的角度说,他们关心的只是论的效果，至于真假、善恶，是非、曲直,他们是不管的。不但不管,为了赢得更多的学生,他们还有意模糊是非善恶的界限,声称世界上本来没有什么善恶是非,只要你掌握了论辩的技术,你就是是非善恶的标准。所以他们经常允诺说,他们在任何情况下都可以帮助你说服他人。这就是说,智者可以帮助你证明煤是黑的,雪是白的,也可以帮助你证明煤是白的,雪是黑的。当然,智者的确使雅典的政治生活越来越不正常,但是政治生活不正常的根本原因不在智者而在于民主制的衰落。不过,智者的泛滥的确进一步加速了民主制的衰落。</p><p>这也就是为什么苏格拉底柏拉图和亚里士多德都把智者当作批判对象的原因。因此在相当长的历史时期内,智者们声名狼藉,俨然就是哲学的“敌人”,以至于“智者”这个概念一向都被看做是“诡”的同义语,直到黑格尔才恢复了智者的本来面目,开始比较客观地评价智者的地位</p><h2 id="3-2、苏格拉底之死"><a href="#3-2、苏格拉底之死" class="headerlink" title="3.2、苏格拉底之死"></a>3.2、苏格拉底之死</h2><p>公元前399年，苏格拉底以引进新神、毒害青年的罪名被雅典公民大会判决服毒自杀。苏格拉底之死，一般都认为是标榜典范民主的古希腊城邦文明的一大污点，甚至是批判者反对民主政治的头号素材 </p><p>表面看来,苏格拉底提倡的原则即使不是反民主制的也是非民主制的,至少在雅典人看来是这样的。城邦民主制的基本原则是每一个公民都有参加政治生活的权利和义务,这就是说,他们用不着学习就天生票赋正义感,就知道怎样决定城邦的大事,这可以说是雅典民主制的根本原则。然而苏格拉底可不这么看。他认为雅典之所以衰落了,根本原因就在于民主制的原则出了问题。正如做鞋子的工匠必须懂得做鞋子的知识一样,管理城邦也需要专门的知识。如果让不懂得治国的民众决定城邦大事,不可能治理好城邦。所以,苏格拉底鼓吹专家治国论。但是,雅典人无论如何难以接受苏格拉底的理论,因为那完全违背了民主制的基本原则。显然,这种专家治国论与城邦民主制是相互矛盾的。</p><p>苏格拉底属于那种实践哲学家,他一生探索真理,虽然没有留下任何著作,但却留下了许多故事。使生苏格拉底死,使死苏格拉底生的,就是他对知识的不懈追求。在城邦民主制度衰落的背景下,苏格拉底试图通过知识来挽救雅典。在他看来,对任何事物,我们只有具有了知识才能知道怎样做和做得更好。所以,他给自己安排的工作就是在任何一种公共场合与人交谈,刺激人们的求知欲,让人们知道自己是无知的。他自比牛虹（hong）,说雅典这匹马太迟钝了,需要有人时不时地刺激它一下。在某种意义上说,苏格拉底企图通过自己的死来唤醒雅典人的良知,雅典人后来也的确觉悟了,为苏格拉底平了反,也惩罚了起诉苏格拉底的人:按照雅典的法律规定,你起诉他人如果败诉,你就必须承担法律责任。换言之,你起诉别人,如果别人没有问题,那就是你有问题。可惜的是,即使雅典人觉悟了,也仍然无能为力。苏格拉底的思想集中表现在“德性即知识”的学说之中。</p><h2 id="3-3、德性即知识"><a href="#3-3、德性即知识" class="headerlink" title="3.3、德性即知识"></a>3.3、德性即知识</h2><p>对苏格拉底而言,认识人自己就是认识心灵的内在原则,亦即认识“德性“。德性是人之为人的本性,由神平均分配给了每一个人,因而人人都具有德性。但是说人人都有“德性”,并非指现实地拥有,而是潜在地拥有。换言之,人并不是生来就符合人的本性,只有在理性指导下认识自己的德性,才能使之实现出来,成为现实的和真正的善。所以苏格拉底认为,未经理性审慎的生活是没有价值的，一个人只有真正认识了他自己,才能实现自己的本性,完成自己的使命,成为一个有德性的人。因此,他把德性与知识等同起来,得出了“知识即德性,无知即罪恶”“无人有意作恶”的结论。在苏格拉底看来,趋善避恶是人的本性,没有人志愿追求恶或他认为恶的东西,是行善还是作恶,关键取决于他的知识,因而每个人在他有知识的事情上是善的,在他无知识的事情上则是恶的。</p><h1 id="4、柏拉图的“洞穴”"><a href="#4、柏拉图的“洞穴”" class="headerlink" title="4、柏拉图的“洞穴”"></a>4、柏拉图的“洞穴”</h1><p>柏拉图早年喜爱文学,写过诗歌和悲剧,并且对政治感兴趣，二十岁左右与苏格拉底相遇,回家把诗稿统统烧掉,从此醉心于哲学研究。苏格拉底之死,使他对城邦完全失望,于是离开雅典到埃及、西西里等地游历,寻求治国安邦的灵丹妙药,时间达十多年之久。公元前 387 年,已届不感之年的柏拉图回到雅典在城外西北角一座为纪念希腊英雄阿卡德穆而设的花园和运动场附近创立了自己的学校学园。这是西方最早的高等学府,后世的高等学术机构(academy)因此而得名。柏拉图学园一直延续了900年之,要不是在公元529 年被皈依了基督教的罗马皇帝封闭了的话,也许今天还在招生呢。</p><p>“洞穴”比喻出现在《国家篇》(汉译为《理想国》第七卷中，内容是这样：假设人类居住在一个洞穴之中,有一条长长的过道通向外面。人类从一开始就住在这里像徒一样双腿和脖子都被锁链锁住了所以他们不能回头，只能看到眼前的洞壁。在他们之后有一堆火在燃烧,在火与因徒之间有一条路和一道矮墙,简直就像是木偶戏的舞台。沿着矮墙,有一些人举着各式各样动物和人的雕像走来走去,火光把这些雕像投射到洞壁上,形成了各式各样的影子。由于那些囚徒生来就不能转身掉头,所以他们就把洞壁上的影子看做是真实的存在。假设有一天,不知因为什么原因,有一个囚徒挣脱了锁链,他回过头来,看到了火光,最初他的眼睛不习惯光亮,当然很痛苦,他会认为他所看到的不是真实的存在。但是当他习惯了之后就会发现过去被看做是真实存在的东西不过是影像,眼前的东西才是真实的。</p><p>柏拉图的洞穴比喻明确区分了现象与本质,主张摒弃感觉经验,以思想把握真理,既奠定了西方哲学此后两千多年的基本思路,也引发了一系列的哲学问题,例如本质与现象、一与多、一般与个别、共相与殊相、理性与感性等等。</p><h2 id="4-1、理想国"><a href="#4-1、理想国" class="headerlink" title="4.1、理想国"></a>4.1、理想国</h2><p>柏拉图政治学说的出发点是寻求正义,这应该是一个城邦(国家)秩序井然稳定发展的基础。<br>在柏拉图看来,人的灵魂由理性、激情、欲望三部分构成,正义的人必须让理性统治激情,由激情抑制欲望。个人是缩小了的国家,国家是放大了的个人。所以,国家的三个阶层即统治者、武士和生产者,它们各自的德性应该是智慧勇敢和节制。统治者的职能是依靠智慧,理性地管理国家;武士的职能是发挥激情,勇敢地保卫国家;生产者的职能是节制欲望安分守己努力劳动。如果这三个阶层各自具备了自己的德性,各司其职,不相懵越国家就达到了正义,否则便是不正义。</p><h2 id="4-2、两个世界"><a href="#4-2、两个世界" class="headerlink" title="4.2、两个世界"></a>4.2、两个世界</h2><p>把事物的本质—理念,与事物分开并且以理念为存在的根据,是柏拉图哲学的基本原则。<br>一类事物有一个理念，各式各样的事物有各式各样的理念。不同的事物组成了<strong>事物的世界</strong>,而由它们的理念所组成的总体就是柏拉图所谓的<strong>理念世界</strong>。在柏拉图看来,前者是可感世界,后者是可知世界。</p><p>他的目的是要人们去关注众多、相对、变动、暂时的事物之外的那个单一、绝对、不动、永恒的理念,并且从中获得真正的认识。例如,人们要获得美的认识,就不能靠美的人物、美的雕像、美的建筑、美的风景或美的图画等事物,因为它们总是相对的,不可能十全十美也不可能永远美丽,只有去把握美自身即美的理念,它才是永恒的、绝对的无限的</p><h1 id="5、亚里士多德的形而上学"><a href="#5、亚里士多德的形而上学" class="headerlink" title="5、亚里士多德的形而上学"></a>5、亚里士多德的形而上学</h1><p>亚里士多德是柏拉图的学生,不过他的观点却与老师不同。亚里士多德将柏拉图的问题称做“分离问题”即理念与事物的分离所造成的一系列问题,他认为分离于事物之外的理念是不存在的,事物的概念与事物本身不可分割,原本是一体。在某种意义上说,在亚里士多德的思想中深深地渗透着经验的因素,他重新恢复了被柏拉图抛弃的自然哲学的地位,以至于在他流传下来的著作中,自然哲学方面的著作占了百分之八十。亚里士多德有一句名言:“吾爱吾师,但吾更爱真理。”</p><h2 id="5-1、科学分类"><a href="#5-1、科学分类" class="headerlink" title="5.1、科学分类"></a>5.1、科学分类</h2><p>亚里士多德是有史以来第一个全面系统地为科学知识分类的哲学家思想家。不过需要注意的是,当亚里士多德说到“科学”的时候,他所指的也是“哲学”。在他的时代,甚至直到两千多年后的 18 世纪,哲学与科学还是同义语。不仅许多自然科学家的著作冠以“哲学”的字样,如牛顿的物理学著作叫做《自然哲学的数学原理》,甚至有些科学试验的仪器还被称为哲学仪器。还有一点需要注意,希腊人意义上的知识或科学与我们所说的知识或科学是不同的。我们所说的科学通常指的是科学技术,它们是认识世界改造世界的工具和手段,这样的科学对希腊人来说是不可思议的。按照希腊人的观念,宇宙自然是活生生的有生命的有机整体,自然是神圣的,人是自然的一部分,自然是大宇宙,人是小宇宙。因此,他们的确主张认识自然认识自然的本性,并且把这种认识看做是人的使命和最高的境界,但是却没有“改造自然”的观念。自然不能“改造”也不应该“改造”,那将使神圣的活生生的自然失去生命。其实不仅是希腊人，古代各大古老文明都具有类似的朴素观念,所谓“改造自然”的观念是近代才产生的。</p><p>在《论题篇》中,亚里士多德以知识的目的为依据,将科学或知识分为三大类,每一大类又分为若干类:<br>1.“理论知识”(theoretike)是为着自身而被追求的知识,包括“物理学”，“数学”和“第一哲学”;<br>2.“实践知识”(praktike)是为着行动而被追求的知识,包括“伦理学”，”家政学”和“政治学”<br>3.“创制知识”(poietike)是为着创作和制造而被追求的知识,包括“修辞学”“诗学”和“辩证法”</p><h2 id="5-2、形而上学"><a href="#5-2、形而上学" class="headerlink" title="5.2、形而上学"></a>5.2、形而上学</h2><p>“形而上学”一词，最初是由亚里士多德著作的编排者所使用的，用以命名这本著述。“形而上学”（metaphysics）一词，字面义是“在《物理学》之后”（after the Physics）。编排者之所以使用这个词，或许仅仅意指这本著述在著作编排顺序上，是位于《物理学》之后的。同学们应该在学习《物理学》之后，再学习《在&lt;物理学&gt;之后》，也就是《形而上学》。但很多研究形而上学的同学，比如我，就没完整读过《物理学》……）在此之后，哲学家们渐渐开始用“形而上学”一词，来指代亚里士多德所创建的那门学科。尽管有时也用“第一哲学”、“神学”等其他名称，但“形而上学”是更常用的名称。</p><p>汉语中这个概念。汉语据《周易》:“形而上者谓之道,形而下者谓之器”将 metaphusika 译作“形而上学”。那么，“形而上学”，如果仅仅从中文理解，就应该是“道学”（与“器学”相对），也就是，“研究无形象的、非物质性的、可以作为规律或准则的事物的学科”。然而，亚里士多德创建的形而上学，却远非“道学”</p><p>那么，亚里士多德创建的“形而上学”，究竟是什么？事实上，这是最难回答的哲学问题之一。亚里士多德本人说对象是“作为存在者的存在者”。“作为存在者的存在者”没有任何玄妙之处，它指一切存在的事物、一切存在者。形而上学的研究对象，就是一切存在者。各门科学也研究存在者，但各门科学仅研究某一部分存在者，并非一切存在者。比如，数学研究“作为数、量的存在者”，物理学研究“作为物质的、运动变化的存在者”，生物学研究“作为生命、有生命机体的存在者”，等等。那么，我们理应有一门学科同时研究一切存在者，而不局限于存在者的某一部分。我们同时考察所有存在者的分类、结构、相互关系等等。这门学科，就是形而上学。</p><h3 id="5-2-1、存在论"><a href="#5-2-1、存在论" class="headerlink" title="5.2.1、存在论"></a>5.2.1、存在论</h3><p>众所周知,形而上学以“存在”作为研究的对象,以至于后来有人创造了个概念ontologia(本体论)作为形而上学的同义语</p><p>认识事物的关键就在于把握事物的本质规定,也就是认识事物的“是什么”,认识“存在”亦当如此,然而实际上我们却不可能像认识具体事物“是什么”那样认识存在“是什么”。因为认识事物“是什么”亦即给事物下定义而所谓“下定义”也就是通过形式逻辑“种加属差”的方式对之做出规定。例如当我们给玫瑰花下定义的时候,首先要确定玫瑰花属于“花”(种),然后就是说明它又与其他的花有什么不同(属差)。显然存在是不可能这样下定义的,因为存在乃是最高的概念,因而既没有与之并列的“属差”,更没有在它之上的“种”。所以,我们是不可能认识存在“是什么”的,只能认识存在是怎样存在的,这就是存在的“存在方式”。存在有两类存在方式,亦即“偶然的存在方式”和“本然的存在方式”。例如我们说“这位建筑师是有德性的”“这位建筑师长得很帅气”它们所表述的就是建筑师的“偶然的存在方式”因为一位建筑师的“本然的存在方式”是具有建筑学的知识,至于他有没有德性,长得漂亮不漂亮,与身为建筑师没有必然的联系。换言之,所谓“本然的存在方式”就是必然为存在所拥有的存在方式。于是，亚里士多德就将形而上学的任务确定在研究“存在”的本然的存在方式上他也称之为“范畴”</p><p>普遍一般的形式在现实中虽然不能独立存在,但当我们认识事物的时候却可以存在于思想之中,所以我们可以通过“范畴”来表现事物的存在方式。<br>亚里士多德在《范畴篇》中提出了关于事物的十种描述方式,也就是十个范畴。他并没有说只有这十个范畴,不过这十个范畴的确是最基本的。</p><p>如果我们要描述一个人,我们会说<br>1.“实体”:他是一个人,这描述的是他“是什么”。<br>2.“数量”:他有 2米高,100 公斤重。<br>3.“性质”:他是一个受过高等教育的人。<br>4.“关系”:他比一般人都要高。<br>5.“地点”:他生活在北京<br>6.“时间”:他昨天出了<br>7.“状态”:他住在旅馆里。<br>8.“动作”:他买了一本书。<br>9.“所有”:他拥有这本书。<br>10.“承受”:他深受这本书的影响。<br>这就是我们用来描述事物存在方式的十个范畴,即:实体、数量性质关系、何处(地点)、何时(时间)、所处(状态)、所有、动作和承受。于是,亚里士多德对“存在”的研究就转向了对存在的存在方式亦即“范畴”的研究</p><h3 id="5-2-2、实体论"><a href="#5-2-2、实体论" class="headerlink" title="5.2.2、实体论"></a>5.2.2、实体论</h3><p>亚里士多德的第一哲学提出十大范畴（必然的本质），他认为“实体”作为哲学的最基本的范畴是第一性的和独立存在的，一切其他范畴都必须依附于实体而存在</p><p>“实体”这个哲学术语，在英语的翻译上有两个，一个是entity，另一个是substance。前者表示存在着的具体事物，也就是可直观的，譬如现实生活当中的桌子、椅子或手上的书……等等，就是一个实体&#x2F;entity。后者表示的是，真正持续地存在着的独立事物。一般而言，是处于一种相对抽象的层面上论述的。关于这个争论在哲学史上就有很多的了。譬如，有些哲学家认为实体&#x2F;substance是物质、精神、上帝、神、心灵、绝对这些……等等。</p><h3 id="5-2-3、神学"><a href="#5-2-3、神学" class="headerlink" title="5.2.3、神学"></a>5.2.3、神学</h3><p>亚里士多德神学并没有吸收基督教思想的因素，也就是没有三位一体等的思想观念。亚里士多德的神更多是一个“不动的推动者”，既然是“不动的”，那么又怎么“推动”呢？亚里士多德认为神是作为一种“现实”的形式而存在的。万物都有发展自身，完善自身的潜能在里面。神是最完善的，万物是朝着神这种最高级的完善性去发展的。然而，这种“不动的推动者”是不会干预自然的。亚里士多德的神更多的是自然领域的，更像是万物的一种目的，他是最现实的，万物都朝向他自己最完善的形象发展。</p><h2 id="5-3、伦理学"><a href="#5-3、伦理学" class="headerlink" title="5.3、伦理学"></a>5.3、伦理学</h2><p>亚里士多德认为灵魂可以分为有滋养的、感性的、理性的三类，有滋养的灵魂属于一切生命体，它们都有新陈代谢功能。感性的灵魂属于动物和人类，但不属于植物。理性的灵魂是人类独有的，灵魂与肉体溶为一体，对个人来说，人死后灵魂不复存在。人生的目的是什么？亚里士多德认为生活是一种积极理性的活动，充满了德行，并为人们努力追求。关于道德或品德，亚里士多德提出德行理论，并将它作为一种中庸之道。在任何情况下，人的行为都有可能不足或过分，这两者都无法构成适当的行为，而德行则介乎这两个极端之间。因此，坚定的勇气既不是率性的放肆，也不是怯懦的退缩。一个人不应该过高地估计自身的价值，同样也不应该妄自菲薄。关于人的善恶问题，亚里士多德认为除了受到强迫和出于无知，人的行动都是自发的，他认为一个人可能会故意作恶。对于友谊观，亚里士多德认为我们要想过一种美满的生活，就必须有朋友，在为环境所迫时，可以相互商量和依靠。对亚里士多德而言，友谊就是把自尊延伸到他人。正是为了自身的利益，你才会爱你的兄弟如同爱你自己一样。虽然亚里士多德提出的伦理学观点现代人基本都能接受，但亚里士多德是在2400年前提出这些观点的，足以说明他对人类哲学史作出的贡献</p><h1 id="6、晚期希腊哲学"><a href="#6、晚期希腊哲学" class="headerlink" title="6、晚期希腊哲学"></a>6、晚期希腊哲学</h1><p>“晚期希腊哲学”包括希腊化时期和罗马时期的哲学思想。所谓“希腊化时期”一般指公元前323 年亚历山大大帝去世至公元前 31 年罗马人征服埃及，也有学者主张这个时期从公元前 336 年亚历山大大帝登基开始算起</p><p>柏拉图和亚里士多德时代的希腊哲学，着重于对自然现象，万物起源等问题进行研究，而亚里士多德以后，马其顿王国兴起，亚历山大远征，希腊恬静的国土沦为战场，人们的生命和财产安全充满危机，哲学家们关心的重点从自然转向到了人，人应该怎么生活，这样的伦理学问题成为了研究的重心，回到了苏格拉底时代，人应该如何安身立命，如何获得幸福的人生。产生了晚期的希腊哲学四大流派：伊壁鸠鲁主义、斯多亚学派、怀疑主义、新柏拉图学派</p><h2 id="6-1、伊壁鸠鲁主义"><a href="#6-1、伊壁鸠鲁主义" class="headerlink" title="6.1、伊壁鸠鲁主义"></a>6.1、伊壁鸠鲁主义</h2><p>伊壁鸠鲁(公元前 342一公元前270)生于雅典，到过萨摩斯等地,在那里熟悉了德漠克利特的著作,18 岁返回雅典求学,大约 36 岁时创办了自己的学校,人称“花园”。此后他一直在学校里从事学术工作,终年72岁。伊壁鸠鲁一生撰写的著作据说多达三百多卷,现在仅存残篇和三封书信。<br>伊壁鸠鲁的哲学体系包括三个部分:研究真理标准的准则学; 研究自然及其生灭的物理学; 研究人生及其目的的伦理学。在他看来，一个人要想获得灵魂的安宁,享受人生的幸福,就必须认识宇宙自然的本性。因而在他的哲学中,准则学和物理学是手段,伦理学则是目的。</p><p>伊壁鸠鲁提倡的是个人快乐，也叫“快乐主义”（享乐主义是后期发展的一种误解。）他认为人天生就是趋乐避苦，趋利避害的，所以人生的意义就是追求快乐，达到幸福的人生也是最大的善（好）。所以快乐都是好的，痛苦都是坏的。但是，不是说所有的快乐都应该去追求，所有的痛苦都应该避免，那样就会发展成错误的享乐主义、纵欲主义。应当有所节制。<strong>“伊壁鸠鲁说过：‘你若按照本性生活，你永远不会穷；而你若按照人们的观念生活，你永远不会富。’本性要求不多，而人们的观念所要求的则漫无节制</strong></p><p>有的快乐是伴随痛苦的，有的痛苦也是伴随快乐的。因为肉体只是现在此刻的瞬间的感觉，不管是吃饭还是看电影还是听歌，还是做运动或者和人打架，都是短暂的，而精神是贯穿过去现在和将来的，有时候多年前的感觉到今天依然无法忘怀，所以他认为精神上的快乐，比肉体上的快乐更大，精神上的痛苦，也比肉体上的痛苦更大。</p><p>伊壁鸠鲁学派认为诸神对人类的事情并不参与（类似《道德经》里说的天地不仁以万物为刍狗），既不会奖赏人，也不会惩罚人，所以向诸神祷告或献祭都是没有用的。增广见闻只是为了消除人在幻想方面的恐惧和迷信。最后，如何能达到这种长久的快乐，伊壁鸠鲁列了四种方法：理解力使我们摆脱烦扰我们的偏见，摆脱空洞的幻想和愿望。它教给我们真正的生活艺术。自我克制以其对待快乐和痛苦的正确态度使我们免受伤害。勇敢则以蔑视死亡和痛苦同样使我们免受伤害；对惩罚的畏惧决不能扰乱我们内心的平安，这要归功于正义</p><h2 id="6-2、斯多亚学派"><a href="#6-2、斯多亚学派" class="headerlink" title="6.2、斯多亚学派"></a>6.2、斯多亚学派</h2><p>伊壁鸠鲁学派从摇篮时期就遭遇另一学派的猛烈抨击，该学派也一样诞生于公元前4世纪末。它的创立者是芝诺（前334—前262，并非巴门尼德的学生芝诺），但并不叫芝诺学派，而因芝诺在希腊广场的壁画柱廊（“柱廊”希腊文作Stoa）聚众讲学，得名为斯多亚学派。对于“享乐乃是至善之事”，斯多亚学派予以反对，认为“至善在于德行”。两大学派之间的尖锐对立，在几百年间也使罗马帝国疆域内的绝大多数知识人分为两大阵营。《新约·使徒行传》中，使徒保罗在雅典城中遇到了“伊壁鸠鲁和斯多亚两门的学士与他争论”。这两个学派的主要兴趣点并不在于获知宇宙间的终极真理，而在于探究何种生活是真正最值得过的。</p><p>斯多亚学派的伦理学是建立在他的自然观上的，他们认为，宇宙是一个活生生的、不断运动的整体，个体从属于这个整体之中。人与自然有着内在的一致性，自然有自己的运行规则，即逻各斯。这种逻各斯，他们认为是一种温暖的气息，他支配着宇宙的运转。宇宙和人有着内在的同构性。逻各斯支配着宇宙灵魂，也支配着个体的灵魂，所以说个体灵魂要服从于宇宙灵魂，人与自然是和谐一致的。所以说，个体最好的生活方式就是顺从自然，合乎自然生活是目的。由于逻各斯是理性，是自然地支配法则，因此顺从自然就是顺从理性。在他们看来，我们需要按照义务来生活，所谓义务就是合于自然。而任何非理性、情欲的东西，都是不符合自然，也都是不能干的，所以形成了禁欲主义的思想，对基督教影响很大</p><blockquote><p>伊壁鸠鲁与斯多亚不同，他强调个体的本位。伊壁鸠鲁认为，感性高于理性，只有感觉才是真实的，真理的存在，在于个体的感觉</p></blockquote><h2 id="6-3、怀疑主义"><a href="#6-3、怀疑主义" class="headerlink" title="6.3、怀疑主义"></a>6.3、怀疑主义</h2><p>怀疑论者，是处于一种社会变化很快时期，导致的一种思潮。他们认为，不给出一个给定的真理体系，也不对此做出否定的结论，而是处于存疑的状态，他们的做法叫做悬置判断。比如他们提出所谓的怀疑论的十式，如，、<br>1、观点分歧。同一个现象，人们的看法往往不同，甚至对立，我们没有标准判断谁对谁错<br>2、无穷后退。当有人认为自己的观点是正确的，就需要进行论证。但是论证本身也需要论证，导致无穷后退<br>3、假设武断。为了不让论证无穷后退，就必须假定一个不证自明的前提，但是他是独断。<br>4、循环论证。当对那个不证自明的独断前提也要进行论证，就会形成循环论证</p><p>因此，不要对于一个观点说对说错。但是怀疑论者，并不是在认识论上探讨这个问题，而是在伦理学上。他们既然，没有对错，那么伦理学的命题也没有真正的答案。如，事物的本性是什么？我们要采取什么态度？我们能够从这种态度中获得什么好处？这些问题我们不知道答案。所以说，我们要保持内心的平静，不动心。一个著名的故事是：</p><blockquote><p>有一次在海上遇到风浪，别人都惊慌失措，他却若无其事，指着船上一头正在吃食的猪说，这才是这人应有的不动心的状态。</p></blockquote><h1 id="7、信仰的时代"><a href="#7、信仰的时代" class="headerlink" title="7、信仰的时代"></a>7、信仰的时代</h1><p>通常我们把西方哲学史划分为几个历史时期:古代哲学(希腊学)中古哲学(中世纪哲学)、近代哲学和现代哲学。中古哲学主要包括教父哲学、经院哲学、文艺复兴和宗教改革,时间从公元2世纪到16 世纪。我们比较笼统地称这一时期的哲学思想为中世纪哲学目的是突出这个时代的主导精神</p><p>前面几讲我们讨论的都是希腊哲学。现在我们转向西方哲学的另个源泉:基督教哲学。一般说来,中世纪哲学就是基督教哲学,或者说是哲学在基督教神学背景之下的特殊形态。</p><h2 id="7-1、基督教的诞生"><a href="#7-1、基督教的诞生" class="headerlink" title="7.1、基督教的诞生"></a>7.1、基督教的诞生</h2><p>要想了解基督教的起源，一切还得从犹太人说起，那么犹太人又是怎么来的？历史上没有明确的记载，不过，根据犹太教的传说，犹太人的起源可以追溯到《圣经》中的“创世纪”。根据犹太教和基督教的传统观点，神创造了天地万物。他在第六天创造了亚当和夏娃，并赋予他们掌管大地的权力。但是，亚当和夏娃却违背了神的命令，在撒旦的引诱下偷吃了禁果，因此被逐出了伊甸园，并来到世界上繁衍生息。因此，他们认为亚当和夏娃是人类的始祖，也是犹太人的始祖。</p><p>亚当和夏娃繁衍的后代，在中东地区发展到了一定的规模，并形成了大大小小的族群，随着时间的流逝，到了诺亚这一代。提到诺亚，这里就不得不提“诺亚方舟”的故事，诺亚是亚当夏娃的第九代后人，根据《圣经》记载，神在创造了世界和人类后，看到了人类的恶行不断增加，便对人性产生了厌恶。于是，神决定发大洪水来清除所有的邪恶，只留下正义的人幸存。</p><p>诺亚就是被神选中的正义之人，在神的指引下，诺亚建造了一艘方舟，并在方舟中为他的家人和各种动物储备食物。洪水来临时，只有诺亚一家人和各种动物得以生存，世界上其他的生命都被淹没在洪水中。大洪水持续了40天40夜，人类的罪恶被清洗干净。</p><p>当洪水消退时，他们重新踏上了这片土地，亚伯拉罕便在这时出生了，他的父亲是诺亚的儿子“闪”。随着亚伯拉罕的长大，神又看到了人类不断的罪恶，总不能一直清洗吧！于是，神与亚伯拉罕建立了契约，承诺要保护他和他的子孙后代，而亚伯拉罕则被要求遵守上帝的命令，放弃自己的祖国，搬到地中海东岸去生活。这个契约是犹太教、基督教和伊斯兰教的共识，也是他们教义的核心，它被认为是上帝与人类建立的第一个神圣约定。上帝还承诺，赐给亚伯拉罕和他的妻子撒拉一个儿子，他就是以撒。</p><p>后来，上帝的承诺在以撒身上应验了，以撒和他的妻子利百加生了一个儿子叫雅各（Jacob），因为是被上帝选中的子民，所以雅各长大后，上帝赐给他新的名字：以色列（Israel），时间一天天过去，以色列也很给力，前前后后总共生了12个儿子，这些人又继续繁衍后代，不断的扩大家族的人数，也分成了12个大大小小的部落，他们自称是“以色列人”。大概过了400年，有一个以色列人叫摩西，有一天摩西来到埃及，并帮助那里的以色列奴隶，逃离了埃及人的奴役。摩西在神的指引下，带领着那些以色列人来到西奈山，并在此得到神的启示，获得了十诫和其他律法，这也是犹太教最早的教义。</p><p>又过了很多年，那12个部落因为各种历史原因，不断的兼并和消失，最后，只剩下了一个犹大（Judah）部落，这里的犹大不是出卖耶稣的那个犹大，而是以色列的儿子“犹大”，经过不断的历史演变，又因为汉语翻译的原因，犹大人也慢慢的被翻译成“犹太人”，犹太这个词就是这么来的，他们也是最早的犹太人。不过，随着各个族群的消失，犹太人也成了唯一留存下来的部落，他们也名正言顺的成了从亚当夏娃到以色列文化合理合法的继承人。随着犹大部落不断的发展壮大，他们形成了独有的信仰体系，就是“犹太教”。这里值得一提的是，由于过去的信息传播并不那么发达，后来的基督教徒，经常把出卖耶稣的犹大和整个犹大部落相关联，所以就衍生出了一种说法，就是犹太人出卖了耶稣，其实，他们之间没有关系，还有，耶稣本身也是犹太人。</p><p>写到这里，犹太人的形成与发展，基本上就交代清楚了。那么，他们又和基督教有什么关系呢？在犹太人的信仰体系中，因为是神和他们的祖先亚伯拉罕签订的契约，只有他们才是神的选民，其他人是得不到神的庇佑的。所以，犹太教只传犹太人，不传外邦人。而且，直到今天，犹太教还在等待一个弥赛亚的到来，因为圣经中说道：终有一天，地球会毁灭，你们当中一人，会引领你们去向天国，那里没有战争，没有痛苦。</p><p>时间来到了公元30年左右，有一个叫耶稣的犹太人，自称是神的儿子（他口中的神就是造就万物的妥拉，也是犹太教信仰的唯一的神）并在犹太教的宗教背景下招募门徒，很快他便收获了一大批追随者，这时候的耶稣也只是在犹太人中传教布道，并没有接收外邦人，还是按照犹太教的律法约束自己。耶稣宣扬上帝的国度即将到来，并呼吁人们悔改、并彼此相爱。但是，他的这些言行，引起罗马当局和犹太教领袖的不满，认为他是亵渎神灵，挑战宗教权威的异端。所以，便命人逮捕了耶稣，并在几天后将耶稣钉死在了十字架上。然而，三天后耶稣却奇迹般的复活，并在40天后升天。</p><p>这就让一部分犹太人更加坚信，耶稣就是他们要等的弥赛亚，因为在《圣经》中，还有一段预言：“神的仆人终将降临，神会将众人的罪孽归罪他一人，他将受到苦难”于是，耶稣显神迹，死而复生就在中东地区一部分人中间传播开来。然而，当时主流的犹太教并不承认耶稣是弥赛亚，认为耶稣死而复生的故事就是编出来的，他的追随者就是异端。所以，最初形成的基督教，遭受到了犹太教非常严酷的打压。</p><p>时间来到公元40年，有一个叫保罗的犹太教信徒出现了，根据《新约》记载，保罗出生于元年前后，他是非常忠诚的犹太信徒，严格的遵守教内律法，并且，在耶稣死后，他也是打压基督信徒最严厉的那波人。据传说，有一天保罗在去耶路撒冷的路上，突然遇到耶稣显灵，并在耶稣的指引下，得到新的启示，从此便转信耶稣。</p><p>从此以后，保罗更是以书信的方式，联系散布在各地的耶稣信徒，不断的通过辩论和宣传，并在这个过程中逐渐形成了基督教的基本教义：只要心中有耶，就能得到救赎。在公元49的时候，保罗又召集了最初的那些耶稣信徒，在耶路撒冷召开了一个教内会议，最终，确定了一套自己的信仰体系和神学思想：外邦人不必在遵守犹太律法，便能加入基督教。</p><p>至此，基督教开始迅速扩展到整个罗马帝国内外，由于加入宗教的门槛降低，越来越多的信徒加入。而犹太教那边始终固守在民族圈子里，无法得到更好的发展。相比之下的基督教，在随后的200多年的发展中，先是由罗马皇帝君士坦丁颁布“米兰赦令”，承认其合法宗教的身份，随后又在公元380年被罗马皇帝狄奥多西一世定为国教。</p><h2 id="7-2、教父哲学"><a href="#7-2、教父哲学" class="headerlink" title="7.2、教父哲学"></a>7.2、教父哲学</h2><p>教父哲学大约发端于2世纪,终结于6世纪。根据教父们活动的区域和使用的语言,后人把他们划分为“希腊教父”和“拉丁教父”,亦称之为“东方教父”和“西方教父”。从总体上来说,以查士丁、奥里根等人为代表的希腊教父比较注重理性与信仰的关系、注重上帝的“三位一体”、上帝与世界的关系等形而上学层面的问题,而以德尔图良奥古斯丁等人为代表的拉丁教父则更多地注重信仰和伦理、注重人的罪以及救赎等问题。奥古斯丁是教父哲学的最杰出的代表，也是基督教神学的重要奠基者</p><p>奥古斯丁(Aurelius Augustinus,354-430)出生于北非的塔加斯特,母亲是基督徒,父亲是异教徒,奥古斯丁出生时并未接受洗礼。386年皈依基督教。奥古斯丁皈依基督教的经历被教会誉为浪子回头的典范。他曾作过教师、神父,后升任北非希波主教,后半生忠心耿耿地致力于基督教的传教事业被教会称为“伟大的教父”“杰出的大师”“上帝的使者”。奥古斯丁一生著述很多，《忏悔录》、《论三位一体》《上帝之城》是他的代表作。</p><h3 id="7-2-1、上帝创世说"><a href="#7-2-1、上帝创世说" class="headerlink" title="7.2.1、上帝创世说"></a>7.2.1、上帝创世说</h3><p>苏格拉底、柏拉图和亚里士多德等希腊哲学家所理解的神与基督教的上帝之间的一个显著差别，就在于前者是一个赋形于质的工匠，后者则是一个“无中生有”的创世者。柏拉图描述的神只是创造了事物的“形式”，而事物的“质料”却是原来就有的。圣经中描绘了一个开天辟地的上帝，世界上的一切事物都是“上帝言说”的结果。</p><p>奥古斯丁对基督教的这种“无中生有”的创世说进行理论上的辩护，他认为希腊哲学家对自然元素的追问不能产生确定的知识，基督徒只需承认世间一切事物都是因上帝的仁慈而受造的就够了。</p><p>上帝创世既不需要材料，也不需要工具，甚至连时间和空间也不存在，他仅凭语言就足以产生出整个世界。</p><p>在谈到上帝创世的具体过程时，奥古斯丁将柏拉图的理念论、亚里士多德的形式学说与基督教的创世说结合起来，他认为上帝首先创造了无形的“种质”，“种质”的复制和展开就产生出有形的万物。但是上帝创造“种质”和有形万物是在“瞬间”完成的。“种质”对于万物的优先性并非是时间上的，而是本质上的、逻辑上的。</p><p>为了说明“瞬间创世说”，奥古斯丁还对时间做了新的解释，在他看来，时间并非永恒的和客观的存在，而只是一种主观的知觉。奥古斯丁把这种主观知觉的持续称为“现在”，“现在”不是时间的一部分，而是时间的全部，因为所谓“过去”和“将来”都不过是在现在的主观知觉中对已逝事物的记忆和对将来事物的期望而已。</p><p>由于时间只是流逝的事物在主观知觉中的持续，因此在上帝创世之前就既无空间，也无时间，时间和空间是与万物一起被上帝创造出来的，这样就不存在创世之前上帝在哪里、创世之前上帝在干什么的问题了。</p><h3 id="7-2-2、“原罪”与“救赎”"><a href="#7-2-2、“原罪”与“救赎”" class="headerlink" title="7.2.2、“原罪”与“救赎”"></a>7.2.2、“原罪”与“救赎”</h3><p>在早期基督教神学中，人性论构成了上帝论和基督论之外的第三个重要领域，而基督教人性论的核心问题就是“原罪”与“救赎”。奥古斯丁早年曾经把罪恶看作是与善良同样具有本质性的实体，后来皈依基督教后认为只有善才是本质和实体，它的根源就是上帝，而罪恶只不过是“善的缺乏”或“本体的缺乏”。上帝作为至善，是一切善的根源，上帝并没有在世间和人身上创造罪恶。罪恶的原因在于人滥用了上帝赋予人的自由意志，自愿地背离了善之本体（上帝）。</p><p>由于始祖亚当对自由意志的滥用，导致了人类永恒的罪性，即“原罪”。尽管最初的人性是纯洁无邪的，但是自从亚当堕落之后，人性就被注定成为有罪和邪恶的。作为对原罪的公正惩罚，上帝使人遭受各种生老病死。正是“原罪”注定了人类的先验罪性、邪恶本质和必死命运。这种情况下，只能依靠上帝的恩典，才能使一部分人的意志重新获得向善的能力，摆脱必死的惩罚而获得灵魂的永生。</p><p>奥古斯丁认为，上帝的救恩已经通过基督代替人类蒙难和死而复活的奇迹而昭示给我们，这恩宠的实质就是把信、望、爱注入我们的心中。上帝在创世之初就已经根据他自己的理由——这理由是我们人类无法理解的“奥秘”——预定了哪些人将被拯救，就此而言，拯救表现了上帝的仁慈，因为它是上帝白白赐予的恩典，得救并非我们自己功德的结果，恰恰相反，我们的一切功德都是上帝恩典的结果；至于那些未被上帝挑选的人，他们应该为始祖所犯的“原罪”而承受惩罚，因为惩罚表现了上帝的公正。</p><p>这种决定论的“原罪”和“救赎”理论使得基督教的人性论像上帝论和基督论一样充满了神秘主义色彩。“原罪”是先验的和形而上学的罪，而“救赎”同样也是先验地被预定的。人的自由意志遭到了贬抑，人的邪恶本性使他不可能依靠自身的力量而向善，只有上帝的恩典才能使人重新获得善良意志，并最终得到拯救。</p><p>亚当的一次滥用自由意志为什么就会造就人类的永罪？上帝依据什么预定了一部分人将得到拯救？这些神圣的“奥秘”，只能在虔诚的信仰中接受其结果，无法妄用理性来追问其理由。</p><h3 id="7-2-3、上帝之城与世俗之城"><a href="#7-2-3、上帝之城与世俗之城" class="headerlink" title="7.2.3、上帝之城与世俗之城"></a>7.2.3、上帝之城与世俗之城</h3><p>公元410年，西哥特人（日耳曼民族中的一支）劫掠了罗马，使罗马这座不朽之城蒙受了巨大的耻辱。</p><p>一些异教徒认为这是罗马多神教的主神对背叛多神教而改信基督教的罗马人的惩罚。</p><p>为了回应这种责难，奥古斯丁提出上帝之城与世俗之城，反驳了异教徒的指责，指出罗马人自古以来就是一个邪恶的民族，因此西哥特人的劫掠体现了上帝的天惩。</p><p>奥古斯丁认为，自从人类祖先亚当、夏娃因犯罪而被贬人间之后，现实世界就被划分为两座城：“一座城由按照肉体生活的人组成，另一座城由按照灵性生活的人组成。”前者是“世俗之城”，它是撒旦的领域，是肉体淫乱的渊薮，在现世中表现为异教徒的生活态度；后者是“上帝之城”，它是上帝的“选民”即预定得救的基督徒的社会，这是一座永恒之城，在现世中代表着它的就是教会。</p><p>这两座城并非两个政治实体或社会群体，它们在现实中是交织、混合在一起的，实际上它们只是对待同一个现实世界的两种截然对立的生活态度。这种对峙在一个身上就表现为肉体（魔鬼的采邑）与灵魂（上帝的采邑）之间的对立。在《上帝之城》中，奥古斯丁把柏拉图的感觉世界和理念世界的对立进一步发展为肉体与灵魂、人间与天国的对立。</p><h3 id="7-2-4、“光照说”"><a href="#7-2-4、“光照说”" class="headerlink" title="7.2.4、“光照说”"></a>7.2.4、“光照说”</h3><p>奥古斯丁在认识论上综合了柏拉图的回忆说和亚里士多德关于积极能动的理性灵魂的观点，提出了“光照说”。他将恩典和真理说成是源之于上帝、见之于我们心灵的理性之中的东西。他把上帝比作真理之光，把人的心灵比作眼睛，而把理性比作心灵的视觉，正是上帝的光照使心灵的理性看到了真理。他认为，由于灵魂本身就是上帝创造的，因此在被造的心灵中已经潜在地包含着真理的成分，这种观点与柏拉图的回忆说有几分相似之处，所不同的是，奥古斯丁认为理性对于真理的认识不是通过感觉经验的刺激，而是依照上帝的光照。按照这种“光照说”，只有在虔诚的信仰中，上帝的光照才会显得通明透亮，而神圣的真理也只有在灵魂摆脱肉体之后才能最终被认识。</p><h3 id="7-2-5、上帝存在的证明"><a href="#7-2-5、上帝存在的证明" class="headerlink" title="7.2.5、上帝存在的证明"></a>7.2.5、上帝存在的证明</h3><p>奥古斯丁不仅通过“原罪”与“恩典”学说表达了一种神正论思想，而且也试图用理性的方式来证明上帝的存在。虽然他强调基督教真理的奥秘性，但是他与极力贬抑理性的德尔图良不同，在保证信仰至上性的前提下，并不拒绝运用理性来为信仰提供支持。他是教父派中最早尝试用理性来证明上帝存在的人之一，他把基督教称为真正的哲学，认为上帝的智慧已经铭刻于《圣经》之中，而信仰的特点就在于“以赞同的态度思想”来对待表现在《圣经》和各种教义中的基督教真理。因此他坚持“相信，然后理解”的基本立场，在坚持信仰至上性的前提下承认理性的作用。</p><p>奥古斯丁认为，运用理性来证明上帝存在的方法有三种：一是通过宇宙的秩序，二是通过万物的等级，三是通过人心的内省和思辨。前两者都属于宇宙论证明，后者属于本体论证明。奥古斯丁对前两种证明方法都不太感兴趣，他主张用第三种方法证明上帝的存在。</p><p>他的论证过程是，凡存在于记忆中的东西，都有着事先的原因，我们对上帝的认识也是如此。我们平时只要一听到人们说起上帝，马上就能在心中想起他来，可见关于上帝的观念是早就存在于我们的心灵中的。而这个上帝的观念必定是一个外在于我们的某物事先放于心灵中的，这个某物作为原因要比作为结果的心灵更加优异或伟大，我们将其称之为真理，而真理本身就说明了上帝的存在。</p><p>从这个证明中，我们既可以看到柏拉图回忆说的影响，也可以找到安瑟尔谟关于上帝存在的本体论证明的思想渊源。</p><h1 id="8、人的发现"><a href="#8、人的发现" class="headerlink" title="8、人的发现"></a>8、人的发现</h1><h2 id="8-1、文艺复兴"><a href="#8-1、文艺复兴" class="headerlink" title="8.1、文艺复兴"></a>8.1、文艺复兴</h2><p>“文艺复兴”一词最先是由意大利艺术史家乔治奥瓦萨里在其《意大利艺苑名人录》的序言中提出的。该词源自意大利文“Rinascita”，一般写为法文“Renaissance”，意为再生、复兴，中文译作文艺复兴”。这里所说的复兴主要是指复兴古典文化，即古希腊罗马文化。当时一些新兴资产阶级的代表人物提出“回到希腊去”的口号，声称要重“文艺新振兴已湮没的古典文化，使之“再生”复兴”由此得名。核心是人文主义</p><p>其实，文艺复兴并不是对希腊和罗马文化的简单重复与再现，新兴的资产阶级之所以打着古典文化的旗帜，是将之作为反封建、反教会的思想武器，旨在冲破中世纪的禁锢。文艺复兴的指导思想和有力武器是人文主义。它主张社会生活以人为中心，重视人的价值，反对以神为中心;提倡人权，反对君权，推崇个性自由和解放，反对宗教的桎梏;主张发展科学，探索自然和社会奥秘，反对教会愚民说教。可以说，文艺复兴是一场把人的思想、感情和智慧从神学的束缚下解放出来的思想解放运动</p><p>1.文学成就</p><p>(1) 但丁: 被称为“中世纪最后一位诗人，同时又是新时代的最初一位诗人”。<br>他的《神曲》以梦幻文学的形式，通过对幻游地狱、炼狱和天堂三界过程中遇到的各类人物的描写，抨击了教会的贪婪腐化和封建统治的黑暗残暴，歌颂了自由的理性和求知的精神</p><p>(2)彼特拉克: 是文艺复兴时期的第一位人文主义者。<br>他的《歌集》歌颂了对恋人劳拉的爱情，摆脱了教会的禁欲主义束缚，表现了人文主义者以个人幸福为中心的爱情观</p><p>(3)薄伽丘: 其代表作《十日谈》以通俗的格调，批判封建社会阶级不平等和男女不平等，反映了新兴市民阶级对禁欲主义的反抗。</p><p>(4)莎士比亚: 文艺复兴时期英国杰出的戏剧家和诗人。17世纪他写了悲剧《哈姆雷特》《奥赛罗》《李尔王》等，代表他创作的最高成就。</p><p>2.文艺复兴时期的艺术成就</p><p>(1)达芬奇: 著名画家、数学家、力学家和工程师。其代表作《蒙娜丽莎》是一副肖像画，作品提示了画中人物的微妙心理，蕴含着对新时代新生活的喜悦。</p><p>(2)米开朗基罗: 著名雕塑家、画家和建筑师。他塑造的形象刚健雄浑、豪放宏伟。代表作有雕塑作品《大卫像》《摩西像》，壁画《创世纪》和《末日审判》</p><p>(3)拉斐尔:杰出的画家和建筑师，被称为“画圣”以画人像著称，他画的圣母完全是现实生活中一位年轻的洋溢着欢乐幸福的母亲形象。代表作《西斯廷圣母》</p><h2 id="8-2、宗教改革"><a href="#8-2、宗教改革" class="headerlink" title="8.2、宗教改革"></a>8.2、宗教改革</h2><p>宗教改革是基督教在16至17世纪进行的一次改革，代表人物有马丁·路德、加尔文及慈运理等人。一般认为宗教改革始于1517年马丁·路德提出九十五条论纲，结束于1648年的威斯特法伦和约。其核心思想是“因信称义”</p><blockquote><p>因信称义是德国神学家马丁·路德的神学思想核心。他认为，基督徒之所以是自由的，是因为他们“因信称义”，不再受善功律的支配，他们通过自己的信仰而与基督建立了新的个人关系。灵魂的得救不是教会的工作，是上帝把恩赐给了他的信仰者。因此，信徒不必依靠教会极其繁琐的宗教礼仪，只凭对上帝对的虔诚信仰就可以得到灵魂的拯救。<br> “因信称义”是对天主教会所宣扬的“行为称义”的否定，这种思想也有利于培养新兴资产阶级的个人主义</p></blockquote><p>宗教改革的社会背景就是当时的教会腐败以及政治上的混乱。思想背景是随着中世纪城市的发展，市民阶层逐渐兴起，对教会的大一统神权与正统神学的统治极其不满，于是酝酿出反教会的市民“异端”思想。市民的“异端”思想，有力地冲击了天主教会神权的合法权威，反映了市民阶级建立“民族教会”或“廉价教会”的愿望，为16世纪西欧的宗教改革提供了可借鉴的历史遗产。</p><p>宗教改革直接的要求是消除教会的权威，把奢侈教会变为廉洁教会，而从哲学上看，其内在要求则是由外在的权威返回个人的内心信仰。新的宗教哲学思想是宗教改革的核心。宗教改革的代表运动是马丁－路德领导的宗教改革运动和加尔文的宗教改革。</p><h1 id="9、主体性的崛起"><a href="#9、主体性的崛起" class="headerlink" title="9、主体性的崛起"></a>9、主体性的崛起</h1><p>近代哲学标志着“主体性的觉醒”,近代哲学的创始人是法国哲学家笛卡尔,而使笛卡尔成为近代哲学名副其实的创始人的乃是一个哲学命题，这就是:“我思故我在”</p><h2 id="9-1、方法论"><a href="#9-1、方法论" class="headerlink" title="9.1、方法论"></a>9.1、方法论</h2><p>笛卡尔对经院哲学的逻辑方法与科学的数学方法进行了比较研究。在笛卡尔之前,经院哲学使用的方法主要是亚里士多德的三段论,他称之为“旧逻辑”。笛卡尔并不完全否定亚里士多德逻辑的作用,只是在他看来旧逻辑只能用来推理分析已知的知识而不能获得新知识。数学方法也有其局限性,它虽然具有清楚明白无可置疑的确定性,并且能够推演出新知识来但却只研究抽象的符号,而不研究知识。于是,笛卡尔设想了一种包含这两种方法的优点而避免了它们的缺点的新方法,它既推理严密又能获得新知识。为此,他首先提出了四条方法论原则:</p><p>第一条:“决不能把任何我没有明确地认识其为真的东西当作真的加以接受,也就是说,小心避免仓促的判断和偏见,只把那些十分清楚明白地呈现在我的心智之前,使我根本无法怀疑的东西放进我的判断之中”。笛卡尔首先确立了理性的权威,主张以理性来检验一切知识,并且确定了检验的标准:清楚明白,无可置疑。</p><p>第二条:“把我所考察的每一个难题,都尽可能地分成细小的部分,直到可以而且适于加以圆满解决的程度为止”。这就是近代自然科学和哲学中流行的分析方法,亦即从个别、特到一般,将对象分解为不可再分的基本性质。</p><p>第三条:“按照次序引导我的思想,以便以最简单、最容易认识的对象开始，一点一点上升到对复杂的对象的认识,即便是那些彼此间没有自然的先后次序的对象,我也要给它们设定一个次序”。这就是“综合方法”,即从抽象的一般上升到具体的个别,在理论上重现事物之整体的真实本性。</p><p>第四条:“把一切情形尽量完全地列举出来,尽量普遍地加以审视,使我确信毫无”</p><p>这四条方法论原则灌注了一种批判的理性主义和一丝不苟的科学精神。在此基础上,笛卡尔建立了他的“理性演绎法”。一般说来,笛卡尔的理性演绎法包括两个部分,即直观和演绎。所谓“直观”既不是感性直观也不是神秘的直觉而是“直观”它是一个清晰而周详的心灵的无可置疑的概念,仅仅由理性之光突然而出;它比演绎本身更确实可靠,因为它更简单,虽然演绎也不可能被我们错误地使用。所谓演绎”就是从业已确知的基本原理出发而进行的带有必然性的推理。由此可见智直观的作用是为演绎提供进行推理的基本原理,演绎就从这些基本原理出发,形成一个具有普遍必然性的推理过程,最终形成科学知识的体系。笛卡尔认为,他的“演绎”与经院哲学的演绎法不同,是一种能够产生新的知识、形成科学体系的新方法。因此,笛卡尔要求哲学的基本原理必须满足两个条件:</p><p>第一，“它们必须是明白而清晰的，人心在注意思考它们时，一定不能怀疑它们的真理”;<br>第二，“我们关于别的事物方面所有的知识一定是完全依靠那些原理的,以至于我们虽然可以离开依靠于它们的事物,单独了解那些原理,可是离开那些原理,我们就一定不能知道依靠于它们的那些事物”。<br>笛卡尔称这些基本原理为“天赋观念”。“天赋观念”是卡尔哲学乃至唯理论哲学的基础</p><p>于是,笛卡尔以怀疑为武器给予已经漏洞百出的经院哲学以毁灭性的打击。不过,他的怀疑不仅是破坏性的,而且是建设性的。就像阿基米德要求一个牢固的支点来撬动地球一样,笛卡尔要运用怀疑来寻求一个无可置疑的依据,以此为基础建立一座知识的大厦。所以,他的怀疑与怀疑论的怀疑有所不同:怀疑论以怀疑为目的,而卡尔的怀疑则是一种方法和手段。正是运用这种“方法论上的怀疑”,笛卡尔开始了重建形而上学的工作</p><h2 id="9-2、我思故我在"><a href="#9-2、我思故我在" class="headerlink" title="9.2、我思故我在"></a>9.2、我思故我在</h2><p>“我思故我在”是笛卡尔哲学中最著名的命题之一，在西方哲学史上也具有重要地位。<br>笛卡尔的思考方法是怀疑主义的，他试图从最基本的感性知识开始，通过怀疑这些知识来达到真正的认识。他质疑了所有传统的观念和信仰，并且只相信那些可以被自己的理性所证明的东西。<br>在这个过程中，他发现唯一不可能被怀疑的一个东西就是“我思故我在”，因为在怀疑的过程中，有一个思考者在进行怀疑。即使其他方面都被怀疑了，这个思考者的存在还是不容置疑的。因此，他得出结论：“Cogito, ergo sum.”（我思故我在）</p><p>注:其中“我”指代的是思维主体，即人类自身所拥有的意识、理智和思维能力。这个“我”并不是指身体或其他物质实体，而是精神实体，也就是思维主体的本体。从这个角度来看，“我思故我在”强调了思维主体的存在和价值，认为它是不可分割的精神实体。所以这个命题可以翻译为:因为我能思考，所以存在一个思考的精神实体。而不是我思考，所以我存在的意思，高中必修三课本上把这句话主观的归为唯心主义就是一种谬误。<br>笛卡尔提出“我思故我在”的目的，是旨在从自身存在的角度出发，探讨人类是如何认识自身和世界的。所以我思故我在属于哲学中存在论的部分</p><h1 id="10、大陆理性主义"><a href="#10、大陆理性主义" class="headerlink" title="10、大陆理性主义"></a>10、大陆理性主义</h1><p>三大理性主义者：莱布尼茨、笛卡尔、斯宾诺莎</p><h2 id="10-1、斯宾诺莎"><a href="#10-1、斯宾诺莎" class="headerlink" title="10.1、斯宾诺莎"></a>10.1、斯宾诺莎</h2><p>巴鲁赫·德·斯宾诺莎（1632-1677） “一般的哲学是从被创造物开始的（研究自然），笛卡尔是从心灵开始的，我则是从神开始的（神圣的必然性）。”<br>“事物被我们认为是真实的，不外两个方式：或者是就事物存在于一定的时间及地点的关系中加以认识，或者是就事物被包括在神内，从神圣的自然之必然性去加以认识。”</p><h2 id="10-2、莱布尼茨"><a href="#10-2、莱布尼茨" class="headerlink" title="10.2、莱布尼茨"></a>10.2、莱布尼茨</h2><p>莱布尼茨（1646-1716）提出哲学始终面对的两大迷宫：自由与必然之间的矛盾；不可分的点与连续性之间的矛盾。莱布尼茨认为实体是无限多的，并具有以下几个特征：</p><p>1、不可分割性。有广延的东西可以被分割，且依他物而被知，不具有自足性，而实体是自足的，依自身而被知，因此不是具有广延的东西，也就不可分割。实体也被他称作“单子”；</p><p>2、封闭性。因为每一个单子必然自足，不依他而存在，所以单子之间没有交互作用，“单子之间没有窗户。”</p><h1 id="11、-经验论"><a href="#11、-经验论" class="headerlink" title="11、 经验论"></a>11、 经验论</h1><p>经验论重视实验科学，以“心理论”的方式构建体系，往往按照“经验—观念—知识”的模式。经验论的基本原则：一切知识来源于感觉经验；我们无法超脱出感觉经验去认识世界。</p><h2 id="11-1、洛克"><a href="#11-1、洛克" class="headerlink" title="11.1、洛克"></a>11.1、洛克</h2><p>洛克（1632-1704）经验主义唯物论 《人类理智论》。反对“天赋观念”的存在，提出“白板说”，人的心灵一开始就是一张白纸，外部事物通过外感官印在这张白纸上，产生经验，它变成观念再变成知识；同时人还会通过内感官来反省，形成另一种知识或者处理原有的知识。外物到经验：物体的性质分为“第一性的“</p><p>经验论必然导致的两个难题：</p><p>1、经验从何而来？能不能超出经验去认识引起经验的那个东西？</p><p>2、感觉经验总是个别的、偶然的、相对的，那末以感觉经验为基础的知识怎么会有普遍性与必然性？（经验重复一万次还是经验，黑天鹅的例子）</p><h2 id="11-2、贝克莱"><a href="#11-2、贝克莱" class="headerlink" title="11.2、贝克莱"></a>11.2、贝克莱</h2><p>贝克莱（1685-1753）非物质主义 主观唯心主义 维护宗教 《人类知识原理》 在认识中，只存在感知观念的心灵（主体）和被心灵感知的观念（客体）</p><p>大前提：观念的存在在于被感知</p><p>小前提：物&#x3D;可感物&#x3D;观念的集合</p><p>结论：物的存在即被感知（物存不存在取决于我的心灵有没有感知到物）</p><p>之所以用“观念”而不用“事物”，是为了反对心外有物的唯物主义，他不是想把事物变成观念，而是想把观念变成事物，即维护观念的客观实在性。贝克莱的“存在即感知和被感知”并不是我感知到就存在、感知不到就不存在的唯我论，而是说这个世界以观念的形式存在（观念并非主观的东西，是客观实在的，我们无非是具有感知这些观念的能力而已），你感知到的只能是观念，不能是别的。但我们的心灵只是去感知这个观念的世界，并没有创造它，在此，贝克莱说一定有一个无限的心灵（上帝）创造了这个观念的世界，也创造了我们有限的心灵，使我们能够感知这个世界。</p><blockquote><p>对比:<br> 洛克：物客观存在——物刺激心灵形成观念——观念组成知识，超出经验去判断经验的产生是由于上帝。<br> 贝克莱：观念客观存在——心灵感知观念——观念组成知识，超出观念去判断观念由上帝创造。</p></blockquote><p>两人关于观念的产生问题都违背了经验论的基本原则</p><h2 id="11-3、休谟"><a href="#11-3、休谟" class="headerlink" title="11.3、休谟"></a>11.3、休谟</h2><p>休谟（1711-1776）《人性论》《人类理智研究》人的意识分为观念和印象，人类理智的对象分为观念的关系（关于它的知识是必然的知识，自然界可以不存在三角形，但欧几里得定义的概念上的三角形仍然存在，因为它符合逻辑能够自洽）和实际的事情（关于它的知识是或然的知识，经验重复一万次也是经验，感觉经验只对过去和当下有效，对未来无效），实际上休谟认为人类只有这两方面的知识，其他所有的都不叫知识（特别是形而上学和神学，休谟称之为伪问题，都无法在逻辑和经验上得到证明）。</p><p>“在所有的原则里，只有因果观念使人们超出经验去下判断。”因为休谟认为人只经验到了所谓的“原因”与所谓的“结果”，而没有也不可能经验到这两者之间的所谓的必然的因果联系，因此，人们说的因果联系实际上只是一种习惯性联想，是超出经验范围所下的一个判断。比如看到A之后看到B，多次这样之后便认为A是因，B是果，再比如巴甫洛夫的狗，狗认为铃铛是因，食物是果。但这样的习惯性联想对人来说十分重要，它让人对世界产生秩序感，从而适应世界，“习惯是人生伟大的指南”</p><h1 id="12、社会政治理论"><a href="#12、社会政治理论" class="headerlink" title="12、社会政治理论"></a>12、社会政治理论</h1><p>一种社会制度应该建立符合人的自然本性，那个时代的两个核心概念：自然状态、社会契约。</p><h2 id="12-1、霍布斯"><a href="#12-1、霍布斯" class="headerlink" title="12.1、霍布斯"></a>12.1、霍布斯</h2><p>霍布斯（1588-1679）的国家起源学说：人的本性是趋利避害、自私的，为了利益，人与人之间会发生分歧、争端、争斗乃至战争，当人们处于一种混乱的状态时，每个人的利益都会受损，这时人们为了自己的利益制定出一些道德准则来，但是道德毕竟是软弱的，所以人们便相互约定，把他们的自然权利转让出去，交付给一个人或由一些人组成的会议，把大家的意志变成一个意志，由这个意志来限制暴力、调解争端，保护大家的利益。“国家的产生是通过人们相互之间订立契约，把全部权利交付给一个人或一些人组成的会议而实现的。”（国家就是利维坦,至高无上）</p><h2 id="12-2、洛克"><a href="#12-2、洛克" class="headerlink" title="12.2、洛克"></a>12.2、洛克</h2><p>同意社会契约论，但认为人们订立契约、建立政府的目的是为了保护自己的自然权利，所以人们并非像霍布斯所说的将全部自然权利都交给专制的政府或君主，他们放弃的唯一的自然权利只是维护自然法，惩罚犯罪者的执行权。人们拥有人民主权，如果政府不能维护好订立契约者们的自然权利，人们就可以群起推翻之。为了防止君主专制，提出权力分散、互相制约的学说。</p><h2 id="12-3、孟德斯鸠"><a href="#12-3、孟德斯鸠" class="headerlink" title="12.3、孟德斯鸠"></a>12.3、孟德斯鸠</h2><p>一切存在物都有它们的“法（规律）”，人类的法是“根本理性”，所谓“法的精神”就是指作为一般的普遍的人类的法与一个国家的具体情况（宗教、民族、文化等等方面）相结合（地理环境决定论），由此产生了不同的政治体制。</p><p>认为人类历史上存在过三种政体：共和政体（全体人民或仅仅一部分人民握有最高权力的政体）、君主政体（由一个人执政，不过参照固定的法律，英国君主立宪制就是典范，孟德斯鸠倾向于它）、专制政体（既无法律又无规章，由一个人按照自己的意志与性情领导一切）</p><p>自由： “在一个有法律的社会里，自由仅仅是：一个人能够做他应该做的事情，而不被强迫去做他不应该做的事情。”“自由是做法律所许可的一切事情的权利；如果一个公民能够哦做法律所禁止的事情，他就不再有自由了，因为其他人同样会有这种权利。” </p><p>在人们从自然状态向社会状态过渡的过程中出现的法律绝不是为了限制人们的自由，而是为了保障人们的自由，法律为社会人的活动划定了一条底线，允许人们在这条底线之上实现自己的价值、追求自己的幸福</p><h2 id="12-4、卢梭"><a href="#12-4、卢梭" class="headerlink" title="12.4、卢梭"></a>12.4、卢梭</h2><p>卢梭（1712-1778）把“人所形成的人”即社会人与自然人加以比较，来说明人类社会的基础和不平等的起源。</p><p>在自然状态下，人人自由平等，人类的不平等源自私有制的产生，后来出现的国家加剧了这一不平等状态。启蒙思想家认为人只要大胆地使用理性，提倡科学与知识进步，社会就会不断进步，但卢梭则认为社会越发展越不平等。卢梭认为迄今为止一切社会制度都以人失去自由平等为代价，唯有合理的社会契约制度能保留人们的自由与平等，这样的制度的要旨就在于“每个结合者及其自身的一切权利全部都转让给整个的集体”，在这样的社会里，不存在统治者与被统治者，自己是自己的主人，法律、决策、政策、规则、制度等等依“公意”（公共利益的代表，是从作为个人意志总和的“众意”中除掉相异的地方而剩下的相同的部分）来制定。</p><h1 id="13、康德的“哥白尼式的革命”"><a href="#13、康德的“哥白尼式的革命”" class="headerlink" title="13、康德的“哥白尼式的革命”"></a>13、康德的“哥白尼式的革命”</h1><p>一、康德哲学面对的问题（都可以归结为和“知识”相关的问题）</p><p>1、理性的危机：经验论和唯理论（与精神世界无关的物质世界里的有关事物属性的知识无法进入人的精神里）没有做到证明科学知识具有普遍性与必然性。</p><p>2、自由的失落：启蒙思想要实现人的自由与解放，但当时的科学主义渗透到哲学乃至一切学科的研究里，导致哲学里决定论占据上风（即人、社会、自然都服从于自然法则），这就使自由失去了自己的地位。</p><p>3、形而上学的名存实亡：形而上学想成为科学但是没有成为。康德认为形而上学体现的是人类理性试图超越自身有限性，通达自由境界的一种理想，但假如形而上学试图成为一种科学，去探索那些普遍性必然性的法则，那么就与这个理想背道而驰了。</p><p>问题总结：在一个严格受自然法则限制的世界上，人有没有自由？有没有不同于其他自然存在物的价值与尊严？</p><p>对康德影响最大的两个人：休谟，打破了康德的独断论迷梦，独断主义&#x2F;独断论（dogmatism）：没有对理性的认识能力进行深入的考察，就武断断定的哲学理论；卢梭，让康德改变过去的看法，认为真正体现人的价值与尊严的不是知识与理性，而是人的道德水平。</p><p>二、康德哥白尼式的革命</p><p>经验论和唯理论的困境是：如果知识必须建立在感觉经验之上，就不可能有普遍必然性；如果有普遍必然性，就必须是先天的，不可能来源于感觉经验。两者达成共识——从感觉经验不可能探索出具有普遍性与必然性的科学知识。</p><p>但现有的科学知识（牛顿物理学和欧几里得几何学）却具有普遍性必然性，前人在这里无计可施，而康德参照了哥白尼颠倒人们关于太阳围绕地球公转的成见，提出：不是知识必须符合对象（意味着知识具有普遍必然性），而是对象必须符合认识主体的先天认识形式。康德一方面承认一切知识来源于感觉经验，一方面认为主体具有加工整理感觉经验的先天认识形式（独立于经验同时作为经验的先决条件，对象符合这种先天形式，也就意味着加工出来的知识具有普遍必然性），而由此形成的科学知识也就同时具有经验内容与普遍必然性了。</p><p>不可知论：一个难题随着这种逆向的哥白尼式的观点而来，即所谓的“先天知识形式”限制了我们的认识能力与范围，我们认识到的只是事物那符合我们的先天形式的那一方面，而无法认识事物的整体面貌——物自体不可知，康德在此区分了一组概念，erscheinungen&#x2F;appearance（显现）&amp; dinge an sich&#x2F;things in themselves（物自体），这种不可知论打破了形而上学探索世界的终极原因的理想。但随即，康德就把这个看似消极的结论转化为了一个积极的论证出发点：在现象界中，一切事物都受到限制，没有自由，但物自体却不受任何先天认识形式的限制，我们可以从逻辑上假设erscheinungen是自由的，这就为伦理学和道德留下了追求自由的机会。“我必须限制知识（科学-纯粹理论理性），以便为信念（伦理学-纯粹实践理性，甚至是形而上学）留地盘”，康德在伦理学和科学中间严格地划分界限，科学只能去认识必然性，不可能使人类得到自由，一旦逾越界限甚至会妨害人类的自由。</p><p>“人是有限的理性存在”——人是两个世界的成员，一方面是感觉世界、自然的成员，受到自然法则的必定限制，一切都是必然的，没有自由，另一方面是理性世界的成员，可以拥有理性但不必然拥有理性，可以但不必定受理性法则的限制。人之为人还是在于理性，人类应该按照理性法则（体现为道德法则）去做，只有在这个领域人类才拥有自由。</p><p>康德为何要为形而上学和伦理学“留地盘”？</p><p>康德的三大批判（康德的“批判”指的是分析和考察，对象是理性，这种哲学方法与独断论相对）实际上解决的是形而上学和伦理学问题，在那个科学高歌猛进的启蒙时代，科学主义登上宝座，上帝（宗教信仰，也包括伦理学、道德、形而上学等等）退位，工具理性呈现出压倒价值理性的发展趋势，实际上卢梭已经看出了这种迹象，而康德和他的关注一样，想要去研究科学和理论理性究竟能不能代替上帝，填补人们的精神空虚。价值多元化、道德相对主义出现并在今日成为普遍现象，今天研究康德仍然有现实意义。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哲学 </tag>
            
            <tag> 西方哲学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步非阻塞编程：CompletableFuture</title>
      <link href="/posts/20328.html"/>
      <url>/posts/20328.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h1><p>我们都知道可以通过继承Thread类或者实现Runnable接口两种方式实现多线程。但是有时候我们希望得到多线程异步任务执行后的结果，也就是异步任务执行后有返回值，Thread和Runnable是不能实现的。当我们需要返回值的时候怎么办呢？ Java 1.5 推出的Callable和Future接口就解决了这个问题。但是因为Future有几个局限，由于这几个局限，在Java1.8就推出了加强版的Future类：CompletableFuture</p><p>Future用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java8之前若要设置回调一般会使用guava的ListenableFuture。 CompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排</p><h1 id="2、Future使用"><a href="#2、Future使用" class="headerlink" title="2、Future使用"></a>2、Future使用</h1><p>假如我们现在有如下需求：</p><p>老板正在开会，开会过程中发现少一份材料，通知秘书去整理，在秘书整理过程中老板这边还在继续开会，秘书整理完以后将材料给到老板手中。</p><p>需求分析：</p><p>老板开会是主线程，不能中断。秘书就是异步任务秘书执行完任务需要将结果返回给老板这个主线程手中。咱们看看通过Future实现此需求有什么局限，然后再通过CompletableFuture实现此需求看看是否更好。</p><p>Future接口（实现类：FutureTask）定义了操作异步任务执行的一些方法：如获取异步任务执行结果、取消任务的执行结果、判断任务是否被取消、判断任务执行是否完成等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BossMeeting</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 主线程为老板正在开会</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老板开会start&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        FutureTask&lt;String&gt; secretaryFuture = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;老板需要的材料&quot;</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//老板发现缺少材料，提交异步任务（找秘书）</span></span><br><span class="line">        executorService.submit(secretaryFuture);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方法1</span></span><br><span class="line"><span class="comment">         * 局限：导致线程堵塞</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取秘书搜集的材料 （堵塞线程）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">material</span> <span class="operator">=</span> secretaryFuture.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;秘书搜集到的材料：&quot;</span> + material);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方法2</span></span><br><span class="line"><span class="comment">         * 通过while轮询方式会消耗cpu</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secretaryFuture.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取秘书搜集的材料 （堵塞线程）</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">material</span> <span class="operator">=</span> secretaryFuture.get();</span><br><span class="line">                    System.out.println(<span class="string">&quot;秘书搜集到的材料：&quot;</span> + material);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;老板开会end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：<br>老板开会start<br>秘书搜集到的材料：老板需要的材料<br>老板开会end</p><h1 id="3、CompletableFuture实现非阻塞式执行"><a href="#3、CompletableFuture实现非阻塞式执行" class="headerlink" title="3、CompletableFuture实现非阻塞式执行"></a>3、CompletableFuture实现非阻塞式执行</h1><p>CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompletableFuture</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;</span><br></pre></td></tr></table></figure><p>用CompletableFuture实现上述的业务场景：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 老板开会Future实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BossMeeting</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;老板开会start&quot;</span>);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;秘书搜集完材料&quot;</span>;</span><br><span class="line">                <span class="comment">//结束返回</span></span><br><span class="line">            &#125;, executorService).whenComplete((v, e) -&gt; &#123;</span><br><span class="line">                <span class="comment">//无异常说明 执行成功</span></span><br><span class="line">                <span class="keyword">if</span> (e == <span class="literal">null</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;秘书搜集到的材料：&quot;</span> + v);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//异常处理</span></span><br><span class="line">            &#125;).exceptionally(e -&gt; &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;执行异常：&quot;</span> + e.getCause());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line"> </span><br><span class="line">            System.out.println(<span class="string">&quot;老板继续开会&quot;</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟老板继续开会3秒钟</span></span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;老板开会end&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：<br>老板开会start<br>老板继续开会<br>秘书搜集到的材料：秘书搜集完材料<br>老板开会end</p><h1 id="4、CompletableFuture相关方法"><a href="#4、CompletableFuture相关方法" class="headerlink" title="4、CompletableFuture相关方法"></a>4、CompletableFuture相关方法</h1><h2 id="4-1、CompletableFuture创建方式"><a href="#4-1、CompletableFuture创建方式" class="headerlink" title="4.1、CompletableFuture创建方式"></a>4.1、CompletableFuture创建方式</h2><p>官方推荐使用CompletableFuture提供的静态方法创建CompletableFuture实例，以下是提供的静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无返回值 使用ForkJoinPool线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable)</span></span><br><span class="line"><span class="comment">// 无返回值 可以自定义线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">runAsync</span><span class="params">(Runnable runnable, Executor executor)</span></span><br><span class="line"><span class="comment">// 有返回值 使用ForkJoinPool线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier)</span></span><br><span class="line"><span class="comment">// 有返回值 可以自定义线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">supplyAsync</span><span class="params">(Supplier&lt;U&gt; supplier, Executor executor)</span></span><br></pre></td></tr></table></figure><p>supply开头：这种方法，可以返回异步线程执行之后的结果。<br>run开头：这种不会返回结果，就只是执行线程任务。<br>如果你想异步运行一些后台任务并且不想从任务中返回任何东西，那么你可以使用run开头的</p><h2 id="4-2、CompletableFuture获取返回值"><a href="#4-2、CompletableFuture获取返回值" class="headerlink" title="4.2、CompletableFuture获取返回值"></a>4.2、CompletableFuture获取返回值</h2><p>通过get、join、getNow获取返回值，区别如下：</p><p>join：返回结果或者抛出一个unchecked异常(CompletionException)，不需要显示捕获异常。<br>get：返回结果或者一个具体的异常(ExecutionException, InterruptedException)，此方法继承至Future是堵塞的。<br>getNow：如果当前任务执行完成，返回执行结果，否则返回valueIfAbsent（默认值）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过get获取方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;get方法需要显示捕获异常&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(future.get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * join 不需要显示捕获异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;join方法不需要显示捕获异常&quot;</span>);</span><br><span class="line">    System.out.println(future.join());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getNow方法可以设置默认值</span></span><br><span class="line"><span class="comment"> * 在有效的时间内，未返回结果，则直接返回默认值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;getNow获取返回值&quot;</span>);</span><br><span class="line">    System.out.println(future.getNow(<span class="string">&quot;默认值&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3、其它方法"><a href="#4-3、其它方法" class="headerlink" title="4.3、其它方法"></a>4.3、其它方法</h2><ul><li>thenApply()：拿到上一个异步执行的结果继续后续操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 1 + 1 + 1</span></span><br><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="number">1</span>).thenApply(v -&gt; v + <span class="number">1</span>).thenApply(v -&gt; v + <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;执行结果：&quot;</span> + future.getNow(-<span class="number">1</span>)); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><ul><li>thenAccept() 和 thenRun()方法:如果你不想从你的回调函数中返回任何东西，只想在 Future 完成后运行一些代码，那么你可以使用thenAccept()andthenRun()方法。这些方法是消费者Consumer&lt; ? super T&gt; action，通常用作回调链中的最后一个回调。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟 1 + 1 + 1</span></span><br><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="number">1</span>).thenApply(v -&gt; v + <span class="number">1</span>).thenApply(v -&gt; v + <span class="number">1</span>)</span><br><span class="line">        thenAccept(r -&gt; System.out.println(<span class="string">&quot;1+1+1=&quot;</span> + r));</span><br></pre></td></tr></table></figure><ul><li>complete()：当前阶段异步任务执行完成.complete()其实也是个消费操作，但是与thenRun()不同的是，里面可以可抛出的异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区别就是不是异步处理</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt;  <span class="title function_">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br><span class="line"><span class="comment">// 使用异步处理</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt;  <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action)</span></span><br><span class="line"><span class="comment">// 区别在于可以指定线程池</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt;  <span class="title function_">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="built_in">super</span> T,? <span class="built_in">super</span> Throwable&gt; action, Executor executor)</span></span><br><span class="line"><span class="comment">// 接收一个可抛出的异常，且必须有返回值</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;T&gt;  <span class="title function_">exceptionally</span><span class="params">(Function&lt;Throwable,? extends T&gt; fn)</span></span><br></pre></td></tr></table></figure><ul><li>handle()：相比thenApply()抛出异常后还可以继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handle</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T,Throwable,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T,Throwable,? extends U&gt; fn)</span></span><br><span class="line"><span class="keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="title function_">handleAsync</span><span class="params">(BiFunction&lt;? <span class="built_in">super</span> T,Throwable,? extends U&gt; fn, Executor executor)</span></span><br></pre></td></tr></table></figure><h1 id="5、综合应用"><a href="#5、综合应用" class="headerlink" title="5、综合应用"></a>5、综合应用</h1><p>需求：要查找10个订单信息以及关联的商品、图片信息</p><p>订单上有商品ID，通过商品ID可以查询到商品详细信息，图片信息存储在商品详细信息中。</p><p>那就需要查询完订单再查询商品最后查询图片信息，这3个异步任务需要串行执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//10个订单号</span></span><br><span class="line">        List&lt;String&gt; orderCodeList = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;order_01&quot;</span>, <span class="string">&quot;order_02&quot;</span>, <span class="string">&quot;order_03&quot;</span>, <span class="string">&quot;order_04&quot;</span>,</span><br><span class="line">                <span class="string">&quot;order_05&quot;</span>, <span class="string">&quot;order_06&quot;</span>, <span class="string">&quot;order_07&quot;</span>, <span class="string">&quot;order_08&quot;</span>, <span class="string">&quot;order_09&quot;</span>, <span class="string">&quot;order_10&quot;</span>&#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//定义线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">15</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;String&gt; collect = orderCodeList.stream().map(o -&gt;</span><br><span class="line">                    CompletableFuture.supplyAsync(() -&gt; String.format(<span class="string">&quot;订单：%s，关联商品ID为：%s&quot;</span>, o, ThreadLocalRandom.current().nextInt()), threadPool)</span><br><span class="line">                            .thenApplyAsync((v) -&gt; String.format(v + <span class="string">&quot;,关联图片ID为：%s&quot;</span>, ThreadLocalRandom.current().nextInt()), threadPool)</span><br><span class="line">                            .thenApplyAsync((v) -&gt; String.format(v + <span class="string">&quot;,关联图信息获取成功&quot;</span>), threadPool)</span><br><span class="line">                            .exceptionally(e -&gt; &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                            &#125;)</span><br><span class="line">                            .join()</span><br><span class="line">            ).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//打印结果</span></span><br><span class="line">            System.out.println(collect);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放资源</span></span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> 技术文章 </tag>
            
            <tag> CompletableFuture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sharding-jdbc实现自动按月分表</title>
      <link href="/posts/53776.html"/>
      <url>/posts/53776.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本需求"><a href="#1、基本需求" class="headerlink" title="1、基本需求"></a>1、基本需求</h1><p>1、 项目中我们希望 能够按照时间、类别来添加表。但是sharding-jdbc 是固定配置 的 actual-data-nodes 参数。也就是说我们需要提前创建好分表或者分库。那么我们需要如何来实现动态创建表，并且动态刷新 actual-data-nodes 呢。</p><p>2、思路就是写个定时器来动态创建表 ，在创建表的时候 动态刷新 actual-data-nodes 实现动态创建表被shard加载。</p><h1 id="2、功能实现"><a href="#2、功能实现" class="headerlink" title="2、功能实现"></a>2、功能实现</h1><h2 id="2-1、添加依赖"><a href="#2-1、添加依赖" class="headerlink" title="2.1、添加依赖"></a>2.1、添加依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-namespace<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2、yml配置"><a href="#2-2、yml配置" class="headerlink" title="2.2、yml配置"></a>2.2、yml配置</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sharding:</span>  </span><br><span class="line">    <span class="comment"># 配置绑定表  </span></span><br><span class="line">    <span class="string">binding-tables[0]:</span> <span class="string">ims_test_result,ims_test_sample_fetch,ims_test_sample_diluent,ims_test_reagent_add,ims_test_ls_add,ims_test_incubate,ims_test_read</span>  </span><br><span class="line">    <span class="attr">tables:</span>  </span><br><span class="line"><span class="attr">ims_sample_base:</span>  </span><br><span class="line">    <span class="attr">actual-data-nodes:</span> <span class="string">m1.sharding_data_nodes_2022</span>  </span><br><span class="line">    <span class="attr">key-generator:</span>  </span><br><span class="line">        <span class="attr">column:</span> <span class="string">id</span>  </span><br><span class="line">        <span class="attr">type:</span> <span class="string">SNOWFLAKE</span>  </span><br><span class="line">        <span class="attr">props:</span>  </span><br><span class="line">            <span class="attr">worker.id:</span> <span class="string">$&#123;workerId&#125;</span>  </span><br><span class="line">    <span class="attr">table-strategy:</span>  </span><br><span class="line">        <span class="attr">complex:</span>  </span><br><span class="line">            <span class="attr">sharding-columns:</span> <span class="string">submit_work_time,sample_uid</span>  </span><br><span class="line">            <span class="attr">algorithm-class-name:</span> <span class="string">com.chivd.common.algorithm.TableShardingSampleAlgorithm</span></span><br></pre></td></tr></table></figure><h2 id="2-3、具体分片算法"><a href="#2-3、具体分片算法" class="headerlink" title="2.3、具体分片算法"></a>2.3、具体分片算法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TableShardingSampleAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">ComplexKeysShardingAlgorithm</span>&lt;String&gt; &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COLUMN_SAMPLE_UID</span> <span class="operator">=</span> <span class="string">&quot;sample_uid&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COLUMN_SUBMIT_TIME</span> <span class="operator">=</span> <span class="string">&quot;submit_work_time&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">doSharding</span><span class="params">(Collection&lt;String&gt; collection, ComplexKeysShardingValue&lt;String&gt; complexKeysShardingValue)</span> &#123;  </span><br><span class="line">        <span class="comment">// 逻辑表名  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">logicTableName</span> <span class="operator">=</span> complexKeysShardingValue.getLogicTableName();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 精准工单提交时间  </span></span><br><span class="line">        Collection&lt;String&gt; submitWorkTimeCollection = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SUBMIT_TIME, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());  </span><br><span class="line">        ArrayList&lt;String&gt; submitWorkTimeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(submitWorkTimeCollection);  </span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(submitWorkTimeList)) &#123;  </span><br><span class="line">            Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; submitWorkTimeList.size(); i++) &#123;  </span><br><span class="line">                <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> DateUtils.parseDate(submitWorkTimeList.get(i));  </span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">tableName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">                tableName.append(logicTableName).append(<span class="string">&quot;_&quot;</span>).append(DateUtils.parseDateToStr(DateUtils.YYYYMM, date));  </span><br><span class="line">                set.add(tableName.toString());  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> set;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 工单提交时间范围  </span></span><br><span class="line">        Range&lt;String&gt; submitWorkTimeRange = complexKeysShardingValue.getColumnNameAndRangeValuesMap().get(COLUMN_SUBMIT_TIME);  </span><br><span class="line">        <span class="keyword">if</span> (submitWorkTimeRange != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 实体表名集合  </span></span><br><span class="line">            Set&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();  </span><br><span class="line">            <span class="type">Date</span> <span class="variable">lowerDate</span> <span class="operator">=</span> DateUtils.parseDate(submitWorkTimeRange.lowerEndpoint());  </span><br><span class="line">            <span class="type">Date</span> <span class="variable">upperDate</span> <span class="operator">=</span> DateUtils.parseDate(submitWorkTimeRange.upperEndpoint());  </span><br><span class="line">            <span class="comment">// 获取月份间隔  </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">monthSpace</span> <span class="operator">=</span> DateUtils.getMonthSpace(lowerDate, upperDate);  </span><br><span class="line">            <span class="comment">// 获取所有的实体表名  </span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; monthSpace; i++) &#123;  </span><br><span class="line">                result.add(logicTableName + <span class="string">&quot;_&quot;</span> + DateUtils.parseDateToStr(DateUtils.YYYYMM, lowerDate));  </span><br><span class="line">                lowerDate = DateUtils.addMonths(lowerDate, <span class="number">1</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 样本uid  </span></span><br><span class="line">        Collection&lt;String&gt; testUids = complexKeysShardingValue.getColumnNameAndShardingValuesMap().getOrDefault(COLUMN_SAMPLE_UID, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());  </span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(testUids)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> testUids.stream().map(uid -&gt; &#123;  </span><br><span class="line">                String[] split = uid.split(<span class="string">&quot;-&quot;</span>);  </span><br><span class="line">                <span class="type">StringBuffer</span> <span class="variable">tableName</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">                tableName.append(logicTableName)  </span><br><span class="line">                        .append(<span class="string">&quot;_&quot;</span>)  </span><br><span class="line">                        .append(split[split.length - <span class="number">1</span>].substring(<span class="number">0</span>,<span class="number">6</span>));  </span><br><span class="line">                <span class="keyword">return</span> tableName.toString();  </span><br><span class="line">            &#125;).collect(Collectors.toSet());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4、创建配置表"><a href="#2-4、创建配置表" class="headerlink" title="2.4、创建配置表"></a>2.4、创建配置表</h2><p>配置表包含所有需要分表的逻辑表表名，分表开始年月等信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `ims_sharding_config` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `table_name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;表名&#x27;</span>,</span><br><span class="line">  `start_year_month` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分表开始年月&#x27;</span>,</span><br><span class="line">  `comment` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;备注&#x27;</span>,</span><br><span class="line">  `is_deleted` tinyint(<span class="number">4</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;(0-未删除 1-删除)&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">21</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><h2 id="2-5、创建定时任务"><a href="#2-5、创建定时任务" class="headerlink" title="2.5、创建定时任务"></a>2.5、创建定时任务</h2><ol><li>启动时自动刷新actual-data-nodes节点</li><li>自动创建下月分表</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShardingTableUtils</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    DataSource dataSource;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    IShardingConfigService shardingConfigService;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 项目启动时刷新节点配置  </span></span><br><span class="line"><span class="comment">     **/</span>    </span><br><span class="line">     <span class="meta">@PostConstruct</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startRefresh</span><span class="params">()</span> &#123;  </span><br><span class="line">        AutoCreateTable();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 刷新actual-data-nodes节点配置  </span></span><br><span class="line"><span class="comment">     **/</span>    </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actualTablesRefresh</span><span class="params">()</span> &#123;  </span><br><span class="line">        log.info(<span class="string">&quot;-------------- 开始刷新sharding配置 ---------------&quot;</span>);  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            List&lt;ShardingConfig&gt; shardingConfigList = shardingConfigService.listShardingConfig();  </span><br><span class="line">            <span class="type">ShardingDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (ShardingDataSource) <span class="built_in">this</span>.dataSource;  </span><br><span class="line">            <span class="keyword">if</span> (shardingConfigList == <span class="literal">null</span> || shardingConfigList.isEmpty()) &#123;  </span><br><span class="line">                log.info(<span class="string">&quot;【sharding自动配置】配置表为空&quot;</span>);  </span><br><span class="line">                <span class="keyword">return</span>;            &#125;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">curYearAndMonth</span> <span class="operator">=</span> DateUtils.getYearAndMonth(DateUtils.monthAdd(<span class="keyword">new</span> <span class="title class_">Date</span>(),<span class="number">1</span>).getTime());  </span><br><span class="line">            <span class="type">Field</span> <span class="variable">modifiersField</span> <span class="operator">=</span> Field.class.getDeclaredField(<span class="string">&quot;modifiers&quot;</span>);  </span><br><span class="line">            modifiersField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">            <span class="keyword">for</span> (ShardingConfig item : shardingConfigList) &#123;  </span><br><span class="line">                <span class="type">TableRule</span> <span class="variable">tableRule</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">                tableRule = dataSource.getRuntimeContext().getRule().getTableRule(item.getTableName());  </span><br><span class="line">                List&lt;DataNode&gt; dataNodes = tableRule.getActualDataNodes();  </span><br><span class="line">                <span class="type">String</span> <span class="variable">dataSourceName</span> <span class="operator">=</span> dataNodes.get(<span class="number">0</span>).getDataSourceName();  </span><br><span class="line">                List&lt;String&gt; monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  </span><br><span class="line">                List&lt;DataNode&gt; newDataNodes = monthBetween.stream()  </span><br><span class="line">                        .map(yearMonth -&gt; <span class="keyword">new</span> <span class="title class_">DataNode</span>(dataSourceName + <span class="string">&quot;.&quot;</span> + item.getTableName()  </span><br><span class="line">                                + <span class="string">&quot;_&quot;</span> + yearMonth)).collect(Collectors.toList());  </span><br><span class="line">                <span class="comment">// 修改actualDataNodesField  </span></span><br><span class="line">                <span class="type">Field</span> <span class="variable">actualDataNodesField</span> <span class="operator">=</span> TableRule.class.getDeclaredField(<span class="string">&quot;actualDataNodes&quot;</span>);  </span><br><span class="line">                actualDataNodesField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                modifiersField.setInt(actualDataNodesField, actualDataNodesField.getModifiers() &amp; ~Modifier.FINAL);  </span><br><span class="line">                actualDataNodesField.set(tableRule, newDataNodes);  </span><br><span class="line">                <span class="comment">// 修改actualTablesField  </span></span><br><span class="line">                Set&lt;String&gt; actualTables = Sets.newHashSet();  </span><br><span class="line">                Map&lt;DataNode, Integer&gt; dataNodeIndexMap = Maps.newHashMap();  </span><br><span class="line">                <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);  </span><br><span class="line">                newDataNodes.forEach(dataNode -&gt; &#123;  </span><br><span class="line">                    actualTables.add(dataNode.getTableName());  </span><br><span class="line">                    <span class="keyword">if</span> (index.intValue() == <span class="number">0</span>) &#123;  </span><br><span class="line">                        dataNodeIndexMap.put(dataNode, <span class="number">0</span>);  </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                        dataNodeIndexMap.put(dataNode, index.intValue());  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    index.incrementAndGet();  </span><br><span class="line">                &#125;);  </span><br><span class="line">                <span class="type">Field</span> <span class="variable">actualTablesField</span> <span class="operator">=</span> TableRule.class.getDeclaredField(<span class="string">&quot;actualTables&quot;</span>);  </span><br><span class="line">                actualTablesField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                actualTablesField.set(tableRule, actualTables);  </span><br><span class="line">                <span class="comment">// 动态刷新 dataNodeIndexMapField                Field dataNodeIndexMapField = TableRule.class.getDeclaredField(&quot;dataNodeIndexMap&quot;);  </span></span><br><span class="line">                dataNodeIndexMapField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                dataNodeIndexMapField.set(tableRule, dataNodeIndexMap);  </span><br><span class="line">                <span class="comment">// 动态刷新 datasourceToTablesMapField                Map&lt;String, Collection&lt;String&gt;&gt; datasourceToTablesMap = Maps.newHashMap();  </span></span><br><span class="line">                datasourceToTablesMap.put(dataSourceName, actualTables);  </span><br><span class="line">                <span class="type">Field</span> <span class="variable">datasourceToTablesMapField</span> <span class="operator">=</span> TableRule.class.getDeclaredField(<span class="string">&quot;datasourceToTablesMap&quot;</span>);  </span><br><span class="line">                datasourceToTablesMapField.setAccessible(<span class="literal">true</span>);  </span><br><span class="line">                datasourceToTablesMapField.set(tableRule, datasourceToTablesMap);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            log.info(<span class="string">&quot;【sharding自动配置】异常&quot;</span> + e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 自动创建不存在的表  </span></span><br><span class="line"><span class="comment">     **/</span>    </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">AutoCreateTable</span><span class="params">()</span> &#123;  </span><br><span class="line">        log.info(<span class="string">&quot;-------------- 开始创建分表 ---------------&quot;</span>);  </span><br><span class="line">        List&lt;ShardingConfig&gt; shardingConfigList = shardingConfigService.listShardingConfig();  </span><br><span class="line">        <span class="keyword">if</span> (shardingConfigList == <span class="literal">null</span> || shardingConfigList.isEmpty()) &#123;  </span><br><span class="line">            log.info(<span class="string">&quot;【sharding自动配置】配置表为空&quot;</span>);  </span><br><span class="line">            <span class="keyword">return</span>;        &#125;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">curYearAndMonth</span> <span class="operator">=</span> DateUtils.getYearAndMonth(DateUtils.monthAdd(<span class="keyword">new</span> <span class="title class_">Date</span>(),<span class="number">2</span>).getTime());  </span><br><span class="line">        <span class="keyword">for</span> (ShardingConfig item : shardingConfigList) &#123;  </span><br><span class="line">            List&lt;String&gt; monthBetween = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                monthBetween = getMonthBetween(item.getStartYearMonth(), curYearAndMonth);  </span><br><span class="line">            &#125; <span class="keyword">catch</span> (ParseException e) &#123;  </span><br><span class="line">                log.info(<span class="string">&quot;【sharding自动配置】日期转化失败&quot;</span> + e.getMessage());  </span><br><span class="line">                e.printStackTrace();  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// todo (CREATE TABLE if not exists xx like xxx 表存在会抛异常。为啥呢 这里先catch住让代码继续运行)  </span></span><br><span class="line">            monthBetween.forEach(yearMonth -&gt; &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    shardingConfigService.createTable(item.getTableName(), item.getTableName() + <span class="string">&quot;_&quot;</span> + yearMonth);  </span><br><span class="line">                &#125;<span class="keyword">catch</span> (Exception ignored)&#123;&#125;  </span><br><span class="line">            &#125;);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 刷新配置  </span></span><br><span class="line">        actualTablesRefresh();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 获取两个月份之间的所有月份  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minDate  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxDate  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ParseException  </span></span><br><span class="line"><span class="comment">     */</span>    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getMonthBetween</span><span class="params">(String minDate, String maxDate)</span> <span class="keyword">throws</span> ParseException &#123;  </span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyMM&quot;</span>);<span class="comment">//格式化为年月  </span></span><br><span class="line">  </span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">min</span> <span class="operator">=</span> Calendar.getInstance();  </span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">max</span> <span class="operator">=</span> Calendar.getInstance();  </span><br><span class="line">  </span><br><span class="line">        min.setTime(sdf.parse(minDate));  </span><br><span class="line">        min.set(min.get(Calendar.YEAR), min.get(Calendar.MONTH), <span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line">        max.setTime(sdf.parse(maxDate));  </span><br><span class="line">        max.set(max.get(Calendar.YEAR), max.get(Calendar.MONTH), <span class="number">2</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">curr</span> <span class="operator">=</span> min;  </span><br><span class="line">        <span class="keyword">while</span> (curr.before(max)) &#123;  </span><br><span class="line">            result.add(sdf.format(curr.getTime()));  </span><br><span class="line">            curr.add(Calendar.MONTH, <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 每月27号1点自动刷新配置节点  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0 1 27 * ?&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refreshScheduled</span><span class="params">()</span> &#123;  </span><br><span class="line">        AutoCreateTable();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文章 </tag>
            
            <tag> sharding-jdbc </tag>
            
            <tag> 分库分表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务解决方案seata</title>
      <link href="/posts/18601.html"/>
      <url>/posts/18601.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h1><h2 id="1-1、背景"><a href="#1-1、背景" class="headerlink" title="1.1、背景"></a>1.1、背景</h2><p>在微服务架构下，由于数据库和应用服务的拆分，导致原本一个事务单元中的多个DML 操作，变成了跨进程或者跨数据库的多个事务单元的多个 DML 操作，而传统的数据库事务无法解决这类的问题，所以就引出了分布式事务的概念。分布式事务本质上要解决的就是跨网络节点的多个事务的数据一致性问题，业内常见的解决方法有两种</p><p>a. 强一致性，就是所有的事务参与者要么全部成功，要么全部失败，全局事务协调者需要知道每个事务参与者的执行状态，再根据状态来决定数据的提交或者回滚<br>b. 最终一致性，也叫弱一致性，也就是多个网络节点的数据允许出现不一致的情况，但是在最终的某个时间点会达成数据一致。</p><p>在分布式事务的实现上，对于强一致性，我们可以通过基于 XA 协议下的二阶段提交来实现，对于弱一致性，可以基于 TCC 事务模型、可靠性消息模型等方案来实现。</p><h2 id="1-2、常见分布式事务解决方案"><a href="#1-2、常见分布式事务解决方案" class="headerlink" title="1.2、常见分布式事务解决方案"></a>1.2、常见分布式事务解决方案</h2><p>1、seata阿里分布式事务框架<br>2、消息队列<br>3、sage<br>4、XA</p><p>他们有一个共同的特点，都是两阶段（2PC），两阶段是指完成整个分布式事务，划分为两个步骤完成。<br>实际上这四种方案分别对应着分布式事务的四种模式：AT,TCC,Sage,XA</p><blockquote><p>三阶段提交协议3PC非常难实现，目前市面主流的分布式事务解决方案都是2PC协议</p></blockquote><p>二阶段分别指准备和提交：<br>1、在准备阶段RM执行实际的业务操作，但不提交事务，资源锁定；<br>2、在提交阶段TM会接受RM在准备阶段的执行回复，只要有任一个RM执行失败，TM会通知所有RM执行回滚操 作，否则，TM将会通知所有RM提交该事务。提交阶段结束资源锁释放。</p><h2 id="1-3、seata架构"><a href="#1-3、seata架构" class="headerlink" title="1.3、seata架构"></a>1.3、seata架构</h2><p>TC (Transaction Coordinator) - 事务协调者，维护全局和分支事务的状态，驱动全局事务提交或回滚。<br>TM (Transaction Manager) - 事务管理器，定义全局事务的范围：开始全局事务、提交或回滚全局事务。<br>RM (Resource Manager) - 资源管理器，管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p><h2 id="1-4、seata下的分布式事务解决方案"><a href="#1-4、seata下的分布式事务解决方案" class="headerlink" title="1.4、seata下的分布式事务解决方案"></a>1.4、seata下的分布式事务解决方案</h2><h3 id="1-4-1、AT"><a href="#1-4-1、AT" class="headerlink" title="1.4.1、AT"></a>1.4.1、AT</h3><p>AT模式（自动事务）：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</p><p>在一阶段，seata 会拦截”业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成”before image”快照中，然后执行”业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成”afer image”快照中（这两个快照保存在undo-log表中），同时在执行过程加行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性<br>在二阶段，如果所有分支事务成功，则将一阶段生成的快照数据和行锁删除；如果有分支失败，则所有分支事务进行还原，回滚方式是用before image生成逆向sql进行业务数据还原</p><h3 id="1-4-2、TCC"><a href="#1-4-2、TCC" class="headerlink" title="1.4.2、TCC"></a>1.4.2、TCC</h3><p>TCC模式：最终一致的分阶段事务模式，有业务侵入<br>TCC 模式需要用户根据自己的业务场景实现, Try、Conirm 和 Cancel 三个操作（方法）;事务发起方在一阶段执行 Try 方法，在二阶段提交执行 Confm 方法，二阶段回滚执行 Cancel 方法。</p><h3 id="1-4-3、XA"><a href="#1-4-3、XA" class="headerlink" title="1.4.3、XA"></a>1.4.3、XA</h3><p>XA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入<br>一阶段：注册分支事务到TC， 执行分支业务但不提交，报告执行状态到TC<br>二阶段：TC检测各分支事务执行状态 a.如果都成功，通知所有RM提交事务 b.如果有失败，通知所有RM回滚事务</p><blockquote><p>XA模式的优点是什么？<br>事务的强一致性，满足ACID原则。<br>常用数据库都支持，实现简单，并且没有代码侵入<br>XA模式的缺点是什么？<br>因为一阶段需要锁定数据库资源，等待二阶段结束才释放，性能较差<br>依赖关系型数据库实现事务</p></blockquote><h3 id="1-4-4、SAGA"><a href="#1-4-4、SAGA" class="headerlink" title="1.4.4、SAGA"></a>1.4.4、SAGA</h3><p>SAGA模式：长事务模式，有业务侵入</p><h1 id="2、部署Seata的tc-server"><a href="#2、部署Seata的tc-server" class="headerlink" title="2、部署Seata的tc-server"></a>2、部署Seata的tc-server</h1><h2 id="1-1、下载，解压"><a href="#1-1、下载，解压" class="headerlink" title="1.1、下载，解压"></a>1.1、下载，解压</h2><p>下载seata-server包，地址在<a href="http://seata.io/zh-cn/blog/download.html">http</a><a href="http://seata.io/zh-cn/blog/download.html">:&#x2F;&#x2F;seata.io&#x2F;zh-cn&#x2F;blog&#x2F;download</a><a href="http://seata.io/zh-cn/blog/download.html">.</a><a href="http://seata.io/zh-cn/blog/download.html">html</a> </p><h2 id="1-2、修改-conf-registry-conf-和file-conf配置"><a href="#1-2、修改-conf-registry-conf-和file-conf配置" class="headerlink" title="1.2、修改 conf&#x2F;registry.conf 和file.conf配置"></a>1.2、修改 conf&#x2F;registry.conf 和file.conf配置</h2><p>Seata连接到服务器的时候需要一些配置项，这时候有一个registry.conf文件可以指定注册中心和配置文件是什么。  </p><p>这里有很多可选性，比如file、nacos 、apollo、zk、consul</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">-</span> <span class="string">serverAddr = “127.0.0.1:2181” ：zk 的地址</span></span><br><span class="line"><span class="attr">-</span> <span class="string">cluster = “default” ：集群设置为默认 `default`</span></span><br><span class="line"><span class="attr">-</span> <span class="string">session.timeout = 6000 ：会话的超时时间</span></span><br><span class="line"><span class="attr">-</span> <span class="string">connect.timeout = 2000：连接的超时时间</span></span><br><span class="line"></span><br><span class="line"><span class="attr">registry</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # file zk</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;zk&quot;</span></span><br><span class="line"></span><br><span class="line"> <span class="attr">zk</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">cluster</span> = <span class="string">&quot;default&quot;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    <span class="attr">session.timeout</span> = <span class="string">6000</span></span><br><span class="line">    <span class="attr">connect.timeout</span> = <span class="string">2000</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">file</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">name</span> = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">config</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  # file、nacos 、apollo、zk、consul</span></span><br><span class="line">  <span class="attr">type</span> = <span class="string">&quot;zk&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">zk</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">serverAddr</span> = <span class="string">&quot;127.0.0.1:2181&quot;</span></span><br><span class="line">    <span class="attr">session.timeout</span> = <span class="string">6000</span></span><br><span class="line">    <span class="attr">connect.timeout</span> = <span class="string">2000</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">file</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">name</span> = <span class="string">&quot;file.conf&quot;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>file.conf 配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">主要修改了`store.mode`为`db`,还有数据库相关的配置</span></span><br><span class="line"><span class="attr">store</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">  ## store mode: file、db</span></span><br><span class="line">  <span class="attr">mode</span> = <span class="string">&quot;db&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ## file store</span></span><br><span class="line">  <span class="attr">file</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">dir</span> = <span class="string">&quot;sessionStore&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions</span></span><br><span class="line">    <span class="attr">max-branch-session-size</span> = <span class="string">16384</span></span><br><span class="line"><span class="comment">    # globe session size , if exceeded throws exceptions</span></span><br><span class="line">    <span class="attr">max-global-session-size</span> = <span class="string">512</span></span><br><span class="line"><span class="comment">    # file buffer size , if exceeded allocate new buffer</span></span><br><span class="line">    <span class="attr">file-write-buffer-cache-size</span> = <span class="string">16384</span></span><br><span class="line"><span class="comment">    # when recover batch read size</span></span><br><span class="line">    <span class="attr">session.reload.read_size</span> = <span class="string">100</span></span><br><span class="line"><span class="comment">    # async, sync</span></span><br><span class="line">    <span class="attr">flush-disk-mode</span> = <span class="string">async</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  ## database store</span></span><br><span class="line">  <span class="attr">db</span> <span class="string">&#123;</span></span><br><span class="line"><span class="comment">    ## the implement of javax.sql.DataSource, such as DruidDataSource(druid)/BasicDataSource(dbcp) etc.</span></span><br><span class="line">    <span class="attr">datasource</span> = <span class="string">&quot;dbcp&quot;</span></span><br><span class="line"><span class="comment">    ## mysql/oracle/h2/oceanbase etc.</span></span><br><span class="line">    <span class="attr">db-type</span> = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    <span class="attr">driver-class-name</span> = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">    <span class="attr">url</span> = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/seata&quot;</span></span><br><span class="line">    <span class="attr">user</span> = <span class="string">&quot;root&quot;</span></span><br><span class="line">    <span class="attr">password</span> = <span class="string">&quot;123456&quot;</span></span><br><span class="line">    <span class="attr">min-conn</span> = <span class="string">1</span></span><br><span class="line">    <span class="attr">max-conn</span> = <span class="string">3</span></span><br><span class="line">    <span class="attr">global.table</span> = <span class="string">&quot;global_table&quot;</span></span><br><span class="line">    <span class="attr">branch.table</span> = <span class="string">&quot;branch_table&quot;</span></span><br><span class="line">    <span class="attr">lock-table</span> = <span class="string">&quot;lock_table&quot;</span></span><br><span class="line">    <span class="attr">query-limit</span> = <span class="string">100</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p>修改 conf&#x2F;nacos-config.txt配置为zk-config.properties</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">store.mode :存储模式 默认file 这里我修改为db 模式 ，并且需要三个表global_table、branch_table和lock_table</span><br><span class="line">store.db.driver-class-name： 默认没有，会报错。添加了 com.mysql.jdbc.Driver</span><br><span class="line">store.db.datasource=dbcp ：数据源 dbcp</span><br><span class="line">store.db.db-type=mysql : 存储数据库的类型为mysql</span><br><span class="line">store.db.url=jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true : 修改为自己的数据库url、port、数据库名称</span><br><span class="line">store.db.user=root :数据库的账号</span><br><span class="line">store.db.password=123456 :数据库的密码</span><br><span class="line">service.vgroup_mapping.order-service-seata-service-group=default</span><br><span class="line">service.vgroup_mapping.account-service-seata-service-group=default</span><br><span class="line">service.vgroup_mapping.storage-service-seata-service-group=default</span><br><span class="line">service.vgroup_mapping.business-service-seata-service-group=default</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-4、创建数据库表"><a href="#1-4、创建数据库表" class="headerlink" title="1.4、创建数据库表"></a>1.4、创建数据库表</h2><p>特别注意：tc服务在管理分布式事务时，需要记录事务相关数据到数据库中，你需要提前创建好这些表。<br>这些表主要记录全局事务(global_table)、分支事务(branch_table)、全局锁信息(lock_table)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">SET NAMES utf8mb4;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- 分支事务表</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `branch_table`;</span><br><span class="line">CREATE TABLE `branch_table`  (</span><br><span class="line">  `branch_id` bigint(20) NOT NULL,</span><br><span class="line">  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `transaction_id` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `resource_group_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `resource_id` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `branch_type` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `status` tinyint(4) NULL DEFAULT NULL,</span><br><span class="line">  `client_id` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime(6) NULL DEFAULT NULL,</span><br><span class="line">  `gmt_modified` datetime(6) NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`branch_id`) USING BTREE,</span><br><span class="line">  INDEX `idx_xid`(`xid`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">-- ----------------------------</span><br><span class="line">-- 全局事务表</span><br><span class="line">-- ----------------------------</span><br><span class="line">DROP TABLE IF EXISTS `global_table`;</span><br><span class="line">CREATE TABLE `global_table`  (</span><br><span class="line">  `xid` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,</span><br><span class="line">  `transaction_id` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `status` tinyint(4) NOT NULL,</span><br><span class="line">  `application_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `transaction_service_group` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `transaction_name` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `timeout` int(11) NULL DEFAULT NULL,</span><br><span class="line">  `begin_time` bigint(20) NULL DEFAULT NULL,</span><br><span class="line">  `application_data` varchar(2000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,</span><br><span class="line">  `gmt_create` datetime NULL DEFAULT NULL,</span><br><span class="line">  `gmt_modified` datetime NULL DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`xid`) USING BTREE,</span><br><span class="line">  INDEX `idx_gmt_modified_status`(`gmt_modified`, `status`) USING BTREE,</span><br><span class="line">  INDEX `idx_transaction_id`(`transaction_id`) USING BTREE</span><br><span class="line">) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br><span class="line"></span><br><span class="line">create table `lock_table` (</span><br><span class="line">  `row_key` varchar(128) not null,</span><br><span class="line">  `xid` varchar(96),</span><br><span class="line">  `transaction_id` long ,</span><br><span class="line">  `branch_id` long,</span><br><span class="line">  `resource_id` varchar(256) ,</span><br><span class="line">  `table_name` varchar(32) ,</span><br><span class="line">  `pk` varchar(32) ,</span><br><span class="line">  `gmt_create` datetime ,</span><br><span class="line">  `gmt_modified` datetime,</span><br><span class="line">  primary key(`row_key`)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-5、启动TC服务"><a href="#1-5、启动TC服务" class="headerlink" title="1.5、启动TC服务"></a>1.5、启动TC服务</h2><p>进入bin目录，运行其中的seata-server.bat即可：启动成功后，seata-server应该已经注册到nacos注册中心了。打开浏览器，访问nacos地址：<a href="http://localhost:8848，然后进入服务列表页面，可以看到seata-tc-server的信息：">http://localhost:8848，然后进入服务列表页面，可以看到seata-tc-server的信息：</a></p><h1 id="3、微服务集成seata"><a href="#3、微服务集成seata" class="headerlink" title="3、微服务集成seata"></a>3、微服务集成seata</h1><h2 id="3-1、引入依赖"><a href="#3-1、引入依赖" class="headerlink" title="3.1、引入依赖"></a>3.1、引入依赖</h2><p>首先，我们需要在微服务中引入seata依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--版本较低，1.3.0，因此排除--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--seata starter 采用1.4.2版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2、添加配置类"><a href="#3-2、添加配置类" class="headerlink" title="3.2、添加配置类"></a>3.2、添加配置类</h2><p>需要修改application.yml文件，添加一些配置：<br>DEFAULT_MODE：默认的事务模式 为AT_MODE</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataAutoConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSourceProperties dataSourceProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">druidDataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">druidDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        druidDataSource.setUrl(dataSourceProperties.getUrl());</span><br><span class="line">        druidDataSource.setUsername(dataSourceProperties.getUsername());</span><br><span class="line">        druidDataSource.setPassword(dataSourceProperties.getPassword());</span><br><span class="line">        druidDataSource.setDriverClassName(dataSourceProperties.getDriverClassName());</span><br><span class="line">        druidDataSource.setInitialSize(<span class="number">0</span>);</span><br><span class="line">        druidDataSource.setMaxActive(<span class="number">180</span>);</span><br><span class="line">        druidDataSource.setMaxWait(<span class="number">60000</span>);</span><br><span class="line">        druidDataSource.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        druidDataSource.setValidationQuery(<span class="string">&quot;Select 1 from DUAL&quot;</span>);</span><br><span class="line">        druidDataSource.setTestOnBorrow(<span class="literal">false</span>);</span><br><span class="line">        druidDataSource.setTestOnReturn(<span class="literal">false</span>);</span><br><span class="line">        druidDataSource.setTestWhileIdle(<span class="literal">true</span>);</span><br><span class="line">        druidDataSource.setTimeBetweenEvictionRunsMillis(<span class="number">60000</span>);</span><br><span class="line">        druidDataSource.setMinEvictableIdleTimeMillis(<span class="number">25200000</span>);</span><br><span class="line">        druidDataSource.setRemoveAbandoned(<span class="literal">true</span>);</span><br><span class="line">        druidDataSource.setRemoveAbandonedTimeout(<span class="number">1800</span>);</span><br><span class="line">        druidDataSource.setLogAbandoned(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> druidDataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSourceProxy <span class="title function_">dataSourceProxy</span><span class="params">(DruidDataSource druidDataSource)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataSourceProxy</span>(druidDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">(DataSourceProxy dataSourceProxy)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        factoryBean.setDataSource(dataSourceProxy);</span><br><span class="line">        factoryBean.setMapperLocations(<span class="keyword">new</span> <span class="title class_">PathMatchingResourcePatternResolver</span>()</span><br><span class="line">                .getResources(<span class="string">&quot;classpath*:/mapper/*.xml&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> GlobalTransactionScanner <span class="title function_">globalTransactionScanner</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GlobalTransactionScanner</span>(<span class="string">&quot;account-gts-seata-example&quot;</span>, <span class="string">&quot;account-service-seata-service-group&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-3、业务代码增加-GlobalTransactional"><a href="#3-3、业务代码增加-GlobalTransactional" class="headerlink" title="3.3、业务代码增加@GlobalTransactional"></a>3.3、业务代码增加@GlobalTransactional</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GlobalTransactional(timeoutMills = 300000, name = &quot;dubbo-gts-seata-example&quot;)</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> ObjectResponse <span class="title function_">handleBusiness</span><span class="params">(BusinessDTO businessDTO)</span> &#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文章 </tag>
            
            <tag> seata </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐源泉</title>
      <link href="/posts/60552.html"/>
      <url>/posts/60552.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、段子"><a href="#1、段子" class="headerlink" title="1、段子"></a>1、段子</h1><ol><li>小明考了零分， 老师把小明拽到讲台前说道：“大家都看看， 这就是平时注意力不集中， 不好好听我讲课， 竟然考了零分， 大家要以此为鉴！” 这时，小明泪流满面地说：“老师，啥时候考的试呀， 下回能不能到门外通知我一下？”</li><li>天气预报说今晚会有台风登陆，但是一直没登陆，你知道是为什么吗？因为台风忘记密码</li><li>唉！模拟地震没有地震；模拟火灾没有火；那为什么模拟考试就有考试了啊啊啊！</li><li>司机:你们为什么要去四十公里外的地方吃饭 我:看小红书推荐的 司机:现在还看书的年轻人不多了</li><li>两程序员聊天，程序员甲抱怨：”做程序员太辛苦了，我想换行……我该怎么办？”程序员乙：”敲一下回车。”</li><li>你为家乡脱贫做出了什么贡献？我出门打工，减少贫困人口</li><li>野外有野生龟，家有家规</li><li>大熊猫点外卖，笋到家了</li><li>大多数人回家的第一句话是“妈，我回来了。”如果妈妈不在家，第一句话一定是：“爸，我妈呢？”</li><li>不偷不是意大利，不抢不是法兰西，又偷又抢英吉利，再开两枪是美帝</li><li>一天不打飞机，积阳德，两天不打，积积阳阳德</li><li>小时候被农村大狗撵着跑的那种感觉最恐怖，后面的喘气声和爪子撞击地面的声音慢慢靠近</li><li>武则天死老公，失去理智（李治）</li><li>一点睡觉六点起 阎王夸我好身体 两点睡觉六点起 骨灰盒子长方体 三点睡觉六点起 墓碑和我绑一起 四点睡觉六点起 墙上挂着我自己 五点睡觉六点起 天堂之旅我和你 月亮不睡你不睡,水滴筹里你最贵</li><li>僵尸为什么精瘦精瘦的，因为他一直跳啊跳啊跳</li><li>我过年买了火腿肠，但是我的双汇还是一路狂跌</li><li>女儿回奶奶家睡觉，回来我问她在奶奶家睡觉香吗？她想了半天摇摇头回答：我睡着了，没闻到</li><li>大人为什么不挑食？因为是他们买菜，他们买菜只买自己爱吃的呀</li><li>你小时候的梦想实现了吗？实现了一半，小时候想当警察叔叔，现在当上了叔叔了</li><li>如果你不谈恋爱，请把我的微信退给有需要的人</li><li>长期不谈恋爱的我不是难钓的鱼而是倔强的驴</li><li>长得那么好看为什么还会说没人追，因为她们把丑的不当人</li><li>以前看倚天屠龙记的时候，我18岁的梦想是找一个赵敏一样的老婆，慢慢觉得蛛儿和周芷若也不错，后来觉得小昭这种善解人意的女孩是最值得珍惜的。如今我30多了还单身，感觉灭绝师太也可以的哈</li><li>可怜的汤姆被玩弄于股掌之间</li><li>我爸每天晚上问我要不要双排，他玩小乔我还得帮他禁兰陵王</li></ol><h1 id="2、鸡汤"><a href="#2、鸡汤" class="headerlink" title="2、鸡汤"></a>2、鸡汤</h1><ol><li>这个世界上有两个我。一个想回家，一个想远行，一个举杯邀明月，一个跪地捡碎银。一个在理想里白马春山漫漫行，一个在生活里蝇营狗苟无穷年</li><li>不要因为睡懒觉而自责，因为你起床也创造不了什么价值</li><li>冠军粉的想法：只要我粉最强的球队就不会输球就不会被打脸，这样我就能尽情输出别的球队啦</li><li>弱小和无知不是生存的障碍,傲慢才是! -《三体》</li><li>人生的意义是什么？去码头整些薯条这个梗想告诉我们的是，人生的意义就在此时此刻，如果连此时此刻都不认真度过，还空谈什么人生的终极意义。很多人沉浸在过去，很多人展望着未来，而当下往往被忽略，但生活却正是由无数个当下组成的。很多人总想着莫欺少年穷，只看得到远方的幻景，殊不知脚下的路才是通往前方的唯一途径</li><li>功名利禄，过眼烟云，到头都是为他人做嫁衣裳，人生第一等事，或为一个情字，爱情，亲情，友情….情生而有爱恨，有牵绊，方有悲欢离合，白驹过隙，能解决人生终极孤独的，不是那些外在的名利，而是情的陪伴</li><li>没关系，又活了一天，已经很厉害了</li><li>故乡容不下肉身,他乡留不住灵魂</li><li>一个人有两次生命，第二次生命从你意识到你只有一次生命时开始</li><li>过度倾诉是会被嫌弃的，没有例外</li><li>人性的丑陋就是，在有权，有势、缺德的人身上找优点。在无权无势善良的人身上挑毛病-《晚熟的人》 莫言</li><li>如果你能意识到生命的短暂，你便会多几分勇敢</li><li>接受自己不被喜欢</li><li>用疑问句回答疑问句时一般是说中了</li><li>忘掉人脉，社交的本质是价值互换，没有本事没有资源跟人换，人脉就是个笑话</li><li>有花堪折直须折，莫待无花空折枝</li><li>有时候目的性太强的时候，往往容易把事搞砸，你把人家当朋友处，你就不会那么投鼠忌器了，也就更容易放得开，也不会有太多的功利的考量。适合做对象的，前提应该也是一个不错的朋友</li><li>爱情是轻松而不是压力</li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 段子 </tag>
            
            <tag> 沙雕图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redisson 框架中的分布式锁</title>
      <link href="/posts/46453.html"/>
      <url>/posts/46453.html</url>
      
        <content type="html"><![CDATA[<p>实现分布式锁通常有三种方式：数据库、Redis 和 Zookeeper。我们比较常用的是通过 Redis 和 Zookeeper 实现分布式锁。Redisson 框架中封装了通过 Redis 实现的分布式锁，下面分析一下它的具体实现</p><h1 id="1、关键点"><a href="#1、关键点" class="headerlink" title="1、关键点"></a>1、关键点</h1><ol><li>原子性：要么都成功，要么都失败</li><li>过期时间：如果锁还没来得及释放就遇到了服务宕机，就会出现死锁的问题。给 Redis 的 key 设置过期时间，即使服务宕机了超过设置的过期时间锁会自动进行释放。</li><li>锁续期： 因为给锁设置了过期时间而我们的业务逻辑具体要执行多长时间可能是变化和不确定的，如果设定了一个固定的过期时间，可能会导致业务逻辑还没有执行完，锁被释放了的问题。锁续期能保证锁是在业务逻辑执行完才被释放。</li><li>正确释放锁： 保证释放自己持有的锁，不能出现 A 释放了 B 持有锁的情况。</li></ol><h1 id="2、实现"><a href="#2、实现" class="headerlink" title="2、实现"></a>2、实现</h1><h2 id="2-1、引入依赖"><a href="#2-1、引入依赖" class="headerlink" title="2.1、引入依赖"></a>2.1、引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  pom.xml文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.17.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>版本依赖：</p><table><thead><tr><th>redisson-spring-data module name</th><th>Spring Boot version</th></tr></thead><tbody><tr><td>redisson-spring-data-16</td><td>1.3.y</td></tr><tr><td>redisson-spring-data-17</td><td>1.4.y</td></tr><tr><td>redisson-spring-data-18</td><td>1.5.y</td></tr><tr><td>redisson-spring-data-2x</td><td>2.x.y</td></tr><tr><td>redisson-spring-data-3x</td><td>3.x.y</td></tr></tbody></table><h2 id="2-2、配置yml"><a href="#2-2、配置yml" class="headerlink" title="2.2、配置yml"></a>2.2、配置yml</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">redisson:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">singleServerConfig:</span></span><br><span class="line">          <span class="attr">address:</span> <span class="string">redis://127.0.0.1:6379</span></span><br><span class="line">          <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">password:</span> <span class="literal">null</span></span><br><span class="line">          <span class="attr">timeout:</span> <span class="number">3000</span></span><br></pre></td></tr></table></figure><h2 id="2-3、代码中使用"><a href="#2-3、代码中使用" class="headerlink" title="2.3、代码中使用"></a>2.3、代码中使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 写入redis的key值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">&quot;lock-test&quot;</span>;</span><br><span class="line">        <span class="comment">// 获取一个Rlock锁对象</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="comment">// 获取锁，并为其设置过期时间为10s</span></span><br><span class="line">        lock.lock(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行业务逻辑....</span></span><br><span class="line">            System.out.println(<span class="string">&quot;获取锁成功！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">&quot;释放锁成功！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3、底层剖析"><a href="#3、底层剖析" class="headerlink" title="3、底层剖析"></a>3、底层剖析</h1><h2 id="3-1、lock"><a href="#3-1、lock" class="headerlink" title="3.1、lock()"></a>3.1、lock()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; RFuture&lt;T&gt; <span class="title function_">tryLockInnerAsync</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> commandExecutor.syncedEval(getRawName(), LongCodec.INSTANCE, command,</span><br><span class="line">            <span class="string">&quot;if ((redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) &quot;</span> +</span><br><span class="line">                   <span class="string">&quot;or (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1)) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,</span><br><span class="line">            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>RFuture&lt;T&gt;</code>：表示返回一个异步结果对象，其中泛型参数 T 表示结果的类型。</p></li><li><p><code>tryLockInnerAsync</code> 方法接受以下参数：</p><ul><li><code>waitTime</code>：等待时间，用于指定在获取锁时的最大等待时间。</li><li><code>leaseTime</code>：租约时间，用于指定锁的持有时间</li><li><code>unit</code>：时间单位，用于将 leaseTime 转换为毫秒</li><li><code>threadId</code>：线程 ID，用于标识当前线程</li><li><code>command</code>：Redis 命令对象，用于执行 Redis 操作</li></ul></li><li><p>方法体中的代码使用 Lua 脚本来实现分布式锁的逻辑。</p><blockquote><ul><li>if ((redis.call(‘exists’, KEYS[1]) &#x3D;&#x3D; 0) or (redis.call(‘hexists’, KEYS[1], ARGV[2]) &#x3D;&#x3D; 1)): 如果键不存在或者哈希表中已经存在对应的线程ID，则执行以下操作：<ul><li>redis.call(‘hincrby’, KEYS[1], ARGV[2], 1): 将哈希表中对应线程ID的值加1。</li><li>redis.call(‘pexpire’, KEYS[1], ARGV[1]): 设置键的过期时间为租约时间。</li><li>return nil: 返回nil表示成功获取锁。</li></ul></li><li>else: 如果键存在且哈希表中不存在对应的线程ID，则执行以下操作：    <ul><li>return redis.call(‘pttl’, KEYS[1]): 返回键的剩余生存时间。</li></ul></li></ul></blockquote></li><li><p><code>commandExecutor.syncedEval</code>：表示同步执行 Redis 命令</p></li><li><p><code>LongCodec.INSTANCE</code>：用于编码和解码长整型数据</p></li><li><p><code>Collections.singletonList(getRawName())</code>：创建一个只包含一个元素的列表，元素为锁的名称</p></li><li><p><code>unit.toMillis(leaseTime)</code>：将租约时间转换为毫秒</p></li><li><p><code>getLockName(threadId)</code>：根据线程 ID 生成锁的名称</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省去了那些无关重要的代码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">long</span> leaseTime, TimeUnit unit, <span class="type">boolean</span> interruptibly)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// tryAcquire就是上面分析的lua完整脚本</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">ttl</span> <span class="operator">=</span> tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">    <span class="comment">// 返回null就代表上锁成功。</span></span><br><span class="line">    <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没成功，也就是锁的剩余时间不是null的话，那么就执行下面的逻辑</span></span><br><span class="line">    <span class="comment">// 其实就是说 如果有锁（锁剩余时间不是null），那就死循环等待重新抢锁。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 重新抢锁</span></span><br><span class="line">            ttl = tryAcquire(-<span class="number">1</span>, leaseTime, unit, threadId);</span><br><span class="line">            <span class="comment">// 抢锁成功就break退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (ttl == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 省略一些代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码实现了一个分布式锁的功能。它使用了Lua脚本来尝试获取锁，并在成功获取锁后返回锁的剩余时间（ttl）。如果获取锁失败，则进入一个死循环，不断尝试重新获取锁，直到成功为止。</p><h2 id="3-2、unlock"><a href="#3-2、unlock" class="headerlink" title="3.2、unlock()"></a>3.2、unlock()</h2><p>关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title function_">unlockInnerAsync</span><span class="params">(<span class="type">long</span> threadId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return nil;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;if (counter &gt; 0) then &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 0; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;else &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(&#x27;del&#x27;, KEYS[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;redis.call(ARGV[4], KEYS[2], ARGV[1]); &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                <span class="string">&quot;return nil;&quot;</span>,</span><br><span class="line">            Arrays.asList(getRawName(), getChannelName()),</span><br><span class="line">            LockPubSub.UNLOCK_MESSAGE, internalLockLeaseTime, getLockName(threadId), getSubscribeService().getPublishCommand());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>RFuture&lt;Boolean&gt;</code>: 表示返回一个异步结果对象，其中泛型参数Boolean表示结果的类型。</li><li><code>unlockInnerAsync</code>方法接受以下参数：<ul><li><code>threadId</code>: 线程ID，用于标识当前线程。</li></ul></li><li>方法体中的代码使用Lua脚本来实现分布式锁的解锁逻辑。以下是对Lua脚本的解释：<ul><li><code>if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0)</code>: 如果哈希表中不存在对应的线程ID，则返回nil表示无法解锁。</li><li><code>local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1)</code>: 将哈希表中对应线程ID的值减1，并将结果赋值给变量counter。</li><li><code>if (counter &gt; 0)</code>: 如果counter大于0，表示还有其他线程持有锁，执行以下操作：<ul><li><code>redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2])</code>: 设置键的过期时间为租约时间。</li><li><code>return 0</code>: 返回0表示锁仍然被其他线程持有。</li></ul></li><li><code>else</code>: 如果counter等于0，表示当前线程是最后一个持有锁的线程，执行以下操作：<ul><li><code>redis.call(&#39;del&#39;, KEYS[1])</code>: 删除键，释放锁。</li><li><code>redis.call(ARGV[4], KEYS[2], ARGV[1])</code>: 调用发布命令，通知其他线程锁已经释放。</li><li><code>return 1</code>: 返回1表示成功释放锁。</li></ul></li><li><code>return nil</code>: 如果前面的条件都不满足，返回nil表示无法解锁。</li></ul></li><li><code>evalWriteAsync</code>方法用于执行Lua脚本并返回异步结果对象。</li><li><code>getRawName()</code>: 获取锁的名称。</li><li><code>LongCodec.INSTANCE</code>: 用于编码和解码长整型数据。</li><li><code>RedisCommands.EVAL_BOOLEAN</code>: 指定Lua脚本的返回类型为布尔值。</li><li><code>Arrays.asList(getRawName(), getChannelName())</code>: 创建一个包含两个元素的列表，元素分别为锁的名称和频道名称。</li><li><code>LockPubSub.UNLOCK_MESSAGE</code>: 发布消息的内容。</li><li><code>internalLockLeaseTime</code>: 锁的租约时间。</li><li><code>getLockName(threadId)</code>: 根据线程ID生成锁的名称。</li><li><code>getSubscribeService().getPublishCommand()</code>: 获取发布命令。</li></ul><h2 id="3-3、锁续期"><a href="#3-3、锁续期" class="headerlink" title="3.3、锁续期"></a>3.3、锁续期</h2><p>watchDog</p><p>核心工作流程是定时监测业务是否执行结束，没结束的话在看你这个锁是不是快到期了（超过锁的三分之一时间），那就重新续期。这样防止如果业务代码没执行完，锁却过期了所带来的线程不安全问题。</p><p>Redisson 的 watchDog 机制底层不是调度线程池，而是直接用的 netty 事件轮。</p><p>Redisson的WatchDog机制是用于自动续期分布式锁和监控对象生命周期的一种机制，确保了分布式环境下锁的正确性和资源的及时释放。</p><ol><li>自动续期：当Redisson客户端获取了一个分布式锁后，会启动一个WatchDog线程。这个线程负责在锁即将到期时自动续期，保证持有锁的线程可以继续执行任务。默认情况下，锁的初始超时时间是30秒，每10秒钟WatchDog会检查一次锁的状态，如果锁依然被持有，它会将锁的过期时间重新设置为30秒。</li><li>参数配置：可以通过设置lockWatchdogTimeout参数来调整WatchDog检查锁状态的频率和续期的超时时间。这个参数默认值是30000毫秒（即30秒），适用于那些没有明确指定leaseTimeout参数的加锁请求。</li><li>重连机制：除了锁自动续期外，WatchDog机制还用作Redisson客户端的自动重连功能。当客户端与Redis服务器失去连接时，WatchDog会自动尝试重新连接，从而恢复服务的正常运作。</li><li>资源管理：WatchDog也负责监控Redisson对象的生命周期，例如分布式锁。当对象的生命周期到期时，WatchDog会将其从Redis中删除，避免过期数据占用过多内存空间。</li><li>异步加锁：在加锁的过程中，WatchDog会在RedissonLock#tryAcquireAsync方法中发挥作用，该方法是进行异步加锁的逻辑所在。通过这种方式，加锁操作不会阻塞当前线程，提高了系统的性能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术文章 </tag>
            
            <tag> redisson </tag>
            
            <tag> 分布式锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sharding-jdbc</title>
      <link href="/posts/43456.html"/>
      <url>/posts/43456.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h1><p>分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。分库分表分为分库和分表两部分，通常分为垂直分库、垂直分表、水平分库、水平分表</p><h2 id="1-1、垂直分库"><a href="#1-1、垂直分库" class="headerlink" title="1.1、垂直分库"></a>1.1、垂直分库</h2><p>垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上。例如，将用户信息表和订单信息表分别存储在不同的数据库中，以减轻单个数据库的负载压力</p><h2 id="1-2、水平分库"><a href="#1-2、水平分库" class="headerlink" title="1.2、水平分库"></a>1.2、水平分库</h2><p>水平分库是将一个表的数据按照某个条件（例如，按照用户ID的范围或哈希值）分散存储在多个数据库中。每个数据库只存储部分数据。这样可以将数据库负载均衡，并提高查询性能。例如，将用户信息根据用户ID的哈希值分散存储在不同的数据库中</p><h2 id="1-3、垂直分表"><a href="#1-3、垂直分表" class="headerlink" title="1.3、垂直分表"></a>1.3、垂直分表</h2><p>垂直分表是将一个表按照列的方式进行拆分，将不同的列存储在不同的表中。每个表负责存储特定的列数据。这样可以降低单个表的数据量和表的宽度，提高查询性能。例如，将用户表拆分为用户基本信息表和用户扩展信息表，分别存储基本信息和扩展信息</p><h2 id="1-4、水平分表"><a href="#1-4、水平分表" class="headerlink" title="1.4、水平分表"></a>1.4、水平分表</h2><p>水平分表是将一个表的数据按照某个条件（例如，按照时间范围或哈希值）分散存储在多个表中。每个表只存储部分数据。这样可以将表的数据量减小，提高查询性能。例如，将订单表按照订单创建时间的范围拆分为多个表，每个表存储一段时间内的订单数据。</p><h2 id="1-5、分库分表带来的问题"><a href="#1-5、分库分表带来的问题" class="headerlink" title="1.5、分库分表带来的问题"></a>1.5、分库分表带来的问题</h2><ol><li>事务一致性问题：由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题</li><li>跨节点关联查询：但垂直分库后和不在一个数据库，甚至不在一台服务器，无法进行关联查询</li><li>跨节点分页，排序函数：跨节点多库进行查询时，limit分页、order by排序等问题，就变得比较复杂了</li><li>主键避重：在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题</li></ol><h1 id="2、sharding-jdbc相关概念"><a href="#2、sharding-jdbc相关概念" class="headerlink" title="2、sharding-jdbc相关概念"></a>2、sharding-jdbc相关概念</h1><p>Sharding-JDBC是ShardingSphere的第一个产品，也是ShardingSphere的前身。 它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sharding:</span>  </span><br><span class="line">    <span class="comment"># 配置绑定表,分片键一致，关联查询时不会笛卡尔  </span></span><br><span class="line">    <span class="string">binding-tables[0]:</span> <span class="string">ims_test_result,ims_test_sample_fetch</span> </span><br><span class="line">    <span class="attr">tables:</span>  </span><br><span class="line">        <span class="attr">ims_sample_base:</span>  </span><br><span class="line">            <span class="attr">actual-data-nodes:</span> <span class="string">m1.ims_sample_base_202308,m1.ims_sample_base_202309</span> </span><br><span class="line">            <span class="attr">key-generator:</span>  </span><br><span class="line">                <span class="attr">column:</span> <span class="string">id</span>  </span><br><span class="line">                <span class="attr">type:</span> <span class="string">SNOWFLAKE</span>  </span><br><span class="line">            <span class="attr">table-strategy:</span>  </span><br><span class="line">                <span class="attr">complex:</span>  </span><br><span class="line">                    <span class="attr">sharding-columns:</span> <span class="string">submit_work_time,sample_uid</span>  </span><br><span class="line">                    <span class="attr">algorithm-class-name:</span> <span class="string">com.chivd.common.algorithm.TableShardingSampleAlgorithm</span></span><br></pre></td></tr></table></figure><h2 id="2-1、逻辑表"><a href="#2-1、逻辑表" class="headerlink" title="2.1、逻辑表"></a>2.1、逻辑表</h2><p>未参与分片（不带后缀等信息）的表，实际数据库中并不存在。如ims_sample_base</p><h2 id="2-2、真实表"><a href="#2-2、真实表" class="headerlink" title="2.2、真实表"></a>2.2、真实表</h2><p>在分片的数据库中真实存在的物理表。如ims_sample_base_202308</p><h2 id="2-3、数据节点"><a href="#2-3、数据节点" class="headerlink" title="2.3、数据节点"></a>2.3、数据节点</h2><p>数据分片的最小单元。由数据源名称和数据表组成。如m1.ims_sample_base_202309</p><h2 id="2-4、绑定表"><a href="#2-4、绑定表" class="headerlink" title="2.4、绑定表"></a>2.4、绑定表</h2><p>指分片规则一致的主表和子表。例如: t_order表和t_order_item表，均按照order_id分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">在不配置绑定表关系时，假设分片键order_id将数值<span class="number">10</span>路由至第<span class="number">0</span>片，将数值<span class="number">11</span>路第<span class="number">1</span>片，那么路由后的SOL应该为<span class="number">4</span>条，它们呈现为笛卡尔积:</span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">绑定表关系后，路由<span class="keyword">sql</span>为两条：</span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">其中t_order在<span class="keyword">FROM</span>的最左侧，ShardingSphere将会以它作为整个绑定表的主表。 所有路由计算将会只使用主表的策略，那么t_order_item表的分片计算将会使用t_order的条件。故绑定表之间的分区键要完全相同</span><br></pre></td></tr></table></figure><h2 id="2-5、五种分片策略"><a href="#2-5、五种分片策略" class="headerlink" title="2.5、五种分片策略"></a>2.5、五种分片策略</h2><ol><li>none：不分片策略。对应NoneShardingStrategy ，不分片策略,SQL会被发给所有节点去执行,这个规则没有子项目可以配置。、</li><li>inline：行表达式分片策略。对应InlineShardingStrategy。使用Groovy的表达式，提供对SQL语句中的&#x3D;和IN的分片操作支持.只支持单分片键。对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: t_user_$-&gt;{u_id % 8}表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7</li></ol><blockquote><p>行表达式语法：<br>${begin..end}表示范围区间<br>${[unit1,unit2,unit3]}表示枚举值<br>行表达式中如果出现连续多个$ { expression }或$-&gt;{expression}表达式，整个表达式最终结果将根据每个子表达式结果进行笛卡尔组合</p></blockquote><ol start="3"><li>standard 标准分片策略</li></ol><p>对应StandardShardingStrategy。提供对SQL语句中的&#x3D;,IN和BETWEENAND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理&#x3D;和IN的分片。RangeShardingAlgorithm是可选的，用于处理BETWEEN AND分片，如果不配置RangeShardingAlgorithm,SQL中的BETWEENAND将按照全库路由处理</p><ol start="4"><li>complex复合分片策略</li></ol><p>对应ComplexShardingStrategy。复合分片策略提供对SQL语句中的&#x3D;,IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度</p><ol start="5"><li>hint分片策略</li></ol><p>对应HintShardingStrategy。通过Hint而非SQL解析的方式分片的策略。对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段。例:内部系统，按照员工登录主键分库，而数据库中并无此字段。SQL Hint支持通过JavaAPI和SQL注释(待实现)两种方式使用。</p><h2 id="2-6、主键生成策略"><a href="#2-6、主键生成策略" class="headerlink" title="2.6、主键生成策略"></a>2.6、主键生成策略</h2><p>shardingSphere提供灵活的配置分布式主键生成策略方式的主键生成策略，默认使用雪花算法 (snowflake) 生成64bit的长整型数据。当前提供了SNOWFLAKE、UUID 两种可用方式。</p><h2 id="2-7、事务处理"><a href="#2-7、事务处理" class="headerlink" title="2.7、事务处理"></a>2.7、事务处理</h2><p>有两种，一种是local，一种是XA（基于Atomikas来实现），还有一种未实现的柔性事务。其中如果不跨库，则选择local，否则则选择XA</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161714644.png" alt="sharding-jdbc事务处理"></p><h1 id="3、基本原理"><a href="#3、基本原理" class="headerlink" title="3、基本原理"></a>3、基本原理</h1><p>当Sharding-JDBC接受到一条SQL语句时，会陆续执行 SQL解析 &#x3D;&gt; 查询优化 &#x3D;&gt; SQL路由 &#x3D;&gt; SQL改写 &#x3D;&gt; SQL执行 &#x3D;&gt; 结果归并 ，最终返回执行结果</p><h2 id="3-1、sql解析"><a href="#3-1、sql解析" class="headerlink" title="3.1、sql解析"></a>3.1、sql解析</h2><p>SQL解析过程分为<strong>词法解析</strong>和<strong>语法解析</strong>。<br>词法解析器用于将SQL拆解为不可再分的原子符号，称为Token。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将SQL转换为抽象语法树。<br>例如，以下SQL：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;ACTIVE&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">18</span></span><br></pre></td></tr></table></figure><p>解析之后的为抽象语法树见下图：</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309161722674.png" alt="image.png"></p><p>为了便于理解，抽象语法树中的关键字的Token用绿色表示，变量的Token用红色表示，灰色表示需要进一步拆分</p><h2 id="3-2、sql路由"><a href="#3-2、sql路由" class="headerlink" title="3.2、sql路由"></a>3.2、sql路由</h2><p>SQL路由就是把针对逻辑表的数据操作映射到对数据结点操作的过程。根据解析上下文匹配数据库和表的分片策略，并生成路由路径</p><ol><li>对于携带分片键的sql</li></ol><blockquote><ol><li>根据分片键操作符不同可以划分为单片路由(分片键的操作符是等号)、多片路由(分片键的操作符是IN)和范围路由(分片键的操作符是 BETWEEN)</li><li>根据分片键进行路由的效果可分为直接路由、标准路由、笛卡尔路由等标准路由是Sharding-Jdbc最为推荐使用的分片方式，它的适用范围是不包含关联查询或仅包含绑定表之间关联查询的SQL。 当分片运算符是等于号时，路由结果将落入单库（表），当分片运算符是BETWEEN或IN时，则路由结果不一定落入唯一的库（表），因此一条逻辑SQL最终可能被拆分为多条用于执行的真实SQL.笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此非绑定表之间的关联查询需要拆解为笛卡尔积组合执行</li></ol></blockquote><ol start="2"><li>不携带分片键的sql则采用广播路由</li></ol><h2 id="3-3、sql改写"><a href="#3-3、sql改写" class="headerlink" title="3.3、sql改写"></a>3.3、sql改写</h2><p>工程师面向逻辑表书写的SQL，并不能够直接在真实的数据库中执行，SQL改写用于将逻辑SQL改写为在真实数据库中可以正确执行的SQL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如一个简单的例子，若逻辑<span class="keyword">SQL</span>为：</span><br><span class="line"><span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> order_id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">假设该<span class="keyword">SQL</span>配置分片键order_id，并且order_id<span class="operator">=</span><span class="number">1</span>的情况，将路由至</span><br><span class="line">分片表<span class="number">1</span>。那么改写之后的<span class="keyword">SQL</span>应该为：</span><br><span class="line"><span class="keyword">SELECT</span> order_id <span class="keyword">FROM</span> t_order_1 <span class="keyword">WHERE</span> order_id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="3-4、sql执行"><a href="#3-4、sql执行" class="headerlink" title="3.4、sql执行"></a>3.4、sql执行</h2><p>Sharding-JDBC采用一套自动化的执行引擎，负责将路由和改写完成之后的真实SQL安全且高效发送到底层数据源执行。 </p><p>它不是简单地将SQL通过JDBC直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题</p><h2 id="3-5、结果归并"><a href="#3-5、结果归并" class="headerlink" title="3.5、结果归并"></a>3.5、结果归并</h2><p>将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并。</p><p>Sharding-JDBC支持的结果归并从功能上可分为遍历、排序、分组、分页和聚合5种类型</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> sharding-jdbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汽车</title>
      <link href="/posts/28223.html"/>
      <url>/posts/28223.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、汽车汇总"><a href="#1、汽车汇总" class="headerlink" title="1、汽车汇总"></a>1、汽车汇总</h1><h2 id="1-1、日系"><a href="#1-1、日系" class="headerlink" title="1.1、日系"></a>1.1、日系</h2><table><thead><tr><th align="left">价位</th><th align="left">本田-轿车</th><th align="left">本田-suv</th><th align="left">丰田-轿车</th><th align="left">丰田-suv</th><th align="left">日产-轿车</th><th align="left">日产-suv</th><th align="left">马自达-轿车</th><th align="left">马自达-suv</th></tr></thead><tbody><tr><td align="left">10W</td><td align="left">飞度</td><td align="left"></td><td align="left">致炫&#x2F;威驰</td><td align="left"></td><td align="left">骐达</td><td align="left">劲客</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">10-15W</td><td align="left">凌派</td><td align="left">缤智</td><td align="left">卡罗拉&#x2F;雷凌</td><td align="left">锐放&#x2F;锋兰达</td><td align="left">轩逸</td><td align="left">逍客</td><td align="left">昂克赛拉</td><td align="left">CX-30</td></tr><tr><td align="left">15-20W</td><td align="left">思域</td><td align="left">XR-V</td><td align="left">亚洲狮</td><td align="left">奕泽</td><td align="left">天籁</td><td align="left">奇骏&#x2F;楼兰</td><td align="left"></td><td align="left">CX-4</td></tr><tr><td align="left">20-25W</td><td align="left">雅阁&#x2F;英诗派</td><td align="left">CR-V&#x2F;皓影</td><td align="left">亚洲龙&#x2F;凯美瑞</td><td align="left">荣放&#x2F;威兰达</td><td align="left">天籁</td><td align="left"></td><td align="left">阿特兹</td><td align="left">CX-5</td></tr><tr><td align="left">30W</td><td align="left"></td><td align="left">冠道&#x2F;U-RV</td><td align="left"></td><td align="left">陆放&#x2F;汉兰达</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">CX-8</td></tr><tr><td align="left">35W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">80W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">途乐</td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="1-2、德系"><a href="#1-2、德系" class="headerlink" title="1.2、德系"></a>1.2、德系</h2><table><thead><tr><th align="left">价位</th><th align="left">大众-轿车</th><th align="left">大众-suv</th><th align="left">奔驰-轿车</th><th align="left">奔驰-suv</th><th align="left">宝马-轿车</th><th align="left">宝马-suv</th><th align="left">奥迪-轿车</th><th align="left">奥迪-suv</th></tr></thead><tbody><tr><td align="left">10W</td><td align="left">Polo&#x2F;桑塔纳</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">10-15W</td><td align="left">宝来&#x2F;朗逸</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">15-20W</td><td align="left">速腾&#x2F;凌度&#x2F;高尔夫</td><td align="left">探影&#x2F;途岳</td><td align="left">A系列</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">Q2L</td></tr><tr><td align="left">20-25W</td><td align="left">帕萨特&#x2F;迈腾</td><td align="left">探岳&#x2F;途观</td><td align="left">C系列</td><td align="left">GLA</td><td align="left">1系</td><td align="left"></td><td align="left">A3</td><td align="left"></td></tr><tr><td align="left">30W</td><td align="left">昂辉</td><td align="left">揽巡&#x2F;途昂</td><td align="left"></td><td align="left">GLB</td><td align="left">2系</td><td align="left">X1</td><td align="left">A4L</td><td align="left">Q3</td></tr><tr><td align="left">35W+</td><td align="left"></td><td align="left">揽境&#x2F;威然</td><td align="left">E系列</td><td align="left">GLC</td><td align="left">3系</td><td align="left">X2</td><td align="left">A5</td><td align="left"></td></tr><tr><td align="left">40W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">4系</td><td align="left">X3</td><td align="left">A6L</td><td align="left">Q5L</td></tr><tr><td align="left">50W+</td><td align="left"></td><td align="left">途锐</td><td align="left"></td><td align="left"></td><td align="left">5系</td><td align="left">X4</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">60W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">X5</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">80W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">GLE</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">Q7</td></tr><tr><td align="left">100W+</td><td align="left"></td><td align="left"></td><td align="left">S系列</td><td align="left"></td><td align="left"></td><td align="left">X7</td><td align="left"></td><td align="left"></td></tr></tbody></table><h2 id="1-3、美系"><a href="#1-3、美系" class="headerlink" title="1.3、美系"></a>1.3、美系</h2><table><thead><tr><th align="left">价位</th><th align="left">别克-轿车</th><th align="left">别克-suv</th><th align="left">福特-轿车</th><th align="left">福特-suv</th><th align="left">凯迪拉克-轿车</th><th align="left">凯迪拉克-suv</th><th align="left">雪佛兰-轿车</th><th align="left">雪佛兰-suv</th><th align="left">林肯-suv</th><th align="left">特斯拉-轿车</th><th align="left">特斯拉-suv</th></tr></thead><tbody><tr><td align="left">10W</td><td align="left"></td><td align="left"></td><td align="left">福睿斯</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">科鲁泽</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">10-15W</td><td align="left">英朗&#x2F;威朗</td><td align="left">昂科拉</td><td align="left">福克斯</td><td align="left">领界&#x2F;领睿</td><td align="left"></td><td align="left"></td><td align="left">沃兰多</td><td align="left">创酷&#x2F;创界</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">15-20W</td><td align="left">君威</td><td align="left"></td><td align="left">蒙迪欧</td><td align="left">领裕&#x2F;锐际</td><td align="left"></td><td align="left"></td><td align="left">迈锐宝</td><td align="left">探险者</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">20-25W</td><td align="left">君越</td><td align="left">昂科威</td><td align="left"></td><td align="left">锐界</td><td align="left">CT4</td><td align="left"></td><td align="left"></td><td align="left">开拓者</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">25-30W</td><td align="left"></td><td align="left">昂科旗</td><td align="left">金牛座</td><td align="left">撼路者</td><td align="left">CT5</td><td align="left">XT4</td><td align="left"></td><td align="left"></td><td align="left">冒险家</td><td align="left">Model3</td><td align="left">Model Y</td></tr><tr><td align="left">35W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">探险者</td><td align="left">CT6</td><td align="left">XT5</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">40W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">XT6</td><td align="left"></td><td align="left"></td><td align="left">航海家</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">50W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">60W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">飞行家</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">80W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">100W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">领航员</td><td align="left">Model s</td><td align="left">Model X</td></tr></tbody></table><h2 id="1-4、国产"><a href="#1-4、国产" class="headerlink" title="1.4、国产"></a>1.4、国产</h2><table><thead><tr><th align="left">价位</th><th align="left">长安</th><th align="left">长安-suv</th><th align="left">奇瑞-轿车</th><th align="left">奇瑞-suv</th><th align="left">吉利</th><th align="left">吉利-suv</th><th align="left">比亚迪-轿车</th><th align="left">比亚迪-suv</th><th align="left">荣威-轿车</th><th align="left">荣威-SUV</th><th align="left">领克</th><th align="left">领克-suv</th><th align="left">沃尔沃</th><th align="left">沃尔沃-suv</th><th align="left">北京现代</th></tr></thead><tbody><tr><td align="left">10W</td><td align="left">逸动</td><td align="left">CS 35P</td><td align="left">艾瑞泽5</td><td align="left">瑞虎5</td><td align="left">帝豪</td><td align="left">缤越</td><td align="left">海豚</td><td align="left"></td><td align="left">I5</td><td align="left">RX3</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">伊兰特</td></tr><tr><td align="left">10-15W</td><td align="left"></td><td align="left">CS 55P&#x2F;UNI-T</td><td align="left">艾瑞泽8</td><td align="left">瑞虎7</td><td align="left">星瑞</td><td align="left">博越</td><td align="left">秦</td><td align="left">元</td><td align="left">I6</td><td align="left">RX5</td><td align="left"></td><td align="left">06&#x2F;02</td><td align="left"></td><td align="left"></td><td align="left">菲斯塔&#x2F;名图</td></tr><tr><td align="left">15-20W</td><td align="left">UNI-V</td><td align="left">CS 75P&#x2F;UNI-K</td><td align="left"></td><td align="left">瑞虎8</td><td align="left"></td><td align="left">星越</td><td align="left"></td><td align="left">宋</td><td align="left"></td><td align="left">RX8</td><td align="left">03</td><td align="left">01</td><td align="left"></td><td align="left"></td><td align="left">索纳塔</td></tr><tr><td align="left">20-25W</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">海豹</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">05</td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">25-30W</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">汉</td><td align="left">唐</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">09</td><td align="left"></td><td align="left">XC40</td><td align="left"></td></tr><tr><td align="left">35W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">S60</td><td align="left"></td><td align="left"></td></tr><tr><td align="left">40W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">S90</td><td align="left">XC60</td><td align="left"></td></tr><tr><td align="left">50W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">60W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left">XC90</td><td align="left"></td></tr><tr><td align="left">80W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">100W+</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr></tbody></table><h1 id="2、汽车参数名词"><a href="#2、汽车参数名词" class="headerlink" title="2、汽车参数名词"></a>2、汽车参数名词</h1><p>发动机 变速箱和底盘俗称汽车三大件，是一个汽车核心部件</p><h2 id="2-1、发动机（缸数、马力、功率）"><a href="#2-1、发动机（缸数、马力、功率）" class="headerlink" title="2.1、发动机（缸数、马力、功率）"></a>2.1、发动机（缸数、马力、功率）</h2><p>缸数越多劲越大 油耗越高，别选三缸容易抖动，四缸为宜。<br>马力的话轿车120-200就行了，太低跑不动，SUV基本要150-250，价格高的车马力会更大 当然这个是越多越好。选车时差一个十几马力使用差别不大，要舍得给油。<br>功率，马力，扭矩。三者成正比关系且密切相关。气缸单位时间做的功叫功率，功率越大发动机产生的马力越大，这样传到车轮上的扭矩越大，扭矩越大车轮越有劲 对于急加速 爬坡 负重有很大作用</p><h2 id="2-2、进气方式"><a href="#2-2、进气方式" class="headerlink" title="2.2、进气方式"></a>2.2、进气方式</h2><p>进气方式，自然吸气 涡轮增压。<br>自然吸气多数是多少L，这个技术很老 使用车比较少了，通过发动机曲轴的动力带动空气压缩机旋转来压缩进气，常见的应该就是凯美瑞，自然吸气平顺，维修简单。</p><p>涡轮增压，现在主流的，排出的气回收进来 进行再利用，提高接近一半的动力 也减少了油耗。一般用T表示。1.5T的卡罗拉应该是比2.0L的凯美瑞更迅猛，凯美瑞还是要2.5L起。</p><p>简单说一下进气方式。气缸首先是吸一些气进来。让活塞往下压 压的实在压不动了。就和我们轮胎打气一样。然后喷油嘴喷一点油火花塞一点 这样爆一下就可以利用反冲力 将活塞和曲轴顶起来去推齿轮转动。顶起来后这些废气被排出，新气又被吸进来 如此重复。这样四两拨千斤用少量的汽油就能做大事。自然吸气就是吸车周围自然环境里的空气。车不走发动机不转基本 所以不用担心被吸光。而车开动起来气流运动自然会冲进你的进气口。涡轮增压不一样。反正你要用气 不管气的好坏 那我把本来要排出去的废气找一部分回来再压进去不就行了？这样从自然环境中拿更少的气倒是其次。很重要的是汽车的汽油大部分燃烧不充分。大部分没有燃烧的被当成废气排掉。一些好的发动机热效率转化也只有百分之四十多。那我把这些气压进来下次火花塞点的时候一起爆起来 岂不是更足？这样即动力又环保。2.0L的发动机里边吸的全是新鲜空气。1.5T的增压发动机里有1.0是包含汽油的空气 自然动力就来了。而增压发动机在极端的空气稀薄环境下也不容易趴窝。<br>总体来看轿车1.5T-2.0T足够。SUV小型的1.5T最少了，大一点就会动力不足。最好是2.0-3.0</p><h2 id="2-3、变速箱"><a href="#2-3、变速箱" class="headerlink" title="2.3、变速箱"></a>2.3、变速箱</h2><p>变速箱的作用主要是保证汽车能平稳起步，变速换挡时减轻变速齿轮的冲击载荷并防止传动系统过载。所以我们说的变速箱种类其实指的就是离合器。目前变速箱主要分为MT手动变速箱、AT自动变速箱、CVT无级变速箱、DCT和AMT五种</p><p><strong>1.MT手动变速箱</strong></p><p>MT手动变速箱的车在市场的占有率如今已经不是很高了，但是一些性能车依然保留了手动变速箱，也不乏一些汽车发烧友对手动变速箱有着一种执念。原因在于手动变速箱的结构简单动力传动效率高，通过手动挡杆的变换让机组大小不一的齿轮咬合来实现变速，让驾驶者对爱车的操控有更深的体验，从而带来更多的驾驶乐趣。在日常的使用当中，手动变速箱会更加地可靠，故障率很低。但是在加减档的时候需要左脚掌控离合器，这就使得很多新手司机非常排斥手动变速箱。</p><p><strong>2.AMT变速箱</strong></p><p>如果说MT手动变速箱罕见的原因在于一些消费者认为操作起来比较麻烦，那AMT变速箱的罕见的原因则在于被更新的技术所取代。</p><p>AMT变速箱是在手动变速箱的基础上增加了一套电子控制系统，当然手动变速箱的高传动效率和耐用性等优点得到了保留，并且操作过程比较简单。当然更重要的是，在多年前自动变速箱成本较高的时候，搭载AMT变速箱的车型有着更加亲民的售价。但是之所以还是被市场所淘汰的原因在于换挡时的顿挫感强，对驾驶者的驾驶技术要求高。</p><p><strong>3.CVT无级变速箱</strong></p><p>CVT变速箱在今天依然颇为畅想，大多数日系车采用的都是CVT无级变速箱，但实际上这款变速箱最早是德国奔驰公司应用到汽车上的，距今已经有一百多年的历史</p><p>CVT变速箱主要是通过皮带和变速轮盘进行工作，并没有齿轮的存在，因此在进行换挡时，时间会更短一些，而且平顺性会更好，几乎没有顿挫感。而且燃油经济性更高，可以更大程度上实现能源的转换，因此一定程度上可以节省成本，但是皮带的承受力有限，扭矩承受力较小，因此CVT变速箱主要适用于小排量汽车，当然它的制造和维修成本比较高，传送带相比齿轮不耐用的缺点也值得慎重考虑</p><p><strong>4.AT变速箱</strong></p><p>喜欢大排量车所带来动力上的快感，CVT变速箱不能满足但是AT变速箱能够做到。AT变速箱操作更加方便，而且技术更为成熟可承载的扭矩更大，其动力输出更强。并且不用离合器换档，档位少变化大，连接平稳，因此操作容易，既给开车人带来方便，也给坐车人带来舒适。通用旗下的凯迪拉克、雪佛兰大多采用的都是AT变速箱</p><p>但是其内部结构较为复杂，它是由液力自动变速箱通过液力传动和行星齿轮组合的方式来实现自动变速，一般由液力变矩器、行星齿轮机构、换挡执行机构、换挡控制系统、换档操纵机构等装置组成，这就造成了后期的维修费用会更高。在液力变扭器内高速循环流动的液压油会产生高温，所以要用指定的耐高温液压油。还有一点需要注意的是，如果车辆方式故障需要托运，一定要注意使驱动轮脱离地面，以保护自动变速箱齿轮不受损害</p><p><strong>5.DCT双离合变速箱</strong></p><p>提及双离合变速箱，大家印象最深的就是大众的DSG双离合变速器。因为才有了两个离合器，所以有人称“双离合变速器”，而它的全称是Dual Clutch Transmission，简称DCT。这种类型的变速器起源于上个世纪80年代，并最早被应用到了赛车上。如今双离合变速器的技术已经非常成熟，并且有了干式双离合和湿式双离合两种分别。它们的区别在于两者不同的离合器片工作环境。湿式双离合器片，是指离合器片浸泡在变速箱油液里，而干式双离合的离合器片直接与发动机飞轮接触。</p><h2 id="2-4、底盘悬挂"><a href="#2-4、底盘悬挂" class="headerlink" title="2.4、底盘悬挂"></a>2.4、底盘悬挂</h2><p>底盘悬挂，底盘是车的整个车底，给人感觉不松散，整车稳定性好，悬挂是减震，是车轮遇到颠簸路段的反馈。悬挂软了比较舒服但是车支撑性差 转弯等容易出事儿。硬了支撑好但是容易颠簸。SUV因为车大 重心高所以悬挂多数教硬。所以乘坐舒适性多数轿车更优。而SUV视野开阔 车大力足驾驶感受更爽一点。当然舒适性还要与车座的空间 车座材质 长短等有关系。这也是购车的考虑因素之一。</p><p>悬挂按照结构分为：</p><p>麦佛逊 ，当前使用最多的，成本低效果还不错。但稳定性稍差。</p><p>扭力梁，最廉价的悬挂，稳定性舒适性差，有点是重量轻，承载能力大。</p><p>多连杆 ，当前高端的悬挂，体积大成本高，但是舒适性和支撑性好。</p><p>空气悬挂，主要是高档车型上的使用的，可以根据路面自动调整高度</p><h2 id="2-5、驱动系统"><a href="#2-5、驱动系统" class="headerlink" title="2.5、驱动系统"></a>2.5、驱动系统</h2><p>双驱就是要么前轮发力带着后轮跑 要么就是后轮发力顶着前轮跑。后驱车爬坡吃亏，雪地容易甩尾，前驱车容易转向不足 操控性差。<br>四驱就是四个轮子都发力，对于越野车辆是必须的利器。各大豪华运动 厂家都有成熟的四驱系统，其中奥迪的quattro是最为著名，能做到智能感知路面和车辆状况 给每一个轮子配置不同的功率。其余的奔驰宝马也在这方面做了大量研发成果不错。四驱成本较高，对于日常家用两驱足够价格还更好。<br>四驱系统分全时四驱和分时四驱，全时四驱代表车辆全部时间都是四驱模式，分时四驱可以在不需要四驱的时候关闭四驱</p><h2 id="2-6、轴距"><a href="#2-6、轴距" class="headerlink" title="2.6、轴距"></a>2.6、轴距</h2><p>轴距，车的长宽尺寸，车按照大小分为A级 紧凑 B级中型 C级中大型。这也基本将车分为了三个价格区间。A紧凑家用代步 B家用及基本商务 C高档豪华运动。国人比较在意空间大小，一般B级应该接近5米车长轴距2800mm，另外车参数大小和实际的内部空间不一定划等号，要去实际看看，尤其是第二排空间和座椅。包括后备箱容积</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汽车 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/posts/41682.html"/>
      <url>/posts/41682.html</url>
      
        <content type="html"><![CDATA[<ul><li>创建型模式：创建型模式关注对象的创建过程，主要包括简单工厂模式、工厂方法模式、抽象工厂模式、单例模式、建造者模式和原型模式。</li><li>结构型模式：结构型模式关注对象之间的组合和协作关系，主要包括适配器模式、桥接模式、组合模式、装饰者模式、外观模式、享元模式和代理模式。</li><li>行为型模式：行为型模式关注对象之间的交互和通信，主要包括模板方法模式、策略模式、命令模式、职责链模式、状态模式、观察者模式、中介者模式和访问者模式。</li></ul><h1 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h1><ol><li><p>饿汉模式：在类加载时就完成了初始化，但是加载比较慢，获取对象比较快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton_hungry</span> &#123;</span><br><span class="line">    <span class="comment">//构造函数私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton_hungry</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">//定义私有的引用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton_hungry</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton_hungry</span>();</span><br><span class="line">    <span class="comment">//对外提供获取实例的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton_hungry <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>懒汉模式：懒汉式是延时加载,他是在需要的时候才创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton_lazy</span> &#123;</span><br><span class="line">    <span class="comment">//构造函数私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton_lazy</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton_lazy instance;</span><br><span class="line">    <span class="comment">//对外提供获取实例的接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton_lazy <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            instance =  <span class="keyword">new</span> <span class="title class_">Singleton_lazy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒汉模式存在线程安全问题，用双重校验锁去解决</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton_lazy2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton_lazy2</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton_lazy2 instance;</span><br><span class="line">    <span class="keyword">public</span> Singleton_lazy2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//第一次校验singleton是否为空（已经创建实例不用竞争锁，提高效率）</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton_lazy2.class)&#123;</span><br><span class="line">                <span class="comment">//第二次判断是因为假设有两个线程A、B,两个同时通过了第一个if，然后A获取了锁，进入然后判断doubleLock是null，他就实例化了doubleLock，然后他出了锁，</span></span><br><span class="line">                <span class="comment">//这时候线程B经过等待A释放的锁，B获取锁了，如果没有第二个判断，那么他还是会去new DoubleLock()，再创建一个实例，所以为了防止这种情况，需要第二次判断</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    instance =  <span class="keyword">new</span> <span class="title class_">Singleton_lazy2</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>在java内存模型中，volatile 关键字作用可以是保证可见性或者禁止指令重排。这里是因为 singleton &#x3D; new Singleton() ，它并非是一个原子操作，事实上，在 JVM 中上述语句至少做了以下这 3 件事：<br> 第一步是给 singleton 分配内存空间；<br> 第二步开始调用 Singleton 的构造函数等，来初始化 singleton；<br> 第三步，将 singleton 对象指向分配的内存空间（执行完这步 singleton 就不是 null 了）。<br> 这里需要留意一下 1-2-3 的顺序，因为存在指令重排序的优化，也就是说第 2 步和第 3 步的顺序是不能保证的，最终的执行顺序，可能是 1-2-3，也有可能是 1-3-2。<br> 如果是 1-3-2，那么在第 3 步执行完以后，singleton 就不是 null 了，可是这时第 2 步并没有执行，singleton 对象未完成初始化，它的属性的值可能不是我们所预期的值。假设此时线程 2 进入 getInstance 方法，由于 singleton 已经不是 null 了，所以会通过第一重检查并直接返回，但其实这时的 singleton 并没有完成初始化，所以使用这个实例的时候会报错</p></blockquote><h1 id="2、简单工厂模式"><a href="#2、简单工厂模式" class="headerlink" title="2、简单工厂模式"></a>2、简单工厂模式</h1><p>简单工厂模式又称为<strong>静态工厂方法</strong>模式，它通过一个工厂类来创建不同类型的对象，客户端只需要知道具体产品的名称即可。<br>简单工厂模式的优点是简单易用，但是如果需要添加新的产品类型，则需要修改工厂类的代码，违反了开闭原则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">createProduct</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> SimpleFactory.createProduct(<span class="string">&quot;A&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="3、工厂方法模式"><a href="#3、工厂方法模式" class="headerlink" title="3、工厂方法模式"></a>3、工厂方法模式</h1><p>工厂方法模式通过定义一个抽象的工厂接口和多个具体的工厂类来创建不同类型的对象，每个具体的工厂类只负责创建一种产品类型。客户端只需要知道具体工厂类的名称即可。<br>工厂方法模式的优点是更加灵活，可以更方便地添加新的产品类型，但是需要创建多个工厂类，增加了系统的复杂度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    Product <span class="title function_">createProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactoryA</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactoryB</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactoryA</span>();</span><br><span class="line"><span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> factory.createProduct();</span><br></pre></td></tr></table></figure><h1 id="4、抽象工厂模式"><a href="#4、抽象工厂模式" class="headerlink" title="4、抽象工厂模式"></a>4、抽象工厂模式</h1><p>抽象工厂模式通过定义一个抽象的工厂接口和多个具体的工厂类来创建不同类型的对象，每个具体的工厂类负责创建一组相关的产品类型。客户端需要知道具体的工厂类和产品族的名称。<br>抽象工厂模式的优点是可以创建一组相关的产品，而且更加灵活，但是需要创建多个工厂类和产品族，增加了系统的复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    Product <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    Product <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Product <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">Factory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line"><span class="type">Product</span> <span class="variable">productA</span> <span class="operator">=</span> factory.createProductA();</span><br><span class="line"><span class="type">Product</span> <span class="variable">productB</span> <span class="operator">=</span> factory.createProductB();</span><br></pre></td></tr></table></figure><h1 id="5、原型模式"><a href="#5、原型模式" class="headerlink" title="5、原型模式"></a>5、原型模式</h1><p>原型模式是一种创建型设计模式，它允许通过克隆现有对象来创建新对象，而不是通过实例化类来创建。这种模式适用于需要创建多个相似对象的情况，因为它可以减少对象创建的开销和复杂性<br>原型模式的优点包括：提高了对象创建的效率，减少了重复的代码，简化了对象创建的过程。缺点是如果原型对象的属性较为复杂或包含引用类型的属性，则需要进行深度克隆，否则会影响对象的正确性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Prototype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Prototype</span><span class="params">(String name, List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Prototype <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Prototype</span> <span class="variable">prototype</span> <span class="operator">=</span> (Prototype) <span class="built_in">super</span>.clone();</span><br><span class="line">        <span class="comment">// 对包含的引用对象进行深度克隆</span></span><br><span class="line">        prototype.list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.list);</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="6、装饰者模式"><a href="#6、装饰者模式" class="headerlink" title="6、装饰者模式"></a>6、装饰者模式</h1><p>装饰者模式是一种结构型设计模式，它允许动态地向一个对象添加新的行为，同时又不影响其原有行为。这种模式的关键在于装饰者类和被装饰者类实现相同的接口，使得装饰者对象可以代替被装饰者对象，从而实现透明性。<br>在装饰者模式中，有四个角色：</p><ol><li>抽象组件（Component）</li><li>具体组件（ConcreteComponent）</li><li>抽象装饰者（Decorator）：实现抽象组件</li><li>具体装饰者（ConcreteDecorator）：继承抽象装饰者</li></ol><p>核心思想是：将对象的行为分离出来，使得每个行为都可以被单独地扩展和修改，而不会影响到其他行为。这种分离行为的方式是通过将行为封装到不同的类中，并将这些类组合起来形成一个<strong>对象链</strong>来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象组件</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体组件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体组件的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象装饰者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰者A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorA</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        addedBehavior();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addedBehavior</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体装饰者A的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体装饰者B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteDecoratorB</span><span class="params">(Component component)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.operation();</span><br><span class="line">        addedBehavior();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addedBehavior</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体装饰者B的操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConcreteComponent</span> <span class="variable">concreteComponent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>();</span><br><span class="line">        <span class="type">ConcreteDecoratorA</span> <span class="variable">concreteDecoratorA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecoratorA</span>(concreteComponent);</span><br><span class="line">        <span class="type">ConcreteDecoratorB</span> <span class="variable">concreteDecoratorB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecoratorB</span>(concreteDecoratorA);</span><br><span class="line">        concreteDecoratorB.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="7、代理模式"><a href="#7、代理模式" class="headerlink" title="7、代理模式"></a>7、代理模式</h1><p>代理模式是一种结构型设计模式，主要作用是在访问对象时引入一定程度的间接性，以便更好地控制访问和管理对象。<br>Java中实现代理模式通常有两种方式：静态代理和动态代理<br>静态代理是指在编译时就已经确定代理类和被代理类的关系，代理类和被代理类都必须实现相同的接口或者继承相同的父类。静态代理的优点是简单易懂，缺点是需要为每一个被代理类写一个代理类，增加了代码量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象主题接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject.request()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxySubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RealSubject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxySubject</span><span class="params">(RealSubject realSubject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.realSubject = realSubject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxySubject.request()&quot;</span>);</span><br><span class="line">        realSubject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RealSubject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        <span class="type">ProxySubject</span> <span class="variable">proxySubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxySubject</span>(realSubject);</span><br><span class="line">        proxySubject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>动态代理是指在运行时动态生成代理类，不需要为每一个被代理类写一个代理类，可以节省代码量。Java中提供了两种动态代理机制：基于接口的动态代理和基于类的动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于接口的动态代理：</span></span><br><span class="line"><span class="comment">// 抽象主题接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际主题类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RealSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">request</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RealSubject.request()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InvocationHandler实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProxySubject.request()&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RealSubject</span> <span class="variable">realSubject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSubject</span>();</span><br><span class="line">        <span class="type">ProxyHandler</span> <span class="variable">proxyHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyHandler</span>(realSubject);</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">proxySubject</span> <span class="operator">=</span> (Subject) Proxy.newProxyInstance(</span><br><span class="line">                realSubject.getClass().getClassLoader(),</span><br><span class="line">                realSubject.getClass().getInterfaces(),</span><br><span class="line">                proxyHandler);</span><br><span class="line">        proxySubject.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8、享元模式"><a href="#8、享元模式" class="headerlink" title="8、享元模式"></a>8、享元模式</h1><p>享元模式是一种结构型设计模式，它用于减少系统中对象的数量，从而提高系统的性能和效率。在享元模式中，多个对象共享相同的状态和数据，这些状态和数据通常是不可变的，因此可以被多个对象共享使用</p><ol><li>抽象享元（Flyweight）：定义享元对象的接口，通常包含一个操作方法。</li><li>具体享元（ConcreteFlyweight）：实现抽象享元接口，包含内部状态和外部状态两部分，其中内部状态可以被共享，而外部状态需要在使用时传递给享元对象。</li><li>享元工厂（FlyweightFactory）：用于创建和管理享元对象，通常使用工厂模式来实现。</li></ol><p>在Java中，可以使用HashMap来存储享元对象，使用享元对象的属性作为HashMap的key，将享元对象作为HashMap的value。这样，当需要创建新的对象时，先在HashMap中查找是否已经存在相同属性的对象，如果存在，则返回已有的对象，否则创建新的对象并将其加入HashMap中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, Flyweight&gt; flyweights = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title function_">getFlyweight</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight</span> <span class="operator">=</span> flyweights.get(key);</span><br><span class="line">        <span class="keyword">if</span> (flyweight == <span class="literal">null</span>) &#123;</span><br><span class="line">            flyweight = <span class="keyword">new</span> <span class="title class_">ConcreteFlyweight</span>(key);</span><br><span class="line">            flyweights.put(key, flyweight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> <span class="keyword">implements</span> <span class="title class_">Flyweight</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteFlyweight</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ConcreteFlyweight with key &quot;</span> + key + <span class="string">&quot; is performing operation.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight1</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight2</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;key2&quot;</span>);</span><br><span class="line">        <span class="type">Flyweight</span> <span class="variable">flyweight3</span> <span class="operator">=</span> FlyweightFactory.getFlyweight(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        flyweight1.operation();</span><br><span class="line">        flyweight2.operation();</span><br><span class="line">        flyweight3.operation();</span><br><span class="line"></span><br><span class="line">        System.out.println(flyweight1 == flyweight3); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="9、策略模式"><a href="#9、策略模式" class="headerlink" title="9、策略模式"></a>9、策略模式</h1><p>策略模式是一种行为型设计模式，它允许选择算法的不同实现。在策略模式中，算法被封装在单独的类中，并且可以在运行时进行切换，以便在不同的情况下使用不同的算法<br>在策略模式中，有三个角色：策略接口、具体策略类和上下文类<br>上下文类包含一个策略接口的引用，并且可以在运行时切换具体策略类的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] data)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 策略实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSortStrategy</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        <span class="comment">// 冒泡排序算法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSortStrategy</span> <span class="keyword">implements</span> <span class="title class_">SortStrategy</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        <span class="comment">// 快速排序算法实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上下文类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sorter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> SortStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStrategy</span><span class="params">(SortStrategy strategy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] data)</span> &#123;</span><br><span class="line">        strategy.sort(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="type">int</span>[] data = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">Sorter</span> <span class="variable">sorter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sorter</span>();</span><br><span class="line">sorter.setStrategy(<span class="keyword">new</span> <span class="title class_">BubbleSortStrategy</span>());</span><br><span class="line">sorter.sort(data);</span><br><span class="line"></span><br><span class="line">sorter.setStrategy(<span class="keyword">new</span> <span class="title class_">QuickSortStrategy</span>());</span><br><span class="line">sorter.sort(data);</span><br></pre></td></tr></table></figure><h1 id="10、观察者模式"><a href="#10、观察者模式" class="headerlink" title="10、观察者模式"></a>10、观察者模式</h1><p>观察者模式是一种行为型设计模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，所有依赖于它的观察者对象都会得到通知并自动更新<br>实现观察者模式需要定义两个接口：主题接口和观察者接口。主题接口定义了注册、删除和通知观察者的方法，观察者接口定义了更新自己状态的方法<br>最典型的应用场景就是消息订阅系统（如微博）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 被观察者类，即微博用户或话题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 观察者列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123; <span class="comment">// 添加观察者</span></span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123; <span class="comment">// 移除观察者</span></span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notifyObservers</span><span class="params">(String message)</span> &#123; <span class="comment">// 通知所有观察者</span></span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者接口，即微博用户</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体观察者类，即关注了某个微博用户或话题的其他用户</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteObserver</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot; received message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Subject</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ConcreteObserver</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;User1&quot;</span>);</span><br><span class="line">        <span class="type">ConcreteObserver</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;User2&quot;</span>);</span><br><span class="line">        <span class="type">ConcreteObserver</span> <span class="variable">topic1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteObserver</span>(<span class="string">&quot;Topic1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        subject.attach(user1);</span><br><span class="line">        subject.attach(user2);</span><br><span class="line">        subject.attach(topic1);</span><br><span class="line"></span><br><span class="line">        subject.notifyObservers(<span class="string">&quot;Hello world!&quot;</span>); <span class="comment">// 发布新消息</span></span><br><span class="line"></span><br><span class="line">        subject.detach(user2); <span class="comment">// 取消关注</span></span><br><span class="line"></span><br><span class="line">        subject.notifyObservers(<span class="string">&quot;Goodbye!&quot;</span>); <span class="comment">// 发布新消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springBoot</title>
      <link href="/posts/59868.html"/>
      <url>/posts/59868.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、Spring-Boot基础应用"><a href="#1、Spring-Boot基础应用" class="headerlink" title="1、Spring Boot基础应用"></a>1、Spring Boot基础应用</h1><h2 id="1-1、springBoot特征"><a href="#1-1、springBoot特征" class="headerlink" title="1.1、springBoot特征"></a>1.1、springBoot特征</h2><p><strong>概念：</strong></p><p>约定优于配置，简单来说就是你所期待的配置与约定的配置一致，那么就可以不做任何配置，约定不符合期待时才需要对约定进行替换配置。</p><p><strong>特征：</strong></p><p>1.SpringBoot Starter：他将常用的依赖分组进行了整合，将其合并到一个依赖中，这样就可以一次性添加到项目的Maven或Gradle构建中</p><p>2.使编码变得简单，SpringBoot采用 JavaConfig的方式对Spring进行配置，并且提供了大量的注解，极大的提高了工作效率，比如@Configuration和@bean注解结合，基于@Configuration完成类扫描，基于@bean注解把返回值注入IOC容器。</p><p>3.自动配置：SpringBoot的自动配置特性利用了Spring对条件化配置的支持，合理地推测应用所需的bean并自动化配置他们</p><p>4.使部署变得简单，SpringBoot内置了三种Servlet容器，Tomcat，Jetty,undertow.我们只需要一个Java的运行环境就可以跑SpringBoot的项目了，SpringBoot的项目可以打成一个jar包</p><h2 id="1-2、springBoot热部署"><a href="#1-2、springBoot热部署" class="headerlink" title="1.2、springBoot热部署"></a>1.2、springBoot热部署</h2><h3 id="1-2-1、实现方式"><a href="#1-2-1、实现方式" class="headerlink" title="1.2.1、实现方式"></a>1.2.1、实现方式</h3><p>通过引入spring-bootdevtools插件，可以实现不重启服务器情况下，对项目进行即时编译。引入热部署插件的步骤如下：</p><p>1.添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.设置开启自动编译</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311020900514.png" alt="idea自动编译|850"></p><p>3.在项目任意页面中使用组合快捷键“Ctrl+Shift+Alt+&#x2F;”打开Maintenance选项框，选中并打开Registry页面，列表中找到“compiler.automake.allow.when.app.running”，将该选项后的Value值勾选，用于指定IDEA工具在程序运行过程中自动编译</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311020902140.png" alt="image.png"></p><p>4.项目配置中开启自动更新</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311030924388.png" alt="image.png"></p><h3 id="1-2-2、基本原理"><a href="#1-2-2、基本原理" class="headerlink" title="1.2.2、基本原理"></a>1.2.2、基本原理</h3><p>基本原理就是我们在编辑器上启动项目，然后改动相关的代码，然后编辑器自动触发编译，替换掉历史的.class文件后，项目检测到有文件变更后会重启srpring-boot项目。内部主要是通过引入的插件对我们的classpath资源变化进行监听，当classpath有变化，才会触发重启。</p><p>从官方文档可以得知，其实这里对类加载采用了两种类加载器，对于第三方jar包采用baseclassloader来加载，对于开发人员自己开发的代码则使用restartClassLoader来进行加载，这使得比停掉服务重启要快的多，因为使用插件只是重启开发人员编写的代码部分。</p><h1 id="2、注入-IOC"><a href="#2、注入-IOC" class="headerlink" title="2、注入(IOC)"></a>2、注入(IOC)</h1><h2 id="2-1、属性注入"><a href="#2-1、属性注入" class="headerlink" title="2.1、属性注入"></a>2.1、属性注入</h2><p>属性注入是通过在类中声明属性，并使用注解将属性值直接注入到相应的属性中。这种方式通常用于注入简单的值，如配置文件中的属性值或常量值</p><h3 id="2-1-1、-Value值注入"><a href="#2-1-1、-Value值注入" class="headerlink" title="2.1.1、@Value值注入"></a>2.1.1、@Value值注入</h3><p>参数值在application.properties配置文件中编写，并利用@Value注解注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span></span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>   <span class="comment">//用bean注解将返回值添加到容器中</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1-2、-ConfigurationProperties批量注入"><a href="#2-1-2、-ConfigurationProperties批量注入" class="headerlink" title="2.1.2、@ConfigurationProperties批量注入"></a>2.1.2、@ConfigurationProperties批量注入</h3><p>1.注入到该类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;person&quot;)</span> <span class="comment">//将配置文件中以person开头的属性注入到该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id; <span class="comment">//id</span></span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//名称</span></span><br><span class="line">    <span class="keyword">private</span> List hobby;     <span class="comment">// 爱好</span></span><br><span class="line">    <span class="keyword">private</span> String[] family;    <span class="comment">// 家庭</span></span><br><span class="line">    <span class="keyword">private</span> Map map;</span><br><span class="line">    <span class="keyword">private</span> Pet pet;    <span class="comment">// 宠物</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.id=<span class="number">1</span></span><br><span class="line">person.name=tom</span><br><span class="line">person.hobby=音乐,篮球,阅读</span><br><span class="line">person.family=father,mother</span><br><span class="line">person.map.k1=v1</span><br><span class="line">person.map.k2=v2</span><br><span class="line">person.pet.type=dog</span><br><span class="line">person.pet.name=旺财</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.第三方配置</p><p>除了 @ConfigurationProperties 用于注释类之外，您还可以在公共 @Bean 方法上使用它。当要将属 性绑定到控件之外的第三方组件时，这样做特别有用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnotherComponent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> InetAddress remoteAddress;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;another&quot;)</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AnotherComponent <span class="title function_">anotherComponent</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AnotherComponent</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">another.enabled=<span class="literal">true</span></span><br><span class="line">another.remoteAddress=<span class="number">192.168</span><span class="number">.10</span><span class="number">.11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-2、依赖注入"><a href="#2-2、依赖注入" class="headerlink" title="2.2、依赖注入"></a>2.2、依赖注入</h2><p>依赖注入是通过在类中声明依赖关系，并由Spring容器负责在运行时将相应的依赖注入到类中。这种方式通常用于注入其他类的实例</p><h3 id="2-2-1、属性注入"><a href="#2-2-1、属性注入" class="headerlink" title="2.2.1、属性注入"></a>2.2.1、属性注入</h3><p>这里是使用 @Autowired 注解注入。另外也有 @Resource 以及 @Inject 等注解，都可以实现注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BService</span> &#123;</span><br><span class="line"><span class="meta">@autowired</span></span><br><span class="line">Aservice aService;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-2、构造方法注入"><a href="#2-2-2、构造方法注入" class="headerlink" title="2.2.2、构造方法注入"></a>2.2.2、构造方法注入</h3><p>如果类只有一个构造方法，那么 @Autowired 注解可以省略；如果类中有多个构造方法，那么需要添加上 @Autowired 来明确指定到底使用哪个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Aservice</span> &#123;</span><br><span class="line">Bservice bService;</span><br><span class="line"><span class="meta">@autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Aservice</span><span class="params">(BService bService)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.bService = bService;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-3、set方法注入"><a href="#2-2-3、set方法注入" class="headerlink" title="2.2.3、set方法注入"></a>2.2.3、set方法注入</h3><p>set 方法注入太过于臃肿，实际上很少使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bservice</span> &#123;</span><br><span class="line">Aservice aService;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setaService</span><span class="params">(Aservice aService)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.aService = aService;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>spring官方不建议第一种属性注入的方式。推荐使用构造方法注入的方式。<br>（1）属性注入无法注入一个不可变的对象（final 修饰的对象）在 Java 中 final 对象（不可变）要么直接赋值，要么在构造方法中赋值，所以当使用属性注入 final 对象时，它不符合 Java 中 final 的使用规范，所以就不能注入成功了<br>（2）更容易违背单一设计原则。使用属性注入是比较简单的,我们可以很容易的在一个类中注入多个对象,但是这些对象可能会违背原则,因为很多对象没有必要去注入</p></blockquote><h1 id="3、日志框架"><a href="#3、日志框架" class="headerlink" title="3、日志框架"></a>3、日志框架</h1><p>日志的基本概念参考java core文章中的第13节<br>Spring Boot 默认已经使用了 SLF4J + LogBack . 所以我们在不进行任何额外操作的情况下就可以使用 SLF4J + Logback 进行日志输出。SLF4J 日志级别从小到大trace,debug,info,warn,error，默认是info级别。</p><table><thead><tr><th>日志级别</th><th>描述</th></tr></thead><tbody><tr><td><strong>trace</strong></td><td>较低的日志级别，通常不会被使用，日志的输出很详细</td></tr><tr><td><strong>debug</strong></td><td>程序员调式代码的时候使用，开发过程中打印一些运行信息</td></tr><tr><td><strong>info</strong></td><td>记录运维（程序运行）过程的数据</td></tr><tr><td><strong>warn</strong></td><td>警告信息，潜在的问题信息，在生产日志中，作为给程序员的一种提醒而使用</td></tr><tr><td><strong>error</strong></td><td>打印错误日志，但是不会影响程序继续运行</td></tr></tbody></table><h2 id="3-1、application配置文件"><a href="#3-1、application配置文件" class="headerlink" title="3.1、application配置文件"></a>3.1、application配置文件</h2><p>可以指定指定包下的日志级别</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 日志配置  </span></span><br><span class="line"><span class="attr">logging:</span>  </span><br><span class="line">  <span class="attr">level:</span>  </span><br><span class="line">    <span class="attr">com.baidu:</span> <span class="string">debug</span>  <span class="comment"># 设置指定路径下的日志输出级别</span></span><br><span class="line">    <span class="attr">org.springframework:</span> <span class="string">warn</span></span><br></pre></td></tr></table></figure><h2 id="3-2、logback配置"><a href="#3-2、logback配置" class="headerlink" title="3.2、logback配置"></a>3.2、logback配置</h2><p>SpringBoot项目默认使用logback，首先SpringBoot会从resource包下查找logback-test.xml或logback.xml ，如果这两个都不存在，则会调用BasicConfigurator，创建一个最小化的基本配置。最小化配置由一个关联到根logger的ConsoleAppender组成，默认输出模式为%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n，root logger级别为DEBUG，所以并不会生成日志文件，只会输出到控制台</p><p>通过自定义<code>logback.xml</code>配置文件来控制日志输出情况，通常我们会配置三个日志组件：</p><ul><li>控制台输出</li><li>输出info级别日志文件</li><li>输出error级别日志文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Logback configuration. See http:&lt;span class=&quot;hljs-comment&quot;&gt;//logback.qos.ch/manual/index.html --&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=&lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;true&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> scanPeriod=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;2 seconds&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">    <span class="comment">&lt;!--定义日志文件的存储地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=&lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;LOG_PATH&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> value=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;./logs&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> /&gt;</span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=&lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;STDOUT&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-class&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-keyword&quot;</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ch.qos.logback.core.ConsoleAppender&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> &lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-class&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-keyword&quot;</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">            <span class="comment">&lt;!--格式化输出：%d表示日期，%-&lt;span class=&quot;hljs-number&quot;&gt;5l&lt;/span&gt;evel：级别从左显示&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;个字符宽度，%t表示线程名，%msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>5l<span class="tag">&lt;/<span class="name">span</span>&gt;</span>evel $&#123;PID:-&#125; --- [%t] %logger&#123;<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>50<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- info级别日志文件输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=&lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;INFO_FILE&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-class&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-keyword&quot;</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">        <span class="comment">&lt;!-- 日志文件输出的文件名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;LOG_PATH&#125;/info.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> &lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-class&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-keyword&quot;</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">            <span class="comment">&lt;!-- 每日生成日志文件或日志文件大小超出限制后输出的文件名模板 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/info-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件保留天数 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志文件最大大小：&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;MB --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">span</span>&gt;</span>MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> &lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-class&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-keyword&quot;</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>5l<span class="tag">&lt;/<span class="name">span</span>&gt;</span>evel $&#123;PID:-&#125; --- [%t] %logger&#123;<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>50<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- error级别日志文件输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=&lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ERROR_FILE&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-class&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-keyword&quot;</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">        <span class="comment">&lt;!-- 日志输出级别，优先级 &gt; &lt;span class=&quot;hljs-string&quot;&gt;&#x27;&lt;root level&gt;&#x27;&lt;/span&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> &lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-class&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-keyword&quot;</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;LOG_PATH&#125;/error.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> &lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-class&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-keyword&quot;</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>30<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>100<span class="tag">&lt;/<span class="name">span</span>&gt;</span>MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> &lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-class&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-keyword&quot;</span>&gt;</span>class<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>=<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %-<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>5l<span class="tag">&lt;/<span class="name">span</span>&gt;</span>evel $&#123;PID:-&#125; --- [%t] %logger&#123;<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-number&quot;</span>&gt;</span>50<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 默认日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=&lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;INFO&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span>&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=&lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;STDOUT&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> /&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=&lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;INFO_FILE&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> /&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=&lt;<span class="attr">span</span> <span class="attr">class</span>=<span class="string">&quot;hljs-string&quot;</span>&gt;</span>&quot;ERROR_FILE&quot;<span class="tag">&lt;/<span class="name">span</span>&gt;</span> /&gt;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4、多环境配置"><a href="#4、多环境配置" class="headerlink" title="4、多环境配置"></a>4、多环境配置</h1><p>Spring Boot 自己本身带的有多环境配置，对多环境整合已经有了很好的支持，能够在打包，运行期间自由切换环境</p><h2 id="4-1、springBoot多环境配置"><a href="#4-1、springBoot多环境配置" class="headerlink" title="4.1、springBoot多环境配置"></a>4.1、springBoot多环境配置</h2><h3 id="4-1-1、创建不同环境配置文件"><a href="#4-1-1、创建不同环境配置文件" class="headerlink" title="4.1.1、创建不同环境配置文件"></a>4.1.1、创建不同环境配置文件</h3><p>不同环境的配置文件需要进行分开，按照项目运行环境启用加载。新建 application-dev.yml, application-test.yml, application-prod.yml。加上 application.yml 一共有四个配置文件。注意：配置文件名称一定要是 application-name.yml 格式，name可以自定义</p><h3 id="4-1-2、指定不同环境配置文件"><a href="#4-1-2、指定不同环境配置文件" class="headerlink" title="4.1.2、指定不同环境配置文件"></a>4.1.2、指定不同环境配置文件</h3><p>在 application.yml 文件中指定启用哪个环境的配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定启用环境为 开发环境 dev</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br></pre></td></tr></table></figure><blockquote><p>如果没有指定运行的环境，Spring Boot 会默认加载 application.yml 配置文件</p></blockquote><h3 id="4-1-3、运行jar时指定配置文件"><a href="#4-1-3、运行jar时指定配置文件" class="headerlink" title="4.1.3、运行jar时指定配置文件"></a>4.1.3、运行jar时指定配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar xxx.jar --spring.profiles.active=dev</span><br></pre></td></tr></table></figure><h2 id="4-2、maven多环境配置"><a href="#4-2、maven多环境配置" class="headerlink" title="4.2、maven多环境配置"></a>4.2、maven多环境配置</h2><p>Maven 也提供了对多环境的支持，不仅仅支持 Spring Boot 项目，只要是基于 Maven 的项目都可以配置。Maven 对于多环境的支持在功能方面更加强大，支持 JDK 版本、资源文件、操作系统等等</p><h3 id="4-2-1、创建不同环境配置文件"><a href="#4-2-1、创建不同环境配置文件" class="headerlink" title="4.2.1、创建不同环境配置文件"></a>4.2.1、创建不同环境配置文件</h3><p>同4.1.1</p><h3 id="4-2-2、定义激活的变量"><a href="#4-2-2、定义激活的变量" class="headerlink" title="4.2.2、定义激活的变量"></a>4.2.2、定义激活的变量</h3><p>需要将 Maven 激活的环境作用于 Spring Boot，实际还是利用了 spring.profiles.active 这个属性，只是现在这个属性的取值将是取值于 Maven，配置如下:</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">@profile.active@</span></span><br></pre></td></tr></table></figure><p>profile.active 实际上就是一个变量，在 maven 打包的时候指定的 -P dev 传入的就是值。</p><h3 id="4-2-3、pom文件中定义profiles"><a href="#4-2-3、pom文件中定义profiles" class="headerlink" title="4.2.3、pom文件中定义profiles"></a>4.2.3、pom文件中定义profiles</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义三种开发环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不同环境的唯一id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--默认激活开发环境--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--profile.active对应application.yml中的@profile.active@--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>test<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">profile.active</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">profile.active</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-4、打包时指定环境"><a href="#4-2-4、打包时指定环境" class="headerlink" title="4.2.4、打包时指定环境"></a>4.2.4、打包时指定环境</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package -Pdev -DskipTests</span><br></pre></td></tr></table></figure><h1 id="5、事务实现"><a href="#5、事务实现" class="headerlink" title="5、事务实现"></a>5、事务实现</h1><h2 id="5-1、事务实现方案"><a href="#5-1、事务实现方案" class="headerlink" title="5.1、事务实现方案"></a>5.1、事务实现方案</h2><p>Spring 事务管理分为<strong>编码式和声明式</strong>的两种方式</p><p>编程式事务管理： 利用TransactionTemplate模板通过编程的方式实现事务管理,而无需关注资源获取、复用、释放、事务同步及异常处理等操作</p><p>声明式事务管理： 建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务（使用<strong>isolation</strong>属性声明事务的隔离级别,使用<strong>propagation</strong>属性声明事务的传播机制）</p><blockquote><p>声明式事务管理不需要入侵代码，更快捷而且简单，推荐使用</p></blockquote><h2 id="5-2、-Transactional详解"><a href="#5-2、-Transactional详解" class="headerlink" title="5.2、@Transactional详解"></a>5.2、@Transactional详解</h2><h3 id="5-2-1、常用参数"><a href="#5-2-1、常用参数" class="headerlink" title="5.2.1、常用参数"></a>5.2.1、常用参数</h3><table><thead><tr><th><strong>参 数 名 称</strong></th><th><strong>功 能 描 述</strong></th></tr></thead><tbody><tr><td>readOnly</td><td>该属性用于设置当前事务是否为只读事务，设置为true表示只读，false则表示可读写，默认值为false。例如：<code>@Transactional(readOnly=true)</code></td></tr><tr><td>rollbackFor</td><td>rollbackFor 该属性用于设置需要进行回滚的异常类数组，当方法中抛出指定异常数组中的异常时，则进行事务回滚。例如：指定单一异常类：@Transactional(rollbackFor&#x3D;RuntimeException.class)指定多个异常类：@Transactional(rollbackFor&#x3D;{RuntimeException.class,Exception.class})</td></tr><tr><td><strong>propagation</strong></td><td>该属性用于设置事务的传播行为。例如：<code>@Transactional(propagation=Propagation.NOT_SUPPORTED, readOnly=true)</code></td></tr><tr><td><strong>isolation</strong></td><td>该属性用于设置底层数据库的事务隔离级别，事务隔离级别用于处理多事务并发的情况，通常使用数据库的默认隔离级别即可，基本不需要进行设置</td></tr><tr><td>timeout</td><td>该属性用于设置事务的超时秒数，默认值为-1表示永不超时 事物超时设置：<code>@Transactional(timeout=30)</code> ，设置为30秒</td></tr></tbody></table><h3 id="5-2-2、事务传播行为"><a href="#5-2-2、事务传播行为" class="headerlink" title="5.2.2、事务传播行为"></a>5.2.2、事务传播行为</h3><p>Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。Propagation枚举则引用了这些类型，开发过程中我们一般直接用Propagation枚举。例如@Transactional(propagation&#x3D;Propagation.NOT_SUPPORTED,readOnly&#x3D;true)，常用的三项已经加粗</p><table><thead><tr><th><strong>事务传播行为类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>PROPAGATION_SUPPORTS</td><td>支持事务。若当前没有事务以非事务方式执行；若当前有事务，加入此事务中</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>不支持事务。若当前存在事务，把当前事务挂起，然后运行方法</td></tr><tr><td>PROPAGATION_NEVER</td><td>不使用事务。若当前方法存在事务，则抛出IllegalTransactionStateException异常，否则继续使用无事务机制运行</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>强制使用事务。若当前有事务，就使用当前事务；若当前没有事务，抛出IllegalTransactionStateException异常</td></tr><tr><td><strong>PROPAGATION_REQUIRED</strong></td><td>需要事务（<strong>默认</strong>）。若当前无事务，新建一个事务；若当前有事务，加入此事务中</td></tr><tr><td><strong>PROPAGATION_REQUIRES_NEW</strong></td><td>新建事务。无论当前是否有事务，都新建事务运行</td></tr><tr><td><strong>PROPAGATION_NESTED</strong></td><td>嵌套。如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作</td></tr></tbody></table><h3 id="5-2-3、事务隔离级别"><a href="#5-2-3、事务隔离级别" class="headerlink" title="5.2.3、事务隔离级别"></a>5.2.3、事务隔离级别</h3><p>@Transactional(isolation &#x3D; Isolation.DEFAULT)，默认的隔离级别，使用数据库默认的事务隔离级别，下面四个与JDBC的隔离级别相对应</p><table><thead><tr><th><strong>级别</strong></th><th><strong>名字</strong></th><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th><th><strong>数据库默认隔离级别</strong></th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>读未提交</td><td>read uncommitted</td><td>是</td><td>是</td><td>是</td><td></td><td>事务A可以读取到事务B未提交的数据</td></tr><tr><td>2</td><td>读已提交</td><td>read committed</td><td>否</td><td>是</td><td>是</td><td>Oracle和SQL Server</td><td>事务A只能读取其它事务已提交的数据（避免了脏读）</td></tr><tr><td>3</td><td>可重复读</td><td>repeatable read</td><td>否</td><td>否</td><td>是</td><td>MySQL</td><td>保证在同一个事务中多次读取同样数据的结果是一样的</td></tr><tr><td>4</td><td>串行化</td><td>serializable</td><td>否</td><td>否</td><td>否</td><td></td><td>事务串行化顺序执行</td></tr></tbody></table><h2 id="5-3、事务使用事项"><a href="#5-3、事务使用事项" class="headerlink" title="5.3、事务使用事项"></a>5.3、事务使用事项</h2><p>1.@Transactional 注解应该只被应用在 public 修饰的方法上(注意)。 如果在 protected、private 或者 package-visible 的方法上使用 该注解，它也不会报错(IDEA会有提示)， 但事务并没有生效</p><p>2.@Transactional是基于动态代理的(注意)，需要一个类调用另一个类，类内调用会失效</p><blockquote><p>当在类的内部调用被@Transactional注解修饰的方法时，实际上是通过类的实例直接调用方法，而不是通过代理对象。这样做会绕过代理对象，从而导致@Transactional注解失效</p></blockquote><p>3.事务@Transactional由spring控制时，它会在抛出异常的时候进行回滚。如果自己使用try-catch捕获处理了，是不生效的。如果想事务生效可以进行手动回滚或者在catch里面将异常抛出throw new RuntimeException()</p><h1 id="6、starter-（自动配置原理）"><a href="#6、starter-（自动配置原理）" class="headerlink" title="6、starter （自动配置原理）"></a>6、starter （自动配置原理）</h1><p>spring boot 在配置上相比spring要简单许多, 其核心在于spring-boot-starter, 在使用spring boot来搭建一个项目时, 只需要引入官方提供的starter, 就可以直接使用, 免去了各种配置。starter简单来讲就是做了起步依赖和自动配置</p><blockquote><p>Spring官方提供了很多starter，第三方也可以定义starter。为了加以区分，starter从名称上进行了如下规范：<br>  -Spring官方提供的starter名称为：spring-boot-starter-xxx 例如Spring官方提供的spring-boot-starter-web<br>  -第三方提供的starter名称为：xxx-spring-boot-starter 例如由mybatis提供的mybatis-spring-boot-starter</p></blockquote><h2 id="6-1、起步依赖"><a href="#6-1、起步依赖" class="headerlink" title="6.1、起步依赖"></a>6.1、起步依赖</h2><p>起步依赖，其实就是将具备某种功能的坐标打包到一起，可以简化依赖导入的过程。例如，我们导入spring-boot-starter-web这个starter，则和web开发相关的jar包都一起导入到项目中了。如下图所示：</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311031115469.png" alt="起步依赖"></p><h2 id="6-2、自动配置"><a href="#6-2、自动配置" class="headerlink" title="6.2、自动配置"></a>6.2、自动配置</h2><blockquote><p>spring boot默认扫描启动类所在的包下的主类与子类的所有组件，但并没有包括依赖包中的类，那么依赖包中的bean是如何被发现和加载的。我们需要从Spring Boot项目的启动类开始跟踪</p></blockquote><p>在启动类上我们一般会加入SpringBootApplication注解，它是一个复合注解，它下面的@EnableAutoConfiguration这个注解，这个注解也是一个复合注解。@EnableAutoConfiguration注解导入AutoConfigurationImportSelector类，这个类中有一个selectImports()方法，扫描了所有包含META-INF&#x2F;spring.factories的jar包，这些jar包实际上就是我们引入的starter中的依赖。而自动配置的类的全类名就在这个文件中，然后就可以通过反射加载这些类</p><p>这些配置类@Configuration和@Bean这两个注解一起使用就可以创建一个基于java代码的配置类.比如<strong>MybatisAutoConfiguration</strong>这个类，会先通过依赖条件判断@ConditionOnClass等，判断有没有SqlSessionFactory类和Datasource实例。满足条件时创建对应的需要的实例</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311031446904.png" alt="image.png"></p><h2 id="6-3、自定义starter"><a href="#6-3、自定义starter" class="headerlink" title="6.3、自定义starter"></a>6.3、自定义starter</h2><p>SpringBoot中的starter是一种非常重要的机制，能够抛弃以前繁杂的配置，将其统一集成进starter，应用者只需要在maven中引入starter依赖，Spring Boot就能自动扫描各个jar包下classpath路径的spring.factories文件，加载自动配置类信息，加载相应的bean信息并启动相应的<code>默认配置</code></p><h3 id="6-3-1、创建starter项目"><a href="#6-3-1、创建starter项目" class="headerlink" title="6.3.1、创建starter项目"></a>6.3.1、创建starter项目</h3><p>SpringBoot官方命名方式<br>格式：spring-boot-starter-{模块名}<br>举例：spring-boot-starter-web<br>自定义命名方式<br>格式：{模块名}-spring-boot-starter<br>举例：mystarter-spring-boot-starter</p><h3 id="6-3-2、添加依赖"><a href="#6-3-2、添加依赖" class="headerlink" title="6.3.2、添加依赖"></a>6.3.2、添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">optional</span>&gt;</span>2.2.9.RELEASE<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-3-3、编写bean"><a href="#6-3-3、编写bean" class="headerlink" title="6.3.3、编写bean"></a>6.3.3、编写bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyBean .class)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mybean&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;<span class="keyword">private</span> String name;<span class="comment">//省略setter和getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-4、编写自动配置类"><a href="#6-3-4、编写自动配置类" class="headerlink" title="6.3.4、编写自动配置类"></a>6.3.4、编写自动配置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanAutoConfiguration</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MyBean <span class="title function_">myBean</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-5、编写spring-factories"><a href="#6-3-5、编写spring-factories" class="headerlink" title="6.3.5、编写spring.factories"></a>6.3.5、编写spring.factories</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\ com.blue.config.MyBeanAutoConfiguration</span><br></pre></td></tr></table></figure><h3 id="6-3-6、打包"><a href="#6-3-6、打包" class="headerlink" title="6.3.6、打包"></a>6.3.6、打包</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><h3 id="6-3-7、测试"><a href="#6-3-7、测试" class="headerlink" title="6.3.7、测试"></a>6.3.7、测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.blue&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;mybean-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = TestApplication.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestApplicationTests</span> &#123;</span><br><span class="line"><span class="meta">@Autowiredprivate</span> </span><br><span class="line">MyBean ba;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Testvoid</span> contextLoads() &#123;</span><br><span class="line">System.out.println(ba.getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3-8、实现热插拔"><a href="#6-3-8、实现热插拔" class="headerlink" title="6.3.8、实现热插拔"></a>6.3.8、实现热插拔</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 新增标记类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigMarker</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.定义@EnableMyBean注解</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(&#123;ConfigMarker.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableMyBean&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.改造配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnBean(ConfigMarker.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanAutoConfiguration</span> &#123;</span><br><span class="line"><span class="meta">@Beanpublic</span> </span><br><span class="line">MyBean <span class="title function_">myBean</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBean</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在测试启动类上开启MyBean功能</span></span><br><span class="line"><span class="meta">@EnableMyBean</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestApplication</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">SpringApplication.run(TestApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4、springBoot内置tomcat原理"><a href="#6-4、springBoot内置tomcat原理" class="headerlink" title="6.4、springBoot内置tomcat原理"></a>6.4、springBoot内置tomcat原理</h2><p>1、springboot启动时会自动加载spring-boot-starter-web依赖中的配置类：servletWebServerFactoryAutoConfiguration<br>2、该自动配置类通过@Import导入了可用的web容器工厂（默认tomcat，通过@ConditionalOnClass判断决定使用哪个）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用默认tomcat，使用jetty容器时的配置</span></span><br><span class="line"><span class="comment">// 1. application配置文件</span></span><br><span class="line">spring:</span><br><span class="line">main:</span><br><span class="line">web-application-type: SERVLET</span><br><span class="line">servlet:</span><br><span class="line">container: org.eclipse.jetty.server.Server</span><br><span class="line"><span class="comment">// 2.maven配置文件</span></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- Jetty容器 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;exclusions&gt;</span><br><span class="line">            &lt;exclusion&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;</span><br><span class="line">            &lt;/exclusion&gt;</span><br><span class="line">        &lt;/exclusions&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;jetty-server&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;$&#123;jetty.version&#125;&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>3、在调用run()方法的时候完成Tomcat对象的创建，环境设置和启动，从而实现Tomcat容器的自动化处理</p><h1 id="7、spring-Bean的生命周期"><a href="#7、spring-Bean的生命周期" class="headerlink" title="7、spring Bean的生命周期"></a>7、spring Bean的生命周期</h1><h2 id="7-1、spring-bean声明周期"><a href="#7-1、spring-bean声明周期" class="headerlink" title="7.1、spring bean声明周期"></a>7.1、spring bean声明周期</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230927436.png" alt="spring bean生命周期"></p><p>1、 实例化（Instantiation）：当Spring容器接收到Bean的定义时，会使用反射机制创建一个Bean实例。<br>2、属性赋值（Populate Bean）： Spring 将值和bean的引用注入到bean对应的属性中<br>3、回调实现Aware接口的方法。BeanNameAware，BeanFactoryAware，ApplicationContextAware对应的方法。</p><blockquote><p>Spring的依赖注入的最大亮点就是你所有的Bean对Spring容器的存在是没有意识的。即你可以将你的容器替换成别的容器，例如Goggle Guice,这时Bean之间的耦合度很低。<br>但是在实际的项目中，我们不可避免的要用到Spring容器本身的功能资源，这时候Bean必须要意识到Spring容器的存在，才能调用Spring所提供的资源，这就是所谓的Spring Aware。其实Spring Aware本来就是Spring设计用来框架内部使用的，若使用了Spring Aware，你的Bean将会和Spring框架耦合。  </p></blockquote><p>4、初始化（Initialization）：分别调用（1）BeanPostProcessor的前置处理器，（2）InitialzingBean的afterPropertiesSet（）方法，（3）调用init初始化方法（4）调用BeanPostProcessor的后置处理器<br>5、使用（In Use）：在初始化完成之后，Bean就可以被使用了。<br>6、销毁（Destruction）：当Spring容器关闭时，会销毁所有的Bean。在销毁Bean之前，（1）如果实现DisposableBean接口，Spring将调用它的destory()接口方法（2）如果bean使用destroy-method声明了销毁方法，该方法也会被调用</p><h1 id="8、拦截器和过滤器"><a href="#8、拦截器和过滤器" class="headerlink" title="8、拦截器和过滤器"></a>8、拦截器和过滤器</h1><p>在构建 Web 应用时，我们经常需要对请求进行拦截和处理，以实现诸如身份验证、授权、日志记录等功能。在 Spring Boot 中，为我们提供了两种强大的工具来实现这些功能：过滤器（Filter）和拦截器（Interceptor）</p><blockquote><p>拦截器与过滤器的区别<br> 归属不同：Filter属于Servlet技术，Interceptor属于SpringMVC技术<br> 拦截器内容不同：Filter对所有访问进行增强（在Tomcat服务器进行配置），Interceptor仅针对SpringMVC的访问进行增强</p></blockquote><h2 id="8-1、拦截器"><a href="#8-1、拦截器" class="headerlink" title="8.1、拦截器"></a>8.1、拦截器</h2><p>在Spring Boot中，拦截器分为两类：<br>一种是对请求进来的url进行拦截，HandlerInterceptor接口<br>一种是对发送出去的请求进行拦截，ClientHttpRequestInterceptor</p><h3 id="8-1-1、HandlerInterceptor接口"><a href="#8-1-1、HandlerInterceptor接口" class="headerlink" title="8.1.1、HandlerInterceptor接口"></a>8.1.1、HandlerInterceptor接口</h3><p>1、创建一个类，实现org.springframework.web.servlet.HandlerInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录检查</span></span><br><span class="line"><span class="comment"> * 1.配置到拦截器要拦截哪些请求</span></span><br><span class="line"><span class="comment"> * 2.把这些配置放在容器中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行之前</span></span><br><span class="line"><span class="comment">     * 登录检查写在这里，如果没有登录，就不执行目标方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 获取进过拦截器的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">requestURI</span> <span class="operator">=</span> request.getRequestURI();</span><br><span class="line">        <span class="comment">// 登录检查逻辑</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">loginUser</span> <span class="operator">=</span> session.getAttribute(<span class="string">&quot;loginUser&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(loginUser !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 拦截   就是未登录,自动跳转到登录页面，然后写拦截住的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 目标方法执行完成以后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.postHandle(request, response, handler, modelAndView);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面渲染以后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HandlerInterceptor.<span class="built_in">super</span>.afterCompletion(request, response, handler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、将拦截器添加到容器当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//定制SpringMVC的一些功能都使用WebMvcConfigurer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdminWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry 相当于拦截器的注册中心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line"><span class="comment">// 下面这句代码相当于添加一个拦截器   添加的拦截器就是我们刚刚创建的</span></span><br><span class="line">         registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>())</span><br><span class="line"><span class="comment">//  addPathPatterns()配置我们要拦截哪些路径 addPathPatterns(&quot;/**&quot;)表示拦截所有请求，包括我们的静态资源</span></span><br><span class="line">                 .addPathPatterns()</span><br><span class="line"><span class="comment">// excludePathPatterns()表示我们要放行哪些（表示不用经过拦截器）</span></span><br><span class="line"><span class="comment">// excludePathPatterns(&quot;/&quot;,&quot;/login&quot;)表示放行“/”与“/login”请求</span></span><br><span class="line"><span class="comment">// 如果有静态资源的时候可以在这个地方放行</span></span><br><span class="line">                 .excludePathPatterns(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;/login&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-2、ClientHttpRequestInterceptor接口"><a href="#8-1-2、ClientHttpRequestInterceptor接口" class="headerlink" title="8.1.2、ClientHttpRequestInterceptor接口"></a>8.1.2、ClientHttpRequestInterceptor接口</h3><p>对于服务间调用，你可以使用ClientHttpRequestInterceptor接口来拦截和处理发送出去的请求。<br>这通常用于处理微服务之间的通信，例如添加认证信息、自定义请求头等</p><p>1、创建一个类，实现org.springframework.http.client.ClientHttpRequestInterceptor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomHeaderInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;    </span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span>  <span class="keyword">throws</span> IOException &#123;                       request.getHeaders().set(<span class="string">&quot;Custom-Header&quot;</span>, <span class="string">&quot;CustomHeaderValue&quot;</span>);        </span><br><span class="line"><span class="keyword">return</span> execution.execute(request, body);   </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure><p>2、创建一个配置类，将拦截器添加到RestTemplate或WebClient中。这两个类都是Spring框架中用于发起HTTP请求的客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configurationpublic</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;    </span><br><span class="line"><span class="meta">@Bean</span>    </span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();        </span><br><span class="line">List&lt;ClientHttpRequestInterceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();        </span><br><span class="line">interceptors.add(<span class="keyword">new</span> <span class="title class_">CustomHeaderInterceptor</span>());        </span><br><span class="line">restTemplate.setInterceptors(interceptors);        </span><br><span class="line"><span class="keyword">return</span> restTemplate;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-3、两者区别"><a href="#8-1-3、两者区别" class="headerlink" title="8.1.3、两者区别"></a>8.1.3、两者区别</h3><table><thead><tr><th align="left">特征</th><th align="left">HandlerInterceptor</th><th align="left">ClientHttpRequestInterceptor</th></tr></thead><tbody><tr><td align="left">作用范围</td><td align="left">拦截收到的Http请求</td><td align="left">拦截使用RestTemplate或WebClient发送的HTTP请求</td></tr><tr><td align="left">使用场景</td><td align="left">身份验证，授权，日志记录</td><td align="left">添加认证信息，自定义请求头</td></tr><tr><td align="left">需要实现的方法</td><td align="left">preHandle、postHandle、afterCompletion</td><td align="left">intercept</td></tr></tbody></table><h2 id="8-2、过滤器"><a href="#8-2、过滤器" class="headerlink" title="8.2、过滤器"></a>8.2、过滤器</h2><p>在 Spring Boot 中，过滤器（Filter）是用于在 Servlet 容器级别拦截和处理 HTTP 请求的组件。它们通常用于实现诸如身份验证、授权、日志记录、请求和响应的数据转换等功能。过滤器位于整个请求处理链的最前端，因此在请求到达 Spring 应用的任何其他组件之前，都会先经过过滤器处理</p><p>1、注册过滤器</p><p>注册过滤器：将过滤器作为一个 Bean 注册到 Spring 应用中。以下是一个简单的过滤器示例，用于记录每个请求的处理时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestTimingFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> &#123;&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span>  <span class="keyword">throws</span> IOException, ServletException &#123;                       <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();        </span><br><span class="line"><span class="keyword">try</span> &#123;            </span><br><span class="line">chain.doFilter(request, response);        </span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;            </span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();            </span><br><span class="line"><span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> endTime - startTime;            </span><br><span class="line"><span class="type">HttpServletRequest</span> <span class="variable">httpRequest</span> <span class="operator">=</span> (HttpServletRequest) request;            </span><br><span class="line">System.out.println(String.format(<span class="string">&quot;%s %s took %d ms&quot;</span>, httpRequest.getMethod(), httpRequest.getRequestURI(), duration));        </span><br><span class="line">&#125;   </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、要将此过滤器添加到 Spring Boot 应用中，请将其注册为 Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configurationpublic</span> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FilterConfig</span> &#123;    </span><br><span class="line"><span class="meta">@Bean</span>    </span><br><span class="line"><span class="keyword">public</span> FilterRegistrationBean&lt;RequestTimingFilter&gt; <span class="title function_">requestTimingFilter</span><span class="params">()</span> &#123;        </span><br><span class="line">FilterRegistrationBean&lt;RequestTimingFilter&gt; registrationBean = <span class="keyword">new</span> <span class="title class_">FilterRegistrationBean</span>&lt;&gt;();        </span><br><span class="line">registrationBean.setFilter(<span class="keyword">new</span> <span class="title class_">RequestTimingFilter</span>());        </span><br><span class="line">registrationBean.addUrlPatterns(<span class="string">&quot;/*&quot;</span>);        </span><br><span class="line"><span class="keyword">return</span> registrationBean;    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-3、两者之间的关系"><a href="#8-3、两者之间的关系" class="headerlink" title="8.3、两者之间的关系"></a>8.3、两者之间的关系</h2><table><thead><tr><th align="left">特征</th><th align="left">过滤器</th><th align="left">拦截器</th></tr></thead><tbody><tr><td align="left">处理层级</td><td align="left">servlet容器级别</td><td align="left">spring mvc层级</td></tr><tr><td align="left">使用场景</td><td align="left">通用功能，如身份验证，授权，日志记录等</td><td align="left">与spring框架相关的功能，如身份验证，请求参数处理</td></tr><tr><td align="left">优势</td><td align="left">处理任何web应用请求，更大的控制范围</td><td align="left">集成于springmvc，可以访问spring上下文和其它组件</td></tr></tbody></table><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311061524568.png" alt="image.png|525"></p><h1 id="9、监听器"><a href="#9、监听器" class="headerlink" title="9、监听器"></a>9、监听器</h1><p>SpringBoot 的监听器多用于监听Web应用中某些对象，信息的创建、销毁、增加、修改、删除等动作的发生，然后做出响应的处理。的那个范围对象状态发生变化时，服务器自动调用监听器对象的方法，<br>使用场景：</p><ul><li>系统统计在线用户</li><li>系统加载时进行信息初始化</li><li>系统网站的访问量 </li><li>等…..</li></ul><h2 id="9-1、监听器分类"><a href="#9-1、监听器分类" class="headerlink" title="9.1、监听器分类"></a>9.1、监听器分类</h2><p>Spring的监听器也可以说是一种观察者模式，它能实现事件与事件监听者直接的解耦，在Spring中监听器的实现主要有一下重要组件：</p><ul><li>ApplicationListener：事件监听者，观察者；</li><li>ApplicationEvent：Spring 事件，记录事件源、事件内容、时间等数据；</li><li>@EventListener：除了实现ApplicationListener接口注册监听器，也可以使用注解的方式</li><li>ApplicationEventPublisher：发布事件；</li></ul><h2 id="9-2、事件监听方式"><a href="#9-2、事件监听方式" class="headerlink" title="9.2、事件监听方式"></a>9.2、事件监听方式</h2><h3 id="9-2-1、实现ApplicationListener接口"><a href="#9-2-1、实现ApplicationListener接口" class="headerlink" title="9.2.1、实现ApplicationListener接口"></a>9.2.1、实现ApplicationListener接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener2</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MyEvent&gt;&#123;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(MyListener2.class);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MyEvent event)</span>&#123;</span><br><span class="line">logger.info(String.format(<span class="string">&quot;%s监听到事件源：%s.&quot;</span>, MyListener2.class.getName(), event.getSource()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="9-2-2、通过-EventListener注解实现事件监听"><a href="#9-2-2、通过-EventListener注解实现事件监听" class="headerlink" title="9.2.2、通过@EventListener注解实现事件监听"></a>9.2.2、通过@EventListener注解实现事件监听</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyListener4</span>&#123;</span><br><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(MyListener4.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// @EventListener 注解支持根据Event参数类型进行匹配</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listener</span><span class="params">(MyEvent event)</span>&#123;</span><br><span class="line">logger.info(String.format(<span class="string">&quot;%s监听到事件源：%s.&quot;</span>, MyListener4.class.getName(), event.getSource()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10、原理相关知识"><a href="#10、原理相关知识" class="headerlink" title="10、原理相关知识"></a>10、原理相关知识</h1><h2 id="10-1、springmvc执行流程"><a href="#10-1、springmvc执行流程" class="headerlink" title="10.1、springmvc执行流程"></a>10.1、springmvc执行流程</h2><p>1.客户端发送请求到DispatcherServlet。<br>2.DispatcherServlet根据请求的URL找到对应的HandlerMapping。<br>3.HandlerMapping返回对应的HandlerExecutionChain，其中包含处理请求的Controller以及拦截器。<br>4.DispatcherServlet根据返回的HandlerExecutionChain取出对应的Controller，并调用其处理方法。<br>5.Controller处理请求，并返回一个ModelAndView对象。<br>6.DispatcherServlet根据返回的ModelAndView对象，调用对应的ViewResolver进行视图解析。<br>7.ViewResolver返回对应的View对象。DispatcherServlet将Model传递给View，View对Model进行渲染。<br>8.DispatcherServlet将渲染后的视图返回给客户端</p><h2 id="10-2、spring解决循环依赖问题"><a href="#10-2、spring解决循环依赖问题" class="headerlink" title="10.2、spring解决循环依赖问题"></a>10.2、spring解决循环依赖问题</h2><table><thead><tr><th><strong>缓存</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>singletonObjects</td><td>第一级缓存，存放可用的成品Bean。</td></tr><tr><td>earlySingletonObjects</td><td>第二级缓存，存放半成品的Bean，半成品的Bean是已创建对象，但是未注入属性和初始化。用以解决循环依赖。</td></tr><tr><td>singletonFactories</td><td>第三级缓存，存的是Bean工厂对象，用来生成半成品的Bean并放入到二级缓存中。用以解决循环依赖。</td></tr><tr><td></td><td></td></tr></tbody></table><ol><li>A 调用doCreateBean()创建Bean对象：由于还未创建，从第1级缓存singletonObjects查不到，此时只是一个半成品（提前暴露的对象），放入第3级缓存singletonFactories。</li><li>A在属性填充时发现自己需要B对象，但是在三级缓存中均未发现B，于是创建B的半成品，放入第3级缓存singletonFactories。</li><li>B在属性填充时发现自己需要A对象，从第1级缓存singletonObjects和第2级缓存earlySingletonObjects中未发现A，但是在第3级缓存singletonFactories中发现A，将A放入第2级缓存earlySingletonObjects，同时从第3级缓存singletonFactories删除。</li><li>将A注入到对象B中。</li><li>B完成属性填充，执行初始化方法，将自己放入第1级缓存singletonObjects中（此时B是一个完整的对象），同时从第3级缓存singletonFactories和第2级缓存earlySingletonObjects中删除。</li><li>A得到“对象B的完整实例”，将B注入到A中。</li><li>A完成属性填充，执行初始化方法，并放入到第1级缓存singletonObjects中。</li></ol>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> spring </tag>
            
            <tag> springBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm</title>
      <link href="/posts/37319.html"/>
      <url>/posts/37319.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、jvm概念"><a href="#1、jvm概念" class="headerlink" title="1、jvm概念"></a>1、jvm概念</h1><h2 id="1-1、JVM-JRE-JDK区别"><a href="#1-1、JVM-JRE-JDK区别" class="headerlink" title="1.1、JVM JRE JDK区别"></a>1.1、JVM JRE JDK区别</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310250949549.png" alt="JVM JRE JDK关系"></p><p>JVM：就是一个虚拟的用于执行bytecode字节码的”虚拟计算机”。一般与OS操作系统打交道</p><p>JRE：java运行环境，包含Java虚拟机、库函数、运行Java应用程序所必须的文件</p><blockquote><p>javaw(windos java启动器，不显示黑窗口),libraries（外部类库）,rt_jar（核心库）</p></blockquote><p>JDK：java开发工具,包含JRE,以及增加编译器和调试器等用于程序开发的文件</p><blockquote><p>javac(编译器),debugging（调试器）,tools,javap（反编译工具）</p></blockquote><h1 id="2、内存结构"><a href="#2、内存结构" class="headerlink" title="2、内存结构"></a>2、内存结构</h1><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222232072.jpg" alt="jvm内存结构"></p><p>注意：常量池，运行时常量池，字符串常量池逻辑上属于方法区，只是存储的物理位置在堆（所以他们属于方法区）</p><h2 id="2-1、程序计数器"><a href="#2-1、程序计数器" class="headerlink" title="2.1、程序计数器"></a>2.1、程序计数器</h2><p>当前线程所执行的字节码的行号指示器。在JVM的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</p><blockquote><p>特点：<br>（1）.为了在线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，独立存储，互不影响。所以，程序计数器是线程私有的内存区域<br>（2）.如果线程执行的是一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程执行的是一个Native方法，计数器的值为空<br>（3）.Java虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域</p></blockquote><h2 id="2-2、虚拟机栈"><a href="#2-2、虚拟机栈" class="headerlink" title="2.2、虚拟机栈"></a>2.2、虚拟机栈</h2><h3 id="2-2-1、定义"><a href="#2-2-1、定义" class="headerlink" title="2.2.1、定义"></a>2.2.1、定义</h3><p>每个方法执行的同时会创建一个栈帧，栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。栈是线程私有的，它的生命周期与线程相同</p><blockquote><p>局部变量表：存放方法参数和方法内部定义的局部变量<br>  操作数栈：操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区<br>  动态链接：将这些符号引用转换为调用方法的直接引用</p></blockquote><h3 id="2-2-2、问题辨析"><a href="#2-2-2、问题辨析" class="headerlink" title="2.2.2、问题辨析"></a>2.2.2、问题辨析</h3><ol><li>垃圾回收是否涉及栈内存？<ul><li><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</li></ul></li><li>栈内存的分配越大越好吗？<ul><li>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</li></ul></li></ol><h3 id="2-2-3、线程运行诊断（CPU占用过高）"><a href="#2-2-3、线程运行诊断（CPU占用过高）" class="headerlink" title="2.2.3、线程运行诊断（CPU占用过高）"></a>2.2.3、线程运行诊断（CPU占用过高）</h3><ol><li>查询占用cpu过高程序pid（top）</li><li>查询该进程下各线程的CPU占用情况  （ ps H -eo pid,tid,%cpu|grep 27598）</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235151.png" alt="image (17).png"></p><ol start="3"><li>找到cpu占用最高的线程id，转为16进制</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222235572.png" alt="image (18).png"></p><ol start="4"><li>打印堆栈 （jstack pid）</li></ol><p>jstack 27598 | grep -A 100 6bdf</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222236269.png" alt="image (19).png"></p><h2 id="2-3、本地方法栈"><a href="#2-3、本地方法栈" class="headerlink" title="2.3、本地方法栈"></a>2.3、本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务（也就是字节码），而本地方法栈为虚拟机使用到的Native方法服务（一个Native Method就是一个java调用非java代码的接口）</p><h2 id="2-4、堆"><a href="#2-4、堆" class="headerlink" title="2.4、堆"></a>2.4、堆</h2><h3 id="2-4-1、定义"><a href="#2-4-1、定义" class="headerlink" title="2.4.1、定义"></a>2.4.1、定义</h3><p>Java堆的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存（特例：栈上分配策略）</p><blockquote><p>从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆可以细分为：新生代、老生代。新生代又可分为Eden和Suvivor区</p></blockquote><p>（1）新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2</p><blockquote><p>通过参数 –XX:NewRatio 来指定</p></blockquote><p>（2）Eden : from : to &#x3D; 8 : 1 : 1</p><blockquote><p>以通过参数 –XX:SurvivorRatio 来设定</p></blockquote><p>（3）最大物理内存大小不超过192兆字节（MB）时默认最大堆大小是物理内存的一半，否则占用物理内存的四分之一</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222237526.png" alt="image (20).png"></p><h3 id="2-4-2、堆内存诊断"><a href="#2-4-2、堆内存诊断" class="headerlink" title="2.4.2、堆内存诊断"></a>2.4.2、堆内存诊断</h3><p>jps：查看java进程<br>jmap：查看堆内存占用情况 jmap -heap 进程id<br>jconsole：图形界面，检测堆栈，CPU占用，类加载情况等（可以连续监测）<br>jvisualvm：和jconsole功能类似，但功能更强。可以抓取和导入堆dump快照</p><h3 id="2-4-3、内存泄漏"><a href="#2-4-3、内存泄漏" class="headerlink" title="2.4.3、内存泄漏"></a>2.4.3、内存泄漏</h3><p>内存溢出：是程序在申请内存时，没有足够的内存空间供其使用<br>内存泄漏：内存空间使用完毕之后未回收</p><p>内存泄露的原因？</p><p>（1）static字段引起的内存泄露<br>大量使用static字段会潜在的导致内存泄露，在Java中，静态字段通常拥有与整个应用程序相匹配的生命周期。<br>解决办法：最大限度的减少静态变量的使用；单例模式时，依赖于延迟加载对象而不是立即加载方式</p><p>（2）未关闭的资源导致内存泄露<br>每当创建连接或者打开流时，JVM都会为这些资源分配内存。如果没有关闭连接，会导致持续占有内存。在任意情况下，资源留下的开放连接都会消耗内存，如果我们不处理，就会降低性能，甚至OOM。<br>解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；jdk1.7后，可以使用try-with-resource块</p><h2 id="2-5、方法区"><a href="#2-5、方法区" class="headerlink" title="2.5、方法区"></a>2.5、方法区</h2><h3 id="2-5-1、结构"><a href="#2-5-1、结构" class="headerlink" title="2.5.1、结构"></a>2.5.1、结构</h3><p><strong>方法区（线程共享）</strong></p><p>方法区是java虚拟机的一个模型规范，具体实现是永久代和元空间。方法区存储了每个类的信息（包括类的名称、方法信息、字段信息）、常量以及编译器编译后的代码等。（GC分代收集扩展至方法区，可以不必为方法区编写专门的内存管理，但带来的后果是容易碰到内存溢出的问题。元空间占用本地内存，也就是说，只要不碰触到系统内存上限，方法区会有足够的内存空间）</p><blockquote><p>jdk1.7前：采用永久代<br>  jdk1.7：字符串常量池被移到堆内存（1.7前在方法区）<br>  jdk8：废除了永久代。类的元信息会被放入本地内存（元空间）。将类的静态变量和字符串常量池放入到java堆</p></blockquote><h3 id="2-5-2、class常量池"><a href="#2-5-2、class常量池" class="headerlink" title="2.5.2、class常量池"></a>2.5.2、class常量池</h3><p>class常量池：每个class文件都包含有一个class常量池，包含符号引用和字面量。符号引用就是类的全限定名和字段名称，描述符。字面量就是具体的值，包含数字型和字符型</p><h3 id="2-5-3、运行时常量池"><a href="#2-5-3、运行时常量池" class="headerlink" title="2.5.3、运行时常量池"></a>2.5.3、运行时常量池</h3><p>运行时常量池：运行时常量池是方法区的一部分。运行时常量池是当 Class 文件被加载到内存后，Java虚拟机会将 Class 文件常量池里的内容转移到运行时常量池里，<strong>并且把里面的符号地址变为真实地址，数值型字面量存放在运行时常量池，字符型字面量存放到字符串常量池</strong>**</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311011512926.png" alt="运行时常量池"></p><h3 id="2-5-4、字符串常量池"><a href="#2-5-4、字符串常量池" class="headerlink" title="2.5.4、字符串常量池"></a>2.5.4、字符串常量池</h3><p>JVM为了提高性能，减少内存开销，维护的一个存放字符串常量的内存区域，里面的字符串不允许重复，有长度限制，最大为65535字节</p><ol><li><strong>两种创建字符串对象不同方式的比较</strong></li></ol><p>（1）采用字面值的方式创建字符串对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Str</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String str1=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        String str2=<span class="string">&quot;aaa&quot;</span>;</span><br><span class="line">        System.out.println(str1==str2);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>采用字面值的方式创建一个字符串时，JVM 首先会去字符串池中查找是否存在 “aaa” 这个对象，如果不存在，则在字符串池中创建 “aaa” 这个对象，然后将池中 “aaa” 这个对象的引用地址返回给字符串常量 str，这样 str 会指向池中”aaa”这个字符串对象；如果存在，则不创建任何对象，直接将池中 “aaa” 这个对象的地址返回，赋给字符串常量。</p></blockquote><blockquote><p>对于上述的例子：这是因为，创建字符串对象 str2 时，字符串池中已经存在 “aaa” 这个对象，直接把对象 “aaa” 的引用地址返回给 str2，这样 str2 指向了池中 “aaa” 这个对象，也就是说 str1 和 str2 指向了同一个对象，因此语句 System.out.println(str1&#x3D;&#x3D; str2) 输出：true。</p></blockquote><p>（2）采用 new 关键字新建一个字符串对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Str</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        String str1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        String str2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        System.out.println(str1==str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果：</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>采用 new 关键字新建一个字符串对象时，JVM 首先在字符串常量池中查找有没有 “aaa” 这个字符串对象，如果有，则不在池中再去创建 “aaa” 这个对象了，直接在堆中创建一个 “aaa” 字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用 str1，这样，str1 就指向了堆中创建的这个 “aaa” 字符串对象；如果没有，则首先在字符串常量池池中创建一个 “aaa” 字符串对象，然后再在堆中创建一个 “aaa” 字符串对象，然后将堆中这个 “aaa” 字符串对象的地址返回赋给 str1 引用，这样，str1 指向了堆中创建的这个 “aaa” 字符串对象。</p></blockquote><blockquote><p>对于上述的例子：因为，采用new关键字创建对象时，每次new出来的都是一个新的对象，也即是说引用str1和str2指向的是两个不同的对象，因此语句System.out.println(str1 &#x3D;&#x3D; str2)输出：false</p></blockquote><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab &#x3D; “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul><ol start="2"><li><strong>字符串拼接问题</strong></li></ol><p>（1）字符串变量拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">//拼接字符串对象来创建新的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b; </span><br><span class="line">        System.out.println(ab == ab2);  <span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过变量拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()<br>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p></blockquote><p>（2）字符串拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">//拼接字符串对象来创建新的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>; </span><br><span class="line">        System.out.println(ab == ab2);  <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接引用串池中的地址，所以进行的操作和 ab &#x3D; “ab” 一致。</p></blockquote><ol start="3"><li>i<strong>ntern方法</strong></li></ol><p>jdk1.8调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中，如果有则不会放入</p><blockquote><p>jdk1.6调用字符串对象的intern方法，会将该字符串对象复制一份放入到串池中，如果有则不会放入</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将串池引用指向堆，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">st2</span> <span class="operator">=</span> str.intern();</span><br><span class="line"><span class="comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class="line">        <span class="comment">// 注意：上面的结果是在1.8下，在1.6下都为false（字符串常量池和堆不是一个对象）</span></span><br><span class="line">System.out.println(str == st2);</span><br><span class="line">System.out.println(str == str3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>思考</li></ol><p>（1）String str &#x3D; new String(“abc”);创建了几个对象，常量池有abc字段是1个，常量池没有”abc”字段则是2个。<br>（2）String str&#x3D;“abc”;创建了几个对象（如果常量池里面已经有对象了就是0个。如果没有就是1个）;<br>（3）new String(“abc”).intern();创建了几个对象（如果常量池里面已经有该字符串对象了就是1个，如果没有就是两个）<br>（4）string a &#x3D; “a”+”b“创建几个对象？0个或1个。因为编译器优化，不会创建”a”或”b”.</p><h1 id="3、垃圾回收算法"><a href="#3、垃圾回收算法" class="headerlink" title="3、垃圾回收算法"></a>3、垃圾回收算法</h1><h2 id="3-1、如何判断一个对象可以被回收"><a href="#3-1、如何判断一个对象可以被回收" class="headerlink" title="3.1、如何判断一个对象可以被回收"></a>3.1、如何判断一个对象可以被回收</h2><ol><li>引用计数法</li></ol><p>每个对象关联一个引用计数器属性，任何一个对象引用了A，引用计数器的值加1.当引用失效时，引用计数器就减1.当引用计数器的值为0时，表示对象不再被使用，可进行回收</p><blockquote><p>缺点：（1）需要单独的字段存储计数器，这样增加了存储空间的开销 （2）每次赋值都要更新计数器值，增加了时间开销 （3）存在循环引用的问题（所以jvm不用）</p></blockquote><ol start="2"><li>可达性分析法</li></ol><p>设立若干根对象（GC Root Object），当任何一个根对象到某一个对象均不可达时，认为这个对象可以被回收</p><blockquote><p>哪些对象可以被作为根对象？</p><ul><li>虚拟机栈（Java Stack）中的局部变量和参数（它们是线程私有的，因此可以作为根对象）</li><li>方法区中静态变量常量（生命周期与应用程序的生命周期相同）</li></ul></blockquote><p>为什么这些对象可以作为根对象？</p><blockquote><p>GC Root 需要确保引用所指的对象都是活着的,而当前线程栈帧中的对象和方法区中的对象，在这一时刻是存活的。</p></blockquote><h2 id="3-2、五种引用"><a href="#3-2、五种引用" class="headerlink" title="3.2、五种引用"></a>3.2、五种引用</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222241216.png" alt="五种引用"></p><ol><li><strong>强引用</strong>：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它</li></ol><blockquote><p>在java程序中，一般由Object object &#x3D; new Object();定义的object就是一个强引用<br>如上图B、C对象都不引用A1对象时，A1对象才会被回收</p></blockquote><ol start="2"><li><strong>软引用</strong>：当GC Root指向软引用对象时，在内存不足时，会回收软引用所引用的对象</li></ol><blockquote><p>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收<br>作用：软引用是用来描述一些有用但并不是必需的对象，JVM 内存空间充足的时候将数据缓存在内存中，如果空间不足了就将其回收掉</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;456&quot;</span>);</span><br><span class="line">SoftReference&lt;String&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;String&gt;(str);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>弱引用</strong>：有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</li></ol><blockquote><p>如上图如果B对象不再引用A3对象，则A3对象会被回收</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eakReference&lt;String&gt; sr = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>));</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>虚引用</strong>：  虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列</li></ol><p>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。你声明虚引用的时候是要传入一个queue的。当你的虚引用所引用的对象已经执行完finalize函数的时候，就会把对象加到queue里面。你可以通过判断queue里面是不是有对象来判断你的对象是不是要被回收了</p><blockquote><p>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;String&gt; abcWeakRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;String&gt;(abc, referenceQueue);</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>引用强度</strong></li></ol><p>强引用&gt;软引用&gt;弱引用&gt;虚引用</p><h2 id="3-3、垃圾回收算法"><a href="#3-3、垃圾回收算法" class="headerlink" title="3.3、垃圾回收算法"></a>3.3、垃圾回收算法</h2><h3 id="3-3-1、标记清除算法"><a href="#3-3-1、标记清除算法" class="headerlink" title="3.3.1、标记清除算法"></a>3.3.1、标记清除算法</h3><ol><li>概念：通过根节点，标记所有根节点开始的可达对象，清除未被标记对象</li><li>优点：算法简单</li><li>缺点：（1）产生内存碎片，造成新来的大对象（如数组）可能没有有效的内存空间</li></ol><h3 id="3-3-2、标记整理算法（老年代默认）"><a href="#3-3-2、标记整理算法（老年代默认）" class="headerlink" title="3.3.2、标记整理算法（老年代默认）"></a>3.3.2、标记整理算法（老年代默认）</h3><ol><li>概念：将标记的对象移动到内存的一端，清除边界外的所有空间</li><li>优点：解决了标记清除算法的碎片问题</li><li>缺点：效率低（整理后依赖这个对象的对象更新一下引用地址信息）</li></ol><h3 id="3-3-3、复制算法（新生代默认）"><a href="#3-3-3、复制算法（新生代默认）" class="headerlink" title="3.3.3、复制算法（新生代默认）"></a>3.3.3、复制算法（新生代默认）</h3><ol><li>概念：将内存分为一块较大的Eden和两块较小的survivor，每次使用Eden和其中一块survivo,gc时将Eden存活对象复制到suvivorTo,suvivorFrom存活的对象没有达到分代年龄阈值时复制到suvivorTo，达到分带年龄阈值复制到老年区，之后清除Eden和suvivorFrom的对象,交换两个suvivor的角色,后面以此类推</li><li>优点：（1）不会产生内存碎片（2）在存活对象不多的情况下，效率较高，适合新生代</li><li>缺点：浪费内存空间，始终要有一个空闲的survivor</li></ol><h2 id="3-4、FULL-GC原因"><a href="#3-4、FULL-GC原因" class="headerlink" title="3.4、FULL GC原因"></a>3.4、FULL GC原因</h2><blockquote><p>Full GC为一次特殊GC行为的描述，这次GC会回收整个堆的内存，包含老年代，新生代，元空间等。是说在这次GC的全过程中所有用户线程都是处于暂停的状态（stop the world）</p></blockquote><ol><li><strong>System.gc()方法的调用</strong></li></ol><p>在代码中调用System.gc()方法会建议JVM进行Full GC，但是注意这只是建议，JVM执行不执行是另外一回事儿，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p><ol start="2"><li><strong>老年代空间不足</strong></li></ol><p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：java.lang.OutOfMemoryError: Java heap space</p><h2 id="3-5、内存溢出和内存泄漏"><a href="#3-5、内存溢出和内存泄漏" class="headerlink" title="3.5、内存溢出和内存泄漏"></a>3.5、内存溢出和内存泄漏</h2><p>内存溢出：是程序在申请内存时，没有足够的内存空间供其使用<br>内存泄漏：内存空间使用完毕之后未回收</p><p><strong>内存泄漏的原因？</strong><br>（1）static字段引起的内存泄露<br>大量使用static字段会潜在的导致内存泄露，在Java中，静态字段通常拥有与整个应用程序相匹配的生命周期。</p><blockquote><p>解决办法：最大限度的减少静态变量的使用；单例模式时，依赖于延迟加载对象而不是立即加载方式</p></blockquote><p>（2）未关闭的资源导致内存泄露<br>每当创建连接或者打开流时，JVM都会为这些资源分配内存。如果没有关闭连接，会导致持续占有内存。在任意情况下，资源留下的开放连接都会消耗内存，如果我们不处理，就会降低性能，甚至OOM。</p><blockquote><p>解决办法：使用finally块关闭资源；关闭资源的代码，不应该有异常；jdk1.7后，可以使用try-with-resource块</p></blockquote><h2 id="3-6、jvm对象何时会进入老年代"><a href="#3-6、jvm对象何时会进入老年代" class="headerlink" title="3.6、jvm对象何时会进入老年代"></a>3.6、jvm对象何时会进入老年代</h2><ol><li>达到晋升年龄：新生代对象在经历每次GC的时候，如果没有被回收，则对象的年龄+1。当年龄超过阈值的时候，便会进入老年代。默认情况下，阈值为15（为什么15？对象头年龄为4bit）</li><li>大对象直接进入老年代。比如 -XX:PretenureSizeThreshold &#x3D;1024，那么就表示超过1kb大小的对象在垃圾回收时直接进入到老年代（大对象：很长的字符串或数组）</li></ol><h1 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h1><h2 id="4-1、新生代垃圾收集器"><a href="#4-1、新生代垃圾收集器" class="headerlink" title="4.1、新生代垃圾收集器"></a>4.1、新生代垃圾收集器</h2><h3 id="4-1-1、Serial（串行）收集器"><a href="#4-1-1、Serial（串行）收集器" class="headerlink" title="4.1.1、Serial（串行）收集器"></a>4.1.1、Serial（串行）收集器</h3><ol><li><strong>概念</strong>：Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程</li></ol><blockquote><p>优点：简单高效，拥有很高的单线程收集效率<br>  缺点：收集过程需要暂停所有线程<br>  算法：复制算法应用</p></blockquote><ol start="2"><li><strong>收集过程</strong></li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242409.png" alt="image (23).png"></p><h3 id="4-1-2、ParNew-收集器"><a href="#4-1-2、ParNew-收集器" class="headerlink" title="4.1.2、ParNew 收集器"></a>4.1.2、ParNew 收集器</h3><ol><li><strong>概念：</strong>可以把这个收集器理解为Serial收集器的多线程版本</li></ol><blockquote><p>优点：在多CPU时，比Serial效率高。<br>  缺点：收集过程暂停所有应用程序线程，单CPU时比Serial效率差。<br>  算法：复制算法</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222242011.png" alt="image (24).png"></p><h3 id="4-1-3、Parallel-Scavenge-收集器"><a href="#4-1-3、Parallel-Scavenge-收集器" class="headerlink" title="4.1.3、Parallel Scavenge 收集器"></a>4.1.3、Parallel Scavenge 收集器</h3><ol><li><strong>概念</strong>：Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注系统的吞吐量 。</li><li><strong>可设置参数</strong>：-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间， -XX:GC Time Ratio直接设置吞吐量的大小</li></ol><blockquote><p>吞吐量 &#x3D; 运行用户代码的时间 &#x2F; (运行用户代码的时间 + 垃圾收集时间)<br>  比如虚拟机总共运行了120秒，垃圾收集时间用了1秒，吞吐量&#x3D;(120-1)&#x2F;120&#x3D;99.167%。<br>  若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序的运算任务。</p></blockquote><h2 id="4-2、老年代收集器"><a href="#4-2、老年代收集器" class="headerlink" title="4.2、老年代收集器"></a>4.2、老年代收集器</h2><h3 id="4-2-1、serial-old"><a href="#4-2-1、serial-old" class="headerlink" title="4.2.1、serial old"></a>4.2.1、serial old</h3><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用”标记-整理算法”，运行过程和Serial收集器一样。</p><h3 id="4-2-2、Parallel-old"><a href="#4-2-2、Parallel-old" class="headerlink" title="4.2.2、Parallel old"></a>4.2.2、Parallel old</h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理算法”进行垃圾回收，吞吐量优先。<br><strong>回收算法</strong>：标记-整理<br><strong>适用场景</strong>：为了替代serial old与Parallel Scanvenge配合使用。</p><h3 id="4-2-3、CMS"><a href="#4-2-3、CMS" class="headerlink" title="4.2.3、CMS"></a>4.2.3、CMS</h3><ol><li><p><strong>特点</strong>最短回收停顿时间，</p></li><li><p><strong>回收算法</strong>标记-清除</p></li><li><p><strong>回收步骤：</strong><br>（1）初始标记：标记GC Roots直接关联的对象，速度快<br>（2）并发标记：GC Roots Tracing过程，耗时长，与用户进程并发工作<br>（3）重新标记：修正并发标记期间用户进程运行而产生变化的标记，好事比初始标记长，但是远远小于并发标记<br>（4）并发清除：清除标记的对象</p></li><li><p><strong>缺点</strong>：</p><p> 对CPU资源非常敏感，CPU少于4个时，CMS岁用户程序的影响可能变得很大，由此虚拟机提供了“增量式并发收集器”；无法回收浮动垃圾；采用标记清除算法会产生内存碎片，不过可以通过参数开启内存碎片的合并整理。</p></li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222243378.png" alt="cms垃圾收集器"></p><h2 id="4-3、整堆收集器"><a href="#4-3、整堆收集器" class="headerlink" title="4.3、整堆收集器"></a>4.3、整堆收集器</h2><h3 id="4-3-1、G1"><a href="#4-3-1、G1" class="headerlink" title="4.3.1、G1"></a>4.3.1、G1</h3><ol><li><strong>基本概念</strong></li></ol><p>G1将整个JVM堆划分成多个大小相等的独立区域regin，跟踪各个regin里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收最大的regin，当然还保留有新生代和老年代的概念，但新生代和老年代不在是物理隔离了，他们都是一部分regin集合。内存“化整为零”的思路：在GC根节点的枚举范围汇总加入remembered set 即可保证不对全堆扫面也不会遗漏。</p><ol start="2"><li><strong>回收步骤</strong>：<br>（1）初始标记：标记GC Roots直接关联的对象<br>（2）并发标记：对堆中对象进行可达性分析，找出存活对象，耗时长，与用户进程并发工作<br>（3）重新标记：修正并发标记期间用户进程继续运行而产生变化的标记<br>（4）筛选回收：对各个regin的回收价值进行排序，然后根据期望的GC停顿时间制定回收计划</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310222244637.png" alt="G1垃圾收集器"></p><h3 id="4-3-2、ZGC"><a href="#4-3-2、ZGC" class="headerlink" title="4.3.2、ZGC"></a>4.3.2、ZGC</h3><p>ZGC（Z Garbage Collector）是一款由Oracle公司研发的，以低延迟为首要目标的一款垃圾收集器。<br>在JDK 11新加入，还在实验阶段，主要特点是：回收TB级内存（最大4T），停顿时间不超过10ms。<br><strong>优点</strong>：低停顿，高吞吐量，ZGC收集过程中额外耗费的内存小<br><strong>缺点</strong>：浮动垃圾<br>目前使用的非常少，真正普及还是需要写时间的。</p><h2 id="4-4、垃圾收集器的选择？"><a href="#4-4、垃圾收集器的选择？" class="headerlink" title="4.4、垃圾收集器的选择？"></a>4.4、垃圾收集器的选择？</h2><p>jdk1.8 前默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）<br>jdk1.9 默认垃圾收集器G1</p><ol><li>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选择串行收集器依然是合适的，这时候启用一些并行收集器没有任何收益</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数：-XX:+UseSerialGC。</span><br></pre></td></tr></table></figure><ol start="2"><li>如果你的应用是“吞吐量”优先的，并且对较长时间的停顿没有什么特别的要求。选择并行收集器是比较好的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">参数：-XX:+UseParallelGC。</span><br></pre></td></tr></table></figure><ol start="3"><li>如果你的应用对响应时间要求较高，想要较少的停顿。甚至 1 秒的停顿都会引起大量的请求失败，那么选择G1、ZGC、CMS都是合理的。虽然这些收集器的 GC 停顿通常都比较短，但它需要一些额外的资源去处理这些工作，通常吞吐量会低一些</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">-XX:+UseConcMarkSweepGC、</span><br><span class="line">-XX:+UseG1GC、</span><br><span class="line">-XX:+UseZGC 等。</span><br></pre></td></tr></table></figure><h1 id="5、类加载机制"><a href="#5、类加载机制" class="headerlink" title="5、类加载机制"></a>5、类加载机制</h1><p>虚拟机把类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型的过程就是虚拟机的类加载机制</p><h2 id="5-1、类加载过程"><a href="#5-1、类加载过程" class="headerlink" title="5.1、类加载过程"></a>5.1、类加载过程</h2><h3 id="5-1-1、加载阶段"><a href="#5-1-1、加载阶段" class="headerlink" title="5.1.1、加载阶段"></a>5.1.1、加载阶段</h3><p>（1）通过一个类的全限定名来获取定义此类的二进制字节流<br>（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><h3 id="5-1-2、链接阶段"><a href="#5-1-2、链接阶段" class="headerlink" title="5.1.2、链接阶段"></a>5.1.2、链接阶段</h3><p>（1）<strong>验证</strong>： 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p><blockquote><p><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，如：是否以模数0xCAFEBABE开头、主次版本号是否在当前虚拟机处理范围内等等。<br>  <strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求；如：这个类是否有父类，是否实现了父类的抽象方法，是否重写了父类的final方法，是否继承了被final修饰的类等等。<br>  <strong>符号引用验证</strong>：确保解析动作能正确执行；如：通过符合引用能找到对应的类和方法，符号引用中类、属性、方法的访问性是否能被当前类访问等等<br>（验证阶段是非常重要的，但不是必须的。可以采用-Xverify:none参数来关闭大部分的类验证措施）</p></blockquote><p>（2）<strong>准备</strong>：为类的静态变量分配内存，并将其赋默认值</p><blockquote><p>为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：<br>只对<strong>static</strong>修饰的静态变量进行内存分配、赋默认值（如0、0L、null、false等）。<br>对<strong>final</strong>的静态字面值常量直接赋初值（赋初值不是赋默认值，如果不是字面值静态常量，那么会和静态变量一样赋默认值）</p></blockquote><p>（3）<strong>解析</strong>：将常量池中的符号引用替换为直接引用（内存地址）的过程</p><blockquote><p>符号引用：就是一组符号来描述目标，可以是任何字面量。属于编译原理方面的概念如：包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符（eg:java.lang.String）。<br>  直接引用：就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。如指向方法区某个类的一个指针</p></blockquote><h3 id="5-1-3、初始化阶段"><a href="#5-1-3、初始化阶段" class="headerlink" title="5.1.3、初始化阶段"></a>5.1.3、初始化阶段</h3><p>为类的静态变量赋初值</p><blockquote><p>赋初值两种方式：<br>（1）定义静态变量时指定初始值。如 private static String x&#x3D;”123”;<br>（2）在静态代码块里为静态变量赋值。如 static{ x&#x3D;”123”; }<br> 注意：只有对类的主动使用才会导致类的初始化。</p></blockquote><p><strong>初始化顺序：</strong><br>初始化顺序：静态成员 - 父类构造器 - 非静态成员 - 子类构造器</p><h2 id="5-2、类加载器分类"><a href="#5-2、类加载器分类" class="headerlink" title="5.2、类加载器分类"></a>5.2、类加载器分类</h2><ol><li><strong>启动类加载器</strong></li></ol><p>使用c++实现，加载jre和jre&#x2F;lib目录下的核心库</p><ol start="2"><li><strong>扩展类加载器</strong></li></ol><p>java编写，父加载器为启动类加载器，从jre&#x2F;lib&#x2F;ext下加载类库</p><ol start="3"><li><strong>应用类加载器</strong></li></ol><p>负责加载用户类路径（classpath）上的指定类库</p><h2 id="5-3、双亲委派机制"><a href="#5-3、双亲委派机制" class="headerlink" title="5.3、双亲委派机制"></a>5.3、双亲委派机制</h2><p>概念：<br>当某个类加载器需要加载某个.class文件时，它首先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，自己才会去加载这个类</p><p>好处：<br>（1）避免重复加载，通过委托去向上面问一问，加载过了，就不用再加载一遍<br>（2）保证核心api定义的类型不会被随意篡改，比如自己定义一个java.lang.String，顶级加载器系统类加载器加载时会加载核心包下的String类而不是自定义的。保证了核心类的安全</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311010834246.png" alt="双亲委派机制"></p><h1 id="6、逃逸分析"><a href="#6、逃逸分析" class="headerlink" title="6、逃逸分析"></a>6、逃逸分析</h1><p>逃逸分析（Escape Analysis）是编译器优化的一种技术，用于确定对象的生命周期和作用域，以便更好地进行优化。</p><h2 id="6-1、逃逸方式"><a href="#6-1、逃逸方式" class="headerlink" title="6.1、逃逸方式"></a>6.1、逃逸方式</h2><p>方法逃逸（Method Escape）：对象在方法中创建后被返回，逃逸到方法的调用者中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">createList</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">1</span>);</span><br><span class="line">        list.add(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> list;  <span class="comment">// 对象在方法中创建后逃逸到方法的调用者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程逃逸（Thread Escape）：对象在一个线程中创建后，被其他线程所引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  <span class="comment">// 对象在一个线程中创建后逃逸到其他线程</span></span><br><span class="line">            list.add(<span class="number">1</span>);</span><br><span class="line">            list.add(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 在这里访问list...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2、逃逸结果"><a href="#6-2、逃逸结果" class="headerlink" title="6.2、逃逸结果"></a>6.2、逃逸结果</h2><p>(1)栈上分配<br>逃逸分析的主要目的是减少内存分配的开销和垃圾回收的压力。当对象被分配在栈上时，它的分配和回收都非常高效，因为它们可以通过简单的指针移动来完成。而在堆上分配的对象则需要进行动态内存分配和垃圾回收，这会产生额外的开销（栈上分配）</p><p>(2)标量替换　　<br>Java虚拟机中的原始数据类型（int，long等数值类型以及reference类型等）都不能再进一步分解，它们可以称为标量。相对的，如果一个数据可以继续分解，那它称为聚合量，Java中最典型的聚合量是对象。如果逃逸分析证明一个对象不会被外部访问，并且这个对象是可分解的，那程序真正执行的时候将不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。拆散后的变量便可以被单独分析与优化，可以各自分别在栈帧或寄存器上分配空间，原本的对象就无需整体分配空间了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标量替换举例</span></span><br><span class="line"><span class="comment">//如果逃逸分析确定`createPoint()`方法中创建的`Point`对象不会逃逸出该方法，就可以进行标量替换优化。即将`Point`对象拆分为其两个字段的独立局部变量，而不是作为一个对象分配在堆上.在优化后的代码中，`Point`对象被替换为两个独立的局部变量`x`和`y`，并直接在栈上分配。这样可以避免了对象的内存分配和字段访问的开销，从而提高了程序的性能。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplacementExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> createPoint(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> calculateSum(point);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Point <span class="title function_">createPoint</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">        point.x = x;</span><br><span class="line">        point.y = y;</span><br><span class="line">        <span class="keyword">return</span> point;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSum</span><span class="params">(Point point)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> point.x + point.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScalarReplacementExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> calculateSum(x, y);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sum: &quot;</span> + sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateSum</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mqtt</title>
      <link href="/posts/36971.html"/>
      <url>/posts/36971.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><p>MQTT 可以简单看做一个网络协议，用于机器对机器的通信（与客户端到服务器的传输有点区别）。智能传感器、可穿戴设备和其他物联网（IoT）设备通常必须通过带宽有限的资源受限网络传输和接收数据。这些物联网设备使用 MQTT 进行数据传输，因为它易于实施，并且可以有效地传输物联网数据。MQTT 支持设备到云端和云端到设备之间的消息传递。</p><h2 id="1-1、特点"><a href="#1-1、特点" class="headerlink" title="1.1、特点"></a>1.1、特点</h2><ol><li><p>轻量级：MQTT协议是一种轻量级的协议，它的开销非常小，可以在低带宽、不稳定的网络环境下运行。</p></li><li><p>灵活性：双向通信，MQTT协议支持多种消息传输模式，包括点对点、发布&#x2F;订阅和请求&#x2F;响应等模式，可以根据不同的应用场景选择合适的模式。</p></li><li><p>可靠性：MQTT协议支持QoS（服务质量）等级，可以确保消息的可靠传输，同时还支持消息持久化和重传机制，保证消息不会丢失。</p></li><li><p>易于集成：MQTT协议可以与各种不同的平台和设备集成，包括传感器、嵌入式设备、移动设备和云平台等，可以实现跨平台、跨设备的通信。</p></li><li><p>安全性：MQTT协议支持TLS&#x2F;SSL加密和认证机制，可以保证消息的安全传输和身份验证，防止数据泄露和攻击。</p></li></ol><h2 id="1-2、mqtt为什么比ampq轻量"><a href="#1-2、mqtt为什么比ampq轻量" class="headerlink" title="1.2、mqtt为什么比ampq轻量"></a>1.2、mqtt为什么比ampq轻量</h2><ol><li><p>较低的带宽和资源消耗：MQTT使用更紧凑的消息头和较少的协议开销，这使得它在网络带宽有限或资源受限的环境下表现更好。它使用较小的消息包大小和更少的网络往返次数，减少了传输延迟和网络负载</p></li><li><p>适用于低功耗设备：由于MQTT的设计目标是针对低带宽、不稳定网络和低功耗设备（如传感器和物联网设备），它采用了一些优化策略，如保持TCP连接的持久性、支持消息压缩和QoS级别控制等。这些特性使得MQTT成为物联网领域的首选协议</p></li></ol><h1 id="2、三种服务质量"><a href="#2、三种服务质量" class="headerlink" title="2、三种服务质量"></a>2、三种服务质量</h1><h2 id="2-1、QoS-0：最多一次传递"><a href="#2-1、QoS-0：最多一次传递" class="headerlink" title="2.1、QoS 0：最多一次传递"></a>2.1、QoS 0：最多一次传递</h2><p>在QoS 0级别下，发布者只需将消息发送给MQTT代理，代理会将消息发送给订阅者，但不会保证消息是否到达订阅者。这种级别的实现非常简单，因为不需要进行确认或重传，所以消息传递的延迟和带宽占用都很低</p><p>通常选择使用 QoS 0 传输一些高频且不那么重要的数据，比如传感器数据，周期性更新，即使遗漏几个周期的数据也可以接受</p><h2 id="2-2、QoS-1：最少一次传递"><a href="#2-2、QoS-1：最少一次传递" class="headerlink" title="2.2、QoS 1：最少一次传递"></a>2.2、QoS 1：最少一次传递</h2><p>在QoS 1级别下，发布者将消息发送给MQTT代理，代理会将消息发送给订阅者，并等待订阅者的确认。如果代理没有收到确认，它会<strong>重新发送消息，直到收到确认为止</strong>。这种级别的实现需要进行确认和重传，所以消息传递的延迟和带宽占用都比QoS 0高</p><blockquote><p>QoS1在协议层面上无法避免消息重复的情况，因此在我们的报文内容里面通常加上报文的唯一id，在应用层通过id去对消息去重是最常规的处理方法</p></blockquote><h2 id="2-3、QoS-2：恰好一次传递"><a href="#2-3、QoS-2：恰好一次传递" class="headerlink" title="2.3、QoS 2：恰好一次传递"></a>2.3、QoS 2：恰好一次传递</h2><blockquote><p>MQTT识别报文是通过一个Packet ID来识别是不是重复信息。Qos1收到两条相同Packet ID报文的消息是没办法知道这是重复的信息，还是两条不同的消息只是用的同一个ID的情况，因此Qos1是存在重复消息的问题。QoS2会用更加复杂的交互逻辑来确保消息不会重复</p></blockquote><blockquote><p>发送方发送完报文，需要等待收到接收方发送PUBREC报文（在这期间还可以超时重发这个报文），等到收到PUBREC报文后，发送方会继续发送PUBREL （Publish Release）报文，此时不能再重发报文了，并且Packet ID也不能使用。等待收到对端回复的 PUBCOMP 报文后，才表示此时Packet ID被释放完成，可以继续使用Packet ID去发送消息。因此对于接</p><p>收方以 PUBREL 报文为界限，凡是在 PUBREL 报文之前到达的 PUBLISH 报文，有相同的Packet ID都必然是重复的消息；而凡是在 PUBREL 报文之后到达的 PUBLISH 报文，有相同的Packet ID都必然是全新的消息。</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310171035585.png" alt="image.png"></p><p>在QoS 2级别下，发布者将消息发送给MQTT代理，代理会将消息发送给订阅者，并等待订阅者的确认。如果代理没有收到确认，它会重新发送消息，直到收到确认为止。订阅者收到消息后，会发送确认给代理，代理再将确认发送给发布者。如果代理没有收到确认，它会重新发送消息，直到收到确认为止。这种级别的实现需要进行确认、重传和去重，所以消息传递的延迟和带宽占用都比QoS 1更高。</p><p>总的来说，QoS级别越高，消息传递的可靠性越高，但延迟和带宽占用也越高。在选择QoS级别时，需要根据应用场景的需求来进行权衡。</p><h1 id="3、消息可靠（持久化）"><a href="#3、消息可靠（持久化）" class="headerlink" title="3、消息可靠（持久化）"></a>3、消息可靠（持久化）</h1><p>MQTT还有一个持久会话的功能，对应的是Clean Session（清理会话）选项。当Clean Session &#x3D; 0，以及QoS为1或着2的时候，加入接收端离线了也会在下次在线时收到断连期间的消息。此时的消息会暂存在我们的MQTT服务器端</p><h1 id="4、mqtt负载均衡"><a href="#4、mqtt负载均衡" class="headerlink" title="4、mqtt负载均衡"></a>4、mqtt负载均衡</h1>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> 消息队列 </tag>
            
            <tag> mqtt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro</title>
      <link href="/posts/15277.html"/>
      <url>/posts/15277.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、shiro基本概念"><a href="#1、shiro基本概念" class="headerlink" title="1、shiro基本概念"></a>1、shiro基本概念</h1><p>Shiro是Apache组织下的一个开源的安全框架，常常用来做：安全认证、权限管理、会话管理、加密</p><h2 id="1-1、安全认证"><a href="#1-1、安全认证" class="headerlink" title="1.1、安全认证"></a>1.1、安全认证</h2><p>可用于验证用户的身份凭证，如用户名和密码。通过配置 Shiro 的 Realm（领域）来自定义身份验证的逻辑，通过 Subject 对象进行身份验证，可以获取用户的身份信息和执行相关操作</p><h2 id="1-2、权限管理"><a href="#1-2、权限管理" class="headerlink" title="1.2、权限管理"></a>1.2、权限管理</h2><p>可以通过配置 Shiro 的 Realm 来定义用户的角色和权限信息，或者使用注解方式进行权限控制。通过 Subject 对象进行权限检查，可以判断用户是否具有某个角色或权限，并根据结果进行相应的处理</p><h2 id="1-3、会话管理"><a href="#1-3、会话管理" class="headerlink" title="1.3、会话管理"></a>1.3、会话管理</h2><p>shiro 提供了会话管理的功能，用于跟踪用户的登录状态和管理用户的会话信息。Shiro 的会话管理可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理（redis等）</p><h2 id="1-4、加密"><a href="#1-4、加密" class="headerlink" title="1.4、加密"></a>1.4、加密</h2><p>对密码进行加密和解密操作，以保护用户的密码安全。Shiro 支持常用的加密算法，如MD5、SHA、AES等。你可以根据需求选择适当的加密算法进行使用</p><h1 id="2、shiro架构"><a href="#2、shiro架构" class="headerlink" title="2、shiro架构"></a>2、shiro架构</h1><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309131118959.jpg" alt="shiro"></p><h2 id="2-1、主体（Subject）"><a href="#2-1、主体（Subject）" class="headerlink" title="2.1、主体（Subject）"></a>2.1、主体（Subject）</h2><p>Subject即主体，外部应用与subject进行交互，subject记录了当前操作用户，将用户的概念理解为当前操作的主体，可能是一个通过浏览器请求的用户，也可能是一个运行的程序。Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权</p><h2 id="2-2、安全管理器（Security-Manager）"><a href="#2-2、安全管理器（Security-Manager）" class="headerlink" title="2.2、安全管理器（Security Manager）"></a>2.2、安全管理器（Security Manager）</h2><p>SecurityManager即安全管理器，对全部的subject进行安全管理，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，实质上SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。<br>SecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口</p><h2 id="2-3、认证器（Authenticator）"><a href="#2-3、认证器（Authenticator）" class="headerlink" title="2.3、认证器（Authenticator）"></a>2.3、认证器（Authenticator）</h2><p>Authenticator即认证器，对用户身份进行认证，Authenticator是一个接口，shiro提供ModularRealmAuthenticator实现类，通过ModularRealmAuthenticator基本上可以满足大多数需求，也可以自定义认证器</p><h2 id="2-4、授权器（Authorizer）"><a href="#2-4、授权器（Authorizer）" class="headerlink" title="2.4、授权器（Authorizer）"></a>2.4、授权器（Authorizer）</h2><p>Authorizer即授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限</p><h2 id="2-5、领域（Realm）"><a href="#2-5、领域（Realm）" class="headerlink" title="2.5、领域（Realm）"></a>2.5、领域（Realm）</h2><p>Realm即领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据，比如：如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。</p><blockquote><p>注意：不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。</p></blockquote><h2 id="2-6、会话管理器（SessionManager）"><a href="#2-6、会话管理器（SessionManager）" class="headerlink" title="2.6、会话管理器（SessionManager）"></a>2.6、会话管理器（SessionManager）</h2><p>会话管理器负责管理主体的会话，跟踪用户的登录状态和管理会话数据。<br>在 Shiro 中，会话管理器可以基于 Web 容器的 HttpSession，也可以使用自己的非 Web 环境会话管理</p><h1 id="3、认证"><a href="#3、认证" class="headerlink" title="3、认证"></a>3、认证</h1><p>在shiro中,用户需要提供principlas(身份)和credentials(证明)给shiro，从而应用能验证用户身份</p><h2 id="3-1、认证流程"><a href="#3-1、认证流程" class="headerlink" title="3.1、认证流程"></a>3.1、认证流程</h2><ol><li>提交身份凭证：用户在应用程序的登录页面或其他身份验证入口提交身份和凭证，例如用户名和密码</li><li>创建 Subject 对象：应用程序根据用户提交的身份凭证创建一个 Subject 对象，代表当前与应用程序交互的用户</li><li>提交身份凭证给认证器：Subject 对象将身份凭证提交给 Shiro 的认证器（Authenticator）进行验证</li><li>认证器验证身份凭证：认证器对身份凭证进行验证，通常是通过比对凭证与存储在数据源中的用户信息进行匹配。认证器可以使用一个或多个 Realm 来获取用户信息并进行验证。Realm 对获取到的用户信息与提交的身份凭证进行比对验证，判断凭证是否有效</li><li>结果处理：如果身份验证成功，认证器将成功的身份信息存储在 Subject 对象中，以便后续使用</li></ol><h2 id="3-2、认证实现"><a href="#3-2、认证实现" class="headerlink" title="3.2、认证实现"></a>3.2、认证实现</h2><h3 id="3-2-1、自定义Realm"><a href="#3-2-1、自定义Realm" class="headerlink" title="3.2.1、自定义Realm"></a>3.2.1、自定义Realm</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Realm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerRealm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==================&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">        <span class="comment">//在token中获取 用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">principal</span> <span class="operator">=</span> (String) token.getPrincipal();</span><br><span class="line">        System.out.println(principal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实际开发中应当 根据身份信息使用jdbc mybatis查询相关数据库</span></span><br><span class="line">        <span class="comment">//在这里只做简单的演示</span></span><br><span class="line">        <span class="comment">//假设username,password是从数据库获得的信息</span></span><br><span class="line">        String username=<span class="string">&quot;zhangsan&quot;</span>;</span><br><span class="line">        String password=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(username.equals(principal))&#123;</span><br><span class="line">            <span class="comment">//参数1:返回数据库中正确的用户名</span></span><br><span class="line">            <span class="comment">//参数2:返回数据库中正确密码</span></span><br><span class="line">            <span class="comment">//参数3:提供当前realm的名字 this.getName();</span></span><br><span class="line">            <span class="type">SimpleAuthenticationInfo</span> <span class="variable">simpleAuthenticationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthenticationInfo</span>(principal,password,<span class="built_in">this</span>.getName());</span><br><span class="line">            <span class="keyword">return</span> simpleAuthenticationInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2、用定义的Realm进行认证"><a href="#3-2-2、用定义的Realm进行认证" class="headerlink" title="3.2.2、用定义的Realm进行认证"></a>3.2.2、用定义的Realm进行认证</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试自定义的Realm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAuthenticatorCusttomerRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建安全管理对象 securityManager</span></span><br><span class="line">        <span class="type">DefaultSecurityManager</span> <span class="variable">defaultSecurityManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSecurityManager</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.给安全管理器设置realm（设置为自定义realm获取认证数据）</span></span><br><span class="line">        defaultSecurityManager.setRealm(<span class="keyword">new</span> <span class="title class_">CustomerRealm</span>());</span><br><span class="line">        <span class="comment">//IniRealm realm = new IniRealm(&quot;classpath:shiro.ini&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.给安装工具类中设置默认安全管理器</span></span><br><span class="line">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.获取主体对象subject</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.创建token令牌</span></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            subject.login(token);<span class="comment">//用户登录</span></span><br><span class="line">            System.out.println(<span class="string">&quot;登录成功~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownAccountException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;用户名错误!!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IncorrectCredentialsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;密码错误!!!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、授权"><a href="#4、授权" class="headerlink" title="4、授权"></a>4、授权</h1><h2 id="4-1、授权流程"><a href="#4-1、授权流程" class="headerlink" title="4.1、授权流程"></a>4.1、授权流程</h2><p>认证成功后，Shiro会将用户的身份信息保存在Subject对象中。一旦用户通过认证，就可以进行授权操作。授权是基于用户的身份和角色进行的，用于确定用户是否有权进行特定的操作或访问特定的资源。Shiro提供了基于角色的访问控制（Role-Based Access Control）和基于权限的访问控制（Permission-Based Access Control）两种授权方式。授权的核心是Realm。Realm是用于获取安全数据的组件</p><ol><li>用户发起访问请求。</li><li>Shiro的Subject对象获取当前用户的身份信息，并创建相应的Principal对象。</li><li>Subject将Principal对象传递给SecurityManager进行授权操作。</li><li>SecurityManager委托Realm获取用户的角色和权限信息。</li><li>Realm根据Principal对象从数据源（如数据库）中获取用户的角色和权限信息。</li><li>Realm将获取的角色和权限信息返回给SecurityManager。</li><li>SecurityManager根据获取的角色和权限信息进行授权判断，确定用户是否有权访问资源。</li><li>根据授权结果，SecurityManager返回授权成功或失败的结果给Subject对象。</li><li>Subject根据授权结果执行相应的操作，允许或拒绝用户访问受限资源。</li></ol><h2 id="4-2、授权方式"><a href="#4-2、授权方式" class="headerlink" title="4.2、授权方式"></a>4.2、授权方式</h2><h3 id="4-2-1、基于角色的访问控制"><a href="#4-2-1、基于角色的访问控制" class="headerlink" title="4.2.1、基于角色的访问控制"></a>4.2.1、基于角色的访问控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(subject.hasRole(<span class="string">&quot;admin&quot;</span>))&#123;</span><br><span class="line">   <span class="comment">//操作什么资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2、基于资源的访问控制"><a href="#4-2-2、基于资源的访问控制" class="headerlink" title="4.2.2、基于资源的访问控制"></a>4.2.2、基于资源的访问控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(subject.isPermission(<span class="string">&quot;user:update:01&quot;</span>))&#123; <span class="comment">//资源实例</span></span><br><span class="line">  <span class="comment">//对资源01用户具有修改的权限</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(subject.isPermission(<span class="string">&quot;user:update:*&quot;</span>))&#123;  <span class="comment">//资源类型</span></span><br><span class="line">  <span class="comment">//对 所有的资源 用户具有更新的权限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>权限字符串的规则是：资源标识符：操作：资源实例标识符，意思是对哪个资源的哪个实例具有什么操作，“:”是资源&#x2F;操作&#x2F;实例的分割符，权限字符串也可以使用<em>通配符<br>用户创建权限：user:create，或user:create:</em><br> 用户修改实例001的权限：user:update:001<br> 用户实例001的所有权限：user:*：001</p></blockquote><h2 id="4-3、授权实现"><a href="#4-3、授权实现" class="headerlink" title="4.3、授权实现"></a>4.3、授权实现</h2><h3 id="4-3-1、定义Reaml"><a href="#4-3-1、定义Reaml" class="headerlink" title="4.3.1、定义Reaml"></a>4.3.1、定义Reaml</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用自定义realm</span></span><br><span class="line"><span class="comment"> * 实现授权操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerMd5Realm</span> <span class="keyword">extends</span> <span class="title class_">AuthorizingRealm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthorizationInfo <span class="title function_">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">primaryPrincipal</span> <span class="operator">=</span> (String)principals.getPrimaryPrincipal();</span><br><span class="line">        System.out.println(<span class="string">&quot;身份信息: &quot;</span>+primaryPrincipal); <span class="comment">//用户名</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据身份信息 用户名 获取当前用户的角色信息，以及权限信息</span></span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> <span class="variable">simpleAuthorizationInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleAuthorizationInfo</span>();</span><br><span class="line">        <span class="comment">//假设 admin,user 是从数据库查到的 角色信息</span></span><br><span class="line">        simpleAuthorizationInfo.addRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        simpleAuthorizationInfo.addRole(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">//假设 ... 是从数据库查到的 权限信息赋值给权限对象</span></span><br><span class="line">        simpleAuthorizationInfo.addStringPermission(<span class="string">&quot;user:*:01&quot;</span>);</span><br><span class="line">        simpleAuthorizationInfo.addStringPermission(<span class="string">&quot;prodect:*&quot;</span>);<span class="comment">//第三个参数为*省略</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> AuthenticationInfo <span class="title function_">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-2、授权"><a href="#4-3-2、授权" class="headerlink" title="4.3.2、授权"></a>4.3.2、授权</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCustomerMd5RealmAuthenicator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//授权</span></span><br><span class="line">        <span class="keyword">if</span> (subject.isAuthenticated())&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于角色权限控制</span></span><br><span class="line">            System.out.println(subject.hasRole(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">            <span class="comment">//基于多角色的权限控制</span></span><br><span class="line">            System.out.println(subject.hasAllRoles(Arrays.asList(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;user&quot;</span>)));<span class="comment">//true</span></span><br><span class="line">            System.out.println(subject.hasAllRoles(Arrays.asList(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;manager&quot;</span>)));<span class="comment">//false</span></span><br><span class="line">            <span class="comment">//是否具有其中一个角色</span></span><br><span class="line">            <span class="type">boolean</span>[] booleans = subject.hasRoles(Arrays.asList(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;user&quot;</span>, <span class="string">&quot;manager&quot;</span>));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">boolean</span> aBoolean : booleans) &#123;</span><br><span class="line">                System.out.println(aBoolean);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;====这是一个分隔符====&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//基于权限字符串的访问控制  资源标识符：操作：资源类型</span></span><br><span class="line">            <span class="comment">//用户具有的权限 user:*:01  prodect:*</span></span><br><span class="line">            System.out.println(<span class="string">&quot;权限:&quot;</span>+subject.isPermitted(<span class="string">&quot;user:update:01&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;权限:&quot;</span>+subject.isPermitted(<span class="string">&quot;prodect:update:02&quot;</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分别具有哪些权限</span></span><br><span class="line">            <span class="type">boolean</span>[] permitted = subject.isPermitted(<span class="string">&quot;user:*:01&quot;</span>, <span class="string">&quot;user:update:02&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">boolean</span> b : permitted) &#123;</span><br><span class="line">                System.out.println(b);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同时具有哪些权限</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">permittedAll</span> <span class="operator">=</span> subject.isPermittedAll(<span class="string">&quot;prodect:*:01&quot;</span>, <span class="string">&quot;prodect:update:03&quot;</span>);</span><br><span class="line">            System.out.println(permittedAll);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5、会话管理（cacheManager）"><a href="#5、会话管理（cacheManager）" class="headerlink" title="5、会话管理（cacheManager）"></a>5、会话管理（cacheManager）</h1><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309141528819.png" alt="shiro会话管理"></p><h2 id="5-1、shiro会话管理实现-EhCache"><a href="#5-1、shiro会话管理实现-EhCache" class="headerlink" title="5.1、shiro会话管理实现(EhCache)"></a>5.1、shiro会话管理实现(EhCache)</h2><h3 id="5-1-1、引入依赖"><a href="#5-1-1、引入依赖" class="headerlink" title="5.1.1、引入依赖"></a>5.1.1、引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入shiro和ehcache--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="5-1-2、开启缓存"><a href="#5-1-2、开启缓存" class="headerlink" title="5.1.2、开启缓存"></a>5.1.2、开启缓存</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.创建自定义realm</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Realm <span class="title function_">getRealm</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">CustomerRealm</span> <span class="variable">customerRealm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CustomerRealm</span>();</span><br><span class="line">    <span class="comment">//修改凭证校验匹配器</span></span><br><span class="line">    <span class="type">HashedCredentialsMatcher</span> <span class="variable">credentialsMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashedCredentialsMatcher</span>();</span><br><span class="line">    <span class="comment">//设置加密算法为md5</span></span><br><span class="line">    credentialsMatcher.setHashAlgorithmName(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">    <span class="comment">//设置散列次数</span></span><br><span class="line">    credentialsMatcher.setHashIterations(<span class="number">1024</span>);</span><br><span class="line">    customerRealm.setCredentialsMatcher(credentialsMatcher);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开启缓存管理器</span></span><br><span class="line">    customerRealm.setCachingEnabled(<span class="literal">true</span>);</span><br><span class="line">    customerRealm.setAuthorizationCachingEnabled(<span class="literal">true</span>);</span><br><span class="line">    customerRealm.setAuthorizationCachingEnabled(<span class="literal">true</span>);</span><br><span class="line">    customerRealm.setCacheManager(<span class="keyword">new</span> <span class="title class_">EhCacheManager</span>());</span><br><span class="line">    <span class="keyword">return</span> customerRealm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、springboot整合shiro"><a href="#6、springboot整合shiro" class="headerlink" title="6、springboot整合shiro"></a>6、springboot整合shiro</h1><h2 id="6-1、引入依赖"><a href="#6-1、引入依赖" class="headerlink" title="6.1、引入依赖"></a>6.1、引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--增加Shiro的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shiro<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shiro-spring-boot-web-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Thymeleaf模板引擎--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在Thymeleaf中使用shiro标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.theborakompanioni<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>thymeleaf-extras-shiro<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-2、配置文件"><a href="#6-2、配置文件" class="headerlink" title="6.2、配置文件"></a>6.2、配置文件</h2><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启Shiro配置，默认为true</span></span><br><span class="line"><span class="attr">shiro.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#开启ShiroWeb配置，默认为true</span></span><br><span class="line"><span class="attr">shiro.web.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#登录地址</span></span><br><span class="line"><span class="attr">shiro.loginUrl</span>=<span class="string">/login</span></span><br><span class="line"><span class="comment">#登录成功地址</span></span><br><span class="line"><span class="attr">shiro.successUrl</span>=<span class="string">/index</span></span><br><span class="line"><span class="comment">#未获授权默认跳转地址</span></span><br><span class="line"><span class="attr">shiro.unauthorizedUrl</span>=<span class="string">/unauthorized</span></span><br><span class="line"><span class="comment">#允许通过URL参数实现会话跟踪，如果网站支持Cookie，可以关闭这个选项。默认为true</span></span><br><span class="line"><span class="attr">shiro.sessionManager.sessionIdUrlRewritingEnabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#是否允许通过Cookie实现会话跟踪，默认为true</span></span><br><span class="line"><span class="attr">shiro.sessionManager.sessionIdCookieEnabled</span>=<span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-3、配置类"><a href="#6-3、配置类" class="headerlink" title="6.3、配置类"></a>6.3、配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShiroConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义Realm</span></span><br><span class="line"><span class="comment">     * 直接配置了两个用户</span></span><br><span class="line"><span class="comment">     * nihiu=123</span></span><br><span class="line"><span class="comment">     * admin=123</span></span><br><span class="line"><span class="comment">     * 角色分别对应user和admin两个角色</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Realm <span class="title function_">realm</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">TextConfigurationRealm</span> <span class="variable">realm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextConfigurationRealm</span>();</span><br><span class="line">        realm.setUserDefinitions(<span class="string">&quot;nihui=123,user</span></span><br><span class="line"><span class="string"> admin=123,admin&quot;</span>);</span><br><span class="line">        realm.setRoleDefinitions(<span class="string">&quot;admin=read,write</span></span><br><span class="line"><span class="string"> user=read&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> realm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ShiroFilterChainDefinition</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroFilterChainDefinition <span class="title function_">shiroFilterChainDefinition</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DefaultShiroFilterChainDefinition</span> <span class="variable">chainDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultShiroFilterChainDefinition</span>();</span><br><span class="line">        chainDefinition.addPathDefinition(<span class="string">&quot;/login&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        chainDefinition.addPathDefinition(<span class="string">&quot;/doLogin&quot;</span>,<span class="string">&quot;anon&quot;</span>);</span><br><span class="line">        chainDefinition.addPathDefinition(<span class="string">&quot;logout&quot;</span>,<span class="string">&quot;logout&quot;</span>);</span><br><span class="line">        chainDefinition.addPathDefinition(<span class="string">&quot;/**&quot;</span>,<span class="string">&quot;authc&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> chainDefinition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个在Thymeleaf中支持Shiro标签。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ShiroDialect <span class="title function_">shiroDialect</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShiroDialect</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4、登录接口控制类"><a href="#6-4、登录接口控制类" class="headerlink" title="6.4、登录接口控制类"></a>6.4、登录接口控制类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/doLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLogin</span><span class="params">(String username, String password, Model model)</span>&#123;</span><br><span class="line">        <span class="comment">//构造一个UsernamePasswordToken实例获取</span></span><br><span class="line">        <span class="type">UsernamePasswordToken</span> <span class="variable">token</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordToken</span>(username,password);</span><br><span class="line">        <span class="comment">//获取Subject对象访问login方法当有异常的时候抛出异常</span></span><br><span class="line">        <span class="type">Subject</span> <span class="variable">subject</span> <span class="operator">=</span> SecurityUtils.getSubject();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (AuthenticationException e)&#123;</span><br><span class="line">            model.addAttribute(<span class="string">&quot;error&quot;</span>,<span class="string">&quot;用户名密码输入错误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequiresRoles(&quot;admin&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/admin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequiresRoles(value = &#123;&quot;admin&quot;,&quot;user&quot;&#125;,logical = Logical.OR)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;user&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5、编写页面代码"><a href="#6-5、编写页面代码" class="headerlink" title="6.5、编写页面代码"></a>6.5、编写页面代码</h2><p>在对应的目录下面建立五个页面分别表示用户登录页面、首页、用户页面、管理员页面、认证错误页面</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> shiro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>thymeleaf</title>
      <link href="/posts/2904.html"/>
      <url>/posts/2904.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>Thymeleaf 是一个服务器端 Java 模板引擎，能够处理 HTML、XML、CSS、JAVASCRIPT 等模板文件。Thymeleaf 模板可以直接当作静态原型来使用，它主要目标是为开发者的开发工作流程带来优雅的自然模板，也是 Java 服务器端 HTML5 开发的理想选择</p><h1 id="2-创建模板文件"><a href="#2-创建模板文件" class="headerlink" title="2. 创建模板文件"></a>2. 创建模板文件</h1><p>创建一个html模板文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Index Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span>Welcome to BeiJing!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><!DOCTYPE HTML> ：声明文档的解析类型(document.compatMode)，使用标准模式渲染页面，避免浏览器的怪异模式 (浏览器使用自己的怪异模式解析渲染页面).</li></ol><blockquote><p>标准模式，浏览器使用W3C的标准解析渲染页面</p></blockquote><ol start="2"><li><html xmlns:th="[http://www.thymeleaf.org](http://www.thymeleaf.org)">: 引入 Thymeleaf 命名空间 (xmlns 属性规定文档的 xml 命名空间)</li></ol><h1 id="3、标准表达式语法"><a href="#3、标准表达式语法" class="headerlink" title="3、标准表达式语法"></a>3、标准表达式语法</h1><p>Thymeleaf 提供了非常丰富的标准表达式语法，总共有 8 大类：</p><ul><li>简单表达式 </li><li>字面值 </li><li>文本操作 </li><li>算术运算 </li><li>布尔运算 </li><li>比较和相等 </li><li>条件运算 </li><li>无操作符</li></ul><h2 id="3-1-简单表达式"><a href="#3-1-简单表达式" class="headerlink" title="3.1 简单表达式"></a>3.1 简单表达式</h2><table><thead><tr><th>语法</th><th>名称</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td>${…}</td><td>Variable Expressions</td><td>变量表达式</td><td>取出上下文变量的值</td></tr><tr><td>*{…}</td><td>Selection Variable Expressions</td><td>选择表达式</td><td>取出选择的对象的属性值</td></tr><tr><td>#{…}</td><td>Message Expressions</td><td>消息表达式</td><td>使文字消息国际化，I18N</td></tr><tr><td>@{…}</td><td>Link URL Expressions</td><td>链接表达式</td><td>用于表示各种超链接地址</td></tr><tr><td>~{…}</td><td>Fragment Expressions</td><td>片段表达式</td><td>引用一段公共的代码片段</td></tr></tbody></table><h3 id="3-1-1-…-变量表达式"><a href="#3-1-1-…-变量表达式" class="headerlink" title="3.1.1 ${…}   变量表达式"></a>3.1.1 ${…}   变量表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/standard-expression-syntax/variables&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">variables</span><span class="params">(ModelMap model, HttpSession session)</span> &#123;</span><br><span class="line">    model.put(<span class="string">&quot;now&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    model.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;Welcome to BeiJing!&quot;</span>);</span><br><span class="line">    session.setAttribute(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;fanlychie&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="number">24</span>));</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过变量表达式<code>$&#123;&#125;</code>取出上下文环境中的<code>message</code>变量：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-2-…-选择表达式"><a href="#3-1-2-…-选择表达式" class="headerlink" title="3.1.2  *{…}   选择表达式"></a>3.1.2  *{…}   选择表达式</h3><p>变量表达式<code>$&#123;&#125;</code>是面向整个上下文的，而选择变量表达式<code>*&#123;&#125;</code>的上下文是父标签（<code>th:object</code>）所选择的对象</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;session.user&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;sex&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;*&#123;age&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-3-…-消息表达式"><a href="#3-1-3-…-消息表达式" class="headerlink" title="3.1.3  #{…}   消息表达式"></a>3.1.3  #{…}   消息表达式</h3><p>消息表达式可用于国际化文字信息.首先我们来了解一下 i18n 资源文件的命名规则：</p><ul><li>basename.properties</li><li>basename_language.properties</li><li>basename_language_country.properties</li></ul><p><code>basename</code>是自定义的资源文件名称，<code>language</code>和<code>country</code>必须是 Java 支持的语言和国家。<code>basename.properties</code>是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。</p><p><code>basename</code>是自定义的资源文件名称，<code>language</code>和<code>country</code>必须是 Java 支持的语言和国家。<code>basename.properties</code>是缺省加载的资源文件，当客户端根据本地语言查找不到相关的资源文件时，则使用该配置文件。</p><p>创建文件<code>src/main/resources/messages.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">welcome.message</span> = <span class="string">北京欢迎你！</span></span><br></pre></td></tr></table></figure><p>创建文件<code>src/main/resources/messages_en_US.properties</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">welcome.message</span> = <span class="string">Welcome to BeiJing!</span></span><br></pre></td></tr></table></figure><p>在 IntelliJ IDEA 编辑视图：</p><p><code>messages</code>是 Spring Boot 加载资源文件默认采用的名称（<code>basename</code>），如果你所使用的资源文件名称不是以<code>messages</code>命名或所使用的资源文件不是在<code>src/main/resources</code>根目录，你可以通过<code>spring.messages.basename</code>属性来做具体的配置。如，资源文件<code>messages.properties</code>和<code>messages_en_US.properties</code>假设它们所在的目录位置是<code>src/main/resources/i18n</code>。</p><p>application.properties 配置示例：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.messages.basename</span>:<span class="string">i18n/messages</span></span><br></pre></td></tr></table></figure><p>静态文本消息示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 北京欢迎你！ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;#&#123;welcom.message&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-4-…-链接表达式"><a href="#3-1-4-…-链接表达式" class="headerlink" title="3.1.4 @{…} 链接表达式"></a>3.1.4 @{…} 链接表达式</h3><p>链接表达式<code>@&#123;&#125;</code>是专门用来处理 URL 链接地址的</p><p>（1）绝对地址示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://fanlychie.github.io --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;@&#123;https://fanlychie.github.io&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）页面相对地址示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- commons/base.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;@&#123;commons/base.html&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）上下文相对地址（相对于当前的服务）示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /css/mian.css --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;@&#123;/css/mian.css&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（4）服务器相对地址（相对于部署在同一个服务器中的不同服务）示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /image/upload --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;@&#123;~/image/upload&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-5-…-片段表达式"><a href="#3-1-5-…-片段表达式" class="headerlink" title="3.1.5 ~{…} 片段表达式"></a>3.1.5 ~{…} 片段表达式</h3><p>片段表达式<code>~&#123;&#125;</code>可以用来引用一段公共的 HTML 代码片段</p><table><thead><tr><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>~{templatename}</td><td>引用整个模板文件的代码片段</td></tr><tr><td>~{templatename :: selector}</td><td>selector 可以是 th:fragment 指定的名称或其他选择器。如类选择器、ID选择器等</td></tr><tr><td>~{::selector}</td><td>相当于 ~{this :: selector}，表示引用当前模板定义的代码片段</td></tr></tbody></table><p>在 Thymeleaf 模板文件中，你可以使用<code>th:fragment</code>属性来定义一段公共的代码片段，然后你可以通过使用<code>th:insert</code>、<code>th:replace</code>、<code>th:include</code>（Thymeleaf 3.0 开始不再推荐使用，本文也将不再介绍它）属性来将这些公共的代码片段引入到模板文件中来。</p><p>（1）src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;base.html，通过<code>th:fragment</code>属性定义一段公共的代码片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">th:fragment</span>=<span class="string">&quot;footerFragment&quot;</span>&gt;</span><span class="symbol">&amp;copy;</span> 2017 fanlychie<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）src&#x2F;main&#x2F;resources&#x2F;templates&#x2F;index.html，通过<code>th:insert</code>属性引用一段公共的代码片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;~&#123;base :: footerFragment&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>th:fragment</code>属性定义代码片段时，你还可以声明一组参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:fragment</span>=<span class="string">&quot;crumbs(parent, child)&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;parent&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">i</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;child&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;i&gt;用户中心&lt;/i&gt;</span></span><br><span class="line"><span class="comment">&lt;i&gt;我的订单&lt;/i&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;::crumbs(&#x27;用户中心&#x27;, &#x27;我的订单&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，我们还可以通过类选择器、ID选择器等来引用公共的代码片段：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:insert</span>=<span class="string">&quot;~&#123;base :: #footer&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-6-内置对象"><a href="#3-1-6-内置对象" class="headerlink" title="3.1.6  内置对象"></a>3.1.6  内置对象</h3><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>#ctx</td><td>上下文对象</td></tr><tr><td>#vars</td><td>同#ctx，表示上下文变量</td></tr><tr><td>#locale</td><td>上下文本地化（特定地理区域）变量，可参考java.utils.Locale</td></tr><tr><td>#request</td><td>HttpServletRequest对象</td></tr><tr><td>#response</td><td>HttpServletResponse 对象</td></tr><tr><td>#session</td><td>HttpSession对象</td></tr><tr><td>#servletContext</td><td>ServletContext 对象</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- #ctx  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#ctx.getLocale()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#ctx.getVariable(&#x27;message&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #vars --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#vars.getLocale()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#vars.getVariable(&#x27;message&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #locale --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#locale&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#locale.country&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #request --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.serverName&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.serverPort&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#request.requestURL&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #response --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#response.status&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#response.characterEncoding&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- #session --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#session.id&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-7-工具类"><a href="#3-1-7-工具类" class="headerlink" title="3.1.7 工具类"></a>3.1.7 工具类</h3><table><thead><tr><th>对象</th><th>描述</th></tr></thead><tbody><tr><td>#message</td><td>消息工具类，与 ＃{…} 作用相同</td></tr><tr><td>#uris</td><td>地址相关的工具类</td></tr><tr><td>#conversions</td><td>对象转换工具</td></tr><tr><td>#dates</td><td>日期转换工具</td></tr><tr><td>#calendars</td><td>日历工具类</td></tr><tr><td>#numbers</td><td>数字工具类</td></tr><tr><td>#strings</td><td>字符串工具类</td></tr><tr><td>#objects</td><td>对象工具类</td></tr><tr><td>#bools</td><td>布尔工具类</td></tr><tr><td>#arrays</td><td>数组工具类</td></tr><tr><td>#list</td><td>List工具类</td></tr><tr><td>#set</td><td>Set工具类</td></tr><tr><td>#maps</td><td>Map工具类</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#strings.isEmpty(message)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;#dates.format(now, &#x27;yyyy-MM-dd HH:mm:ss&#x27;)&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-字面值"><a href="#3-2-字面值" class="headerlink" title="3.2 字面值"></a>3.2 字面值</h2><p>所谓字面值，首先它不是一个变量，它是一个具体的确切的值，通常这些值是比较简单的，例如：<code>18</code>、<code>&#39;welcome&#39;</code>等，它们没有名称，以至于我们只能用值来称呼它们，因此我们称其为字面值。</p><h3 id="3-2-1-文字字面值"><a href="#3-2-1-文字字面值" class="headerlink" title="3.2.1 文字字面值"></a>3.2.1 文字字面值</h3><p>文字字面值是用单引号引起来的任何字符内容，如果字符内容里面含有单引号，则需要进行转义：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Welcome to BeiJing!&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#x27;Welcome to BeiJing!&#x27; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;\&#x27;Welcome to BeiJing!\&#x27;&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-2-数字字面量"><a href="#3-2-2-数字字面量" class="headerlink" title="3.2.2 数字字面量"></a>3.2.2 数字字面量</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 2017 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;2017&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2018 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;2017 + 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-3-布尔字面值"><a href="#3-2-3-布尔字面值" class="headerlink" title="3.2.3 布尔字面值"></a>3.2.3 布尔字面值</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;1 &gt; 2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 否 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;1 &gt; 2 ? &#x27;是&#x27; : &#x27;否&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-4-空字面值"><a href="#3-2-4-空字面值" class="headerlink" title="3.2.4 空字面值"></a>3.2.4 空字面值</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- false --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user == null&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-5-字面令牌"><a href="#3-2-5-字面令牌" class="headerlink" title="3.2.5 字面令牌"></a>3.2.5 字面令牌</h3><p>字面令牌（Literal Tokens）的内容只能含有（不能含有空格、特殊符号等）：</p><ul><li>大写或小写的字母、中文等不含空格和特殊符号的文本</li><li>0 到 9 的数字</li><li>中括号</li><li>下划线</li><li>连字符（-）</li><li>点符号（.）</li></ul><p>实际上，数字、布尔和空字面值都是字面令牌的特殊情况。字面令牌能够用来对标准表达式语法进行简化，我们可以将包裹它的内容的单引号去掉：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;Welcome to BeiJing!&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">等效于</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Welcome to BeiJing!&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-文本操作"><a href="#3-3-文本操作" class="headerlink" title="3.3 文本操作"></a>3.3 文本操作</h2><p>我们可以对文本内容进行两种常用的操作，它们分别为字符串连接和字符串替换</p><h3 id="3-3-1-字符串连接"><a href="#3-3-1-字符串连接" class="headerlink" title="3.3.1 字符串连接"></a>3.3.1 字符串连接</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;Welcome to &#x27; + $&#123;location&#125; + &#x27;!&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-3-2-字面值替换"><a href="#3-3-2-字面值替换" class="headerlink" title="3.3.2 字面值替换"></a>3.3.2 字面值替换</h3><p>符号<code>||</code>可以用来将字面值和表达式包裹起来，这样就能方便的替换变量的值，而不需要使用<code>+</code>连接符：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Welcome to BeiJing! --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;|Welcome to $&#123;location&#125;!|&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-算数运算"><a href="#3-4-算数运算" class="headerlink" title="3.4 算数运算"></a>3.4 算数运算</h2><p>支持<code>+</code>（加）、<code>-</code>（减）、<code>*</code>（乘）、<code>/</code>（除）、<code>%</code>（模）运算：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 6 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;4 + 2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;pagination.page + 1&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;pagination.page&#125; + 1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-布尔运算"><a href="#3-5-布尔运算" class="headerlink" title="3.5 布尔运算"></a>3.5 布尔运算</h2><p>支持<code>and</code>（且）、<code>or</code>（或）、<code>!</code>（非）、<code>not</code>（非）运算：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.online and user.vip&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.online or user.vip&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;!user.online&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;not user.online&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-6-比较和相等"><a href="#3-6-比较和相等" class="headerlink" title="3.6 比较和相等"></a>3.6 比较和相等</h2><p>支持<code>&lt;</code>（<code>lt</code>）、<code>&gt;</code>（<code>gt</code>）、<code>&lt;=</code>（<code>le</code>）、<code>&gt;=</code>（<code>ge</code>）、<code>==</code>（<code>eq</code>）、<code>！=</code>（<code>ne</code>）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age &lt; 60&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age &lt;= 60&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age &gt; 18&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age &gt;= 18&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age == 18&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.age != 18&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-7-条件运算"><a href="#3-7-条件运算" class="headerlink" title="3.7 条件运算"></a>3.7 条件运算</h2><p>三元运算符：<code>(if) ? (then) : (else)</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.online ? &#x27;在线&#x27; : &#x27;离线&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>二元运算符：<code>(value) ?: (defaultValue)</code>。</p><p>其中，<code>value</code>非空（null）即真，条件为真时输出<code>value</code>，否则输出<code>defaultValue</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 你还没有登录，请先登录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;token&#125; ?: &#x27;你还没有登录，请先登录&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- fanlychie@gmail.com --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;user.email&#125; ?: &#x27;你还没有绑定邮箱&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-8-无操作符"><a href="#3-8-无操作符" class="headerlink" title="3.8 无操作符"></a>3.8 无操作符</h2><p>当模板运行在服务器端时，Thymeleaf 会解析<code>th:*</code>属性的具体值替换标签体的内容。无操作符（<code>_</code>）则允许你使用原型标签体的内容作为默认值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 你还没有登录，请先登录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;token&#125; ?: _&quot;</span>&gt;</span>你还没有登录，请先登录<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-使用文本"><a href="#4-使用文本" class="headerlink" title="4. 使用文本"></a>4. 使用文本</h1><p>首先介绍两个最基础的<code>th:*</code>属<code>th:text</code>和<code>th:utext</code>，它们都是用于处理文本消息内容</p><h2 id="4-1-th-text"><a href="#4-1-th-text" class="headerlink" title="4.1 th:text"></a>4.1 th:text</h2><p>在标签体中展示表达式评估结果的文本内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用外部化的文本内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span>Welcome to BeiJing!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当它作为静态文件直接运行时，浏览器会自动忽略它不能识别的<code>th:text</code>属性，而显示<code>&lt;p&gt;</code>标签体的文本内容<code>Welcome to BeiJing!</code></p><p>当它作为模板文件运行在服务器端时，<code>th:text</code>属性的具体值将会替换<code>&lt;p&gt;</code>标签体的文本内容。</p><h2 id="4-2-th-utext"><a href="#4-2-th-utext" class="headerlink" title="4.2 th:utext"></a>4.2 th:utext</h2><p>属性<code>th:utext</code>与<code>th:text</code>的区别在于：</p><ul><li><code>th:text</code>默认会对含有 HTML 标签的内容进行字符转义；</li><li><code>th:utext</code>（Unescaped Text）则不会对含有 HTML 标签的内容进行字符转义；</li></ul><p>假设：<code>message = &quot;&lt;b&gt;Welcome to BeiJing!&lt;/b&gt;&quot;</code>。</p><p>（1）使用<code>th:text</code>属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>th:text</code>效果：<b>Welcome to BeiJing!</b></p><p>（2）使用<code>th:utext</code>属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:utext</span>=<span class="string">&quot;$&#123;message&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>th:utext</code>效果：<strong>Welcome to BeiJing!</strong></p><h1 id="5-设置属性值"><a href="#5-设置属性值" class="headerlink" title="5. 设置属性值"></a>5. 设置属性值</h1><p>在 Thymeleaf 模板文件中，你可以使用<code>th:*</code>（或者使用<code>th:attr</code>属性）来设置任意的 HTML5 标签属性的值。不仅如此，你还可以<code>th:*-*</code>来同时为多个不同的标签属性设置相同的一个值，甚至你可以使用<code>th:attrappend</code>和<code>th:attrprepend</code>来追加新的值到现有的标签属性值中。</p><h2 id="5-1-th-attr"><a href="#5-1-th-attr" class="headerlink" title="5.1 th:attr"></a>5.1 th:attr</h2><p>这种方式是不被推荐的，了解一下就行。下面是用<code>th:attr=&quot;href=...&quot;</code>来设置标签<code>href</code>属性的值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:attr</span>=<span class="string">&quot;href=@&#123;https://www.google.com.hk&#125;&quot;</span>&gt;</span>谷歌一下你就知道<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-2-th"><a href="#5-2-th" class="headerlink" title="5.2 th:*"></a>5.2 th:*</h2><p>显然<code>th:attr=&quot;href=@&#123;http://www.baidu.com&#125;&quot;</code>不够简洁，我们更推荐下面的这种语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;https://www.google.com.hk&#125;&quot;</span>&gt;</span>谷歌一下你就知道<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>th:*</code>中的<code>*</code>可以是 HTML5 支持的任意属性名称，甚至这些属性名称可以是自定义的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;div item-id=&quot;1001&quot;&gt;Welcome to BeiJing!&lt;/div&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:item-id</span>=<span class="string">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span>Welcome to BeiJing!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-3-th"><a href="#5-3-th" class="headerlink" title="5.3 th:-"></a>5.3 th:<em>-</em></h2><p>如果想要同时为标签的多个不同属性设置相同的一个值，可以使用<code>th:*-*</code>的语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span> <span class="attr">th:alt-title</span>=<span class="string">&quot;LOGO图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它相当于</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;logo.png&quot;</span> <span class="attr">th:alt</span>=<span class="string">&quot;LOGO图片&quot;</span> <span class="attr">th:title</span>=<span class="string">&quot;LOGO图片&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-4-th-attrappend-th-attrprepend"><a href="#5-4-th-attrappend-th-attrprepend" class="headerlink" title="5.4 th:attrappend &amp; th:attrprepend"></a>5.4 th:attrappend &amp; th:attrprepend</h2><p><code>th:attrappend</code>和<code>th:attrprepend</code>可以将表达式的结果分别追加到指定的属性值之后和之前。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:attrappend</span>=<span class="string">&quot;class=$&#123;outOfStock&#125; ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;</span>&gt;</span>购买<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;button class=&quot;enable btn&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:attrprepend</span>=<span class="string">&quot;class=$&#123;outOfStock&#125; ? &#x27;enable &#x27; : &#x27;disable &#x27;&quot;</span>&gt;</span>购买<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，还有两个常用的具体附加属性<code>th:classappend=&quot;...&quot;</code>和<code>th:styleappend=&quot;&quot;</code>。</p><p>它们分别用来代替<code>th:attrappend=&quot;class=...&quot;</code>和<code>th:attrappend=&quot;style=...&quot;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;button class=&quot;btn enable&quot;&gt;购买&lt;/button&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">th:classappend</span>=<span class="string">&quot;$&#123;outOfStock&#125; ? &#x27; enable&#x27; : &#x27; disable&#x27;&quot;</span>&gt;</span>购买<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-5-布尔属性"><a href="#5-5-布尔属性" class="headerlink" title="5.5 布尔属性"></a>5.5 布尔属性</h2><p>在 HTML 中有些属性是布尔属性，布尔属性是指没有值的属性，如<code>readonly</code>、<code>checked</code>、<code>selected</code>等。它们若存在那就意味着值为 true</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rememberme&quot;</span> <span class="attr">checked</span> /&gt;</span> 记住我</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span> <span class="attr">checked</span>&gt;</span> 男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span> 女</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;appId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;J123654&quot;</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>广州<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Thymeleaf 也允许我们通过<code>th:*</code>（这里的<code>*</code>表示任意的布尔属性） 来选择是否使用这些布尔属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;rememberme&quot;</span> <span class="attr">ch:checked</span>=<span class="string">&quot;$&#123;rememberme&#125;&quot;</span> /&gt;</span> 记住我</span><br></pre></td></tr></table></figure><p>如果表达式的结果为<code>true</code>，则自动勾选复选框，若为<code>false</code>，则不会自动勾选</p><h1 id="6-遍历"><a href="#6-遍历" class="headerlink" title="6. 遍历"></a>6. 遍历</h1><p>遍历（迭代）的语法<code>th:each=&quot;自定义的元素变量名称 : $&#123;集合变量名称&#125;&quot;</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spn</span>&gt;</span>你所在城市：<span class="tag">&lt;/<span class="name">spn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;mycity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">&quot;city : $&#123;cities&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;city.name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性<code>th:each</code>提供了一个用于跟踪迭代的状态变量，它包含以下几个属性：</p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>index</td><td>int</td><td>当前迭代的索引，从0开始</td></tr><tr><td>count</td><td>int</td><td>当前迭代的计数，从1开始</td></tr><tr><td>size</td><td>int</td><td>集合中元素的总个数</td></tr><tr><td>current</td><td>int</td><td>当前的元素对象</td></tr><tr><td>even</td><td>boolean</td><td>当前迭代的计数是否是偶数</td></tr><tr><td>odd</td><td>boolean</td><td>当前迭代的计数是否是奇数</td></tr><tr><td>first</td><td>boolean</td><td>当前元素是否是集合的第一个元素</td></tr><tr><td>last</td><td>boolean</td><td>当前元素是否是集合的最后一个元素</td></tr></tbody></table><p>状态变量的使用语法：<code>th:each=&quot;自定义的元素变量名称, 自定义的状态变量名称 : $&#123;集合变量名称&#125;&quot;</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spn</span>&gt;</span>所在城市：<span class="tag">&lt;/<span class="name">spn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;mycity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">&quot;city, status : $&#123;cities&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;city.name&#125;&quot;</span> <span class="attr">th:item-index</span>=<span class="string">&quot;$&#123;status.count&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不管什么时候，Thymeleaf 始终会为每个<code>th:each</code>创建一个状态变量，默认的状态变量名称就是自定义的元素变量名称后面加<code>Stat</code>字符串组成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spn</span>&gt;</span>所在城市：<span class="tag">&lt;/<span class="name">spn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;mycity&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">th:each</span>=<span class="string">&quot;city : $&#123;cities&#125;&quot;</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;city.name&#125;&quot;</span> <span class="attr">th:item-index</span>=<span class="string">&quot;$&#123;cityStat.count&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="7-条件判断"><a href="#7-条件判断" class="headerlink" title="7. 条件判断"></a>7. 条件判断</h1><p>条件判断语句有三种，分别是：th:if，th:unless，th:swith</p><h2 id="7-1-th-if"><a href="#7-1-th-if" class="headerlink" title="7.1 th:if"></a>7.1 th:if</h2><p>当表达式的评估结果为真时则显示内容，否则不显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;user != null&#125;&quot;</span>&gt;</span>我的订单<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>真假评估的依据：</p><ul><li>当表达式的值不为空（null）时 <ul><li>如果表达式的值是一个布尔类型，且值为<code>true</code>评估为真，否则为假</li><li>如果表达式的值是一个数字类型，且值为非<code>0</code>评估为真，否则为假</li><li>如果表达式的值是一个字符类型，且值为非<code>0</code>评估为真，否则为假</li><li>如果表达式的值是一个字符串类型，且值为非<code>&quot;false&quot;</code>、<code>&quot;off&quot;</code>、<code>&quot;no&quot;</code>评估为真，否则为假</li><li>如果表达式的值不是一个<code>布尔</code>、<code>数字</code>、<code>字符</code>或<code>字符串</code>评估为真</li></ul></li><li>当表达式的值为空（null）时，评估结果为假</li></ul><p>因此，上面代码我们也可以简写成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot;</span> <span class="attr">th:if</span>=<span class="string">&quot;$&#123;user&#125;&quot;</span>&gt;</span>我的订单<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是，为了代码的可读性，我们并不建议这样使用</p><h2 id="7-2-th-unless"><a href="#7-2-th-unless" class="headerlink" title="7.2 th:unless"></a>7.2 th:unless</h2><p><code>th:unless</code>与<code>th:if</code>判断恰好相反，当表达式的评估结果为假时则显示内容，否则不显示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/user/order(uid=$&#123;user.id&#125;)&#125;&quot;</span> <span class="attr">th:unless</span>=<span class="string">&quot;$&#123;user == null&#125;&quot;</span>&gt;</span>我的订单<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-3-th-swith"><a href="#7-3-th-swith" class="headerlink" title="7.3 th:swith"></a>7.3 th:swith</h2><p>多路选择语句，它需要搭配th:case来使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;admin&quot;</span>&gt;</span>管理员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;user&quot;</span>&gt;</span>普通用户<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="8-定义局部变量"><a href="#8-定义局部变量" class="headerlink" title="8. 定义局部变量"></a>8. 定义局部变量</h1><p>使用th:with属性可以定义局部变量</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:with</span>=<span class="string">&quot;name=&#x27;fanlychie&#x27;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">&quot;$&#123;name&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时定义多个局部变量时，用英文<code>,</code>号分隔开：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:with</span>=<span class="string">&quot;name=$&#123;user.name&#125;,age=&#123;user.age&#125;&quot;</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="9-注释"><a href="#9-注释" class="headerlink" title="9. 注释"></a>9. 注释</h1><h2 id="9-1-标准注释"><a href="#9-1-标准注释" class="headerlink" title="9.1 标准注释"></a>9.1 标准注释</h2><p>语法：<code>&lt;!-- ... ---&gt;</code>，注释的代码块会在文件源代码中显示出来。</p><h3 id="9-1-1-单行注释"><a href="#9-1-1-单行注释" class="headerlink" title="9.1.1 单行注释"></a>9.1.1 单行注释</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- &lt;span&gt;$&#123;message&#125;&lt;/span&gt; ---&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-1-2-多行注释"><a href="#9-1-2-多行注释" class="headerlink" title="9.1.2 多行注释"></a>9.1.2 多行注释</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">&lt;div th:switch=&quot;$&#123;user.role&#125;&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;p th:case=&quot;admin&quot;&gt;管理员&lt;/p&gt;</span></span><br><span class="line"><span class="comment">    &lt;p th:case=&quot;user&quot;&gt;普通用户&lt;/p&gt;</span></span><br><span class="line"><span class="comment">&lt;/div&gt;</span></span><br><span class="line"><span class="comment">---&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-2-解析器级注释"><a href="#9-2-解析器级注释" class="headerlink" title="9.2 解析器级注释"></a>9.2 解析器级注释</h2><p>语法：<code>&lt;!--/* ... */--&gt;</code>，注释的代码块会在引擎解析的时候抹去</p><h3 id="9-2-1-单行注释"><a href="#9-2-1-单行注释" class="headerlink" title="9.2.1 单行注释"></a>9.2.1 单行注释</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--/* &lt;span&gt;$&#123;message&#125;&lt;/span&gt; */--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="9-2-2-多行注释"><a href="#9-2-2-多行注释" class="headerlink" title="9.2.2 多行注释"></a>9.2.2 多行注释</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--/*--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">th:switch</span>=<span class="string">&quot;$&#123;user.role&#125;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;admin&quot;</span>&gt;</span>管理员<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:case</span>=<span class="string">&quot;user&quot;</span>&gt;</span>普通用户<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--*/--&gt;</span></span><br></pre></td></tr></table></figure><h1 id="10-内联表达式"><a href="#10-内联表达式" class="headerlink" title="10. 内联表达式"></a>10. 内联表达式</h1><p>内联表达式允许我们直接在 HTML 文本中使用标准表达式，而不需要使用<code>th:*</code>标签属性</p><h2 id="10-1-…"><a href="#10-1-…" class="headerlink" title="10.1 [[…]]"></a>10.1 [[…]]</h2><p>[[]]相当于th:text，对含有HTML标签的内容自动进行字符转义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The message is : [[$&#123;htmlContent&#125;]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="10-2-…"><a href="#10-2-…" class="headerlink" title="10.2 [(…)]"></a>10.2 [(…)]</h2><p>[()]相当于th:utext，对含有 HTML 标签的内容不进行字符转义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The message is : [($&#123;htmlContent&#125;)]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="10-3-th-inline"><a href="#10-3-th-inline" class="headerlink" title="10.3 th:inline"></a>10.3 th:inline</h2><p>我们已经了解到，使用<code>[[]]</code>和<code>[()]</code>语法可以直接在 HTML 文本中使用标准表达式，如果想要使用更多高级的功能，需要使用<code>th:inline</code>属性来激活，它的取值如下：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>禁止内联表达式，可以原样输出[[]]和[()]字符串</td></tr><tr><td>text</td><td>文本内联，可以使用th:each等高级语法</td></tr><tr><td>css</td><td>样式内联，如：<code>&lt;style th:inline=&quot;css&quot;&gt;</code></td></tr><tr><td>javascript</td><td>脚本内联，如：<code>&lt;style th:inline=&quot;javascript&quot;&gt;</code></td></tr></tbody></table><h4 id="10-3-1-none"><a href="#10-3-1-none" class="headerlink" title="10.3.1 none"></a>10.3.1 none</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [[1, 2], [3, 4]] --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:inline</span>=<span class="string">&quot;none&quot;</span>&gt;</span>[[1, 2], [3, 4]]<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="10-3-2-text"><a href="#10-3-2-text" class="headerlink" title="10.3.2 text"></a>10.3.2 text</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 北京 上海 广州 深圳 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">th:inline</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    [# th:each=&quot;city : $&#123;cities&#125;&quot;]</span><br><span class="line">        [($&#123;city.name&#125;)]</span><br><span class="line">    [/]</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="10-3-3-css"><a href="#10-3-3-css" class="headerlink" title="10.3.3 css"></a>10.3.3 css</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">th:inline</span>=<span class="string">&quot;css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>:[[$&#123;bgColor&#125;]];</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="10-3-4-javascript"><a href="#10-3-4-javascript" class="headerlink" title="10.3.4 javascript"></a>10.3.4 javascript</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">th:inline</span>=<span class="string">&quot;javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> user = [[$&#123;user&#125;]];</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&quot;用户名：&quot;</span> + user.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> thymeleaf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java core</title>
      <link href="/posts/58693.html"/>
      <url>/posts/58693.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、Java概述"><a href="#1、Java概述" class="headerlink" title="1、Java概述"></a>1、Java概述</h1><h2 id="1-1、java特点"><a href="#1-1、java特点" class="headerlink" title="1.1、java特点"></a>1.1、java特点</h2><ol><li>Java 语言是面向对象的(oop) </li><li>Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证</li><li>Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]</li><li>java是一种半编译，半解释型语言。 . Java–&gt;. class是由 Javac 编译，这个过程符合编译型语言的特点。而. class–&gt;对应平台机器码 的这一过程 是由Java解释执行</li></ol><p> </p><h2 id="1-2、访问修饰符"><a href="#1-2、访问修饰符" class="headerlink" title="1.2、访问修饰符"></a>1.2、访问修饰符</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202312221054095.png" alt="image.png|500"></p><h1 id="2、变量"><a href="#2、变量" class="headerlink" title="2、变量"></a>2、变量</h1><h2 id="2-1、java基本数据类型"><a href="#2-1、java基本数据类型" class="headerlink" title="2.1、java基本数据类型"></a>2.1、java基本数据类型</h2><p>java基本数据类型 - 四类八种</p><ol><li><strong>整型</strong></li></ol><p>byte 、short 、int 、long</p><ol start="2"><li><strong>浮点型</strong></li></ol><p>float 、 double</p><ol start="3"><li><strong>字符型</strong></li></ol><p>char</p><ol start="4"><li><strong>布尔型</strong></li></ol><p>boolean</p><table><thead><tr><th>数据类型名称</th><th>占用字节</th><th>范围</th><th>封装器类</th></tr></thead><tbody><tr><td>byte（字节型）</td><td>1</td><td>-（2^7）<del>2^7-1（-128</del>127）</td><td>Byte</td></tr><tr><td>shot（短整型）</td><td>2</td><td>-（2^15）<del>2^15-1(-32768</del>32767)</td><td>Short</td></tr><tr><td>int（整形）</td><td>4</td><td>-（2^31）<del>2^31-1（-2147483648</del>2147483647）</td><td>Integer</td></tr><tr><td>long（长整型）</td><td>8</td><td>-（2^63）~2^63-1</td><td>Long</td></tr><tr><td>float（浮点型）</td><td>4</td><td>-3.403E8~3.403E38</td><td>Float</td></tr><tr><td>double（双精度浮点型）</td><td>8</td><td>-1.798E308~1.798E308</td><td>Double</td></tr><tr><td>boolean（布尔型）</td><td>1</td><td></td><td>Boolean</td></tr><tr><td>char（字符型）</td><td>2</td><td></td><td><strong>Character</strong></td></tr></tbody></table><blockquote><p>注意：计算机的数值是用二进制补码表示的，二进制补码表示法中，最高位是用来表示符号的（0 表示正数，1 表示负数），其余位表示数值部分。所以，如果我们要表示最大的正数，我们需要把除了最高位之外的所有位都设为 1</p></blockquote><h2 id="2-2、基本数据类型转换"><a href="#2-2、基本数据类型转换" class="headerlink" title="2.2、基本数据类型转换"></a>2.2、基本数据类型转换</h2><h3 id="2-2-1、自动类型转换"><a href="#2-2-1、自动类型转换" class="headerlink" title="2.2.1、自动类型转换"></a>2.2.1、自动类型转换</h3><p>当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换<br>精度由小到大排序：</p><p>byte short int long float double</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动类型转换细节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConvertDetail</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//细节 1： 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//ok</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">d1</span> <span class="operator">=</span> n1 + <span class="number">1.1</span>;<span class="comment">//错误 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> n1 + <span class="number">1.1</span>;<span class="comment">//对 n1 + 1.1 =&gt; 结果类型是 double</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">d1</span> <span class="operator">=</span> n1 + <span class="number">1.1F</span>;<span class="comment">//对 n1 + 1.1 =&gt; 结果类型是 float</span></span><br><span class="line">    <span class="comment">//细节 2: 当我们把精度(容量)大 的数据类型赋值给精度(容量)小 的数据类型时，就会报错，反之就会进行自动类型转换。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">1.1</span>;<span class="comment">//错误 double -&gt; int</span></span><br><span class="line">    <span class="comment">//细节 3: (byte, short) 和 char 之间不会相互自动转换</span></span><br><span class="line">     <span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">//对 , -128-127</span></span><br><span class="line">     <span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> b1; <span class="comment">//错误， 原因 byte 不能自动转成 char</span></span><br><span class="line">    <span class="comment">//细节 4：自动提升原则： 表达式结果的类型自动提升为 操作数中最大的类型</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">b4</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num200</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">num300</span> <span class="operator">=</span> <span class="number">1.1F</span>;</span><br><span class="line">    <span class="type">float</span> <span class="variable">num500</span> <span class="operator">=</span> b4 + s3 + num200 + num300; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>floatf&#x3D;3.4;是否正确？<br>不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换floatf&#x3D;(float)3.4;或者写成floatf&#x3D;3.4F;</p></blockquote><h3 id="2-2-2、强制类型转换"><a href="#2-2-2、强制类型转换" class="headerlink" title="2.2.2、强制类型转换"></a>2.2.2、强制类型转换</h3><p>将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符( )，但可能造成精度降低或溢出,格外要注意。</p><h3 id="2-2-3、基本数据类型和String转换"><a href="#2-2-3、基本数据类型和String转换" class="headerlink" title="2.2.3、基本数据类型和String转换"></a>2.2.3、基本数据类型和String转换</h3><ol><li>基本数据类型转String类型</li></ol><p>（1）将基本类型的值加 “” 即可<br>（2）String.valueOf(基本数据类型)</p><ol start="2"><li>String转基本数据类型</li></ol><p>（1）基本类型包装类调用parseXX方法即可</p><h1 id="3、运算符"><a href="#3、运算符" class="headerlink" title="3、运算符"></a>3、运算符</h1><h2 id="3-1、算数运算符"><a href="#3-1、算数运算符" class="headerlink" title="3.1、算数运算符"></a>3.1、算数运算符</h2><p>算数运算符是对数值变量进行运算的，在java程序种使用非常多</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231601761.png" alt="java算数运算符"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 题目1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i = i++; <span class="comment">// 规则会使用临时变量(1)temp=i(2)i=i+1(3)i=temp</span></span><br><span class="line">System.out.println(i); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 题目2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">i = ++i; <span class="comment">// 规则会使用临时变量(1)i=i+1(2)temp=i(3)i=temp</span></span><br><span class="line">System.out.println(i); <span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-2、关系运算符"><a href="#3-2、关系运算符" class="headerlink" title="3.2、关系运算符"></a>3.2、关系运算符</h2><p>关系运算符的结果都是boolean型，也就是要么是true，要么是false</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231605071.png" alt="java关系运算符"></p><h2 id="3-3、逻辑运算符"><a href="#3-3、逻辑运算符" class="headerlink" title="3.3、逻辑运算符"></a>3.3、逻辑运算符</h2><p>用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 值</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231608353.png" alt="逻辑运算符"></p><blockquote><p>  a^b: 叫逻辑异或  ：当 a 和 b 不同时，则结果为 true, 否则为 false<br>  &amp;&amp;短路与：如果第一个条件为 false，则第二个条件不会判断，最终结果为 false，效率高<br>  &amp; 逻辑与：不管第一个条件是否为 false，第二个条件都要判断，效率低  </p></blockquote><h2 id="3-4、赋值运算符"><a href="#3-4、赋值运算符" class="headerlink" title="3.4、赋值运算符"></a>3.4、赋值运算符</h2><p>基本赋值运算符 &#x3D; （ int a &#x3D; 10;）<br>复合赋值运算符 +&#x3D; ，-&#x3D; ，*&#x3D; ， &#x2F;&#x3D; ，%&#x3D; 等</p><h2 id="3-5、三元运算符"><a href="#3-5、三元运算符" class="headerlink" title="3.5、三元运算符"></a>3.5、三元运算符</h2><p>条件表达式 ? 表达式 1: 表达式 2; </p><ol><li>如果条件表达式为 true，运算后的结果是表达式 1；</li><li>如果条件表达式为 false，运算后的结果是表达式 2；</li></ol><h2 id="3-6、进制转换（为位运算准备）"><a href="#3-6、进制转换（为位运算准备）" class="headerlink" title="3.6、进制转换（为位运算准备）"></a>3.6、进制转换（为位运算准备）</h2><p>对于整数，有四种表示方式：<br>二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。<br>十进制：0-9 ，满 10 进 1。<br>八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。<br>十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X 开头表示。此处的 A-F 不区分大小写</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231612057.png" alt="进制转换"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2996398/1659315826387-ed7e7bab-8366-4fd2-8353-b82acde62fa2.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=243&id=uc4b6c469&originHeight=470&originWidth=664&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126331&status=done&style=none&taskId=u69461551-0d4d-415e-bdd3-fb02621b29f&title=&width=343" alt="image.png"></p><h3 id="3-6-1、其它进制转十进制"><a href="#3-6-1、其它进制转十进制" class="headerlink" title="3.6.1、其它进制转十进制"></a>3.6.1、其它进制转十进制</h3><ol><li>二进制转十进制</li></ol><p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以2的（位数-1）次方，然后求和</p><blockquote><p>案例：将ob1011转成十进制数<br>1+2+8&#x3D;11</p></blockquote><ol start="2"><li>八进制转十进制</li></ol><p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以8的（位数-1）次方，然后求和</p><blockquote><p>案例：0234转成十进制<br>4*1+3*8+2*64&#x3D;156</p></blockquote><ol start="3"><li>十六进制转十进制</li></ol><p>规则：从最低位（右边）开始，将每个位上的数提取出来，乘以16的（位数-1）次方，然后求和</p><blockquote><p>案例：0x23A<br>10*1+3*16+2*512&#x3D;570</p></blockquote><h3 id="3-6-2、十进制转其他进制"><a href="#3-6-2、十进制转其他进制" class="headerlink" title="3.6.2、十进制转其他进制"></a>3.6.2、十进制转其他进制</h3><ol><li>十进制转二进制</li></ol><p>规则：将该数不断除以2.直到商为0为止，然后将每步余数倒过来，就是对应二进制</p><blockquote><p>案例：34转为对应二进制 &#x3D; 0B00100010</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231618617.png" alt="十进制转二进制"></p><ol start="2"><li>十进制转八进制</li></ol><p>规则：将该数不断除以8.直到商为0为止，然后将每步余数倒过来，就是对应二进制</p><blockquote><p>案例：131转为8进制</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308231620590.png" alt="十进制转八进制"></p><h3 id="3-6-3、二进制转其它进制"><a href="#3-6-3、二进制转其它进制" class="headerlink" title="3.6.3、二进制转其它进制"></a>3.6.3、二进制转其它进制</h3><ol><li>二进制转八进制</li></ol><p>规则：从低位开始，将二进制数每三位一组，转成对应的八进制</p><blockquote><p>案例：0b11010101转成八进制<br>0325</p></blockquote><ol start="2"><li>二进制转十六进制</li></ol><p>规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可</p><blockquote><p>案例：0b11010101转成十六进制<br>D5</p></blockquote><h3 id="3-6-4、其它进制转二进制"><a href="#3-6-4、其它进制转二进制" class="headerlink" title="3.6.4、其它进制转二进制"></a>3.6.4、其它进制转二进制</h3><ol><li>八进制转二进制</li></ol><p>规则：将八进制数每1位。转成对应的一个3位的二进制数即可</p><blockquote><p>案例：将0237转成二进制<br>0b10011111</p></blockquote><ol start="2"><li>十六进制转二进制</li></ol><p>规则：将十六进制数每1位。转成对应的一个4位的二进制数即可</p><blockquote><p>案例：请将0x23B转成二进制<br>0b001000111011</p></blockquote><h2 id="3-7、位运算符"><a href="#3-7、位运算符" class="headerlink" title="3.7、位运算符"></a>3.7、位运算符</h2><h3 id="3-7-1、原码反码补码"><a href="#3-7-1、原码反码补码" class="headerlink" title="3.7.1、原码反码补码"></a>3.7.1、原码反码补码</h3><ol><li>进制的最高位是符号位: 0表示正数1表示负数</li><li>正数的原码，反码，补码都一样</li><li>负数的反码&#x3D;它的原码符号位不变，其它位取反.负数的补码&#x3D;它的反码+1</li><li>0的反码，补码都是0</li><li>在计算机运算的时候，都是以补码的方式来运算的</li><li>补码的补码就是原码</li></ol><blockquote><p>为什么计算机通过补码进行运算？<br>通过使用补码，无需单独的符号位判断来执行加法和减法运算。计算机可以直接对补码进行位运算，而不需要额外的逻辑电路来处理符号位</p></blockquote><h3 id="3-7-2、位运算"><a href="#3-7-2、位运算" class="headerlink" title="3.7.2、位运算"></a>3.7.2、位运算</h3><p>java种有7个位运算 &amp;（按位与）,|（按位或）,^（按位异或）,~（按位取反），&lt;&lt;（左移），&gt;&gt;（带符号右移），&gt;&gt;&gt;（无符号右移）</p><h4 id="3-7-2-1、-（按位与）"><a href="#3-7-2-1、-（按位与）" class="headerlink" title="3.7.2.1、&amp; （按位与）"></a>3.7.2.1、&amp; （按位与）</h4><p>两位全为1，结果为1，否则为0</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">  10  (2)</span></span><br><span class="line"><span class="section">&amp; 11  (3)</span></span><br><span class="line"><span class="section">------</span></span><br><span class="line"><span class="code">  10  (2)</span></span><br></pre></td></tr></table></figure><h4 id="3-7-2-2、-（按位或）"><a href="#3-7-2-2、-（按位或）" class="headerlink" title="3.7.2.2、|（按位或）"></a>3.7.2.2、|（按位或）</h4><p>两位一个为1，结果为1，否则为0</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">  10  (2)</span></span><br><span class="line"><span class="section">| 11  (3)</span></span><br><span class="line"><span class="section">------</span></span><br><span class="line"><span class="code">  11  (3)</span></span><br></pre></td></tr></table></figure><h4 id="3-7-2-3、-（按位异或）"><a href="#3-7-2-3、-（按位异或）" class="headerlink" title="3.7.2.3、 ^（按位异或）"></a>3.7.2.3、 ^（按位异或）</h4><p>两位一个为0，结果为1，否则为0</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">  10  (2)</span></span><br><span class="line"><span class="section">^ 11  (3)</span></span><br><span class="line"><span class="section">------</span></span><br><span class="line"><span class="code">  01  (1)</span></span><br></pre></td></tr></table></figure><h4 id="3-7-2-4、-（按位取反）"><a href="#3-7-2-4、-（按位取反）" class="headerlink" title="3.7.2.4、~（按位取反）"></a>3.7.2.4、~（按位取反）</h4><p>0-&gt;1, 1-&gt;0</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~2 </span><br><span class="line">原码：00000010</span><br><span class="line">按位取反：11111101</span><br><span class="line">补码表示：10000011 = 3</span><br></pre></td></tr></table></figure><h4 id="3-7-2-5、-（算数右移）"><a href="#3-7-2-5、-（算数右移）" class="headerlink" title="3.7.2.5、&gt;&gt;（算数右移）"></a>3.7.2.5、&gt;&gt;（算数右移）</h4><p>低位溢出，符号位不变，并用符号位补溢出的高位</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &gt;&gt; 2</span><br><span class="line">1的补码：00000001</span><br><span class="line">右移两位，并用符号位填充：00000000</span><br><span class="line">原码结果为：0</span><br><span class="line"></span><br><span class="line">-1 &gt;&gt; 2</span><br><span class="line">-1的补码：11111111</span><br><span class="line">右移两位，并用符号位填充：11111111</span><br><span class="line">原码结果为：100000001 = -1</span><br></pre></td></tr></table></figure><h4 id="3-7-2-6、-（算数左移）"><a href="#3-7-2-6、-（算数左移）" class="headerlink" title="3.7.2.6、&gt;&gt; （算数左移）"></a>3.7.2.6、&gt;&gt; （算数左移）</h4><p>符号位不变，低位补0</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;&lt; 2</span><br><span class="line">0001 &lt;&lt; 2 = 0100 = 4</span><br><span class="line"></span><br><span class="line">-1 &lt;&lt; 3</span><br><span class="line">11111111 &lt;&lt; 3 = 11111000</span><br><span class="line">原码结果为：10001000 = -8</span><br></pre></td></tr></table></figure><h4 id="3-7-2-7、-（逻辑右移-或叫-无符号右移）"><a href="#3-7-2-7、-（逻辑右移-或叫-无符号右移）" class="headerlink" title="3.7.2.7、&gt;&gt;&gt; （逻辑右移 或叫 无符号右移）"></a>3.7.2.7、&gt;&gt;&gt; （逻辑右移 或叫 无符号右移）</h4><p>低位溢出，高位补0</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 &gt;&gt;&gt; 2</span><br><span class="line">1000 &gt;&gt;&gt; 2 = 0010 = 2</span><br></pre></td></tr></table></figure><h1 id="4、面向对象"><a href="#4、面向对象" class="headerlink" title="4、面向对象"></a>4、面向对象</h1><h2 id="4-1、面向对象三大特征"><a href="#4-1、面向对象三大特征" class="headerlink" title="4.1、面向对象三大特征"></a>4.1、面向对象三大特征</h2><h3 id="4-1-1、封装"><a href="#4-1-1、封装" class="headerlink" title="4.1.1、封装"></a>4.1.1、封装</h3><p><strong>封装</strong>：尽量避免向外部暴露实现细节，只提供个别接口让使用方调用，降低耦合性。这样做的话，当自身的逻辑发生变化时，不会破坏使用方的逻辑，或是强制使用方修改自身的逻辑，而是只需要修改自身的代码就可以了</p><h3 id="4-1-2、继承"><a href="#4-1-2、继承" class="headerlink" title="4.1.2、继承"></a>4.1.2、继承</h3><p><strong>继承</strong>：子类继承父类的特征和行为，使得子类对象（实例）具有父类的属性和方法。以降低代码编写的冗余度</p><h3 id="4-1-3、多态"><a href="#4-1-3、多态" class="headerlink" title="4.1.3、多态"></a>4.1.3、多态</h3><p><strong>多态</strong>：父类的引用指向子类的对象。它的意义是可以让我们不用关心某个对象到底是什么具体类型，就可以使用该对象的某些方法，而这些方法通过一个抽象类或者接口来实现，多态就是提供父类调用子类代码的一个手段而已</p><p>java实现多态三个必要条件：继承，重写，向上转型（父类引用指向子类对象）</p><h2 id="4-2、内部类"><a href="#4-2、内部类" class="headerlink" title="4.2、内部类"></a>4.2、内部类</h2><p>如果定义类在局部位置(方法中&#x2F;代码块) :(1) 局部内部类 (2) 匿名内部类<br>如果定义在成员位置 (1) 成员内部类 (2) 静态内部类  </p><h3 id="4-2-1、局部内部类"><a href="#4-2-1、局部内部类" class="headerlink" title="4.2.1、局部内部类"></a>4.2.1、局部内部类</h3><p>局部内部类是定义在外部类的局部位置，比如方法中，并且有类名数据</p><blockquote><p>说明：</p><ol><li>可以直接访问外部类的所有成员，包括私有</li><li>不能添加访问修饰符，因为他就是一个局部变量，局部变量不能使用修饰符</li><li>作用域：仅在定义它的方法或代码块中</li><li>局部内部类访问外部类的成员：直接访问。外部类访问局部内部类的成员，创建对象再访问</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OuterClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">outerData</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">outerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">localVar</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">LocalInnerClass</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">innerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;访问外部类数据：&quot;</span> + outerData);</span><br><span class="line">                System.out.println(<span class="string">&quot;访问局部变量：&quot;</span> + localVar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">LocalInnerClass</span> <span class="variable">innerObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalInnerClass</span>();</span><br><span class="line">        innerObj.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OuterClass</span> <span class="variable">outerObj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OuterClass</span>();</span><br><span class="line">        outerObj.outerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-2、匿名内部类"><a href="#4-2-2、匿名内部类" class="headerlink" title="4.2.2、匿名内部类"></a>4.2.2、匿名内部类</h3><p>匿名内部类是一种没有显式定义类名的内部类，定义在外部类的局部位置，比如方法中，它通常用于创建实现某个接口或继承某个类的匿名对象</p><blockquote><p>说明：</p><ol><li>匿名内部类运行类型：外部类名称$1</li></ol></blockquote><ol><li>基于接口的匿名内部类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 编译类型为IA，运行类型为匿名内部类Outer$1</span></span><br><span class="line">       <span class="comment">// jdk 底层在创建匿名内部类 Outer$1,立即马上就创建了 Outer$1 实例，并且把地址返回给 tiger</span></span><br><span class="line">    <span class="type">IA</span> <span class="variable">tiger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123; </span><br><span class="line">            System.out.println(<span class="string">&quot;老虎叫...&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>基于类的匿名内部类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// father 编译类型 Father, father 运行类型 Outer$1</span></span><br><span class="line">    <span class="type">Father</span> <span class="variable">father</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Father</span>(<span class="string">&quot;jack&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匿名内部类重写了 test 方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-3、成员内部类"><a href="#4-2-3、成员内部类" class="headerlink" title="4.2.3、成员内部类"></a>4.2.3、成员内部类</h3><p>成员内部类是定义在外部类的成员位置，并且没有static修饰</p><blockquote><p>说明：</p><ol><li>可以直接访问外部类的所有成员，包括私有的</li><li>可以添加任何修饰符，因为它的地位就是一个成员</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Outer08.<span class="type">Inner08</span> <span class="variable">inner08Instance</span> <span class="operator">=</span> outer08.getInner08Instance();</span><br><span class="line">    inner08Instance.say();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer08</span> &#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner08</span> &#123;<span class="comment">//成员内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//可以直接访问外部类的所有成员，包含私有的</span></span><br><span class="line">            <span class="comment">//如果成员内部类的成员和外部类的成员重名，会遵守就近原则. </span></span><br><span class="line">            <span class="comment">//可以通过 外部类名.this.属性 来访问外部类的成员</span></span><br><span class="line">            System.out.println(<span class="string">&quot;n1 = &quot;</span> + n1 + <span class="string">&quot; name = &quot;</span> + name + <span class="string">&quot; 外部类的 n1=&quot;</span> + Outer08.<span class="built_in">this</span>.n1);</span><br><span class="line">            hi();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4、静态内部类"><a href="#4-2-4、静态内部类" class="headerlink" title="4.2.4、静态内部类"></a>4.2.4、静态内部类</h3><p>成员内部类是定义再外部类的成员位置，有static修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Outer10.<span class="type">Inner10</span> <span class="variable">inner10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer10</span>.Inner10();</span><br><span class="line">    inner10.say();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer10</span> &#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner10</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;卡卡&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            cry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3、重载和重写"><a href="#4-3、重载和重写" class="headerlink" title="4.3、重载和重写"></a>4.3、重载和重写</h2><p><strong>重载</strong>发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载<br><strong>重写</strong>，子类重写父类方法，返回值（JDK7以后，被重写的方法返回值类型可以不同，但是必须是父类返回值的派生类）和形参都不能改变</p><blockquote><p>不能根据返回类型来区分重载<br>float max(int a, int b);<br>int max(int a, int b);<br>上面两个方法名称和参数都一致，如果在同一个类中，别的地方调用的时候都是max（1，2），不能区分出想调用哪个方法</p></blockquote><h2 id="4-4、抽象类和接口"><a href="#4-4、抽象类和接口" class="headerlink" title="4.4、抽象类和接口"></a>4.4、抽象类和接口</h2><p>1、接口的设计目的，是对类的行为进行约束。也就是提供一种机制，可以强制要求不同的类具有相同的行为。它只约束了行为的有无，但不对如何实现行为进行限制<br>2、而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为。可以在抽象类中实现这种行为。这样它所有的子类就无需重复实现。达到代码复用的目的</p><h2 id="4-5、Object类常用方法"><a href="#4-5、Object类常用方法" class="headerlink" title="4.5、Object类常用方法"></a>4.5、Object类常用方法</h2><ol><li>hashcode（）：将对象的16进制地址值，经过hash算法换算成整值</li><li>toString（）：返回该对象的字符串对象</li><li>equals（）：比较两个对象的地址值是否相同</li><li>clone（）：实现对象的浅拷贝</li><li>getclass（）：获取该对象的字节码文件（该对象运行时的类）Class</li><li>wait（）notify（）notifyAll（）：wait（）让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法</li></ol><blockquote><p>void notify()：唤醒一个正在等待该对象的线程。<br>  void notifyAll()：唤醒所有正在等待该对象的线程</p></blockquote><blockquote><ol><li>equals()没有被重写的情况下等同于 &#x3D;&#x3D;<br>  Object的equals()方法源码：<br> public boolean equals(Object obj) {<br> return (this &#x3D;&#x3D; obj);<br> }<br>  这用情况&#x3D; &#x3D;和equals（）都是引用比较 </li><li>string重写了Object的equals（）方法这种情况equals（）是值比较</li></ol></blockquote><h2 id="4-6、深拷贝和浅拷贝"><a href="#4-6、深拷贝和浅拷贝" class="headerlink" title="4.6、深拷贝和浅拷贝"></a>4.6、深拷贝和浅拷贝</h2><p><strong>浅拷贝</strong>：基本数据类型复制值，引用数据类型复制地址，即拷贝出来的对象与被拷贝出来的对象中的引用的对象是同一个（java默认）：clone方法<br><strong>深拷贝</strong>：基本数据类型复制值，引用数据类型，创建一个新的对象，并复制其内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用对象序列化来实现克隆</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Room</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    Desk desk;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> Room <span class="title function_">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream);</span><br><span class="line">        objectOutputStream.writeObject(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(outputStream.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inputStream);</span><br><span class="line">        <span class="type">Room</span> <span class="variable">roomClone</span> <span class="operator">=</span> (Room)objectInputStream.readObject();</span><br><span class="line">        <span class="keyword">return</span> roomClone;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-7、面向对象和面向过程的理解"><a href="#4-7、面向对象和面向过程的理解" class="headerlink" title="4.7、面向对象和面向过程的理解"></a>4.7、面向对象和面向过程的理解</h2><p>是两种不同的处理问题的角度。面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、及各自需要做什么</p><blockquote><p>比如：洗衣机洗衣服<br>  <strong>面向过程</strong>：会将任务拆解成一系列的步骤（函数），1、打开洗衣机 2、放衣服3、放洗衣粉4、清洗 5、烘干<br>  <strong>面向对象</strong>：会拆出人和洗衣机两个对象：人：打开洗衣机，放衣服，放洗衣粉 洗衣机：清洗，烘干</p></blockquote><p>从以上例子能看出，面向过程比较简单直接，而面向对象更易于复用、扩展和维护</p><h2 id="4-8、sleep（）和wait（）区别"><a href="#4-8、sleep（）和wait（）区别" class="headerlink" title="4.8、sleep（）和wait（）区别"></a>4.8、sleep（）和wait（）区别</h2><ol><li>所属的类型不同</li></ol><ul><li>wait()是Object类的实例方法,调用该方法的线程将进入WTING状态。 </li><li>sleep()是Thread类的静态方法,调用该方法的线程将进入TIMED_WTING状态</li></ul><ol><li>对锁的依赖不同</li></ol><ul><li>wait()依赖于synchronized锁,通过监视器进行调用,调用后线程会释放锁。</li><li>sleep()不依赖于任何锁,所以在调用后它也不会释放锁。</li></ul><ol><li>返回的条件不同</li></ol><ul><li>调用wait()进入等待状态的线程,需要由notify()&#x2F;notifyAll()唤醒,从而返回。 </li><li>调用sleep()进入超时等待的线程,需要在超时时间到达后自动返回。</li></ul><h1 id="5、枚举"><a href="#5、枚举" class="headerlink" title="5、枚举"></a>5、枚举</h1><h2 id="5-1、实现方式"><a href="#5-1、实现方式" class="headerlink" title="5.1、实现方式"></a>5.1、实现方式</h2><p> 枚举是一组常量的集合。 可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象  </p><h3 id="5-1-1、-自定义类实现枚举"><a href="#5-1-1、-自定义类实现枚举" class="headerlink" title="5.1.1、 自定义类实现枚举"></a>5.1.1、 自定义类实现枚举</h3><ol><li>不需提供set方法，因为枚举对象值通常为只读</li><li>对枚举对象&#x2F;属性使用final+static共同修饰，实现底层优化</li><li>枚举 对象名通常使用全部大写，常量的命名规范</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enumeration02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season.AUTUMN);</span><br><span class="line">        System.out.println(Season.SPRING);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-1-2、enum关键字实现枚举"><a href="#5-1-2、enum关键字实现枚举" class="headerlink" title="5.1.2、enum关键字实现枚举"></a>5.1.2、enum关键字实现枚举</h3><ol><li>当我们使用 enum 关键字开发一个枚举类时，默认会继承 Enum 类,  这样我们就可以使用 Enum 类相关的方法  </li><li>如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略</li><li>当有多个枚举对象时，使用,间隔，最后有一个分号结尾</li><li>枚举对象必须放在枚举类的行首</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Enumeration03</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Season2.AUTUMN);</span><br><span class="line">        System.out.println(Season2.SUMMER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演示使用 enum 关键字来实现枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season2</span> &#123;<span class="comment">//类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 如果有多个常量(对象)， 使用 ,号间隔即可</span></span><br><span class="line">    <span class="comment">//4. 如果使用 enum 来实现枚举，要求将定义常量对象，写在前面</span></span><br><span class="line">    <span class="comment">//5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 ()</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;温暖&quot;</span>), </span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;寒冷&quot;</span>), </span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;凉爽&quot;</span>), </span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;炎热&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;<span class="comment">//描述</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">()</span> &#123;<span class="comment">//无参构造器</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season2</span><span class="params">(String name, String desc)</span> &#123;<span class="comment">//有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6、注解"><a href="#6、注解" class="headerlink" title="6、注解"></a>6、注解</h1><pre><code> 注解(Annotation)也被称为元数据(Metadata)，用于修饰解释 包、类、方法、属性、构造器、局部变量等数据信息 。和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息  </code></pre><h2 id="6-1、基本注解介绍"><a href="#6-1、基本注解介绍" class="headerlink" title="6.1、基本注解介绍"></a>6.1、基本注解介绍</h2><p> 使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素 </p><p> 三个基本的 Annotation:  </p><ol><li>@Override: 限定某个方法，是重写父类方法, 该注解只能用于方法 </li><li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时 </li><li>@SuppressWarnings: 抑制编译器警告（当不希望看到某些警告使用该注解，都不想看到使用all）</li></ol><h2 id="6-2、自定义注解"><a href="#6-2、自定义注解" class="headerlink" title="6.2、自定义注解"></a>6.2、自定义注解</h2><p>修饰符：访问修饰符必须为public,不写默认为pubic；<br>关键字：关键字为@interface；<br>注解名称： 注解名称为自定义注解的名称，使用时还会用到；<br>注解类型元素：注解属性 ( 接口方法 ) 返回值类型要求 ,可以使用default来进行赋默认值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Info &#123; </span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;tracy&quot;</span>; </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDelete</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3、元注解"><a href="#6-3、元注解" class="headerlink" title="6.3、元注解"></a>6.3、元注解</h2><p>所谓元注解，其主要作用就是负责注解其他注解，为其他注解提供了相关的解释说明。<br>Java中存在五个元注解，分别是 @Target、@Retention、@Documented、@Inherited、@Repeatable</p><ol><li><strong>Target</strong>：描述了注解修饰的对象范围，取值在java.lang.annotation.ElementType定义，常用包括：</li></ol><blockquote><p>METHOD：用于描述方法<br>PACKAGE：用于描述包<br>PARAMETER：用于描述方法变量<br>TYPE：用于描述类、接口或enum类型</p></blockquote><ol start="2"><li><strong>Retention</strong>：表述注解保留时间的长短，取值在java.lang.annotation.RetentionPolicy中，取值：</li></ol><blockquote><p>SOURCE：在源文件中有效，编译过程中会被忽略<br>CLASS：随源文件一起编译在class文件中，运行时忽略<br>RUNTIME：在运行时有效(只有定义为RetentionPolicy.RUNTIME时，我们才能通过注解反射获取注解)</p></blockquote><ol start="3"><li><p><strong>Document</strong>：表明这个注解应该被 javadoc文档注释工具记录，正常情况下javadoc中不包含注解的，@Documented属于标志注解</p></li><li><p><strong>Inherited</strong>:被该注解注解的元注解注解某个类时，子类继承该注解</p></li><li><p>@Repeatable 是 Java 8 引入的一个注解，用于在同一个元素上多次使用相同的注解。通过使用 @Repeatable 注解，可以使得某个注解可以重复应用于同一目标上，而无需使用容器注解或数组</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Color(&quot;Red&quot;)</span></span><br><span class="line"><span class="meta">@Color(&quot;Blue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printColors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4、案例-自定义注解实现日志功能"><a href="#6-4、案例-自定义注解实现日志功能" class="headerlink" title="6.4、案例-自定义注解实现日志功能"></a>6.4、案例-自定义注解实现日志功能</h2><ol><li>定义一个注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Loggable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建切面类，使用 @Before 注解和 @AfterReturning 注解分别标记了在方法执行前和方法执行后执行的通知方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;@annotation(Loggable)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethodExecution</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Entering method: &quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;@annotation(Loggable)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethodExecution</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Exiting method: &quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在需要进行日志记录的方法上添加 @Loggable 注解即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="meta">@Loggable</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAnotherThing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、异常"><a href="#7、异常" class="headerlink" title="7、异常"></a>7、异常</h1><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251414029.png" alt="异常分类"></p><h2 id="7-1、Error（错误）"><a href="#7-1、Error（错误）" class="headerlink" title="7.1、Error（错误）"></a>7.1、<strong>Error（错误）</strong></h2><p>程序本身不能处理的异常，只能靠外接干预 （常见的如<strong>内存溢出</strong>，j<strong>vm虚拟机自身的非正常运行</strong>等）</p><h2 id="7-2、Exception（异常）"><a href="#7-2、Exception（异常）" class="headerlink" title="7.2、Exception（异常）"></a>7.2、<strong>Exception（异常）</strong></h2><p>是程序正常运行中，可以预料的意外情况。比如数据库连接中断，空指针，数组下标越界。异常出现可以导致程序非正常终止</p><p>（1）编译时异常<br>又叫可检查异常，Java语言强制要求捕获和处理所有非运行时异常。通过行为规范，强化程序的健壮性和安全性</p><p>（2）运行时异常<br>又叫不检查异常RuntimeException，这些异常一般是由程序逻辑错误引起的，即语义错</p><h1 id="8、常用类"><a href="#8、常用类" class="headerlink" title="8、常用类"></a>8、常用类</h1><h2 id="8-1、日期类"><a href="#8-1、日期类" class="headerlink" title="8.1、日期类"></a>8.1、日期类</h2><h3 id="8-1-1、第一代日期类Date（JDK1-0）"><a href="#8-1-1、第一代日期类Date（JDK1-0）" class="headerlink" title="8.1.1、第一代日期类Date（JDK1.0）"></a>8.1.1、第一代日期类Date（JDK1.0）</h3><ol><li>Date：精确到毫秒，代表特定瞬间</li><li>SimpleDateFormat：格式化（日期-文本）和解析日期（文本-日期）的类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy 年 MM 月 dd 日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="comment">// format：将日期转换成指定格式的字符串</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(d1); </span><br><span class="line"><span class="comment">// parse：格式化的String 转成对应的 Date</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1996 年 01 月 01 日 10:20:30 星期一&quot;</span>;</span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> sdf.parse(s);</span><br></pre></td></tr></table></figure><h3 id="8-1-2、第二代日期类Calendar（JDK1-1）"><a href="#8-1-2、第二代日期类Calendar（JDK1-1）" class="headerlink" title="8.1.2、第二代日期类Calendar（JDK1.1）"></a>8.1.2、第二代日期类Calendar（JDK1.1）</h3><p>Calendar它是一种抽象类，相比Date它在操作日历的时候提供了一些方法来操作日历字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calendar 是一个抽象类， 并且构造器是 private,可以通过 getInstance() 来获取实例</span></span><br><span class="line"><span class="comment">// Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建日历类对象</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance(); </span><br><span class="line"><span class="comment">//2. 获取日历对象的某个日历字段</span></span><br><span class="line">System.out.println(<span class="string">&quot;年：&quot;</span> + c.get(Calendar.YEAR));</span><br><span class="line"><span class="comment">// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号</span></span><br><span class="line">System.out.println(<span class="string">&quot;月：&quot;</span> + (c.get(Calendar.MONTH) + <span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;日：&quot;</span> + c.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(<span class="string">&quot;小时：&quot;</span> + c.get(Calendar.HOUR));</span><br><span class="line">System.out.println(<span class="string">&quot;分钟：&quot;</span> + c.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(<span class="string">&quot;秒：&quot;</span> + c.get(Calendar.SECOND));</span><br></pre></td></tr></table></figure><h3 id="8-1-3、第三代日期类LocalDate（JDK8）"><a href="#8-1-3、第三代日期类LocalDate（JDK8）" class="headerlink" title="8.1.3、第三代日期类LocalDate（JDK8）"></a>8.1.3、第三代日期类LocalDate（JDK8）</h3><ol><li><strong>Calendar日期类存在的问题？</strong></li></ol><p>（1）可变性，像日期和时间这样的类应该是不可变的<br>（2）格式化，格式化只对Date有用，Calendar只能自己拼装<br>（3）不是线程安全的；不能处理闰秒（每隔两天，多出一秒）等</p><ol start="2"><li><strong>基本概念</strong></li></ol><p>LocalDate：日期（年月日）<br>LocalTime：包含时间（时分秒）<br>LocalDateTime：包含日期+时间（年月日时分秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 使用 now() 返回表示当前日期时间的 对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now(); <span class="comment">//LocalDate.now();//LocalTime.now()</span></span><br><span class="line"><span class="comment">//2. 使用 DateTimeFormatter 对象来进行格式化</span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dateTimeFormatter.format(ldt);</span><br><span class="line">System.out.println(<span class="string">&quot;格式化的日期=&quot;</span> + format);</span><br><span class="line">System.out.println(<span class="string">&quot;年=&quot;</span> + ldt.getYear());</span><br><span class="line">System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;月=&quot;</span> + ldt.getMonthValue());</span><br><span class="line">System.out.println(<span class="string">&quot;日=&quot;</span> + ldt.getDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">&quot;时=&quot;</span> + ldt.getHour());</span><br><span class="line">System.out.println(<span class="string">&quot;分=&quot;</span> + ldt.getMinute());</span><br><span class="line">System.out.println(<span class="string">&quot;秒=&quot;</span> + ldt.getSecond());</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">now</span> <span class="operator">=</span> LocalDate.now(); <span class="comment">//可以获取年月日</span></span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalTime.now();<span class="comment">//获取到时分秒</span></span><br><span class="line"><span class="comment">// 3. 提供 plus 和 minus 方法可以对当前时间进行加或者减</span></span><br><span class="line"><span class="comment">//看看 890 天后，是什么时候 把 年月日-时分秒</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> ldt.plusDays(<span class="number">890</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;890 天后=&quot;</span> + dateTimeFormatter.format(localDateTime));</span><br><span class="line"><span class="comment">//看看在 3456 分钟前是什么时候，把 年月日-时分秒</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> ldt.minusMinutes(<span class="number">3456</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;3456 分钟前 日期=&quot;</span> + dateTimeFormatter.format(localDateTime2));</span><br></pre></td></tr></table></figure><h2 id="8-2、容器"><a href="#8-2、容器" class="headerlink" title="8.2、容器"></a>8.2、容器</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301540735.png" alt="image.png"></p><table><thead><tr><th>名称</th><th>底层</th><th>线程安全性</th><th>扩容机制</th><th>备注</th></tr></thead><tbody><tr><td>ArrayList</td><td>数组</td><td>线程不安全</td><td>首次创建长度为10，扩为1.5倍</td><td>查找快，增删慢</td></tr><tr><td>Vector</td><td>数组</td><td>线程安全</td><td>首次创建长度为10，扩为1.5倍</td><td>查找快，增删慢</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>线程不安全</td><td>不主动扩容</td><td>增删快，查找慢</td></tr><tr><td>HashSet</td><td>HashMap</td><td>线程不安全</td><td></td><td>可以存null</td></tr><tr><td>LinkedHashSet</td><td>LinkedHashMap</td><td>线程不安全</td><td></td><td>可以存null</td></tr><tr><td>TreeSet</td><td>TreeMap</td><td>线程不安全</td><td></td><td>不允许存null</td></tr><tr><td>HashMap</td><td>数组+链表（jdk7） 数组+链表+红黑树 （jdk8）</td><td>线程不安全</td><td>首次创建长度16，扩容2倍,负载因子0.75</td><td>可以存nul</td></tr><tr><td>LinkedHashMap</td><td>同hashmap</td><td>线程不安全</td><td>不主动扩容</td><td>可以存null</td></tr><tr><td>HashTable</td><td>数组+链表</td><td>线程安全</td><td>首次创建时长度为11，扩容为2n+1</td><td>不能为null</td></tr><tr><td>TreeMap</td><td>红黑树</td><td>线程不安全</td><td>TreeMap由红黑树实现，容量方面没有限制</td><td>不能为null 可以实现自然排序和定制排序</td></tr></tbody></table><h3 id="8-2-1、hashmap原理"><a href="#8-2-1、hashmap原理" class="headerlink" title="8.2.1、hashmap原理"></a>8.2.1、hashmap原理</h3><p>hashmap数据结构是数组+链表+红黑树，HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对<br>两个重要的方法put() get()<br>（1）.put方法：调用key的hash方法得hash值，再与（数组长度-1）做与（&amp;）运算，到这个元素在数组中的位置（即下标）如果该位置已经存在其它元素，那么在同一个位子上的元素将以链表的形式存放，通过equals方法依次比较链表中的key，相同则替换。不同则添加到表尾（1.8之前添加到表头）。<br>（2）.get方法：调用key的hash方法得到这个元素在数组中的位置（即下标），然后通过key的equals方法在对应位置的链表中找到需要的元素。</p><blockquote><p>（需要注意Jdk 1.8中对HashMap的实现做了优化,当链表长度大于8且数组长度超过64并之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)）<br>如果数组长度不足64，优先会进行扩容</p></blockquote><h3 id="8-2-2、自然排序和定制排序"><a href="#8-2-2、自然排序和定制排序" class="headerlink" title="8.2.2、自然排序和定制排序"></a>8.2.2、自然排序和定制排序</h3><p>自然排序：实现Comparable接口，实现compareTo方法</p><blockquote><p>典型实现：String，Integer，Date等</p></blockquote><p>定制排序：当元素对象没有实现comparable接口，又不方便修改，可以考虑使用定制排序，直接在调用方排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(arrayList, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="8-3、String"><a href="#8-3、String" class="headerlink" title="8.3、String"></a>8.3、String</h2><p>不可变性的理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;    <span class="comment">//(1)</span></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line"> </span><br><span class="line">s = <span class="string">&quot;123&quot;</span>;    <span class="comment">//(2)</span></span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br></pre></td></tr></table></figure><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270955924.jpg" alt="b6f0e64b3015ee2ebe2bd49b02c2a68.jpg|275"></p><p>s只是一个String对象的引用，并不是String对象本身。<br>当执行(1)处这行代码之后，会先在方法区的运行时常量池创建一个String对象”abc”，然后在Java栈中创建一个String对象的引用s，并让s指向”abc”<br>当执行完(2)处这行代码之后，会在方法区的运行时常量池创建一个新的String对象”123”，然后让引用s重新指向这个新的对象，而原来的对象”abc”还在内存中，并没有改变</p><p>为什么这样设计？<br>(1)、字符串常量池中的对象可能被很多对象引用，如果一个修改会导致所有对象的内容都变<br>(2)、hashmap中key的hash方法只会调用一次然后缓存起来，如果key可变会导致缓存的结果和真实的计算结果不一致</p><h2 id="8-4、ThreadLocal"><a href="#8-4、ThreadLocal" class="headerlink" title="8.4、ThreadLocal"></a>8.4、ThreadLocal</h2><h3 id="8-4-1、ThreadLocal原理"><a href="#8-4-1、ThreadLocal原理" class="headerlink" title="8.4.1、ThreadLocal原理"></a>8.4.1、ThreadLocal原理</h3><p>ThreadLocal即线程变量，它用于共享变量在多线程中的隔绝，即每个线程都有一个该变量的副本彼此互不影响也就不需要同步机制了<br>每个Thread对象都有一个ThreadLocalMap，当创建一个ThreadLocal的时候，就会将该ThreadLocal对象添加到该Map中，其中键就是ThreadLocal，值可以是任意类型。这样就实现了ThreadLocal在一个线程中是共享的，在不同线程之间是隔离的</p><h3 id="8-4-2、ThreadLocal存在的问题-内存泄漏"><a href="#8-4-2、ThreadLocal存在的问题-内存泄漏" class="headerlink" title="8.4.2、ThreadLocal存在的问题 - 内存泄漏"></a>8.4.2、ThreadLocal存在的问题 - 内存泄漏</h3><ol><li><strong>弱引用</strong></li></ol><p>正是因为有引用，对象才会在内存中存在。当对象的引用数量归零后，垃圾回收程序会把对象销毁。弱引用不会增加对象的引用数量。 引用的目标对象称为所指对象（referent）。 因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。</p><ol start="2"><li><strong>ThreadLocalMap的key使用弱引用原因</strong></li></ol><p>假如使用强引用，当ThreadLocal不再使用需要回收时，发现某个线程中ThreadLocalMap存在该ThreadLocal的强引用，无法回收，造成内存泄漏。因此，使用弱引用可以防止长期存在的线程（通常使用了线程池）导致ThreadLocal无法回收造成内存泄漏。</p><ol start="3"><li><strong>通常说的ThreadLocal泄露是什么原因</strong></li></ol><p>我们注意到Entry对象中，虽然Key(ThreadLocal)是通过弱引用引入的，但是value即变量值本身是通过强引用引入。<br>这就导致，假如不作任何处理，由于ThreadLocalMap和线程的生命周期是一致的，当线程资源长期不释放，即使ThreadLocal本身由于弱引用机制已经回收掉了，但value还是驻留在线程的ThreadLocalMap的Entry中。即存在key为null，但value却有值的无效Entry。导致内存泄漏。</p><ol start="4"><li><strong>怎么避免内存泄露？</strong></li></ol><p>1.Threadlocal自身做了一些处理，在每次调用ThreadLocal的get、set、remove方法时都会执行一个方法，该方法检测整个Entry[]表中对key为null的Entry一并擦除，重新调整索引</p><p>2.程序员自身，在代码逻辑中使用完ThreadLocal，都要调用remove方法，及时清理</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311121410065.png" alt="image.png"></p><h3 id="8-4-3、ThreadLocal使用场景"><a href="#8-4-3、ThreadLocal使用场景" class="headerlink" title="8.4.3、ThreadLocal使用场景"></a>8.4.3、ThreadLocal使用场景</h3><p>ThreadLocal最常见使用场景可用来解决数据库连接、Session用户管理等。</p><ol><li>数据库连接</li></ol><p>频繁创建和关闭Connection是一件非常耗费资源的操作，因此需要创建数据库连接池。ThreadLocal能够实现当前线程的操作都是用同一个Connection，保证了事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Connection&gt;() &#123;  </span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">initialValue</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>session用户管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadLocal</span> <span class="variable">threadSession</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();  </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title function_">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException &#123;  </span><br><span class="line">    <span class="type">Session</span> <span class="variable">s</span> <span class="operator">=</span> (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InfrastructureException</span>(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>避免一些参数的传递</p></li></ol><p>比如我们在底层方法用到某个参数时，不一定要从顶层方法一层层传下去，可以存到ThreadLocal，使用的时候直接去取</p><h1 id="9、泛型"><a href="#9、泛型" class="headerlink" title="9、泛型"></a>9、泛型</h1><h2 id="9-1、基本概念"><a href="#9-1、基本概念" class="headerlink" title="9.1、基本概念"></a>9.1、基本概念</h2><p>（1）泛型：Java在jdk5引入了泛型，在没有泛型之前，每次从集合中读取的对象都必须进行类型转换，如果在插入对象时，类型出错，那么在运行时转换处理的阶段就会报错。在提出泛型之后就可以明确的指定集合接受哪些对象类型，编译器就能知晓并且自动为插入的代码进行泛化，在编译阶段告知是否插入类型错误的对象，程序会变得更加安全清晰。<br>（2）泛型擦除：Java泛型是伪泛型，因为Java代码在编译阶段，所有的泛型信息会被擦除，Java的泛型基本上都是在编辑器这个层次上实现的，在生成的字节码文件中是不包含泛型信息的，使用泛型的时候加上的类型，在编译阶段会被擦除掉，这个过程称为泛型擦除。</p><p>为什么使用泛型？<br>（1）保证类型安全：可以确保在编译时期检测到类型不匹配的错误，避免在运行时出现类型转换错误<br>（2）消除强制转换：消除源代码中的许多强制类型转换，这使得代码更加可读，并且减少了出错机会</p><h2 id="9-2、泛型使用方式"><a href="#9-2、泛型使用方式" class="headerlink" title="9.2、泛型使用方式"></a>9.2、泛型使用方式</h2><p>泛型有三种使用方式，分别为：泛型类、泛型接口和泛型方法。</p><blockquote><p>T是泛型中的类型参数声明，它表示一个占位符,通常用大写字母表示（例如 T、E、K、V 等），但实际上它只是一个占位符，可以根据需要自定义</p><p>T：任意类型 type<br> E：集合中元素的类型 element<br> K：key-value形式 key<br> V：key-value形式 value</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItem</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getItem</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T element)</span>;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Utils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getFirstElement</span><span class="params">(List&lt;T&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list != <span class="literal">null</span> &amp;&amp; !list.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-3、泛型通配符"><a href="#9-3、泛型通配符" class="headerlink" title="9.3、泛型通配符"></a>9.3、泛型通配符</h2><p>泛型通配符是一种特殊的类型参数，用于在使用泛型时表示未知类型或限制类型范围</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1：表示类型参数可以是任何类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;?&gt;&#123;&#125; </span><br><span class="line"><span class="comment">// 2：表示类型参数必须是A或者是A的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T <span class="keyword">extends</span> <span class="title class_">A</span>&gt;&#123;&#125; </span><br><span class="line"><span class="comment">// 3: 表示类型参数必须是A或者是A的超类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T supers A&gt;&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="9-4、实现原理"><a href="#9-4、实现原理" class="headerlink" title="9.4、实现原理"></a>9.4、实现原理</h2><p>原码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caculate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Caculate</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Caculate</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> Object num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java的泛型称为伪泛型，因为Java的泛型只是编译期的泛型，一旦编译成字节码，泛型就被擦除了，即在Java中使用泛型，我们无法在运行期知道泛型的类型，一旦编译成字节码，泛型将被取代为Object。<br>在不使用泛型时，我们需要将Object手动转型成特定类型，而在使用泛型后，我们不需要自己转型，但实际上我们get到的对象仍然是Object类型的，只不过编译器会自动帮我们加入这个转型动作</p><h1 id="10、IO"><a href="#10、IO" class="headerlink" title="10、IO"></a>10、IO</h1><h2 id="10-1、概述"><a href="#10-1、概述" class="headerlink" title="10.1、概述"></a>10.1、概述</h2><h3 id="10-1-1、简介"><a href="#10-1-1、简介" class="headerlink" title="10.1.1、简介"></a>10.1.1、简介</h3><p>I（Input）O（Output）：中文翻译为输入输出，我们知道计算机的数据不管是软件、视频、音乐、游戏等最终都是存储在硬盘中的，当我们打开后，由CPU将硬盘中的数据读取到内存中来运行。这样一个过程就产生了I&#x2F;O（输入&#x2F;输出）</p><blockquote><p>输入：硬盘 -&gt; 内存<br>输出：内存 -&gt; 硬盘</p></blockquote><h3 id="10-1-2、IO流的分类"><a href="#10-1-2、IO流的分类" class="headerlink" title="10.1.2、IO流的分类"></a>10.1.2、IO流的分类</h3><p>按照操作数据单位不同分为：字节流（8bit）二进制文件，字符流（按字符）文本文件<br>按数据流的流向不同分为：输入流，输出流</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2996398/1659662289021-93129478-8cc1-4d9c-82c9-932c15153a37.png#clientId=u6ef58dc1-b2c2-4&from=paste&height=114&id=uf89be968&originHeight=167&originWidth=829&originalType=binary&ratio=1&rotation=0&showTitle=false&size=154323&status=done&style=none&taskId=u5d128cf6-4c3f-4321-a117-49823508580&title=&width=567" alt="image.png"></p><blockquote><p>java的IO流共涉及40多个类，都是从如上4个抽象基类派生</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308251511757.png" alt="IO流体系"></p><h2 id="10-2、字节流"><a href="#10-2、字节流" class="headerlink" title="10.2、字节流"></a>10.2、字节流</h2><h3 id="10-2-1、字节输出流"><a href="#10-2-1、字节输出流" class="headerlink" title="10.2.1、字节输出流"></a>10.2.1、字节输出流</h3><p>OutputStream是所有字节输出的顶层父类，该父类提供如下公共方法：</p><h4 id="10-2-1-1、FileOutputStream"><a href="#10-2-1-1、FileOutputStream" class="headerlink" title="10.2.1.1、FileOutputStream"></a>10.2.1.1、FileOutputStream</h4><p>FileOutputStream是OutputStream中一个常用的子类，他可以关联一个文件，用于将数据写出到文件</p><blockquote><p>构造方法：<br>public FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件。<br> public FileOutputStream(String name)： 创建文件输出流以指定的名称写入文件。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;000.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="string">&quot;abcde&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。</span></span><br><span class="line">        fos.write(b,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，在UTF-8编码下，一个中文占用3个字节，GBK编码下一个中文占用2个字节，因此在使用字节流来精确操作字符数据时将会变得非常麻烦</p></blockquote><h3 id="10-2-2、字节输入流"><a href="#10-2-2、字节输入流" class="headerlink" title="10.2.2、字节输入流"></a>10.2.2、字节输入流</h3><h4 id="10-2-2-1、FileInputStream"><a href="#10-2-2-1、FileInputStream" class="headerlink" title="10.2.2.1、FileInputStream"></a>10.2.2.1、FileInputStream</h4><p>java.io.FileInputStream类是文件输入流，从文件中读取字节</p><blockquote><p>构造方法：<br>FileInputStream(File file)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。<br> FileInputStream(String name)： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;abc.txt&quot;</span>); <span class="comment">// 文件中为abcde</span></span><br><span class="line">        <span class="comment">// 定义变量，作为有效个数</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// 定义字节数组，作为装字节数据的容器</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 每次读取后,把数组的有效字节部分，变成字符串打印</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(b, <span class="number">0</span>, len));<span class="comment">//  len 每次读取的有效字节个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3、字符流"><a href="#10-3、字符流" class="headerlink" title="10.3、字符流"></a>10.3、字符流</h2><p>计算机都是按照字节进行存储的，我们之前学习过编码表，通过编码表可以将字节转换为对应的字符，但是世界上有非常多的编码表，不同的编码表规定的单个字符所占用的字节可能都不一样，例如在GBK编码表中一个中文占2个字节，UTF8编码表则占3个字节；且一个中文字符都是由多个字节组成的，为此我们不能再基于字节的操作单位来操作文本文件了，因为这样太过麻烦，我们希望基于字符来操作文件，一次操作读取一个“字符”而不是一个“字节”，这样在操作文本文件时非常便捷</p><h3 id="10-3-1、字符输出流"><a href="#10-3-1、字符输出流" class="headerlink" title="10.3.1、字符输出流"></a>10.3.1、字符输出流</h3><h4 id="10-3-1-1、FileWriter类"><a href="#10-3-1-1、FileWriter类" class="headerlink" title="10.3.1.1、FileWriter类"></a>10.3.1.1、FileWriter类</h4><p>java.io.FileWriter类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo03_</span>写出字符数组 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;002.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 字符串转换为字节数组</span></span><br><span class="line">        <span class="type">char</span>[] chars = <span class="string">&quot;我是中国人&quot;</span>.toCharArray();</span><br><span class="line">        <span class="comment">// 写出字符数组</span></span><br><span class="line">        fw.write(chars); <span class="comment">// 我是中国人</span></span><br><span class="line">        <span class="comment">// 写出从索引2开始，2个字节。索引2是&#x27;中&#x27;，两个字节，也就是&#x27;中国&#x27;。</span></span><br><span class="line">        fw.write(chars,<span class="number">2</span>,<span class="number">2</span>); <span class="comment">// 中国</span></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-3-2、字符输入流"><a href="#10-3-2、字符输入流" class="headerlink" title="10.3.2、字符输入流"></a>10.3.2、字符输入流</h3><h4 id="10-3-2-1、FileReader类"><a href="#10-3-2-1、FileReader类" class="headerlink" title="10.3.2.1、FileReader类"></a>10.3.2.1、FileReader类</h4><p>java.io.FileReader类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区</p><blockquote><p>Windows系统的中文编码默认是GBK编码表。idea中默认是UTF-8 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IoTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 使用文件名称创建流对象</span></span><br><span class="line">        <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;001.txt&quot;</span>);</span><br><span class="line">        <span class="comment">// 定义变量，保存数据</span></span><br><span class="line">        <span class="type">int</span> data;</span><br><span class="line">        <span class="comment">// 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((data = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 以数值的方式输出</span></span><br><span class="line"><span class="comment">//            System.out.println(b);</span></span><br><span class="line">            <span class="comment">// 以字符的方式输出</span></span><br><span class="line">            System.out.println((<span class="type">char</span>) data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11、反射"><a href="#11、反射" class="headerlink" title="11、反射"></a>11、反射</h1><h2 id="11-1、概述"><a href="#11-1、概述" class="headerlink" title="11.1、概述"></a>11.1、概述</h2><h3 id="11-1-1、基本概念"><a href="#11-1-1、基本概念" class="headerlink" title="11.1.1、基本概念"></a>11.1.1、基本概念</h3><p>Java反射是指在运行时动态地获取类的信息并操作类或对象的能力。它提供了一组API，使得可以在运行时检查类、接口、字段和方法，并且可以在运行时实例化对象、调用方法、获取和设置字段的值</p><h3 id="11-1-2、好处"><a href="#11-1-2、好处" class="headerlink" title="11.1.2、好处"></a>11.1.2、好处</h3><ol><li>运行时类信息：反射允许在运行时获取类的信息，包括类的名称、字段、方法、注解等。这使得可以动态地了解和操作类的结构，从而实现更加灵活和通用的代码设计。</li><li>动态创建对象：通过反射可以在运行时动态地实例化对象，而不需要在编译时明确知道类的类型。这对于根据配置文件或用户输入来创建对象非常有用，可以实现更大程度的灵活性和可配置性。</li><li>动态调用方法：反射可以在运行时动态地调用类的方法，包括公共方法、私有方法和静态方法。这对于实现插件机制、扩展性和动态逻辑非常有用，可以根据运行时条件来调用不同的方法。</li><li>访问私有成员：反射可以绕过访问权限限制，访问类的私有成员。这对于测试、调试和特定场景下的操作非常有用，但也需要小心使用，以遵循封装原则。</li><li>序列化和反序列化：反射在序列化和反序列化过程中起着重要的作用。通过反射可以分析对象的结构，并将其转换为字节流或从字节流中重建对象</li></ol><h2 id="11-2、-获取Class对象的方式"><a href="#11-2、-获取Class对象的方式" class="headerlink" title="11.2、 获取Class对象的方式"></a>11.2、 获取Class对象的方式</h2><ol><li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。多用于配置文件，将类名定义在配置文件中。读取文件，加载类</li><li>类名.class：通过类名的属性class获取，多用于参数的传递 </li><li>对象.getClass()：getClass()方法在Object类中定义着</li></ol><blockquote><p>同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</p></blockquote><h2 id="11-3、Class对象功能"><a href="#11-3、Class对象功能" class="headerlink" title="11.3、Class对象功能"></a>11.3、Class对象功能</h2><ol><li>获取成员变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Field[] getFields() ：获取所有<span class="keyword">public</span>修饰的成员变量</span><br><span class="line">Field <span class="title function_">getField</span><span class="params">(String name)</span>   获取指定名称的 <span class="keyword">public</span>修饰的成员变量</span><br><span class="line">Field[] getDeclaredFields()  获取所有的成员变量，不考虑修饰符</span><br><span class="line">Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span>  </span><br></pre></td></tr></table></figure><ol start="2"><li>获取构造方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;?&gt;[] getConstructors()  返回<span class="keyword">public</span>修饰的构造方法</span><br><span class="line">Constructor&lt;T&gt; <span class="title function_">getConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span>  </span><br><span class="line">Constructor&lt;T&gt; <span class="title function_">getDeclaredConstructor</span><span class="params">(类&lt;?&gt;... parameterTypes)</span>  </span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors()  返回所有的构造方法</span><br></pre></td></tr></table></figure><ol start="3"><li>获取成员方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Method[] getMethods()  </span><br><span class="line">Method <span class="title function_">getMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span><br><span class="line">Method[] getDeclaredMethods()  </span><br><span class="line">Method <span class="title function_">getDeclaredMethod</span><span class="params">(String name, 类&lt;?&gt;... parameterTypes)</span>  </span><br></pre></td></tr></table></figure><ol start="4"><li>获取全类名</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getName</span><span class="params">()</span>  </span><br></pre></td></tr></table></figure><h2 id="11-4、Field-成员变量"><a href="#11-4、Field-成员变量" class="headerlink" title="11.4、Field 成员变量"></a>11.4、Field 成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 设置值</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">set</span><span class="params">(Object obj, Object value)</span>  </span><br><span class="line"><span class="number">2.</span> 获取值</span><br><span class="line">get(Object obj) </span><br><span class="line"><span class="number">3.</span> 忽略访问权限修饰符的安全检查</span><br><span class="line">setAccessible(<span class="literal">true</span>):暴力反射</span><br></pre></td></tr></table></figure><h2 id="11-5、Constructor-构造方法"><a href="#11-5、Constructor-构造方法" class="headerlink" title="11.5、Constructor 构造方法"></a>11.5、Constructor 构造方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T <span class="title function_">newInstance</span><span class="params">(Object... initargs)</span>  </span><br><span class="line">如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</span><br></pre></td></tr></table></figure><h2 id="11-6、Method-方法对象"><a href="#11-6、Method-方法对象" class="headerlink" title="11.6、Method 方法对象"></a>11.6、Method 方法对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 执行方法：</span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object obj, Object... args)</span>  </span><br><span class="line"><span class="number">2.</span> 获取方法名称：</span><br><span class="line">String getName:获取方法名</span><br></pre></td></tr></table></figure><h1 id="12、异常"><a href="#12、异常" class="headerlink" title="12、异常"></a>12、异常</h1><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310301636988.png" alt="image.png"></p><p>Error：错误，无法被处理的</p><p>Exception：异常，能够被程序本身处理的，可以通过try…catch语句捕捉异常，或者是throws抛出异常。分为运行时异常和非运行时异常</p><ul><li>运行时异常：就是RuntimeException，编译时不会检查出错误的。一般是由于逻辑错误引起的，程序员可以手动去解决的，比如判空等。</li><li>非运行时异常：也叫编译异常，就是Exception下除了RuntimeException以外的异常。是必须进行处理的异常，编译器会进行异常提醒的。如果不进行处理，程序编译不通过</li></ul><h1 id="13、日志"><a href="#13、日志" class="headerlink" title="13、日志"></a>13、日志</h1><h2 id="13-1、基本概念"><a href="#13-1、基本概念" class="headerlink" title="13.1、基本概念"></a>13.1、基本概念</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202310270851142.png" alt="image (26).png"></p><blockquote><p>常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。</p></blockquote><h2 id="13-2、java日志演化历史"><a href="#13-2、java日志演化历史" class="headerlink" title="13.2、java日志演化历史"></a>13.2、java日志演化历史</h2><p>（1）最开始出现的是 log4j，也是应用最广泛的日志系统，作者是 Ceki Gülcü，开始时，一切都是美好的。<br>（2）但 java 的开发主体 Sun 公司认为自己才是正统，为了干掉 log4j，在 jdk1.4 中增加了 jul（因为在 java.util.logging 包下）日志的实现，造成了目前开发者的混乱，迄今为止仍饱受诟病。<br>（3）各个日志系统互相没有关联，替换和统一变的非常麻烦。A 项目用 log4j 作为日志系统，但同时引了 B 项目，而 B 项目用 jul 作为日志系统，那么你的应用就得使用两个日志系统。<br>（4）为了搞定这个坑爹的问题，开源社区 apache 提供了一个日志框架作为日志的抽象，叫 commons-logging，也被称为 jcl（java common logging），jcl 对各种日志接口进行抽象，抽象出一个接口层，对每个日志实现都适配或者桥接，这样这些提供给别人的库都直接使用抽象层即可，较好的解决了上述问题。<br>（5）当年 Apache 说服 log4j 以及其他的日志来按照 commons-logging 的标准编写，但是由于 commons-logging 的类加载有点问题，实现起来也不友好，作为元老级日志 log4j 的作者再度出山，搞出了一个更加牛逼的新的日志框架 slf4j（这个也是抽象层），同时针对 slf4j 的接口实现了一套日志系统，即传说中的 logback。<br>（6）同时这个作者心情一好，又把 log4j 进行了改造，就是所谓的 log4j2，同时支持 jcl 以及 slf4j。</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> java </tag>
            
            <tag> core </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认知</title>
      <link href="/posts/31940.html"/>
      <url>/posts/31940.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、硅基生命和碳基生命"><a href="#1、硅基生命和碳基生命" class="headerlink" title="1、硅基生命和碳基生命"></a>1、硅基生命和碳基生命</h1><p>碳基生命：碳基生命是我们所熟知的地球上的生命形式，包括所有的生物，从微生物到植物和动物。碳是碳基生命的主要构建块，因为碳具有独特的化学性质，能够形成稳定的共价化学键。碳可以与其他元素，如氢、氧、氮和磷等，形成复杂的有机化合物，包括蛋白质、核酸、脂质等生物分子。碳基生命依赖于水作为生命体内的溶剂，并且其生物过程是基于碳的有机化学反应进行的。</p><p>硅基生命：硅基生命是一种假设存在于宇宙中的生命形式，其基本结构和生物分子基于硅元素而非碳。硅与碳具有相似的化学性质，也能够形成稳定的共价键。因此，一些科学家认为在特定的条件下，硅也可能成为构建生命体的基本元素。硅基生命假设硅代替碳构建生命体的核酸、蛋白质和其他生物分子，使用其他溶剂代替水。硅基生命的研究仍然处于理论和推测阶段，尚未发现确凿的证据</p><h1 id="2、西西弗斯的惩罚"><a href="#2、西西弗斯的惩罚" class="headerlink" title="2、西西弗斯的惩罚"></a>2、西西弗斯的惩罚</h1><p>希腊神话中，西西弗斯是科林斯的国王。作为统治者，他常常苦恼自己的王国没有充足的饮用水。<br>有一天，事情迎来了转机。西西弗斯无意之中，看到了众神之王宙斯化作鹰的模样绑架河神的女儿伊琴娜的一幕。<br>河神得知女儿失踪，感到悲伤不已。于是，西西弗斯便向河神提出一个交易：如果河神为他的王国创造一个四季常流的河川，他就告诉河神伊琴娜的行踪。河神答应了西西弗斯的请求。<br>这一举动触怒了宙斯，他命令死神将西西弗斯打入阴森的地狱。然而西西弗斯是足智多谋的，他早预言死神会来到他身边。西西弗斯请求死神展示一下如何使用锁链，然后趁机捆住死神！这下子西西弗斯逃离了死神的魔爪，一如既往地过着舒适快乐的生活。<br>一段时间过后，因为死神的消失，世间上再也没有人死去。直到冥王再也忍受不了地狱的荒凉寂寞，决定下命令让战神去解救死神。<br>最终西西弗斯还是进了地狱，不过他早已在死前就想好了计谋。在冥王面前，他假惺惺地诉苦道：自己的妻子是个冷漠无情的人，现在尸体还像狗一样被扔到公共广场上，更何况举办盛大的葬礼呢。他请求冥王让他回到人间，了却这一桩心愿。于是冥王允许他处理完自己的葬礼之后回到地狱。西西弗斯窃喜不已，他如愿回到人间后，便违背了与冥王的约定。<br>众神一怒之下，决定对西西弗斯实施最严厉的惩罚：要求他将一块巨石从平地推到山顶。但由于诅咒的力量，每当巨石抵达山顶的瞬间，就会变得异常沉重，一次又一次滚回起点。西西弗斯便在永无止境当中，不断循环往复推着巨石抵达山顶。</p><h1 id="3、日本偷袭珍珠港的原因"><a href="#3、日本偷袭珍珠港的原因" class="headerlink" title="3、日本偷袭珍珠港的原因"></a>3、日本偷袭珍珠港的原因</h1><p>1941年7月，希特勒的军队正在俄国平原上狂飙猛进，伦敦和华盛顿对此忧心忡忡。因为，一旦苏联崩溃，所有的压力将重新回到英伦三岛的头上。英国能否顶得住德军的全力一击，实属悲观；而英国的失败，将直接导致美国失去他在欧洲的唯一立脚点，美国将会永远失去介入战争的机会。日本陆军正在中国东北大量集结，对苏的进攻似乎箭在弦上。<br>这让伦敦和华盛顿如芒在背，一旦日本配合德国进攻苏联，苏联的困境会呈几何级数地增加，苏联崩溃几乎就是眼前的事了。</p><p>然而，没有国会的授权，没有舆论的支持，对日宣战是不可能的。这种情况下，此前一直在讨论并屡屡被搁置的对日石油禁运，这个时候就有了现实的意义，这也是总统职权范围内的事情，无须国会批准。日本90%石油靠美国，美国对日本采取石油禁运制裁之后，日本国内石油储备只剩下800万吨、仅够使用两年，如果不去东南亚抢夺石油，两年之后日本的军舰飞机就发动不了，但侵略东南亚会严重损害英美利益，日本军部权衡再三还是决定赌上国运、同时对英美开战，山本五十六反对开战无效，只能硬着头皮干下去，于是山本策划了偷袭珍珠港方案，力图开战之初就重创美国太平洋舰队，使其无法投入到东南亚战场，山本的计划成功了，日本得以在半年之内征服东南亚，获得了大量石油资源。</p><h1 id="4、美国的金融霸权"><a href="#4、美国的金融霸权" class="headerlink" title="4、美国的金融霸权"></a>4、美国的金融霸权</h1><p><strong>1、黄金霸权时代</strong><br>一切的来由，要从1944年的布雷顿森林体系说起。  一战美国保持中立大发战争横财，吸收了当时欧洲的大规模黄金，增加了自身的黄金储备。二战前期美国仍保持中立，抓住时机快速发展，同时继续发战争财，不知不觉间超越英法成为世界第一强国。所以在二战即将结束时，美国一跃成了当时的世界军事、经济第一强国，美国的黄金储备也达到全世界的70%，即在1944年的布雷顿国家森林公园建立了美元霸权。从此美元直接与黄金挂钩，只有美元才可以直接兑换黄金，美金，美金，也是由此而来。从此后，国际贸易以美元结算。可是黄金的总量是有限，而美元是可以无限印的，所以但要维持汇率稳定和美元价值稳定，就是要你有多少黄金，就只能印多少美元出来流通。  60-70年代，美国深陷越战泥潭，为了维持军费战争开支，美国超印美元，美元不断贬值，产生信用危机，各国政府开始纷纷拿着美元去美联储换黄金，1971年8月15日，美国尼克松总统宣布停止用美元兑换黄金，布雷顿森林体系瓦解，美元不再和黄金直接挂钩。对，就是不给你换，就是要让你拿着贬值的美元，自己承担损失，有本事你过来抢啊？但你打得过我吗？各国没办法，吃了这个哑巴亏。  </p><p><strong>2、石油霸权时代</strong></p><p>自布雷顿森林体系瓦解后，美国深陷信任危机，但国际市场上，因为几十年来习惯用美元结算，一时间没有哪国货币能够取代美元地位，这也就给了美国重建美元信心的机会。  1973年，第四次中东战争爆发，因为美国暗中支持以色列，引起对手阿拉伯等国家不满，为了打击美国，阿拉伯等周边石油生产国联合抬高石油价格，削减产量，同时禁止石油出口美国。  以弱者身份去威胁强者，是可笑的。它不威胁还好，一威胁还让美国发现了黄金的替代品，当代工业的血液——石油。  很快美国通过经济手段和军事手段，软硬兼施，威逼利诱，逼阿拉伯等主要石油产国与美国签订协议，要求以后石油必须以美元结算，就此美国重新建立了美元霸权。  作为工业的血液——石油，不管是世界上哪个国家，都需要，没有办法，谁让自己不够强大呢？  全世界都离不开美元这个国际货币，自此美国大量印钱买他国商品，他国为了生存也只能增加美元外汇储备，但是都需要用真金白银等实物去换。就这样美国开始收取全世界的铸币税，只要有美元流通使用的地方，就有铸币税收入。  那什么是铸币税呢？简单来讲，铸币税就是纸币的面值和纸币的生产成本之间的差价，比如100块钱面值只需要1块钱，这差价就是99元，这就是铸币税。很多国家靠商品，贷款啊，获得美元，购买石油，多余的怎么办，就如中国这般对美国是长期贸易顺差的国家，赚取的大量外汇深入能干嘛？  如果流入本国，就会造成本国通货膨胀，所以不得已去购买美国国债，或者买美国金融产品，股票等，让热钱不断回流美国，回流到华尔街，美国再通过这些钱，买国外商品，钱不需要印多，只用纸做的美元，就可以源源不断买外国商品，形成了一种回流体系。如今美国国债规模已经达到了26万亿美元，本息总和已经超过了全世界人民能够创造的财富总和，所以知道为什么全世界都在供养着美国人民的奢侈生活了吗？  如今时代，全世界各国都绑上了美元这辆战车，美元跌，全世界跌，美元稳，全世界稳，利益挂钩，难解难分。美国空手钱生钱，通过货币霸权还控制了各国的经济命脉。  世界贸易流通离不开美元。</p><blockquote><p>美国可以通过控制降息，升息随意薅各国羊毛:<br>1.降息释放美元流动性<br>降息会导致资金从银行流向世界各地。由于美国在国际货币结算占据39%左右的份额，也就是说美国把印的钱投资向全世界。尤其是落后的发展中国家，他们为了发展本国经济但资金不够，都愿意借钱增加负债来进行发展。这样，美国即享受到了他国经济发展的红利，又完成了一个“养韭菜”的动作，为下一步收割进行铺垫<br>2.加息资金回流<br>美元一旦加息，就会吸引资金从其他国家抽离，回流美国。资金流出国货币大量兑换成美元，导致本国货币贬值。持有的美元债务还是要以美元偿还的，也就意味着偿还相同金额的美元债务需要付出更多的本国货币或资产，包括股票等风险资产。最严重的是，为了偿还美债和提振经济而印钱，更会加剧通货膨胀和本国货币贬值，直至爆发经济危机<br>3.收割<br>随着美元加息，一些国家或企业会因为资金被抽离，严重缺钱，负债增加，就可能造成企业甚至国家破产。随后，美国由于加息回收了大量资金以及吸收了全世界的资金。有了这些资金就可以大肆低价收购全球因资金链断裂破产的优势资产，完成“割韭菜”的目标</p></blockquote><h1 id="5、马云为何跌落神坛？"><a href="#5、马云为何跌落神坛？" class="headerlink" title="5、马云为何跌落神坛？"></a>5、马云为何跌落神坛？</h1><p>他已经不满足于只掌握着80%的财富了，现在还想让中国人欠他们200%的债务</p><p>2020年10月25日，上海，外滩金融峰会。马云批评金融监管机构胆子太小，步子太慢，执着于将风险最小化。指责国内的银行是“当铺”思维，只贷款给那些可以提供资产抵押的企业。第二天，金融机构约谈马云和蚂蚁集团高层。第三天，上海证券交易所宣布暂停蚂蚁集团的IPO。</p><p>2020年蚂蚁放贷规模超过4万亿。借呗当时自有资金只有30亿，但是却贷款了3600亿，形成了100倍杠杆。这样有没有风险？安不安全？ 风险非常大！一旦出事，就是地震级！ 这3600亿资产规模中，只有30亿是蚂蚁的本金，一旦出问题，贷款收不回，它最多赔光30亿。剩下的3580亿谁来兜底？答案是储户。让中国新一代的年轻人刚毕业就背一屁股贷款，真的对国家、对社会好吗？这方面人类的教训很多很多，随便就抓一把，但人类好像永远不长记性：荷兰郁金香泡沫、英国南海泡沫事件、亚洲金融海啸、美国次贷危机…… </p><p>只希望国家对金融的监管坚持从严管控，因为金融一旦出问题，影响的就是千千万万家庭</p><h1 id="6、白左"><a href="#6、白左" class="headerlink" title="6、白左"></a>6、白左</h1><p>白左是指有偏见的精英主义者忽视社会现实，常年使用双重标准，他们只关心移民、少数族裔、LGBT（同性恋，双性恋，跨性别者）和环保问题，而且对真实世界中的真实问题无知无觉，他们沉迷于政治正确，甚至到了为多元文化主义而容忍落后伊斯兰价值观的程度。除此之外，白左还“可怜世上的其他人，认为自己是救世主”</p><blockquote><p>1.盲目强调政治正确（参看60s-70s的某朝）<br> 2.纵容少数族裔&#x2F;难民获得与其奋斗精神不符的特权<br> 3.给少数族裔&#x2F;难民的特权，极少出于其所谓的普世价值观，而更多的出于息事宁人的态度。这就是为什么闹的最凶的族裔&#x2F;人群（msl（穆斯林），latino(拉丁)，african american（美国黑人））才能获得特权，而闹的不凶的就受到打压（亚裔）。尽管事实上亚裔的人数比latino少一个数量级</p></blockquote><h1 id="7、伊朗和沙特"><a href="#7、伊朗和沙特" class="headerlink" title="7、伊朗和沙特"></a>7、伊朗和沙特</h1><p>沙特是逊尼派穆斯林，拥有<strong>麦加和麦地那</strong>两座伊斯兰教圣城，所以，沙特以全球穆斯林的领袖自居。<br>伊朗是什叶派穆斯林，因沙特当年对伊朗朝觐的信徒迫害过，伊朗就认为沙特王室不合法，想要推翻沙特王室。<br>其实两国宗教矛盾的起因都来自一个人，这个人就是伊斯兰教创始人默罕默德。</p><p><strong>伊斯兰教为什么会有三大圣地？</strong></p><p>公元570年，伊斯兰教的创立者穆罕默德出生在阿拉伯半岛的麦加城，他的童年很不幸，父母早早离开了人世。穆罕默德的少年时代非常清苦，12岁就随着伯父四处经商，在经商的过程中，他接触到了各地不同的原始宗教，这给他留下了深刻的印象。当时的阿拉伯半岛，有一条连接东西方繁荣的商道，每天的商队络绎不绝，这也让旁边的两个大国波斯和拜占庭垂涎已久。于是，两国为了争夺商道开始了长达一个世纪的战争，很多商人不是被抢就是被杀，在阿拉伯半岛生活的底层老百姓非常艰难。穆罕默德为了让老百姓摆脱困境，就想创立一种新的宗教，把阿拉伯半岛统一起来。</p><p>公元610年，已经40岁的穆罕默德在麦加城外的一个山洞里修行，突然，天使伽百利降临，让穆罕默德以真主安拉的名义传播伊斯兰教。自此，穆罕默德自称是伊斯兰教的最后一位先知，先知就是指接受上帝安拉启示的人，并能够传达安拉的旨意。随后，穆罕默德开始到各地传播伊斯兰教，那些生活贫困、深受压迫的底层群众纷纷加入伊斯兰教，阿拉伯半岛的伊斯兰教信徒也越来越多。随着穆罕默德的威望与日俱增，贵族的利益受到了侵犯，于是，贵族们纷纷起立反对伊斯兰教。麦加城最大的贵族阿布·苏菲扬准备暗杀穆罕默德，但这一消息走漏了风声，被穆罕默德知道了。随后，穆罕默德带着自己的信徒离开了麦加，来到了北方的城市麦地那，这也成为了伊斯兰教第二大圣地。</p><p>公元621年的一个夜晚，穆罕默德在天使吉卜利勒的陪同下，来到了耶路撒冷夜游，穆斯林认为耶路撒冷是最神圣的地方，所以，这里成为了伊斯兰教第三大圣地。<br>穆罕默德到了麦地那后，他的宗教和政治主张深受人们的赞赏，当地人纷纷加入了伊斯兰教，并组织起了一支军队。大贵族阿布·苏菲扬看到穆罕默德日益强大后，就想铲除后患，于是，率领大军攻打圣城麦地那，结果以失败告终。随后，穆罕默德率领军队杀回了麦加城，从此，麦加城成为了伊斯兰教的第一大圣地，古老的克尔白庙成了穆斯林朝圣礼拜的中心。</p><p><strong>伊斯兰教为什么分为逊尼派和什叶派？</strong></p><p>穆罕默德利用伊斯兰教统一了阿拉伯半岛，并在原有的土地上建立了一个政教合一、强大的阿拉伯帝国。公元632年，穆罕默德突然去世，但是，生前他并没有指定谁来当继承人哈里发。哈里发在阿拉伯语中的意思就是继承人，是阿拉伯帝国最高统治者，类似于我国古代的皇帝。这时就出现了一个问题，由谁来当哈里发伊斯兰教信徒们产生了分歧。其中主要有两派，一派认为应推举有能力的贤者担任，另一派则认为应由与穆罕默德有血缘关系的后代担任。</p><p><strong>认为由贤者担任的穆斯林就形成了现在的逊尼派，认为由穆罕默德后代担任的穆斯林就形成了现在的什叶派。</strong></p><p>穆罕默德死后，前三任哈里发都是通过选举产生的。阿拉伯帝国也开始迅速对外扩张，先后占领了波斯（现在的伊朗地区），叙利亚、伊拉克、埃及的等地区。<br>奥斯曼当上第三任哈里发后，开始纵情享乐、挥霍无度。这时，穆罕默德的堂弟兼女婿阿里趁机创立了“什叶派”，并发动了推翻奥斯曼的斗争。<br>奥斯曼最终被刺死，阿里当上了第四任哈里发，成为了“什叶派”的领袖。但是，这也引起了叙利亚总督穆阿维亚的不满，他是“逊尼派”领袖，并且是第三任哈里发奥斯曼的侄子。于是，阿里和穆阿维亚开始了战争，经过厮杀，双方最终讲和。阿里妥协的行为引起了一些“什叶派”人的不满，于是，一些人就从“什叶派”脱离出来，组成了“哈瓦利吉”派，并派人刺杀阿里和穆阿维亚。最终，阿里被刺死，穆阿维亚幸存了下来，并且平定了“哈瓦利吉”派的叛乱，当上了哈里发。穆阿维亚当时哈里发后，违背了“逊尼派”的选举制，制定了世袭制，把政权交给自己的儿子。这时，波斯的贵族阿巴斯不满穆阿维亚的做法：“你不是说好的选举产生哈里发吗？怎么又改成世袭制了？”阿巴斯自称是穆罕默德叔叔的后代，哈里发应由穆罕默德出身的哈西姆氏族担任，于是发动战争，打败了穆阿维亚。从此，逊尼派和什叶派彻底决裂，结下了不共戴天之仇。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常识 </tag>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="/posts/13153.html"/>
      <url>/posts/13153.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、数据库基础概念"><a href="#1、数据库基础概念" class="headerlink" title="1、数据库基础概念"></a>1、数据库基础概念</h1><h2 id="1-1、mysql数据类型"><a href="#1-1、mysql数据类型" class="headerlink" title="1.1、mysql数据类型"></a>1.1、mysql数据类型</h2><table><thead><tr><th><strong>分类</strong></th><th><strong>类型名称</strong></th><th><strong>类型说明</strong></th></tr></thead><tbody><tr><td>整数</td><td>tinyInt</td><td>微整型：占8位二进制，1个字节 （-128-127）</td></tr><tr><td></td><td>smallint</td><td>小整型：占16位二进制，2个字节（-32768-32767）</td></tr><tr><td></td><td>mediumint</td><td>中整型：占24位二进制，3个字节（-8388608-8388607）</td></tr><tr><td></td><td><strong>int</strong>(integer)</td><td>整型：占32位二进制，4个字节（-2147483648-2147483647）</td></tr><tr><td></td><td><strong>bigint</strong></td><td>大整型：占64位二进制，8个字节（-9223372036854775808-9223372036854775807）</td></tr><tr><td>小数</td><td><strong>float</strong></td><td>单精度浮点数，占4个字节</td></tr><tr><td></td><td><strong>double</strong></td><td>双精度浮点数，占8个字节</td></tr><tr><td></td><td>decimal(m,n)</td><td>高精度小数型，最大精度为65，最大占用空间30字节</td></tr><tr><td>日期</td><td><strong>time</strong></td><td>表示时间类型 yyyy-MM-DD ，3字节</td></tr><tr><td></td><td><strong>date</strong></td><td>表示日期类型 hh:mm:ss ，3字节</td></tr><tr><td></td><td><strong>datetime</strong></td><td>同时可以表示日期和时间类型，8字节</td></tr><tr><td>字符串</td><td>char(m)</td><td><strong>固定长度的字符串，无论使用几个字符都占满全部</strong>，M为0~255之间的整数 如：char(20)，实际使用只用了1个字符，也占用20个字符</td></tr><tr><td></td><td><strong>varchar</strong>(m)</td><td><strong>可变长度的字符串，使用几个字符就占用几个</strong>，M为0~65535之间的整数。 如：varchar(20)，这个字符串最长是20，大于20会报错。 使用几个，占几个字符。</td></tr></tbody></table><h2 id="1-2、事务的特性"><a href="#1-2、事务的特性" class="headerlink" title="1.2、事务的特性"></a>1.2、事务的特性</h2><p>如果一个业务操作中多次访问了数据库，必须保证每条SQL语句都执行成功。如果其中有一条执行失败，那么所有已经执行过的代码必须回滚（撤销）。回到没有执行前的状态。称为事务。简单来说就是要么所有的SQL语句全部执行成功，要么全部失败</p><table><thead><tr><th><strong>事务特性</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>原子性（Atomicity）</td><td>一个事务内的所有操作要么都执行，要么都执行失败</td></tr><tr><td>一致性（Consistency）</td><td>事务执行前与执行后，数据库中数据应该保持相同的状态。如：转账前总金额与转账后总金额相同。</td></tr><tr><td>隔离性（Isolation）</td><td>指的是一个事务在最终提交前，对其它事务是不可见的</td></tr><tr><td>持久性（Durability）</td><td>如果事务执行成功，对数据库的操作是持久的。</td></tr></tbody></table><h2 id="1-3、并发访问下事务产生的问题"><a href="#1-3、并发访问下事务产生的问题" class="headerlink" title="1.3、并发访问下事务产生的问题"></a>1.3、并发访问下事务产生的问题</h2><p>当同时有多个用户在访问同一张表中的记录，每个用户在访问的时候都是一个单独的事务。事务在操作时的理想状态是：事务之间不应该相互影响，实际应用的时候会引发下面三种问题：</p><ol><li>脏读： 一个事务（用户）读取到了另一个事务没有提交的数据</li><li>不可重复读：一个事务多次读取同一条记录，出现读取数据不一致的情况。一般因为另一个事务更新了这条记录而引发的。</li><li>幻读：在一次事务中，多次读取到的条数不一致</li></ol><h2 id="1-4、事务的隔离级别"><a href="#1-4、事务的隔离级别" class="headerlink" title="1.4、事务的隔离级别"></a>1.4、事务的隔离级别</h2><p>为了尽量避免这些问题的发生。通过数据库本身的功能去避免，设置不同的隔离级别</p><table><thead><tr><th><strong>级别</strong></th><th><strong>名字</strong></th><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th><th><strong>数据库默认隔离级别</strong></th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>读未提交</td><td>read uncommitted</td><td>是</td><td>是</td><td>是</td><td></td><td>事务A可以读取到事务B未提交的数据</td></tr><tr><td>2</td><td>读已提交</td><td>read committed</td><td>否</td><td>是</td><td>是</td><td>Oracle和SQL Server</td><td>事务A只能读取其它事务已提交的数据（避免了脏读）</td></tr><tr><td>3</td><td>可重复读</td><td>repeatable read</td><td>否</td><td>否</td><td>是</td><td>MySQL</td><td>保证在同一个事务中多次读取同样数据的结果是一样的</td></tr><tr><td>4</td><td>串行化</td><td>serializable</td><td>否</td><td>否</td><td>否</td><td></td><td>事务串行化顺序执行</td></tr></tbody></table><blockquote><p>隔离级别越高，安全性就越高，性能越低</p></blockquote><h2 id="1-5、mysql索引分类"><a href="#1-5、mysql索引分类" class="headerlink" title="1.5、mysql索引分类"></a>1.5、mysql索引分类</h2><ol><li>按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。 </li><li>按物理存储分类可分为：聚簇索引（innodb）、非聚簇索引（myisam）。</li></ol><blockquote><p>聚簇索引：顾名思义，索引和数据是放在一块的。其叶子节点中存放的就是整张表的行记录数据。我们称之为聚集索引（如果创建了主键，这个主键索引就是聚簇索引，如果没有，innodb建立一个隐藏的row-id作为聚集索引）<br>非聚集索引：一般也称为二级索引或者辅助索，非聚集索引的叶子节点不存储表中的数据，而是存储索引值和数据对应主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表</p></blockquote><ol start="3"><li>按字段特性分类可分为：主键索引、唯一索引、普通索引、前缀索引。</li></ol><blockquote><p><strong>主键索引</strong>：建立在主键上的索引被称为主键索引，一张数据表只能有一个主键索引，索引列值不允许有空值<br><strong>唯一索引</strong>：建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为空<br><strong>普通索引</strong>：建立在普通字段上的索引被称为普通索引<br><strong>前缀索引</strong>：文本的前几个字符建立索引（具体是几个字符在建立索引时指定），这样建立起来的索引更小，所以查询更快<br>CREATEINDEX index_name ONtable_name (column_name(length));</p></blockquote><ol start="4"><li>按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。</li></ol><blockquote><p>单列索引：建立在单个列上的索引被称为单列索引<br>联合索引：建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引<br>（复合索引遵守“最左前缀”原则，即在查询条件中从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分）</p></blockquote><h2 id="1-6、索引设计原则"><a href="#1-6、索引设计原则" class="headerlink" title="1.6、索引设计原则"></a>1.6、索引设计原则</h2><p><strong>适合建索引的场景</strong></p><ol><li>频繁作为where条件语句查询的字段</li><li>关联字段需要建立索引，例如外键字段，student表中的classid,   classes表中的schoolid 等</li><li>分组排序字段可以建立索引</li><li>统计字段可以建立索引（如.count(),max()）</li></ol><p><strong>不适合建索引的场景</strong></p><ol><li>频繁更新的字段不适合建立索引（需要重建索引）</li><li>where条件中用不到的字段不适合建立索引</li><li>表数据可以确定比较少的不需要建索引</li><li>数据重复且发布比较均匀的的字段不适合建索引（唯一性太差的字段不适合建立索引），例如性别，真假值</li></ol><h2 id="1-7、索引失效的情况"><a href="#1-7、索引失效的情况" class="headerlink" title="1.7、索引失效的情况"></a>1.7、索引失效的情况</h2><ol><li><p>or连接的条件不是每一个列都有索引，这时有索引的列也会失效 </p></li><li><p>复合索引遵守“最左前缀”原则，在通过联合索引检索数据时，从索引中最左边的列开始，一直向右匹配，如果遇到范围查询(&gt;、&lt;、between、like等)，就停止后边的匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eg：建立复合索引index:(a,b,c) --- 实际上已经建立了三个联合索引(a)、(a,b)、(a,b,c)</span><br><span class="line">select * from table where a = &#x27;1&#x27;  //走索引</span><br><span class="line">select * from table where c = &#x27;1&#x27;  //不走索引</span><br><span class="line">where a like &#x27;xxx%&#x27; and b=yyy and c=zzz </span><br></pre></td></tr></table></figure></li><li><p>like查询是以%开头（以%结尾，索引可以使用）</p></li></ol><blockquote><p>B+树，索引是有序排列的。索引的排列顺序是根据比较字符串的首字母排序的，如果首字母相同，就根据比较第二个字母进行排序，以此类推。以%开头，首字母不确定</p></blockquote><ol start="4"><li>存在索引列的数据类型隐形转换，则用不上索引（比如列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引）</li><li>where 子句里对索引列上有数学运算，用不上索引</li><li>where 子句里对有索引列使用函数，用不上索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引（比如数据量极少的表）</li></ol><h2 id="1-8、InnoDB和MyISAM"><a href="#1-8、InnoDB和MyISAM" class="headerlink" title="1.8、InnoDB和MyISAM"></a>1.8、InnoDB和MyISAM</h2><p>innoDB：innodb是mysql默认存储引擎，支持事务，行锁和外键等<br>MyISAM：myisam是mysql5.1版本前默认存储引擎，不支持事务，外键。默认锁的粒度为表锁</p><table><thead><tr><th></th><th>InnoDB</th><th>MyISAM</th></tr></thead><tbody><tr><td>外键</td><td>支持</td><td>不支持</td></tr><tr><td>事务</td><td>支持</td><td>不支持</td></tr><tr><td>锁</td><td>支持表锁和行锁</td><td>支持表锁</td></tr><tr><td>表结构</td><td>数据和索引集中存储</td><td>数据和索引分开存储</td></tr><tr><td>索引</td><td>聚簇索引</td><td>非聚簇索引</td></tr></tbody></table><h2 id="1-9、数据库三大范式"><a href="#1-9、数据库三大范式" class="headerlink" title="1.9、数据库三大范式"></a>1.9、数据库三大范式</h2><ol><li><strong>第一范式（1NF）</strong>：保证每列的原子性。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库满足了第一范式</li></ol><blockquote><p>比如用户表里的名字字段，在中国可能直接存完整的姓名就可以了。但在国外姓和名常常需要分开使用，所以需要分成姓和名两个字段存储。所以是否满足原子性需要根据实际需求来确定</p></blockquote><ol start="2"><li><p><strong>第二范式（2NF）</strong>：满足第一范式前提，不能存在局部依赖。比如有联合主键有两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式 </p></li><li><p><strong>第三范式（3NF）</strong>：消除传递依赖，每列都直接依赖于主键</p></li></ol><blockquote><p>假设存在关系模式主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址。显然满足第一范式和第二范式，但是教师家庭地址传递依赖于教师名，所以不满足第三范式</p></blockquote><blockquote><p>所谓反范式化，是一种对范式化设计的数据库的<strong>性能优化策略</strong>，通过在表中增加冗余或重复的数据来提供数据库的读取性能。没有冗余的数据库不一定是最好的数据库，有时为了提高查询效率，就必须降低范式标准，适当保留冗余数据。具体操作就是在一个表中增加别一个表的冗余字段，减少了两个表查询时的关联，从而提高查询效率</p></blockquote><h1 id="2、数据库基本操作"><a href="#2、数据库基本操作" class="headerlink" title="2、数据库基本操作"></a>2、数据库基本操作</h1><h2 id="2-1、DDL数据定义语言"><a href="#2-1、DDL数据定义语言" class="headerlink" title="2.1、DDL数据定义语言"></a>2.1、DDL数据定义语言</h2><h3 id="2-1-1、数据库相关"><a href="#2-1-1、数据库相关" class="headerlink" title="2.1.1、数据库相关"></a>2.1.1、数据库相关</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建数据库并指定字符集</span></span><br><span class="line"><span class="keyword">create</span> database db01 <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看所有的数据库</span></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某个数据库的DDL语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database db01;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改数据库编码</span></span><br><span class="line"><span class="keyword">alter</span> database db01 <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除数据库</span></span><br><span class="line"><span class="keyword">drop</span> database db01;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 切换数据库</span></span><br><span class="line"><span class="keyword">drop</span> database db01;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-1-2、表相关"><a href="#1-1-2、表相关" class="headerlink" title="1.1.2、表相关"></a>1.1.2、表相关</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp (</span><br><span class="line">    id <span class="type">int</span>,</span><br><span class="line">  <span class="comment">-- ` 是 MySQL 的转义符，避免和 mysql 的本身的关键字冲突，只要你不在列名、表名中使用 mysql 的保留字或中文，就不需要转义。</span></span><br><span class="line">    sex <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">20</span>), </span><br><span class="line">address <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据库所有表</span></span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看表结构</span></span><br><span class="line"><span class="keyword">desc</span> 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看创建表的sql语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 复制表结构</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 新表 <span class="keyword">LIKE</span> 旧表;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 判断表是否存在，存在删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF EXIST 表名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> age <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">drop</span> age;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改字段类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp modify address <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改字段名和字段类型</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp change address addr <span class="type">varchar</span>(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表名（MySQL中没有直接修改库名的语句）</span></span><br><span class="line">rename <span class="keyword">table</span> emp <span class="keyword">to</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改表字符集</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><h2 id="2-2、DML数据操纵语言"><a href="#2-2、DML数据操纵语言" class="headerlink" title="2.2、DML数据操纵语言"></a>2.2、DML数据操纵语言</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入全部字段</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;张三&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="string">&#x27;河南汤阴&#x27;</span>,<span class="number">39</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入指定字段</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(id,name,sex) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入多条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">( <span class="number">4</span>, <span class="string">&#x27;小红&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;四川南充&#x27;</span>, <span class="number">25</span> ),</span><br><span class="line">( <span class="number">5</span>, <span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="string">&#x27;河南平顶山&#x27;</span>, <span class="number">24</span> ),</span><br><span class="line">( <span class="number">6</span>, <span class="string">&#x27;小李&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="string">&#x27;陕西榆林&#x27;</span>, <span class="number">20</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新数据</span></span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> sex<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>,addr<span class="operator">=</span><span class="string">&#x27;陕西忻州&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表数据</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 清空表（先删除表结构,再创建一个相同的表结构 相当于drop table emp，再create table emp）表中有自增长，会把自增长id 重置成1开始</span></span><br><span class="line"><span class="keyword">truncate</span> emp;</span><br></pre></td></tr></table></figure><h2 id="2-3、DQL数据查询语言"><a href="#2-3、DQL数据查询语言" class="headerlink" title="2.3、DQL数据查询语言"></a>2.3、DQL数据查询语言</h2><h3 id="2-3-1、基础查询"><a href="#2-3-1、基础查询" class="headerlink" title="2.3.1、基础查询"></a>2.3.1、基础查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询指定列</span></span><br><span class="line"><span class="keyword">select</span> id,name,addr <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 指定列的别名</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">as</span> 编号,name <span class="keyword">as</span> 姓名,addr 地址 <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 去重id相同的行</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> id <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询时进行列运算</span></span><br><span class="line"><span class="keyword">select</span> id,name,addr,id<span class="operator">+</span>age <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 范围查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> english <span class="keyword">between</span> <span class="number">60</span> <span class="keyword">and</span> <span class="number">90</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 模糊查询</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> address <span class="keyword">like</span> <span class="string">&#x27;%西%&#x27;</span>; <span class="comment">-- 地址中带西的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> address <span class="keyword">like</span> <span class="string">&#x27;_____&#x27;</span>;<span class="comment">-- 查询五个字地址城市的学生</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询列为空的数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> sex <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- limit查询offset：跳过多少条记录，默认是0 length：返回多少条记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> LIMIT <span class="keyword">offset</span>,length</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student limit <span class="number">2</span>, <span class="number">3</span>; <span class="comment">-- 从第二条开始查，显示三条</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- case when（Case When语句用于选择判断，在执行时先对条件进行判断，然后根据判断结果做出相应的操作）</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="operator">*</span>,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line">sex </span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;男&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">&#x27;man&#x27;</span> </span><br><span class="line"><span class="keyword">WHEN</span> <span class="string">&#x27;女&#x27;</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">&#x27;woman&#x27;</span> </span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;其他&#x27;</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">&#x27;other&#x27;</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>通配符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>%</td><td>匹配零个或多个字符</td></tr><tr><td>_</td><td>匹配一个字符</td></tr></tbody></table><h3 id="2-3-2、排序"><a href="#2-3-2、排序" class="headerlink" title="2.3.2、排序"></a>2.3.2、排序</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 升序排列</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 降序排列</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 组合排序（查询所有数据大于20岁的学生,在年龄降序排序的基础上,如果年龄相同再以数学成绩升序排序）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">22</span> <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>, math <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-3、聚合函数"><a href="#2-3-3、聚合函数" class="headerlink" title="2.3.3、聚合函数"></a>2.3.3、聚合函数</h3><table><thead><tr><th><strong>SQL中的聚合函数</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>count</td><td>统计个数，如果这一列有NULL，null不会参与统计</td></tr><tr><td>max</td><td>找这一列中的最大值，一般是数值类型进行操作。</td></tr><tr><td>min</td><td>找这一列中的最小值</td></tr><tr><td>sum</td><td>求这一列的总和</td></tr><tr><td>avg</td><td>求这一列的平均，返回值小数average</td></tr></tbody></table><h3 id="2-3-4、分组"><a href="#2-3-4、分组" class="headerlink" title="2.3.4、分组"></a>2.3.4、分组</h3><p>分组一般搭配聚合函数一起使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄大于23岁的人，按性别分组，统计每组的人数</span></span><br><span class="line"><span class="keyword">select</span> sex, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> student <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">23</span> <span class="keyword">group</span> <span class="keyword">by</span> sex;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于23岁的人，按性别分组，统计每组的人数，并只显示性别人数大于2的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> sex, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">23</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sex <span class="keyword">having</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>子名</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>where 子句</td><td>先过滤掉行上的一些数据，再进行分组操作。(先过滤再分组)</td></tr><tr><td>having子句</td><td>先分组后得到的结果上再进行过滤的操作。(先分组再过滤)</td></tr></tbody></table><blockquote><p><strong>where子句后不能使用分组函数，having子句后可以使用聚合函数</strong></p></blockquote><h3 id="2-3-5、连接查询"><a href="#2-3-5、连接查询" class="headerlink" title="2.3.5、连接查询"></a>2.3.5、连接查询</h3><h4 id="2-3-5-1、表的关系"><a href="#2-3-5-1、表的关系" class="headerlink" title="2.3.5.1、表的关系"></a>2.3.5.1、表的关系</h4><table><thead><tr><th><strong>表与表的关系</strong></th><th><strong>示例</strong></th><th><strong>关系的维护</strong></th></tr></thead><tbody><tr><td>一对多</td><td>班级合学生</td><td>通过从表中外键来维护</td></tr><tr><td>多对多</td><td>学生和课程。拆分成学生，选课，课程</td><td>通过中间表，将两个一对多加到一起变成了一个多对多</td></tr><tr><td>一对一</td><td>在实际的开发中应用不多，因为一对一可以创建成一张表</td><td>（1）外键添加约束 （2）从表的主键又是外键 可以简化成一张表</td></tr></tbody></table><h4 id="2-3-5-2、笛卡尔积"><a href="#2-3-5-2、笛卡尔积" class="headerlink" title="2.3.5.2、笛卡尔积"></a>2.3.5.2、笛卡尔积</h4><p>简单的说就是两个集合相乘的结果。笛卡尔（Descartes）乘积又叫直积。假设集合A&#x3D;{a,b}，集合B&#x3D;{0,1,2}，则两个集合的笛卡尔积为{(a,0),(a,1),(a,2),(b,0),(b,1), (b,2)}</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 笛卡尔查询示例</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table1 , table2</span><br></pre></td></tr></table></figure><p>笛卡尔积产生，有两种情况：<br>（1）表连接缺少关联条件，这个是必须要改的；<br>（2）表连接有关联条件，但是数据库判断用笛卡尔积更快，也会出现笛卡尔积，这个时候要看实际执行速度；数据库这样判断，<strong>一般是表比较小</strong>，这个时候要特别检查表的数据量是不是真的很少，以免oracle因为统计信息错误而误判。</p><h4 id="2-3-5-3、内连接"><a href="#2-3-5-3、内连接" class="headerlink" title="2.3.5.3、内连接"></a>2.3.5.3、内连接</h4><p>用左边表的记录去匹配右边表的记录，如果符合条件的则显示</p><ol><li>隐式内连接：看不到join关键字，条件使用where指定</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept,emp <span class="keyword">where</span> dept.id<span class="operator">=</span>emp.dept_id;</span><br></pre></td></tr></table></figure><ol start="2"><li>显示内连接：**使用INNER JOIN … ON语句, 可以省略INNER</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept d <span class="keyword">inner</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> d.id <span class="operator">=</span> e.dept_id;</span><br></pre></td></tr></table></figure><blockquote><p>隐式内连接只能使用where来进行表的关联；显示内连接可以使用on和where来关联，推荐使用on</p></blockquote><h4 id="2-3-5-4、左外连接"><a href="#2-3-5-4、左外连接" class="headerlink" title="2.3.5.4、左外连接"></a>2.3.5.4、左外连接</h4><p>左外连接：使用LEFT OUTER JOIN … ON，OUTER可以省略(查询的数据以左表为准，即使在其他表中没有匹配的记录也会显示出来)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 需要查询所有的部门和员工，无论这个部门下有没有员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">left</span> <span class="keyword">join</span> emp <span class="keyword">on</span> dept.id <span class="operator">=</span> emp.dept_id;</span><br></pre></td></tr></table></figure><blockquote><p>在使用left jion时，on和where条件的区别如下：<br>1、on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。<br>2、where条件是在临时表生成好后，再对临时表进行过滤的条件。</p></blockquote><h4 id="2-3-5-5、右外连接"><a href="#2-3-5-5、右外连接" class="headerlink" title="2.3.5.5、右外连接"></a>2.3.5.5、右外连接</h4><p>右外连接：使用RIGHT OUTER JOIN … ON，OUTER可以省略（查询的数据以右表为准，即使在其他表中没有匹配的记录也会显示出来）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">right</span> <span class="keyword">join</span> emp <span class="keyword">on</span> dept.id <span class="operator">=</span> emp.dept_id;</span><br></pre></td></tr></table></figure><h4 id="2-3-5-6、全连接"><a href="#2-3-5-6、全连接" class="headerlink" title="2.3.5.6、全连接"></a>2.3.5.6、全连接</h4><p>全连接：左表和右表的数据都能够显示全面呢（在对方表中没有匹配的数据就以null补齐）</p><blockquote><p>MySQL并没有提供全连接，但Oracle支持；虽然MySQL不支持全连接，但是我们可以利用MySQL提供的其它功能来完成全连接的功能：</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept d <span class="keyword">left</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> d.id<span class="operator">=</span>e.dept_id</span><br><span class="line"><span class="keyword">union</span> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept d <span class="keyword">right</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> d.id<span class="operator">=</span>e.dept_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>union关键字可以将两个或多个SQL语句的结果集拼接成一个结果集，前提是这些SQL语句的结果集列数必须相同；（union关键字自带去重功能，即去除重复的数据）</p></blockquote><h4 id="2-3-5-7、子查询"><a href="#2-3-5-7、子查询" class="headerlink" title="2.3.5.7、子查询"></a>2.3.5.7、子查询</h4><p>一个查询语句结果做为另一个查询语句的条件查询语句有嵌套，里面的查询称为子查询，外面的查询称为父查询子查询要使用括号括起来</p><ol><li>子查询结果为单行单列</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(age) <span class="keyword">from</span> emp);</span><br></pre></td></tr></table></figure><ol start="2"><li>子查询结果为多行单列</li></ol><p>查询结果是多行单列的时候，子查询的结果相当于一个集合或数组。父查询要使用in&#x2F;any&#x2F;all这些关键字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 采用in 取结果集中的数据 in (1,2,3)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> dept_id <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">23</span>);</span><br><span class="line"><span class="comment">-- 采用all 查询年龄大于1号部门所有员工的人</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="keyword">all</span> (<span class="keyword">select</span> age <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id<span class="operator">=</span><span class="number">1</span>);</span><br><span class="line"><span class="comment">-- 采用any 比1号部门任意一个大就行</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="keyword">any</span> (<span class="keyword">select</span> age <span class="keyword">from</span> emp <span class="keyword">where</span> dept_id<span class="operator">=</span><span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>子查询结果为多行多列</li></ol><p>如果子查询的结果是多行多列，父查询可以将这个查询结果做为一个虚拟表，进行第2次查询。不是放在where后面，而是放在from的后面</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 询出年龄大于23岁的员工信息和部门名称</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>,d.name 部门名称 <span class="keyword">from</span> dept d, (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">23</span>) e <span class="keyword">where</span> d.id <span class="operator">=</span> e.dept_id</span><br></pre></td></tr></table></figure><h2 id="2-4、DCL数据控制语言"><a href="#2-4、DCL数据控制语言" class="headerlink" title="2.4、DCL数据控制语言"></a>2.4、DCL数据控制语言</h2><p>DCL是数据控制语言,主要是用来设置或更改数据库用户或角色权限的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建用户</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据库用户</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.user;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 授权</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">create</span>,<span class="keyword">alter</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">select</span> <span class="keyword">on</span> db03.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;lisi&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 撤销权限</span></span><br><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> db03.<span class="operator">*</span> <span class="keyword">from</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看用户权限</span></span><br><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;zhangsan&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改管理员密码</span></span><br><span class="line">mysqladmin <span class="operator">-</span>uroot <span class="operator">-</span>p password 新密码</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、数据库约束"><a href="#3、数据库约束" class="headerlink" title="3、数据库约束"></a>3、数据库约束</h1><p>一般在创建表的时候给表的字段添加各种约束，从而保证输入到表中的数据是正确的。保证数据的正确性，完整性和有效性。违反约束的数据是不能添加到表中去的。如果表已经存在，并且表中已经有数据，添加约束的时候如果表中的数据已经违反了现在要添加的约束，约束会添加失败。</p><table><thead><tr><th><strong>约束名</strong></th><th><strong>关键字</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>主键</td><td>primary key</td><td>唯一，非空</td></tr><tr><td>默认</td><td>default</td><td>没有输入值，使用默认值</td></tr><tr><td>非空</td><td>not null</td><td>必须输入</td></tr><tr><td>唯一</td><td>unique</td><td>不能重复</td></tr><tr><td>外键</td><td>foregin key (外键) references 主表(主键)</td><td>外键在从表 主表：1方 从表：多方</td></tr></tbody></table><h2 id="3-1、主键约束"><a href="#3-1、主键约束" class="headerlink" title="3.1、主键约束"></a>3.1、主键约束</h2><p>用来唯一标识表中的每一行记录，在创建表的时候，每张表都应该创建一个主键，每个表只能有一个主键约束，只要有主键就有主键约束。</p><blockquote><p>特点：非空，唯一，一张表最多一个主键</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,<span class="comment">-- 指定id列为主键</span></span><br><span class="line">    city <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在已有的表中添加主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除主键</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t1 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 联合主键</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">id2 <span class="type">int</span>,</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line"><span class="keyword">primary</span> key(id,id2)<span class="comment">-- id和id2列组合为联合主键</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3-2、唯一约束"><a href="#3-2、唯一约束" class="headerlink" title="3.2、唯一约束"></a>3.2、唯一约束</h2><p>这一列的值不能重复</p><blockquote><p>和主键约束区别：唯一性约束允许在该列上存在NULL值，主键约束允许</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3-3、非空约束"><a href="#3-3、非空约束" class="headerlink" title="3.3、非空约束"></a>3.3、非空约束</h2><p>这一列的值必须输入，不能为空</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t4(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">city <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span><span class="comment">-- 非空约束</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3-4、检查约束"><a href="#3-4、检查约束" class="headerlink" title="3.4、检查约束"></a>3.4、检查约束</h2><p>检查约束可以使用一定的范围条件来约束我们的列的值，例如年龄应该在0~120岁之间，性别只能有男或女等；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t6(</span><br><span class="line">id <span class="type">int</span>,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">30</span>),</span><br><span class="line">age <span class="type">int</span> <span class="keyword">check</span>(age<span class="operator">&gt;</span><span class="number">0</span> <span class="keyword">and</span> age<span class="operator">&lt;</span><span class="number">120</span>),<span class="comment">-- 年龄只在0~120之间</span></span><br><span class="line">sex <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">check</span>(<span class="string">&#x27;男&#x27;</span> <span class="keyword">or</span> <span class="string">&#x27;女&#x27;</span>) <span class="comment">-- 性别只能在&#x27;男&#x27; 和 &#x27;女&#x27;之间选择</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="3-5、外键约束"><a href="#3-5、外键约束" class="headerlink" title="3.5、外键约束"></a>3.5、外键约束</h2><p>外键出现在从表中，被主表的主键约束的那一列外键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">dept_id <span class="type">int</span>, <span class="comment">-- 外键的数据类型与主表中的主键相同</span></span><br><span class="line"><span class="keyword">CONSTRAINT</span> `employee_ibfk_1` <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept(id)<span class="comment">-- 本表的dept_id列依赖于dept表的id列</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 新增外键约束</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 约束名 <span class="keyword">FOREIGN</span> KEY (外键字段) <span class="keyword">REFERENCES</span> 主表(主键)</span><br></pre></td></tr></table></figure><h1 id="4、数据库事务"><a href="#4、数据库事务" class="headerlink" title="4、数据库事务"></a>4、数据库事务</h1><p>如果一个业务操作中多次访问了数据库，必须保证每条SQL语句都执行成功。如果其中有一条执行失败，那么所有已经执行过的代码必须回滚（撤销）。回到没有执行前的状态。称为事务。简单来说就是要么所有的SQL语句全部执行成功，要么全部失败</p><table><thead><tr><th><strong>事务特性</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>原子性（Atomicity）</td><td>一个事务内的所有操作要么都执行，要么都执行失败</td></tr><tr><td>一致性（Consistency）</td><td>事务执行前与执行后，数据库中数据应该保持相同的状态</td></tr><tr><td>隔离性（Isolation）</td><td>指的是一个事务在最终提交前，对其它事务是不可见的</td></tr><tr><td>持久性（Durability）</td><td>如果事务执行成功，对数据库的操作是持久的。</td></tr></tbody></table><h2 id="4-1、事务提交"><a href="#4-1、事务提交" class="headerlink" title="4.1、事务提交"></a>4.1、事务提交</h2><ol><li><strong>手动提交事务</strong></li></ol><table><thead><tr><th><strong>功能</strong></th><th><strong>SQL语句</strong></th></tr></thead><tbody><tr><td>开启事务</td><td>start transaction&#x2F;begin</td></tr><tr><td>提交事务</td><td>commit</td></tr><tr><td>回滚事务</td><td>rollback</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启事务</span></span><br><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- a账号-500元</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money<span class="operator">=</span>money<span class="number">-500</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- b账号+500元</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money<span class="operator">=</span>money<span class="operator">+</span><span class="number">500</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询账号信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>自动提交事务，默认是自动提交</strong></li></ol><p>MySQL默认每一条DML(增删改)语句都是一个单独的事务，每条语句都会自动开启一个事务，执行完毕自动提交事务，MySQL默认开始自动提交事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 取消自动提交事务</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@autocommit</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-2、并发访问下事务产生的问题"><a href="#4-2、并发访问下事务产生的问题" class="headerlink" title="4.2、并发访问下事务产生的问题"></a>4.2、并发访问下事务产生的问题</h2><p>当同时有多个用户在访问同一张表中的记录，每个用户在访问的时候都是一个单独的事务。事务在操作时的理想状态是：事务之间不应该相互影响，实际应用的时候会引发下面三种问题：</p><ol><li>脏读： 一个事务（用户）读取到了另一个事务没有提交的数据</li><li>不可重复读：一个事务多次读取同一条记录，出现读取数据不一致的情况。一般因为另一个事务更新了这条记录而引发的。</li><li>幻读：在一次事务中，多次读取到的条数不一致</li></ol><h2 id="4-3、事务的隔离级别"><a href="#4-3、事务的隔离级别" class="headerlink" title="4.3、事务的隔离级别"></a>4.3、事务的隔离级别</h2><p>为了尽量避免这些问题的发生。通过数据库本身的功能去避免，设置不同的隔离级别</p><table><thead><tr><th><strong>级别</strong></th><th><strong>名字</strong></th><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th><th><strong>数据库默认隔离级别</strong></th><th>解释</th></tr></thead><tbody><tr><td>1</td><td>读未提交</td><td>read uncommitted</td><td>是</td><td>是</td><td>是</td><td></td><td>事务A可以读取到事务B未提交的数据</td></tr><tr><td>2</td><td>读已提交</td><td>read committed</td><td>否</td><td>是</td><td>是</td><td>Oracle和SQL Server</td><td>事务A只能读取其它事务已提交的数据（避免了脏读）</td></tr><tr><td>3</td><td>可重复读</td><td>repeatable read</td><td>否</td><td>否</td><td>是</td><td>MySQL</td><td>保证在同一个事务中多次读取同样数据的结果是一样的</td></tr><tr><td>4</td><td>串行化</td><td>serializable</td><td>否</td><td>否</td><td>否</td><td></td><td>事务串行化顺序执行</td></tr></tbody></table><blockquote><p>隔离级别越高，安全性就越高，性能越低</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置隔离级别</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><h1 id="5、视图"><a href="#5、视图" class="headerlink" title="5、视图"></a>5、视图</h1><p>视图其实就是一个select返回的结果集，用于方便我们查询而创建的”临时表”，简化我们的查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> test4 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> class_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">with</span> <span class="keyword">local</span> <span class="keyword">check</span> option;</span><br></pre></td></tr></table></figure><h1 id="6、触发器"><a href="#6、触发器" class="headerlink" title="6、触发器"></a>6、触发器</h1><p>触发器是与表有关的数据库对象，指在 insert&#x2F;update&#x2F;delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p><table><thead><tr><th><strong>触发器类型</strong></th><th><strong>NEW和OLD的使用</strong></th></tr></thead><tbody><tr><td>insert触发器</td><td>NEW 表示将要或者已经新增的数据</td></tr><tr><td>update触发器</td><td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td></tr><tr><td>delete触发器</td><td>OLD 表示将要或者已经删除的数据</td></tr></tbody></table><blockquote><p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基本语法</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name [after<span class="operator">/</span>before] [<span class="keyword">insert</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">/</span><span class="keyword">delete</span>] </span><br><span class="line"><span class="keyword">on</span> table_name</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- insert触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> test1 after <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">on</span> student</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> log <span class="keyword">values</span>(<span class="keyword">null</span>,new.name,now());</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- update触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> test2 after <span class="keyword">update</span></span><br><span class="line"><span class="keyword">on</span> student</span><br><span class="line"> <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> log <span class="keyword">values</span>(<span class="keyword">null</span>,concat(<span class="string">&#x27;之前的值: &#x27;</span>,old.name,<span class="string">&#x27;;之后的值: &#x27;</span>,new.name),now());</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- delete触发器</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> test3 after <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> student</span><br><span class="line"> <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> log <span class="keyword">values</span>(<span class="keyword">null</span>,concat(<span class="string">&#x27;删除的值: &#x27;</span>,old.name),now());</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看当前数据库中的触发器</span></span><br><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> test1;</span><br></pre></td></tr></table></figure><h1 id="7、存储过程和存储函数"><a href="#7、存储过程和存储函数" class="headerlink" title="7、存储过程和存储函数"></a>7、存储过程和存储函数</h1><p>MySQL中提供存储过程与存储函数机制，我们先将其统称为存储程序，一般的SQL语句需要先编译然后执行，存储程序是一组为了完成特定功能的SQL语句集，<strong>经编译后存储在数据库中</strong>，当用户通过指定存储程序的名字并给定参数（如果该存储程序带有参数）来调用才会执行</p><h2 id="7-1、存储过程语法"><a href="#7-1、存储过程语法" class="headerlink" title="7.1、存储过程语法"></a>7.1、存储过程语法</h2><h3 id="7-1-1、变量"><a href="#7-1-1、变量" class="headerlink" title="7.1.1、变量"></a>7.1.1、变量</h3><ol><li>declare：声明变量</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test2 ()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> num <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;<span class="comment">-- 声明变量,赋默认值为0</span></span><br><span class="line"><span class="keyword">select</span> num<span class="operator">+</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test2();<span class="comment">-- 调用存储过程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>set：赋值操作</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test3 ()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> num <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> num <span class="operator">=</span><span class="number">20</span>;<span class="comment">-- 给num变量赋值</span></span><br><span class="line"><span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test3();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>into：赋值</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test4 ()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> num <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">into</span> num <span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test4();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-2、if语句"><a href="#7-1-2、if语句" class="headerlink" title="7.1.2、if语句"></a>7.1.2、if语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据class_id判断是Java还是UI还是产品</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test5 ()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> id <span class="type">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">declare</span> class_name <span class="type">varchar</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">if id<span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> class_name<span class="operator">=</span><span class="string">&#x27;哇塞，Java大佬！&#x27;</span>;</span><br><span class="line">elseif id<span class="operator">=</span><span class="number">2</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> class_name<span class="operator">=</span><span class="string">&#x27;原来是UI的啊&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">set</span> class_name<span class="operator">=</span><span class="string">&#x27;不用想了，肯定是产品小样&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> class_name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test5();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-3、传递参数"><a href="#7-1-3、传递参数" class="headerlink" title="7.1.3、传递参数"></a>7.1.3、传递参数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> procedure_name([<span class="keyword">in</span><span class="operator">/</span><span class="keyword">out</span><span class="operator">/</span><span class="keyword">inout</span>] 参数名  参数类型)</span><br></pre></td></tr></table></figure><blockquote><p>in： 该参数可以作为输入，也就是需要调用方传入值 , 默认<br>out： 该参数作为输出，也就是该参数可以作为返回值<br>inout： 既可以作为输入参数，也可以作为输出参数</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义一个输入参数和一个输出参数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test7 (<span class="keyword">in</span> id <span class="type">int</span>,<span class="keyword">out</span> class_name <span class="type">varchar</span>(<span class="number">100</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">if id<span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> class_name<span class="operator">=</span><span class="string">&#x27;哇塞，Java大佬！&#x27;</span>;</span><br><span class="line">elseif id<span class="operator">=</span><span class="number">2</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> class_name<span class="operator">=</span><span class="string">&#x27;原来是UI的啊&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">set</span> class_name<span class="operator">=</span><span class="string">&#x27;不用想了，肯定是产品小样&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test7(<span class="number">1</span>,<span class="variable">@class_name</span>);<span class="comment">-- 创建会话变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@class_name</span>;<span class="comment">-- 引用会话变量</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>@xxx：代表定义一个会话变量，整个会话都可以使用，当会话关闭（连接断开）时销毁<br>@@xxx：代表定义一个系统变量，永久生效，除非服务器重启</p></blockquote><h3 id="7-1-4、case语句"><a href="#7-1-4、case语句" class="headerlink" title="7.1.4、case语句"></a>7.1.4、case语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 传递一个月份，返回所在季节</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test8 (<span class="keyword">in</span> <span class="keyword">month</span> <span class="type">int</span>,<span class="keyword">out</span> season <span class="type">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span><span class="operator">&lt;=</span><span class="number">3</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> season<span class="operator">=</span><span class="string">&#x27;spring&#x27;</span>;</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span><span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span><span class="operator">&lt;=</span><span class="number">6</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> season<span class="operator">=</span><span class="string">&#x27;summer&#x27;</span>;</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span><span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span><span class="operator">&lt;=</span><span class="number">9</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> season<span class="operator">=</span><span class="string">&#x27;autumn&#x27;</span>;</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">month</span> <span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span><span class="operator">&lt;=</span><span class="number">12</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> season<span class="operator">=</span><span class="string">&#x27;winter&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test8(<span class="number">9</span>,<span class="variable">@season</span>);<span class="comment">-- 定义会话变量来接收test8存储过程返回的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@season</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-5、while循环"><a href="#7-1-5、while循环" class="headerlink" title="7.1.5、while循环"></a>7.1.5、while循环</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 计算任意数的累加和</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test10 (<span class="keyword">in</span> count <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">declare</span> i <span class="type">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">while i<span class="operator">&lt;=</span>count do</span><br><span class="line"><span class="keyword">set</span> total<span class="operator">=</span>total<span class="operator">+</span>i;</span><br><span class="line"><span class="keyword">set</span> i<span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test10(<span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-6、repeat循环（while）"><a href="#7-1-6、repeat循环（while）" class="headerlink" title="7.1.6、repeat循环（while）"></a>7.1.6、repeat循环（while）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test11 (count <span class="type">int</span>)<span class="comment">-- 默认是输入(in)参数</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">repeat </span><br><span class="line"><span class="keyword">set</span> total<span class="operator">=</span>total<span class="operator">+</span>count;</span><br><span class="line"><span class="keyword">set</span> count<span class="operator">=</span>count<span class="number">-1</span>;</span><br><span class="line">until count<span class="operator">=</span><span class="number">0</span><span class="comment">-- 结束条件,注意不要打分号</span></span><br><span class="line"><span class="keyword">end</span> repeat;</span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test11(<span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-7、loop循环"><a href="#7-1-7、loop循环" class="headerlink" title="7.1.7、loop循环"></a>7.1.7、loop循环</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test12 (count <span class="type">int</span>)<span class="comment">-- 默认是输入(in)参数</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> total <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">sum:loop<span class="comment">-- 定义循环标识</span></span><br><span class="line"><span class="keyword">set</span> total<span class="operator">=</span>total<span class="operator">+</span>count;</span><br><span class="line"><span class="keyword">set</span> count<span class="operator">=</span>count<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">if count <span class="operator">&lt;</span> <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">leave sum;<span class="comment">-- 跳出循环</span></span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span> loop sum;<span class="comment">-- 标识循环结束</span></span><br><span class="line"><span class="keyword">select</span> total;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test12(<span class="number">10</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-8、游标"><a href="#7-1-8、游标" class="headerlink" title="7.1.8、游标"></a>7.1.8、游标</h3><p>游标是用来存储查询结果集的数据类型，可以帮我们保存多条行记录结果，我们要做的操作就是读取游标中的数据获取每一行的数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> test13 ()<span class="comment">-- 默认是输入(in)参数</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> id <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">declare</span> `name` <span class="type">varchar</span>(<span class="number">20</span>);</span><br><span class="line"><span class="keyword">declare</span> class_id <span class="type">int</span>(<span class="number">11</span>);</span><br><span class="line"><span class="comment">-- 定义游标结束标识符</span></span><br><span class="line"><span class="keyword">declare</span> has_data <span class="type">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> stu_result <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student;</span><br><span class="line"><span class="comment">-- 监测游标结束</span></span><br><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">not</span> found <span class="keyword">set</span> has_data<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line"><span class="keyword">open</span> stu_result;</span><br><span class="line"></span><br><span class="line">repeat </span><br><span class="line"><span class="keyword">fetch</span> stu_result <span class="keyword">into</span> id,`name`,class_id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> concat(<span class="string">&#x27;id: &#x27;</span>,id,<span class="string">&#x27;;name: &#x27;</span>,`name`,<span class="string">&#x27;;class_id&#x27;</span>,class_id);</span><br><span class="line">until has_data<span class="operator">=</span><span class="number">0</span><span class="comment">-- 退出条件,注意不要打分号</span></span><br><span class="line"><span class="keyword">end</span> repeat;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 关闭游标</span></span><br><span class="line"><span class="keyword">close</span> stu_result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> test13();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-2、存储函数"><a href="#7-2、存储函数" class="headerlink" title="7.2、存储函数"></a>7.2、存储函数</h2><h3 id="7-2-1、存储函数和存储过程区别"><a href="#7-2-1、存储函数和存储过程区别" class="headerlink" title="7.2.1、存储函数和存储过程区别"></a>7.2.1、存储函数和存储过程区别</h3><ol><li>存储函数的限制比较多，例如不能用临时表、不能执行查询语句、只能用表变量等；而存储过程的限制较少，存储过程的实现功能要复杂些,而函数的实现功能针对性比较强。</li><li>返回值不同。存储函数必须有返回值,且仅返回一个结果值；存储过程可以没有返回值,但是能返回结果集(out,inout)。</li><li>调用时的不同。存储函数select 存储函数名(变量值)；存储过程通过call语句调用 call 存储过程名。</li><li>参数的不同。存储函数的参数类型类似于IN参数，没有类似于OUT和INOUT的参数。存储过程的参数类型有三种，in、out和inout：in： 数据只是从外部传入内部使用(值传递),可以是数值也可以是变量</li></ol><h3 id="7-2-2、创建方式"><a href="#7-2-2、创建方式" class="headerlink" title="7.2.2、创建方式"></a>7.2.2、创建方式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 无参函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> test1()</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> num <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> num<span class="operator">=</span><span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> test1()</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 带参函数</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> test2(num <span class="type">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> test2(<span class="number">22</span>);</span><br></pre></td></tr></table></figure><h1 id="8、数据库范式"><a href="#8、数据库范式" class="headerlink" title="8、数据库范式"></a>8、数据库范式</h1><h2 id="8-1、三大范式"><a href="#8-1、三大范式" class="headerlink" title="8.1、三大范式"></a>8.1、三大范式</h2><ol><li><p><strong>第一范式（1NF）</strong>：保证每列的原子性。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库满足了第一范式</p><blockquote><p>比如用户表里的名字字段，在中国可能直接存完整的姓名就可以了。但在国外姓和名常常需要分开使用，所以需要分成姓和名两个字段存储。所以是否满足原子性需要根据实际需求来确定</p></blockquote></li><li><p><strong>第二范式（2NF）</strong>：满足第一范式前提，不能存在局部依赖。比如有联合主键有两个列，不能存在这样的属性，它只依赖于其中一个列，这就是不符合第二范式 </p></li><li><p><strong>第三范式（3NF）</strong>：消除传递依赖，每列都直接依赖于主键</p><blockquote><p>假设存在关系模式主键1: 课程编号; 列1: 教师名; 列2: 教师家庭地址。显然满足第一范式和第二范式，但是教师家庭地址传递依赖于教师名，所以不满足第三范式</p></blockquote></li></ol><h2 id="8-2、反范式化"><a href="#8-2、反范式化" class="headerlink" title="8.2、反范式化"></a>8.2、反范式化</h2><p>所谓反范式化，是一种对范式化设计的数据库的<strong>性能优化策略</strong>，通过在表中增加冗余或重复的数据来提供数据库的读取性能。没有冗余的数据库不一定是最好的数据库，有时为了提高查询效率，就必须降低范式标准，适当保留冗余数据。具体操作就是在一个表中增加别一个表的冗余字段，减少了两个表查询时的关联，从而提高查询效率。</p><h1 id="9、数据库备份与恢复"><a href="#9、数据库备份与恢复" class="headerlink" title="9、数据库备份与恢复"></a>9、数据库备份与恢复</h1><p>mysqldump命令主要用于数据库的备份</p><blockquote><p>options：<br>-h：mysql服务器的IP<br>-P：mysql服务器的端口<br>-u：mysql用户名<br>-p：mysql密码<br>-n（–no-create-db）：不包含创建数据库语句（包含建表语句和数据）<br>-t（–no-create-info）：不包含创建表语句（只要插入语句）<br>-d（–no-data）：不包含数据<br>-B（–database）：导出数据库（也包含建库语句也包含数据）<br>-A（–all-databases）：导出所有数据库</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 导出指定表（没有指定表则导出所有）</span></span><br><span class="line">mysqldump <span class="operator">-</span>h127<span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>P3306 <span class="operator">-</span>uroot <span class="operator">-</span>padmin db02 student <span class="operator">&gt;</span> D:<span class="operator">/</span>test.sql</span><br><span class="line"><span class="comment">-- 导出数据库（比导表增加了 加了create database db_name语句）</span></span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>padmin <span class="comment">--all-databases &gt; D:/test.sql</span></span><br><span class="line"><span class="comment">-- 恢复（执行sql文件）</span></span><br><span class="line">source d:<span class="operator">/</span>test.sql;</span><br></pre></td></tr></table></figure><h1 id="10、JDBC"><a href="#10、JDBC" class="headerlink" title="10、JDBC"></a>10、JDBC</h1><p>是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了操作数据库的所有方法。JDBC是一组接口，没有具体的实现。核心功能也就是实现类由各 <strong>数据库厂商去实现</strong>这些实现类也被成为数据库的驱动。</p><h2 id="10-1、JDBC常用接口"><a href="#10-1、JDBC常用接口" class="headerlink" title="10.1、JDBC常用接口"></a>10.1、JDBC常用接口</h2><table><thead><tr><th><strong>接口或类</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>Driver</td><td>驱动接口，定义建立链接的方式</td></tr><tr><td>DriverManager</td><td>1. 加载和注册第三方厂商的驱动程序 2. 创建一个数据库的连接对象</td></tr><tr><td>Connection</td><td>与数据库的一个连接对象</td></tr><tr><td>Statement</td><td>SQL语句对象，用于封装SQL语句发送给MySQL服务器</td></tr><tr><td>PreparedStatement</td><td>是Statement接口的子接口，功能更加强大</td></tr><tr><td>ResultSet</td><td>封装从数据库中查询到的结果集</td></tr></tbody></table><h2 id="10-2、PreparedStatement"><a href="#10-2、PreparedStatement" class="headerlink" title="10.2、PreparedStatement"></a>10.2、PreparedStatement</h2><p>PreparedStatement 是 Statement 的子类，也能执行Statement之前的所有操作，其中最主要的功能就是提供了占位符传参处理、预编译等功能；我们实际开发中PreparedStatement会使用的更多</p><h3 id="10-2-1、sql注入问题"><a href="#10-2-1、sql注入问题" class="headerlink" title="10.2.1、sql注入问题"></a>10.2.1、sql注入问题</h3><p><strong>用户输入的内容作为了SQL语句语法的一部分，改变了原有SQL真正的意义</strong>，以上问题称为SQL注入。要解决SQL注入就不能让用户输入的密码和我们的SQL语句进行简单的字符串拼接<br>如 用户输入密码：</p><blockquote><p>abc’ or ‘1’&#x3D;’1</p></blockquote><p>执行的sql为：select * from user where name&#x3D;’admin’ and password&#x3D;’abc’ or ‘1’&#x3D;’1’;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PreparedStatement解决sql注入问题：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建预编译的SQL语句</span></span><br><span class="line">ps = conn.prepareStatement(<span class="string">&quot;select * from user where name=? and password=?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//替换占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, name);</span><br><span class="line">ps.setString(<span class="number">2</span>, password);</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行SQL语句，查询</span></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-2-2、CallableStatement"><a href="#10-2-2、CallableStatement" class="headerlink" title="10.2.2、CallableStatement"></a>10.2.2、CallableStatement</h3><p>callableStatement是PreparedStatement的子类，主要是调用数据库中的存储过程&#x2F;存储函数。并通过CallableStatement对象可以获取存储过程&#x2F;存储函数的执行结果；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义存储过程</span></span><br><span class="line">   <span class="type">CallableStatement</span> <span class="variable">cs</span> <span class="operator">=</span> connection.prepareCall(<span class="string">&quot;call test3(?,?,?)&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输入参数</span></span><br><span class="line">   cs.setInt(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出参数</span></span><br><span class="line">   cs.registerOutParameter(<span class="number">2</span>, Types.VARBINARY);</span><br><span class="line">   cs.registerOutParameter(<span class="number">3</span>, Types.VARBINARY);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 执行存储过程</span></span><br><span class="line">   cs.execute();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 根据参数名获取值</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> cs.getString(<span class="string">&quot;str1&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> cs.getString(<span class="string">&quot;str2&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="10-2-3、JDBC事务处理"><a href="#10-2-3、JDBC事务处理" class="headerlink" title="10.2.3、JDBC事务处理"></a>10.2.3、JDBC事务处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo15_</span>事务 &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JdbcUtils.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置事务不要自动提交(手动提交,默认情况下,事务是自动提交的)</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建语句对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//a扣钱</span></span><br><span class="line">            stmt.executeUpdate(<span class="string">&quot;update account set money=money-500 where name=&#x27;a&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// b加钱</span></span><br><span class="line">            stmt.executeUpdate(<span class="string">&quot;update account set money=money+500 where name=&#x27;b&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;转账成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 回滚事务</span></span><br><span class="line">                conn.rollback();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;转账失败&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JdbcUtils.close(conn, stmt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="11、原理相关知识"><a href="#11、原理相关知识" class="headerlink" title="11、原理相关知识"></a>11、原理相关知识</h1><h2 id="11-1、-数据库为什么用B-树索引（平衡-b-b-区别）"><a href="#11-1、-数据库为什么用B-树索引（平衡-b-b-区别）" class="headerlink" title="11.1、 数据库为什么用B+树索引（平衡 b b+区别）"></a>11.1、 数据库为什么用B+树索引（平衡 b b+区别）</h2><p>二叉查找树：二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点</p><p>平衡二叉树：平衡二叉树又称 AVL 树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过 1</p><blockquote><p>平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快</p></blockquote><p>B树：从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据。平衡二叉树可是每个节点只存储一个键值和数据的，如果我们要存储海量的数据，二叉树的节点将会非常多，高度也会极其高。<br>图中的每个节点称为页，页就是我们上面说的磁盘块，在 MySQL 中数据读取的基本单位都是页，所以我们这里叫做页更符合 MySQL 中索引的底层数据结构</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311101517844.png" alt="image (29).png"></p><p>B+树：B+ 树是对 B 树的进一步优化.<br>①B+ 树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储键值，也会存储数据。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数又会再次减少，数据查询的效率也会更快。<br>②因为 B+ 树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，通过双向链表关联。那么 B+ 树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而 B 树因为数据分散在各个节点，要实现这一点是很不容易的。</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311101518699.png" alt="image (30).png"></p><h2 id="11-2、索引下推"><a href="#11-2、索引下推" class="headerlink" title="11.2、索引下推"></a>11.2、索引下推</h2><p>索引下推是索引下推是 MySQL 5.6 及以上版本上推出的，用于对查询进行优化。索引下推是把本应该在服务层进行筛选的条件，下推到存储引擎层来进行筛选判断，这样能有效减少回表。<br>eg: 首先使用联合索引（name，age），现在有这样一个查询语句：</p><blockquote><p>select *  from t_user where name like ‘L’ and age &#x3D; 17;</p></blockquote><p>这条语句从最左匹配原则上来说是不符合的，只有name用的索引，但是age并没有用到。<br>不用索引下推的执行过程：</p><blockquote><p>第一步：存储引擎利用索引找出name带’L’的数据行：LiLei、Lili、Lisa、Lucy 这四条索引数据<br>第二步：存储引擎再根据这四条索引数据中的 id 值，逐一进行回表扫描，从聚簇索引中找到相应的行数据，将找到的行数据返回给服务层。<br>第三步：在server层判断age &#x3D; 17,进行筛选，最终只留下 Lucy 用户的数据信息。</p></blockquote><p>使用索引下推的执行过程：</p><blockquote><p>第一步：存储引擎利用索引找出name带’L’的数据行：LiLei、Lili、Lisa、Lucy 这四条索引数据<br>第二步：存储引擎根据 age &#x3D; 17 这个条件，对四条索引数据进行判断筛选，最终只留下 Lucy 用户的数据信息。（注意：这一步不是直接进行回表操作，而是根据 age &#x3D; 17 这个条件，对四条索引数据进行判断筛选）<br>第三步：将符合条件的索引对应的 id 进行回表扫描，最终将找到的行数据返回给 server 层。</p></blockquote><p>比较二者的第二步我们发现，索引下推的方式极大的减少了回表次数。</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311101520226.png" alt="image.png"></p><blockquote><p>Extra中 Using index condition代表使用了索引下推</p></blockquote><h2 id="11-3、mysql结构"><a href="#11-3、mysql结构" class="headerlink" title="11.3、mysql结构"></a>11.3、mysql结构</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311101520772.png" alt="image (31).png"></p><p>MySQL整体的逻辑结构可以分为4层,客户层、服务层、存储引擎层、数据层<br><strong>客户层</strong><br>客户层:进行相关的连接处理、权限控制、安全处理等操作<br><strong>服务层</strong><br>服务层负责与客户层进行连接处理、处理以及执行SQL语句等,主要包含连接器、查询缓存、优化器、执行器、存储引擎。触发器、视图等也在这一层<br><strong>存储引擎层</strong><br>存储引擎层负责对数据的存储和提取，常见的存储引擎有InnoDB、MyISAM、Memory等，在MySQL5.5之后，MySQL默认的存储引擎就是InnoDB,InnoDB默认使用的索引结构就是B+树,上面的服务层就是通过API接口与存储引擎层进行交互的<br><strong>数据层</strong><br>数据层系主要包括MySQL中存储数据的底层文件，与上层的存储引擎进行交互，是文件的物理存储层。其存储的文件主要有：日志文件、数据文件、配置文件、MySQL的进行pid文件和socket文件等。</p><h2 id="11-4、数据库查询流程"><a href="#11-4、数据库查询流程" class="headerlink" title="11.4、数据库查询流程"></a>11.4、数据库查询流程</h2><ol><li>当客户端的查询语句为select查询语句的时候，如若再查询缓存里面已经查询到了结果，就会直接把查询结果返回给客户端</li><li>在查询缓存并没有查询到结果之后，就会走到解析器，在解析器这儿，解析sql，判断是否有语法错误</li><li>语法没有问题，走到执行器，执行器先会预处理（检测用户对表的权限，和相应字段有没有），优化器（对sql执行顺序，使用索引等进行优化）</li><li>执行器使用引擎提供的接口与存储引擎层进行交互，执行SQL语句，并将结果返回个客户端</li></ol><h2 id="11-5、sql优化的方案有哪些？"><a href="#11-5、sql优化的方案有哪些？" class="headerlink" title="11.5、sql优化的方案有哪些？"></a>11.5、sql优化的方案有哪些？</h2><ol><li>优化表结构</li></ol><p>（1）对经常查询的列添加索引，加快查询速度。<br>（2）尽量避免使用大字段（如 TEXT、BLOB），因为这些字段的读写速度较慢，会影响性能。</p><ol start="2"><li>优化查询语句</li></ol><p>（1）减少查询返回的数据量，避免不必要的 JOIN、子查询等操作。<br>（2）使用优化的查询方式，例如使用 EXISTS 替代 IN 或 NOT IN。<br>（3）避免出现索引失效的情况，如WHERE 子句中使用函数或运算符</p><ol start="3"><li>explain 等工具来分析 SQL 查询语句，找出执行计划，确定是否存在性能瓶颈</li></ol><h2 id="11-6、mysql的explain的详解"><a href="#11-6、mysql的explain的详解" class="headerlink" title="11.6、mysql的explain的详解"></a>11.6、mysql的explain的详解</h2><p>EXPLAIN 命令用于SQL语句的<strong>查询执行计划</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN select * from person <span class="type">where</span> <span class="variable">dept_id</span> <span class="operator">=</span>(select did from dept <span class="type">where</span> <span class="variable">dname</span> <span class="operator">=</span><span class="string">&#x27;python&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2996398/1679319789341-8cecd090-7731-4223-9b27-ab9a3b605275.png#averageHue=%23f9f7f5&clientId=u65a23804-8145-4&from=paste&height=82&id=u45062470&originHeight=82&originWidth=816&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7645&status=done&style=none&taskId=u746f8984-6a64-4768-842a-e3ec65c59d5&title=&width=816" alt="image.png"></p><ol><li>id（查询序列号）：从 2 个表中查询，对应输出 2 行，每行对应一个表， id 列表示执行顺序，id 越大，越先执行，id 相同时，由上至下执行</li><li>select_type（查询类型）：最常见的值包括SIMPLE、PRIMARY、DERIVED 和UNION</li></ol><blockquote><p>simple：简单查询，没有union和子查询<br>primary ：最外层查询 (在存在子查询的语句中，最外面的select查询就是primary)<br>derived  ：子查询(在FROM列表中包含的子查询)  EXPLAIN SELECT <em>FROM (SELECT</em> FROM person LIMIT 5) AS s<br>subquery ：映射为子查询(在SELECT或WHERE列表中包含了子查询)</p></blockquote><ol start="3"><li>table： 输出的行所用的表</li><li>type：连接类型，访问类型，表示MySQL在访问表时所采取的方式</li></ol><p>性能：性能： null &gt; system&#x2F;const &gt; eq_ref &gt; ref &gt; ref_or_null   &gt;  range &gt; index &gt;  all </p><blockquote><p>null：优化过程中就已得到结果，不用再访问表或索引<br>const：在整个查询过程中这个表最多只会有一条匹配的行，比如主键 id&#x3D;1 就肯定只有一行<br>eq_ref：使用有唯一性 索引查找（主键或唯一性索引）<br>ref：非唯一性索引访问（select * from user where username &#x3D; ‘张三’;）<br>ref_or_null：该联接类型如同ref类似,结果包含空行<br>(上面这五种情况都是很理想的索引使用情况)<br>range：索引范围扫描，常见于　&lt;,&lt;&#x3D;,&gt;,&gt;&#x3D;,between,in等操作符<br>index：索引全扫描，MySQL遍历整个索引来查询匹配的行：（select username from user）<br>all：全表扫描</p></blockquote><ol start="5"><li>possible_keys：可能使用的索引</li><li>key：实际使用的索引，表示MySQL在执行查询时所使用的索引</li><li>rows：扫描行数，表示MySQL在执行查询时所扫描的行数。</li><li>extra：重要的额外信息（<a href="https://blog.csdn.net/li1325169021/article/details/113925826">https://blog.csdn.net/li1325169021/article/details/113925826</a>）</li></ol><blockquote><p>（1）Using filesort：排序时没有按照建立复合索引字段的顺序进行，因此产生了外部的索引排序。效率低<br>（2）Using temporary：使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by<br>（3）Using index：select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错<br>（4）Using join buffer：表明使用了连接缓存，给驱动表建立索引可解决此问题</p></blockquote><h2 id="11-7、MVCC"><a href="#11-7、MVCC" class="headerlink" title="11.7、MVCC"></a>11.7、MVCC</h2><p>多版本并发控制，数据库隔离级别读已提交、可重复读 都是基于MVCC实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。【注意】：只有快照读才会使用MVCC，当前读使用行锁+间隙锁（临键锁Next-Key Locks）实现<br>它的实现依赖于三个概念：版本链和快照读和ReadView</p><ol><li>版本链：多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为版本链(最新记录+undo-log)</li></ol><blockquote><p>undo log，<strong>回滚日志</strong>，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据. 可以这样认为，当delete一条记录时，undo log 中会记录一条对应的insert记录</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311101605938.png" alt="image.png"></p><ol start="2"><li>快照读：读取的是记录数据的可见版本，不加锁，普通的select语句都是快照读</li></ol><blockquote><p>当前读：读取的是记录数据的最新版本，显式加锁的都是当前读。如update，delete，select..for update<br>【注意】：只有快照读才会使用MVCC，当前读使用行锁+间隙锁（临键锁Next-Key Locks）实现</p></blockquote><ol start="3"><li>RedaView：读视图，其实就是一个数据结构，包含四个属性：当前活跃事务编号集合，最小活跃事务编号，预分配事务编号（当前最大事务编号+1），创建者事务编号</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311101605005.png" alt="image.png"></p><blockquote><p>读已提交：在每次执行快照读的时候生成ReadView<br>可重复读：（同一事务）只在第一次使用快照读的时候生成ReadView，后续复用（解决不可重复读）,（但两次快照读之间存在当前读，也会重新生成，所以存在幻读的问题）</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311101606136.png" alt="image.png"></p><blockquote><p>流程：</p><ol><li>在执行查询操作时生成一个ReadView（注意在读已提交下，每次快照读都生成一个ReadView）</li><li>遍历版本链，判断是否符合ReadView规则（这个过程其实就是找它最近一次事务提交的数据版本）</li><li>返回符合规则的数据</li></ol></blockquote><h2 id="11-8、行级锁"><a href="#11-8、行级锁" class="headerlink" title="11.8、行级锁"></a>11.8、行级锁</h2><p>innoDB通过给索引记录加锁的方式实现行级锁，具体来说实现了三种行锁算法：<br><strong>记录锁</strong>：锁定单个行记录的锁（RC,RR都支持）<br><strong>间隙锁</strong>：锁定索引记录的间隙，确保索引记录的间隙不变（RR支持）<br><strong>next-key锁</strong>：记录锁和间隙锁的组合，同时锁住数据和数据前后范围（RR支持）</p><blockquote><p>在RR隔离级别，InnoDB对于记录加锁都是线采用next-key锁，sql中含有唯一索引时，会采用记录锁，仅锁住索引本身而非范围</p></blockquote><p>各种操作加锁的特点：<br>（1）select…from：采用MVCC而非加锁<br>（2）select…from for update（在事务完成之前其他事务无法修改它，确保读到的是最新的）：采用next-key，如果有唯一索引，采用记录锁<br>（3）update,insert,delete同上</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>中国古代史</title>
      <link href="/posts/20848.html"/>
      <url>/posts/20848.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、史前时期"><a href="#1、史前时期" class="headerlink" title="1、史前时期"></a>1、史前时期</h1><h2 id="1-1、中国人种起源及生存环境"><a href="#1-1、中国人种起源及生存环境" class="headerlink" title="1.1、中国人种起源及生存环境"></a>1.1、中国人种起源及生存环境</h2><p>人类进化链环的各个阶段，在中国境内大都可以找到对应的遗址。</p><ol><li>直立人: 西侯度人(山西，180万年前)、元谋猿人(云南，170万年前)、蓝田人(陕西，115-70万年前)、北京猿人(70-23万年前)</li><li>早期智人 (古人)：长阳人(湖北，距今19.5万年)、丁村人(山西，距今20多万年）、大荔人（陕西，距今20-15万年前）</li><li>晚期智人（新人）：猿类特征已经退化，体质特征接近现代人。柳江人（距今5-4万年，广西），河套人（距今5-3.7万年，内蒙古），山顶洞人（距今3万年，北京）</li></ol><h2 id="1-2、中国境内旧石器和新石器时代"><a href="#1-2、中国境内旧石器和新石器时代" class="headerlink" title="1.2、中国境内旧石器和新石器时代"></a>1.2、中国境内旧石器和新石器时代</h2><p>在考古学上，根据人类使用工具的进化程度不将历史划为:石器时代 (旧石器时代,新石器时代) -&gt; 青铜时代 -&gt; 铁器时代</p><ol><li>旧石器时代：距今250万年-1万年，特点是使用粗糙的打制石器，过着采集和渔猎生活，相当于人类历史上的原始人阶段</li><li>新石器时代：距今1万-5000年，氏族公社时期，包括母系氏族公社和父系氏族公社，特点是使用磨制石器，能够制造陶和纺织，发明农业和畜牧业，有固定生活来源，不再依赖采集为生。（大汶口文化，红山文化，良渚文化，大溪文化，河姆渡文化，龙山文化）</li></ol><h1 id="2、夏商周三代文明"><a href="#2、夏商周三代文明" class="headerlink" title="2、夏商周三代文明"></a>2、夏商周三代文明</h1><h2 id="2-1、夏王朝"><a href="#2-1、夏王朝" class="headerlink" title="2.1、夏王朝"></a>2.1、夏王朝</h2><h3 id="2-1-1、夏朝年表"><a href="#2-1-1、夏朝年表" class="headerlink" title="2.1.1、夏朝年表"></a>2.1.1、夏朝年表</h3><p>夏朝（约前2070年－约前1600年，470年）是中国历史记载的第一个中原部族世袭制朝代</p><table><thead><tr><th align="left">序号</th><th align="left">姓名</th><th align="left">在位时长</th><th align="left">相关事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">禹</td><td align="left">前2071-前2027（45年）</td><td align="left"><strong>涂山大会</strong>，铸造九鼎，象征九州，第一次有了国家的概念</td></tr><tr><td align="left">2</td><td align="left">启</td><td align="left">前2026-前1988（39年）</td><td align="left">由禅让制变为世袭制，击败了有扈氏的反抗</td></tr><tr><td align="left">3</td><td align="left">太康</td><td align="left">前1987-前1984（4年）</td><td align="left">不理朝政，被有穷氏后羿夺权，<strong>太康失国</strong>，实际在位2年</td></tr><tr><td align="left">4</td><td align="left">仲康</td><td align="left">前1983-前1977（7年）</td><td align="left">后羿专权，仲康反抗失败被软禁，抑郁而终</td></tr><tr><td align="left">5</td><td align="left">相</td><td align="left">前1976-前1949（28年）</td><td align="left">被寒浞的儿子浇攻破自刎，大臣寒浞杀后羿夺权</td></tr><tr><td align="left">6</td><td align="left">少康&#x2F;杜康</td><td align="left">前1908-前1888（21年）</td><td align="left">相的遗腹子，攻杀寒浞，复国，<strong>少康中兴</strong></td></tr><tr><td align="left">7</td><td align="left">季杼</td><td align="left">前1887-前1871（17年）</td><td align="left">参加过复兴夏朝的战争</td></tr><tr><td align="left">8</td><td align="left">槐&#x2F;帝芬</td><td align="left">前前1870-前1827（44年）</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">芒</td><td align="left">前1826-前1769（58年）</td><td align="left"></td></tr><tr><td align="left">10</td><td align="left">泄&#x2F;帝降</td><td align="left">前1768-前1753（16年）</td><td align="left">正式赐封九夷各部诸侯爵位</td></tr><tr><td align="left">11</td><td align="left">不降</td><td align="left">前1752-前1705（48年）</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">扃</td><td align="left">前1704-前1684（21年）</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">廑（jin）</td><td align="left">前1683-前1676（8年）</td><td align="left">夏国开始衰落</td></tr><tr><td align="left">14</td><td align="left">孔甲</td><td align="left">前1675-前1667（9年）</td><td align="left">胡作非为的残暴昏君</td></tr><tr><td align="left">15</td><td align="left">皋</td><td align="left">前1666 -前1664（3年）</td><td align="left"></td></tr><tr><td align="left">16</td><td align="left">发</td><td align="left">前1663-前1645（19年）</td><td align="left">各方诸侯已不来朝贺</td></tr><tr><td align="left">17</td><td align="left">桀</td><td align="left">前1644-前1592（53年）</td><td align="left">暴君，被商汤灭，亡国</td></tr></tbody></table><h3 id="2-1-2、夏王朝的文献和史事"><a href="#2-1-2、夏王朝的文献和史事" class="headerlink" title="2.1.2、夏王朝的文献和史事"></a>2.1.2、夏王朝的文献和史事</h3><p>目前关于夏王朝的主要文献资料来源于《史记·夏本纪》和《尚书》及《诗经》的部分记载。<br>夏王朝始于禹。尧舜禹的禅让到禹时，发生了根本的变化。禹传位于其子启，确立了嫡子世袭制度。据《夏本纪》的材料，禹开始以天下授益<br>就在传位于启不久，这个部落联盟中的有扈氏部族“不服”，向启提出了挑战。启伐之，大战于甘，有扈氏被灭。<br>夏后帝启死后，子太康立。太康时失国，太康崩，弟中康立，是为帝中康。中康生子相。相时受到东夷族有穷氏(其首领为善射的羿)的压迫，在与有穷氏的战争中，夏王相被杀，但他的儿子少康最终取得胜利，这就是“少康复国。</p><h2 id="2-2、商王朝"><a href="#2-2、商王朝" class="headerlink" title="2.2、商王朝"></a>2.2、商王朝</h2><h3 id="2-2-1、商朝年表"><a href="#2-2-1、商朝年表" class="headerlink" title="2.2.1、商朝年表"></a>2.2.1、商朝年表</h3><p>商朝（约公元前1600年-约公元前1046年，554年）</p><table><thead><tr><th>序号</th><th>姓名</th><th>别名</th><th>在位时长</th><th>相关事件</th></tr></thead><tbody><tr><td>1</td><td>商汤</td><td>天乙</td><td>前1600年-前1588年（13年）</td><td>开国君主 鸣条之战</td></tr><tr><td>2</td><td>商哀王</td><td>外丙</td><td>前1587年-前1586年（2年）</td><td></td></tr><tr><td>3</td><td>商懿王</td><td>仲壬</td><td>前1585年-前1582年（4年）</td><td></td></tr><tr><td>4</td><td>商太宗</td><td>太甲</td><td>前1582年-前1570年（13年）</td><td></td></tr><tr><td>5</td><td>商昭王</td><td>沃丁</td><td>前1570年-前1541年（29年）</td><td></td></tr><tr><td>6</td><td>商宣王</td><td>太庚</td><td>前1541年-前1516年（25年）</td><td></td></tr><tr><td>7</td><td>商敬王</td><td>小甲</td><td>前1516年-前1499年（17年）</td><td>商朝始衰</td></tr><tr><td>8</td><td>商元王</td><td>雍己</td><td>前1487年-前1476年（12年）</td><td>诸侯不来朝</td></tr><tr><td>9</td><td>商中宗</td><td>太戊</td><td>前1486年-前1412年（75年）</td><td>小国又纷纷归顺，商朝中兴</td></tr><tr><td>10</td><td>商孝成王</td><td>仲丁</td><td>前1418年-前1408年（13年）</td><td></td></tr><tr><td>11</td><td>商思王</td><td>外壬</td><td>前1407年-前1398年 （10年）</td><td>九世之乱</td></tr><tr><td>12</td><td>商前平王</td><td>河檀（dan）甲</td><td>前1397年-前1389年（9年）</td><td>迁都河南内黄</td></tr><tr><td>13</td><td>商穆王</td><td>祖乙</td><td>前1388年-前1370年（19年）</td><td></td></tr><tr><td>14</td><td>商桓王</td><td>祖辛</td><td>前1369年-前1356年（16年）</td><td></td></tr><tr><td>15</td><td>商僖（xi）王</td><td>沃甲</td><td>前1355年- 前1336年（20年）</td><td></td></tr><tr><td>16</td><td>商庄王</td><td>祖丁</td><td>前1335年- 前1327年（9年）</td><td></td></tr><tr><td>17</td><td>商顷王</td><td>南庚</td><td>前1326年-前1321年（6年）</td><td>国都由庇（山东郓城）迁奄（山东曲阜）</td></tr><tr><td>18</td><td>商悼王</td><td>阳甲</td><td>前1321年- 前1314年（8年）</td><td></td></tr><tr><td>19</td><td>商世祖</td><td>盘庚</td><td>前1313年-前1286年（28年）</td><td>迁都殷（河南安阳）</td></tr><tr><td>20</td><td>商章王</td><td>小辛</td><td>前1285年- 前1272年（14年）</td><td></td></tr><tr><td>21</td><td>商惠王</td><td>小乙</td><td>前1271年- 前1251年（21年）</td><td></td></tr><tr><td>22</td><td>商高宗</td><td>武丁</td><td>前1250年- 前1192年（59年）</td><td>武丁中兴</td></tr><tr><td>23</td><td>商后平王</td><td>祖庚</td><td>前1191年-前1180年（12年）</td><td></td></tr><tr><td>24</td><td>商世宗</td><td>祖甲</td><td>前1180年-前1160年（20年）</td><td></td></tr><tr><td>25</td><td>商甲宗</td><td>廪（lin）辛</td><td>前1159年-前1156年（4年）</td><td></td></tr><tr><td>26</td><td>商康祖</td><td>庚丁</td><td>前1155年- 前1147年（9年）</td><td></td></tr><tr><td>27</td><td>商武祖</td><td>武乙</td><td>前1147年-前1113年（35年）</td><td></td></tr><tr><td>28</td><td>商匡王</td><td>文丁</td><td>前1112年-前1102年（11年）</td><td></td></tr><tr><td>29</td><td>商德王</td><td>帝乙</td><td>前1101年- 前1076年（26年）</td><td></td></tr><tr><td>30</td><td>商纣王</td><td>帝辛</td><td>前1075年-前1046年（30年）</td><td></td></tr></tbody></table><h3 id="2-2-2、商朝建立及迁徙过程"><a href="#2-2-2、商朝建立及迁徙过程" class="headerlink" title="2.2.2、商朝建立及迁徙过程"></a>2.2.2、商朝建立及迁徙过程</h3><p>商朝兴起于夏朝的东方，即黄河中下游，为子姓。其始祖名契，契母简狄是属于有戎的后代。传说是吞玄鸟之蛋而生契，这就是《诗经·商颂· 玄鸟》中的菩名诗句:“天命玄鸟，降而生商。”无疑，商人是以鸟为图腾的。商人逐渐西迁，从契到成汤历十四代王，共移徙八次。到汤时西进逼近夏人所居，终于灭掉夏王朝而建立商朝，都于毫(其地理位置尚存争议，或说商丘，或说偃师)。据史载，商汤立国之后，商人仍“不常厥邑”，又有五次迁都，历史上有“前八后五”的说法。到第二十代王盘庚时，他说服并胁迫商贵族再次迁徙，最终将商朝的都城固定下来，这就是目前所知的殷墟(河南安阳)。</p><h3 id="2-2-3、商朝政治体制"><a href="#2-2-3、商朝政治体制" class="headerlink" title="2.2.3、商朝政治体制"></a>2.2.3、商朝政治体制</h3><p>商周王朝都是世袭王权制，政权掌控在王手，商王在甲骨文中称为“余一人”。商代前期还处在兄终弟及的状态，后期转变为父死子继制度。商王朝的主要官员分为臣、将军和史官（包括巫人、贞人（占卜者）和祭司等）三大类</p><h2 id="2-3、周王朝"><a href="#2-3、周王朝" class="headerlink" title="2.3、周王朝"></a>2.3、周王朝</h2><p>周朝（前1046年—前256年，791年），是中国历史上最长的朝代 </p><h3 id="2-3-1、西周年表"><a href="#2-3-1、西周年表" class="headerlink" title="2.3.1、西周年表"></a>2.3.1、西周年表</h3><table><thead><tr><th align="left">序号</th><th align="left">谥号</th><th align="left">姓名</th><th align="left">在位时间</th><th align="left">相关事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">周文王</td><td align="left">姬昌</td><td align="left">公元前 1110 年-前 1061 年为西伯（50 年）</td><td align="left">创《周易》  寿命 97</td></tr><tr><td align="left">2</td><td align="left">周武王</td><td align="left">姬发</td><td align="left">公元前 1060 年-前 1046 年为西伯（15 年）公元前 1046 年-前 1043 年为周王（4 年）</td><td align="left">孟津观兵   牧野之战  灭商建周，定都镐京（西安）</td></tr><tr><td align="left">3</td><td align="left">周成王</td><td align="left">姬诵</td><td align="left">公元前 1042 年-前 1021 年（22 年）</td><td align="left">成康之治 周公摄政 迁都洛邑（洛阳）</td></tr><tr><td align="left">4</td><td align="left">周康王</td><td align="left">姬钊</td><td align="left">公元前 1020 年-前 996 年（25 年）</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">周昭王</td><td align="left">姬瑕</td><td align="left">公元前 995 年-前 977 年（18 年）</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">周穆王</td><td align="left">姬满</td><td align="left">公元前 976 年-前 922 年（55 年）</td><td align="left"></td></tr><tr><td align="left">7</td><td align="left">周共王</td><td align="left">姬繄扈（yihu）</td><td align="left">公元前 922 年-前 900 年（23 年）</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">周懿王</td><td align="left">姬囏（jian）</td><td align="left">公元前 899 年-前 892 年（8 年）</td><td align="left">迁都槐里（兴平市）</td></tr><tr><td align="left">9</td><td align="left">周孝王</td><td align="left">姬辟方</td><td align="left">公元前 891 年-前 886 年（6 年）</td><td align="left">非子封秦</td></tr><tr><td align="left">10</td><td align="left">周夷王</td><td align="left">姬燮（xie）</td><td align="left">公元前 885 年-前 878 年（8 年）</td><td align="left">煮杀齐哀公</td></tr><tr><td align="left">11</td><td align="left">周厉王</td><td align="left">姬胡</td><td align="left">公元前 877 年-前 841 年（37 年）</td><td align="left">贪图财利</td></tr><tr><td align="left"></td><td align="left">共和（一说为共伯和摄行天子政）</td><td align="left"></td><td align="left">公元前 841 年-前 828 年（14 年）</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">周宣王</td><td align="left">姬静</td><td align="left">公元前 828 年-前 783 年（46 年）</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">周幽王</td><td align="left">姬宫湦</td><td align="left">公元前 782 年-前 771 年（12 年）</td><td align="left">烽火戏诸侯（存疑）</td></tr></tbody></table><h3 id="2-3-2、东周年表"><a href="#2-3-2、东周年表" class="headerlink" title="2.3.2、东周年表"></a>2.3.2、东周年表</h3><p>西周末年，周幽王因宠爱褒姒而废黜申后及太子宜臼，立褒姒为后，并立其子伯服为太子，引起申候的叛变。申候引犬戎政入关中，杀死幽王。于是公元前770年周平王被迫东迁至洛邑，开始了中国历史上的东周。</p><table><thead><tr><th align="left">序号</th><th align="left">谥号</th><th align="left">姓名</th><th align="left">在位时间</th><th align="left">相关事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">周平王</td><td align="left">姬宜臼</td><td align="left">公元前 770 年-前 718 年（53 年）</td><td align="left">迁都洛邑列秦诸侯春秋之始</td></tr><tr><td align="left">2</td><td align="left">周桓王</td><td align="left">姬林</td><td align="left">公元前 718 年-前 697 年（22 年）</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">周庄王</td><td align="left">姬佗</td><td align="left">公元前 697 年-前 682 年（16 年）</td><td align="left">平定王子克之乱</td></tr><tr><td align="left">4</td><td align="left">周釐王</td><td align="left">姬胡齐</td><td align="left">公元前 682 年-前 677 年（6 年）</td><td align="left">齐桓称霸</td></tr><tr><td align="left">5</td><td align="left">周惠王</td><td align="left">姬阆</td><td align="left">公元前 677 年-前 675 年第一次在位（3 年）公元前 673 年-前 652 年第二次在位（22 年）</td><td align="left">五大夫作乱</td></tr><tr><td align="left">6</td><td align="left">周废王（篡位）</td><td align="left">姬颓</td><td align="left">公元前 675 年-前 673 年（3 年）</td><td align="left">叛乱称王，后兵败遭杀</td></tr><tr><td align="left">7</td><td align="left">周襄王</td><td align="left">姬郑</td><td align="left">公元前 652 年-前 619 年（34 年）</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">周顷王</td><td align="left">姬壬臣</td><td align="left">公元前 619 年-前 613 年（7 年）</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">周匡王</td><td align="left">姬班</td><td align="left">公元前 613 年-前 607 年（7 年）</td><td align="left">赵盾事件</td></tr><tr><td align="left">10</td><td align="left">周定王</td><td align="left">姬瑜</td><td align="left">公元前 607 年-前 586 年（22 年）</td><td align="left">赵氏孤儿</td></tr><tr><td align="left">11</td><td align="left">周简王</td><td align="left">姬夷</td><td align="left">公元前 586 年-前 572 年（15 年）</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">周灵王</td><td align="left">姬泄心</td><td align="left">公元前 572 年-前 545 年（28 年）</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">周景王</td><td align="left">姬贵</td><td align="left">公元前 545 年-前 520 年（26 年）</td><td align="left">数典忘祖</td></tr><tr><td align="left">14</td><td align="left">周悼王</td><td align="left">姬猛</td><td align="left">公元前 520 年-前 520 年（1 年）</td><td align="left"></td></tr><tr><td align="left">15</td><td align="left">周敬王</td><td align="left">姬匄</td><td align="left">公元前 520 年-前 475 年（46 年）</td><td align="left"></td></tr><tr><td align="left">16</td><td align="left">周元王</td><td align="left">姬仁</td><td align="left">公元前 475 年-前 473 年（3 年）</td><td align="left">周元王开始为战国时期</td></tr><tr><td align="left">17</td><td align="left">周贞定王</td><td align="left">姬介</td><td align="left">公元前 473 年-前 441 年（33 年）</td><td align="left"></td></tr><tr><td align="left">18</td><td align="left">周哀王</td><td align="left">姬去疾</td><td align="left">公元前 441 年-前 441 年（1 年）</td><td align="left"></td></tr><tr><td align="left">19</td><td align="left">周思王</td><td align="left">姬叔</td><td align="left">公元前 441 年-前 441 年（1 年）</td><td align="left">在位仅五个月，即被弟弟姬嵬杀死</td></tr><tr><td align="left">20</td><td align="left">周考王</td><td align="left">姬嵬</td><td align="left">公元前 441 年-前 426 年（16 年）</td><td align="left">叔弑兄篡位</td></tr><tr><td align="left">21</td><td align="left">周威烈王</td><td align="left">姬午</td><td align="left">公元前 426 年-前 402 年（25 年）</td><td align="left">三家分晋</td></tr><tr><td align="left">22</td><td align="left">周安王</td><td align="left">姬骄</td><td align="left">公元前 402 年-前 376 年（27 年）</td><td align="left"></td></tr><tr><td align="left">23</td><td align="left">周烈王</td><td align="left">姬喜</td><td align="left">公元前 376 年-前 369 年（8 年）</td><td align="left"></td></tr><tr><td align="left">24</td><td align="left">周显王</td><td align="left">姬扁</td><td align="left">公元前 369 年-前 321 年（49 年）</td><td align="left">桂陵之战 马陵之战 商鞅变法</td></tr><tr><td align="left">25</td><td align="left">周慎靓王</td><td align="left">姬定</td><td align="left">公元前 321 年-前 315 年（7 年）</td><td align="left"></td></tr><tr><td align="left">26</td><td align="left">周赧王</td><td align="left">姬延</td><td align="left">公元前 315 年-前 256 年（60 年）</td><td align="left">债台高筑 降秦昭襄王</td></tr></tbody></table><h3 id="2-3-3、甲骨文和金文"><a href="#2-3-3、甲骨文和金文" class="headerlink" title="2.3.3、甲骨文和金文"></a>2.3.3、甲骨文和金文</h3><ol><li>甲骨文</li></ol><p>甲骨文是一种刻写在甲骨上的古文字。从出土实物来看，绝大多数为契刻,仅少数是书写的。甲骨文的“甲”指的是龟甲，多为腹甲:“骨”指的是兽骨，以牛肩脚骨为主，还有少量的牛肋骨、鹿头骨、牛头骨、人头骨、虎骨等<br>殷墟甲骨文的出土，说明了商代历史的可靠性，成为了研究商代历史最主要的资料。金文的出现则大大拓展了周代历史的研究领域，丰富了对周代历史的认识。甲骨文和金文，是研究商周历史极其重要的第一手资料</p><ol start="2"><li>金文</li></ol><p>金文就是铭刻在青铜器上的文字，它与商代甲骨文之间有直接的承关系。西周金文的内容，包括战争、祭祀、外交、土地和人畜买卖等。金文主要铸造或镌刻在青铜器上。保守地估计，中国使用青铜的时间大约有1500多年，即从公元前2000年到公元前500，这段时期被称为中国历史上的“青铜时代”</p><h3 id="2-3-4、周朝政治体制"><a href="#2-3-4、周朝政治体制" class="headerlink" title="2.3.4、周朝政治体制"></a>2.3.4、周朝政治体制</h3><p>周代的政治体制，与商人有某些共同之处。周王是最高的世袭统治者，他自称“天子”<br>西周王朝的直接统治限于王畿内，也就是《诗经》的“王风”部分;其王畿外的统治则是通过分封制度来实现的，即《诗经》中的十五“国风”部分</p><h3 id="2-3-5、周代的几种制度"><a href="#2-3-5、周代的几种制度" class="headerlink" title="2.3.5、周代的几种制度"></a>2.3.5、周代的几种制度</h3><p>周初灭商不久，对商人后裔实行一种由周人亲戚统领管理的相对自治统治，谓之“疆以周索”，又把商人中心区域分成邶（bei）、庸、卫三部分，分别派周武王弟弟管叔、蔡叔、霍叔去监管，这就是历史上的“三监”。但是周武王去世后，三监对周公摄政不满于是与殷人后裔联合起来反叛周王朝。周公便带兵东征，经过几年的战争之后，平服了这场叛乱，杀掉了武庚和管叔，并将蔡叔和霍叔加以流放。史称“周公东征”</p><p>周公东征后，周人便实行分封制度，力图通过“封建亲戚”的办法，实现“以藩屏周”的政治效果。这场大规模的分封，受封的对象主要是三类:是同姓子弟，二是异姓的功臣，三是先王后裔</p><h1 id="3、春秋战国"><a href="#3、春秋战国" class="headerlink" title="3、春秋战国"></a>3、春秋战国</h1><h2 id="3-1、春秋五霸"><a href="#3-1、春秋五霸" class="headerlink" title="3.1、春秋五霸"></a>3.1、春秋五霸</h2><p>　　<br>春秋时期，周王室衰微，诸侯蜂起并作，史称诸侯上千个，实际可考者只有一百四多个，而实力较强的也只有郑、齐、晋、秦、楚、吴，另外还有宋、鲁、陈、蔡、燕等国。在《春秋》《国语》中，主宰当时历史舞台的，按顺序主要是郑、齐、晋、秦、楚、吴、越等，他们分别建立自己的霸业。</p><p>春秋五霸的几种说法：<br>其一，齐桓公、晋文公、秦穆公、吴王夫差和越王勾践。<br>其二，齐桓公、晋文公、秦穆公、宋襄公和楚庄王。<br>其三，也有人认为，五霸实际只是一种虚指，并无实数</p><h2 id="3-2、战国七雄"><a href="#3-2、战国七雄" class="headerlink" title="3.2、战国七雄"></a>3.2、战国七雄</h2><p>“ 战国”之名，在当时就有了，它是指七国争战而言，而不是指那个时期。战国时期的最大特征，就是战争，主要是齐、楚、燕、韩、赵、魏、秦七国之间的战争。其实，战国时期不止以上七国，还有为数为少的小国，如鲁、周、中山、宋等，都是在战国时期才渐被灭掉的。</p><h2 id="3-3、齐魏桂陵之战"><a href="#3-3、齐魏桂陵之战" class="headerlink" title="3.3、齐魏桂陵之战"></a>3.3、齐魏桂陵之战</h2><p>经过一系列改革，魏国强大起来，成为战国时最早显露出统一天下雄心的强国。<br>354BC ，魏国派大将庞涓率8万精兵进攻赵国，包围了赵国都城邯郸（今河北邯郸），赵国向盟国齐国求救。齐威王正欲向外扩张，于是命田忌为主将，孙膑为军师，率兵8万去救赵国。齐国主将田忌接受孙膑的建议，直捣魏都大梁（今开封），迫使远在异国的魏军“释赵而自救”。等庞涓回兵时，在桂陵（有河南长垣、封丘和山东荷泽等异说），设伏截击，大败魏军。<br>这就是历史上著名的“围魏救赵”，通过短短几天，擒获庞涓，后庞涓得脱（一说被释放）。此役使得强大的魏国的霸权上大受折损，也使齐国的军事和政治威望大大提高</p><h2 id="3-4、逢泽之会"><a href="#3-4、逢泽之会" class="headerlink" title="3.4、逢泽之会"></a>3.4、逢泽之会</h2><p>　　<br>桂陵之战虽使魏国受到重创，但魏国仍然逐步扭转战局，后攻破了赵都邯郸，并且于前352 年地襄陵（今河南睢阳）打败齐、宋、卫三国联军。<br>344BC ，魏惠王因国力强盛，自称为王，在逢泽（今河南开封市南）邀集秦、宋、卫、邹、鲁等国参加会盟，并带头朝见周天子，成为七国中最先称王的，由此确立了战国中期魏国在列国间的统治地位。秦国在卫鞅的建议下承认魏的霸主地位，将其锋芒引向楚、齐</p><h2 id="3-4、齐魏马陵之战"><a href="#3-4、齐魏马陵之战" class="headerlink" title="3.4、齐魏马陵之战"></a>3.4、齐魏马陵之战</h2><p>　　<br>两年后（ 342BC ），魏国伐韩，包围了韩都新郑。韩昭侯求救于齐，齐派田忌为帅、田朌为副、孙膑为军师伐魏救韩，率军经曲阜、亢父 ( 今山东济宁 ), 由定陶进入魏境 , 矛头直指与大梁近在咫尺的外黄 ( 今河南民权 ) 。<br>　　<br>魏军闻讯 , 忙弃韩回救。 341BC ，魏惠王派庞涓为将，太子申为上将军，随军参与指挥，欲与齐军决一死战。此次齐军以“减灶之法”诱敌，在马陵（一般认为在今山东范县西南，还有山东鄄城县东北、濮县等多种说法）设伏。“百里而趣利者蹶上将”，大败魏军，魏太子申被擒，庞涓自杀。从此魏国一蹶不振。</p><p>魏国败于马陵之后，国力渐衰。受到齐、秦、赵的夹攻。 340BC 魏国派公子卬与秦国的商鞅交战，试图争夺河西（今山、陕交界的黄河南段以西一带），结果大败于商鞅，公子卬被俘</p><h2 id="3-5、徐州相王"><a href="#3-5、徐州相王" class="headerlink" title="3.5、徐州相王"></a>3.5、徐州相王</h2><p>魏在齐秦的夹攻中累遭惨败，梁惠王不得不采取惠施“变服折节而朝齐”的建议，于 334BC 率领韩昭侯等小国君主，到齐的徐州朝见齐威王，尊其为王，同时齐威王也承认魏惠王的王号，此即所谓“徐州相王”，说明了关东六国内部的暂时均势。</p><h1 id="4、秦国"><a href="#4、秦国" class="headerlink" title="4、秦国"></a>4、秦国</h1><h2 id="4-1、秦朝年表"><a href="#4-1、秦朝年表" class="headerlink" title="4.1、秦朝年表"></a>4.1、秦朝年表</h2><table><thead><tr><th align="left">序号</th><th align="left">谥号</th><th align="left">姓名</th><th align="left">在位时间</th><th align="left">相关事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">非子</td><td align="left">嬴非</td><td align="left">前900年-前858年（43年）</td><td align="left">因善于养马，得到周孝王的赏识，获封秦地，成为秦国始封君</td></tr><tr><td align="left">2</td><td align="left">秦侯</td><td align="left">嬴侯</td><td align="left">前857年-前848年（10年）</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">秦公伯</td><td align="left">嬴伯</td><td align="left">前847年-前845年（3年）</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">秦仲</td><td align="left">嬴仲</td><td align="left">前844年-前822年（23年）</td><td align="left">被周王任命为西我大夫，后战死</td></tr><tr><td align="left">5</td><td align="left">秦庄公</td><td align="left">嬴其</td><td align="left">前821年-前778年（44年）</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">秦襄公(立为诸侯)</td><td align="left">嬴开</td><td align="left">前777年-前766年（12年）</td><td align="left">看秋时期秦国第一任因君，辅平王东迁</td></tr><tr><td align="left">7</td><td align="left">秦文公</td><td align="left">嬴康</td><td align="left">前765年-前716年（50年）</td><td align="left">迁都汧渭之会（千河和渭河交界）</td></tr><tr><td align="left">8</td><td align="left">秦静公(秦竫公)</td><td align="left">嬴鼎</td><td align="left">未即位</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">秦宪公(秦宁公)</td><td align="left">嬴立</td><td align="left">前715年-前704年（12年）</td><td align="left"></td></tr><tr><td align="left">10</td><td align="left">秦出子</td><td align="left">嬴曼</td><td align="left">前703年-前698年（6年）</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left">秦武公</td><td align="left">嬴说</td><td align="left">前697年-前678年（20年）</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">秦德公</td><td align="left">嬴嘉</td><td align="left">前677年-前676年（2年）</td><td align="left">迁都雍城</td></tr><tr><td align="left">13</td><td align="left">秦宣公</td><td align="left">嬴恬</td><td align="left">前675年-前664年（12年）</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left">秦成公</td><td align="left">嬴载</td><td align="left">前663年-前660年（4年）</td><td align="left"></td></tr><tr><td align="left">15</td><td align="left">秦穆公</td><td align="left">嬴任好</td><td align="left">前659年-前621年（39年）</td><td align="left"></td></tr><tr><td align="left">16</td><td align="left">秦康公</td><td align="left">嬴罃</td><td align="left">前620年-前609年（12年）</td><td align="left"></td></tr><tr><td align="left">17</td><td align="left">秦共公</td><td align="left">嬴稻&#x2F;嬴貑</td><td align="left">前608年-前605年（4年）</td><td align="left"></td></tr><tr><td align="left">18</td><td align="left">秦桓公</td><td align="left">嬴荣</td><td align="left">前604年-前577年（28年）</td><td align="left"></td></tr><tr><td align="left">19</td><td align="left">秦景公</td><td align="left">嬴石</td><td align="left">前576年-前537年（40年）</td><td align="left">栎之战 迁延之役</td></tr><tr><td align="left">20</td><td align="left">秦哀公(秦毕公&#x2F;秦㻫公)</td><td align="left">嬴籍</td><td align="left">前536年-前501年（36年）</td><td align="left"></td></tr><tr><td align="left">21</td><td align="left">秦夷公</td><td align="left">嬴扩</td><td align="left">未即位</td><td align="left"></td></tr><tr><td align="left">22</td><td align="left">秦惠公</td><td align="left">嬴宁</td><td align="left">前500年-前492年（9年）</td><td align="left"></td></tr><tr><td align="left">23</td><td align="left">秦悼公</td><td align="left">嬴盘</td><td align="left">前491年-前477年（15年）</td><td align="left"></td></tr><tr><td align="left">24</td><td align="left">秦厉共公(秦剌龚公&#x2F;秦利龚公)</td><td align="left">嬴刺</td><td align="left">前476年-前443年（34年）</td><td align="left"></td></tr><tr><td align="left">25</td><td align="left">秦躁公(秦趮公)</td><td align="left">嬴欣</td><td align="left">前442年-前429年（14年）</td><td align="left"></td></tr><tr><td align="left">26</td><td align="left">秦怀公</td><td align="left">嬴封</td><td align="left">前428年-前425年（4年）</td><td align="left"></td></tr><tr><td align="left">27</td><td align="left">秦灵公(秦肃灵公)</td><td align="left">嬴肃</td><td align="left">前424年-前415年（10年）</td><td align="left"></td></tr><tr><td align="left">28</td><td align="left">秦简公</td><td align="left">嬴悼子</td><td align="left">前414年-前400年（15年）</td><td align="left"></td></tr><tr><td align="left">29</td><td align="left">秦惠公</td><td align="left">嬴仁</td><td align="left">前399年-前387年（13年）</td><td align="left"></td></tr><tr><td align="left">30</td><td align="left">秦出公(秦少主)</td><td align="left">嬴昌</td><td align="left">前386年-前385年（2年）</td><td align="left">母亲主持朝政，重用宦官外戚</td></tr><tr><td align="left">31</td><td align="left">秦献公&#x2F;秦元献公</td><td align="left">嬴师隰&#x2F;嬴连</td><td align="left">前384年-前362年（23年）</td><td align="left">废止人殉制度</td></tr><tr><td align="left">32</td><td align="left">秦孝公</td><td align="left">嬴渠梁</td><td align="left">前361年-前338年（24年）</td><td align="left">启用商鞅变法，迁都咸阳，建立县制行政</td></tr><tr><td align="left">33</td><td align="left">秦惠文王(秦惠王)</td><td align="left">嬴驷</td><td align="left">前337年-前311年（27年）</td><td align="left">改公称王，成为秦国第一王</td></tr><tr><td align="left">34</td><td align="left">秦武王(秦悼武王&#x2F;秦武烈王)</td><td align="left">嬴荡</td><td align="left">前310年-前307年（4年）</td><td align="left"></td></tr><tr><td align="left">35</td><td align="left">秦昭襄王(秦昭王)</td><td align="left">嬴则&#x2F;嬴稷</td><td align="left">前306年-前251年（56年）</td><td align="left">长平破赵，灭亡东周，奠基统一</td></tr><tr><td align="left">36</td><td align="left">秦孝文王</td><td align="left">嬴柱</td><td align="left">前250年（3天）</td><td align="left"></td></tr><tr><td align="left">37</td><td align="left">秦庄襄王(秦庄王)</td><td align="left">嬴异人&#x2F;嬴子楚(嬴楚)</td><td align="left">前249年-前247年（3年）</td><td align="left"></td></tr><tr><td align="left">38</td><td align="left">秦王政（秦始皇）</td><td align="left">嬴政</td><td align="left">前246年-前221年（25年）</td><td align="left">统一六国 建立皇帝制度 修筑万里长城</td></tr><tr><td align="left">39</td><td align="left">秦二世（胡亥）</td><td align="left">嬴胡亥</td><td align="left">前210年―前207年（3年）</td><td align="left"></td></tr><tr><td align="left">40</td><td align="left">秦三世（子婴）</td><td align="left">嬴子婴</td><td align="left">前207年―前207年（46天）</td><td align="left">诛杀赵高</td></tr></tbody></table><h2 id="4-2、秦的建国与发展"><a href="#4-2、秦的建国与发展" class="headerlink" title="4.2、秦的建国与发展"></a>4.2、秦的建国与发展</h2><p>　　<br>西周末年，秦人的祖先仍旧过着游牧生活，养马依然是他们的特长。此时，他们居住在“犬丘”（今甘肃天水地区）。其首领非子善于养马，被周孝王招至汧渭之间，专门负责给王室养马。后来，周孝王封秦为“附庸”，并使其“邑之秦”，这是秦得名的由来。<br>秦的建国，得益于犬戎攻周。公元前 770年，犬戎杀死周幽王，秦襄公率兵救周，有功。平王东迁，襄公又派兵护送。平王封襄公为诸侯，赐以岐西之地。秦始建国。</p><h1 id="5、汉朝"><a href="#5、汉朝" class="headerlink" title="5、汉朝"></a>5、汉朝</h1><p>汉朝（前202年-220年（405年））是继秦朝之后的大一统王朝，分为西汉、东汉时期</p><h2 id="5-1-1、西汉年表"><a href="#5-1-1、西汉年表" class="headerlink" title="5.1.1、西汉年表"></a>5.1.1、西汉年表</h2><table><thead><tr><th align="left">序号</th><th align="left">别名</th><th align="left">姓名</th><th align="left">在位时间</th><th align="left">主要事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">汉高祖</td><td align="left">刘邦</td><td align="left">前202-前195（8年）</td><td align="left">建立汉朝</td></tr><tr><td align="left">2</td><td align="left">汉惠帝</td><td align="left">刘盈</td><td align="left">前195-前188（8年）</td><td align="left">萧规曹随</td></tr><tr><td align="left">3</td><td align="left">前少帝</td><td align="left">刘恭</td><td align="left">前188-前184（5年）</td><td align="left">吕雉称制</td></tr><tr><td align="left">4</td><td align="left">后少帝</td><td align="left">刘弘</td><td align="left">前184-前180（5年）</td><td align="left"></td></tr><tr><td align="left">5</td><td align="left">汉文帝</td><td align="left">刘恒</td><td align="left">前180-前157（24年）</td><td align="left">文景之治 无为而治</td></tr><tr><td align="left">6</td><td align="left">汉景帝</td><td align="left">刘启</td><td align="left">前157-前141（17年）</td><td align="left">儿子中山靖王17代玄孙是刘备</td></tr><tr><td align="left">7</td><td align="left">汉武帝</td><td align="left">刘彻</td><td align="left">前141-前87（45年）</td><td align="left">推恩令，通西域</td></tr><tr><td align="left">8</td><td align="left">汉昭帝</td><td align="left">刘弗陵</td><td align="left">前87-前74（14年）</td><td align="left">昭宣中兴</td></tr><tr><td align="left">9</td><td align="left">汉废帝</td><td align="left">刘贺</td><td align="left">前74年7月-8月</td><td align="left"></td></tr><tr><td align="left">10</td><td align="left">汉宣帝</td><td align="left">刘询</td><td align="left">前74-前48（27年）</td><td align="left">昭宣中兴</td></tr><tr><td align="left">11</td><td align="left">汉元帝</td><td align="left">刘奭（shi）</td><td align="left">前48-前33（16年）</td><td align="left">平灭北匈奴</td></tr><tr><td align="left">12</td><td align="left">汉成帝</td><td align="left">刘骜</td><td align="left">前33-前7（27年）</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">汉哀帝</td><td align="left">刘欣</td><td align="left">前7-前1（7年）</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left">汉平帝</td><td align="left">刘衎</td><td align="left">前1-6年（1年）</td><td align="left">王莽摄政（王政君侄子） <div>9岁被毒死<br></div></td></tr><tr><td align="left">15</td><td align="left">孺子婴</td><td align="left">刘婴</td><td align="left">6年-8年（未称帝）</td><td align="left">21岁被杀</td></tr></tbody></table><h2 id="5-1-2、东汉年表"><a href="#5-1-2、东汉年表" class="headerlink" title="5.1.2、东汉年表"></a>5.1.2、东汉年表</h2><table><thead><tr><th align="left">序号</th><th align="left">别名</th><th align="left">姓名</th><th align="left">在位时间</th><th align="left">主要事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">光武帝</td><td align="left">刘秀</td><td align="left">25年-57年（33年）</td><td align="left">光武中兴</td></tr><tr><td align="left">2</td><td align="left">汉明帝</td><td align="left">刘庄</td><td align="left">57年-75年（19年）</td><td align="left">明章之治</td></tr><tr><td align="left">3</td><td align="left">汉章帝</td><td align="left">刘炟（da）</td><td align="left">75年-88年（14年）</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">汉殇帝</td><td align="left">刘隆</td><td align="left">106年</td><td align="left">邓绥称制</td></tr><tr><td align="left">5</td><td align="left">汉安帝</td><td align="left">刘祜</td><td align="left">106年-125年（20年）</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">少帝</td><td align="left">刘懿</td><td align="left">125年</td><td align="left">阎皇后称制</td></tr><tr><td align="left">7</td><td align="left">汉顺帝</td><td align="left">刘保</td><td align="left">125年-144年（20年）</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">汉冲帝</td><td align="left">刘炳</td><td align="left">144年-145年（2年）</td><td align="left">梁妠称制</td></tr><tr><td align="left">9</td><td align="left">汉质帝</td><td align="left">刘缵</td><td align="left">145年-146年（2年）</td><td align="left">9岁被毒死</td></tr><tr><td align="left">10</td><td align="left">汉桓帝</td><td align="left">刘志</td><td align="left">146年-168年（23年）</td><td align="left">夺回皇权</td></tr><tr><td align="left">11</td><td align="left">汉灵帝</td><td align="left">刘宏</td><td align="left">168年-189年（22年）</td><td align="left">卖官鬻爵 十常侍作乱</td></tr><tr><td align="left">12</td><td align="left">汉少帝</td><td align="left">刘辩</td><td align="left">189年</td><td align="left">被董卓罢黜 15（18）岁自杀</td></tr><tr><td align="left">13</td><td align="left">汉献帝</td><td align="left">刘协</td><td align="left">189年-220年（32年）</td><td align="left">曹操摄政</td></tr></tbody></table><h2 id="5-1-3、三国相关人物表"><a href="#5-1-3、三国相关人物表" class="headerlink" title="5.1.3、三国相关人物表"></a>5.1.3、三国相关人物表</h2><h3 id="5-1-3-1、朝廷（东汉）-群雄"><a href="#5-1-3-1、朝廷（东汉）-群雄" class="headerlink" title="5.1.3.1、朝廷（东汉）&amp; 群雄"></a>5.1.3.1、朝廷（东汉）&amp; 群雄</h3><table><thead><tr><th align="left">序号</th><th align="left">人物</th><th align="left">相关事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">刘志（汉桓帝）</td><td align="left">外戚专权</td></tr><tr><td align="left">2</td><td align="left">刘宏（汉灵帝）</td><td align="left">黄巾起义</td></tr><tr><td align="left">3</td><td align="left">窦妙（窦太后）</td><td align="left">刘志之母</td></tr><tr><td align="left">4</td><td align="left">董太后（永乐太后）</td><td align="left">刘宏之母</td></tr><tr><td align="left">5</td><td align="left">十常侍</td><td align="left">张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜</td></tr><tr><td align="left">6</td><td align="left">何皇后</td><td align="left">刘辩之母，汉灵帝刘宏第二任皇后</td></tr><tr><td align="left">7</td><td align="left">王荣（王美人）</td><td align="left">刘协之母，汉灵帝刘宏妃子，被何皇后毒杀</td></tr><tr><td align="left">8</td><td align="left">何进</td><td align="left">何皇后哥哥，刘辩舅舅</td></tr><tr><td align="left">9</td><td align="left">刘辩（汉少帝）</td><td align="left">被董卓废掉，毒杀</td></tr><tr><td align="left">10</td><td align="left">刘协 （汉献帝）</td><td align="left">陈留王</td></tr><tr><td align="left">11</td><td align="left">刘恢</td><td align="left">代郡太守，刘备鞭都邮后投奔他，他保护刘备不被追查，并推荐他给刘虞</td></tr><tr><td align="left">12</td><td align="left">张角</td><td align="left">“天公将军”，创立太平道，提出“苍天已死，黄天当立”的口号以号召徒众，史称“黄巾军”</td></tr><tr><td align="left">13</td><td align="left">张宝</td><td align="left">“地公将军”，张角之弟，后来被皇甫嵩、郭典击败，被杀</td></tr><tr><td align="left">14</td><td align="left">张梁</td><td align="left">“人公将军”，张宝之弟，遭到遭皇甫嵩击败，被杀</td></tr><tr><td align="left">15</td><td align="left">董太后（永乐太后）</td><td align="left">刘宏之母</td></tr><tr><td align="left">16</td><td align="left">十常侍</td><td align="left">张让、赵忠、封谞、段珪、曹节、侯览、蹇硕（大将军）、程旷、夏恽、郭胜</td></tr><tr><td align="left">17</td><td align="left">卢植</td><td align="left">刘备老师，东汉名臣，参与平叛黄巾起义</td></tr><tr><td align="left">18</td><td align="left">袁绍</td><td align="left">（1）四世三公，早年任中军校尉，曾指挥诛杀宦官，建议何进引董卓 （2）争夺天下的野心与曹操产生冲突，最终在赤壁之战中被曹操击败</td></tr><tr><td align="left">19</td><td align="left">袁术</td><td align="left">（1）袁绍的弟弟。（2）与袁绍、曹操等同时起兵，共讨董卓。其后因与袁绍对立，被袁绍、曹操击败，率余众奔九江，割据扬州 （3）奢侈荒淫，横征暴敛，使江淮地区残破不堪，民多饥死</td></tr><tr><td align="left">20</td><td align="left">董卓</td><td align="left">西凉刺史</td></tr><tr><td align="left">21</td><td align="left">李儒</td><td align="left">董卓谋士 毒死刘辩</td></tr><tr><td align="left">22</td><td align="left">丁原</td><td align="left">字建阳，并州刺史</td></tr><tr><td align="left">23</td><td align="left">吕布</td><td align="left">诛杀董卓</td></tr><tr><td align="left">24</td><td align="left">樊稠</td><td align="left">（1）原为董卓部将，董卓死后，伙同李傕、郭汜、张济等人合众十余万反扑长安，败吕布、杀王允，把持朝政 。后因内斗被李傕外甥胡封在会议上刺死 （2）大败马腾、韩遂</td></tr><tr><td align="left">25</td><td align="left">李肃</td><td align="left">董卓手下虎贲中郎将，主动请命以赤兔马说服吕布杀丁原来降</td></tr><tr><td align="left">26</td><td align="left">王允</td><td align="left">设计诛杀董卓。后欲解散董卓的凉州兵旧部，使其人人自危，董卓部将李傕、郭汜乃合谋为乱，攻进长安，王允被杀</td></tr><tr><td align="left">27</td><td align="left">公孙瓒</td><td align="left">军阀，汉末群雄之一，卢植学生</td></tr><tr><td align="left">28</td><td align="left">华雄</td><td align="left">董卓帐下武将</td></tr><tr><td align="left">29</td><td align="left">颜良</td><td align="left">袁绍部将   白马之围</td></tr><tr><td align="left">30</td><td align="left">文丑</td><td align="left">袁绍部将</td></tr><tr><td align="left">31</td><td align="left">蔡邕</td><td align="left">东汉时期名臣，蔡文姬之父，被董卓重用，董卓死后被王允杀</td></tr><tr><td align="left">32</td><td align="left">陶谦</td><td align="left">徐州太守</td></tr><tr><td align="left">33</td><td align="left">刘表</td><td align="left">雄踞荆州，杀孙坚</td></tr><tr><td align="left">34</td><td align="left">曹豹</td><td align="left">东汉末年徐州牧陶谦部将，吕布的老丈人</td></tr><tr><td align="left">35</td><td align="left">张绣</td><td align="left">称雄宛城、在官渡之战力战有功，封邑最多</td></tr><tr><td align="left">36</td><td align="left">潘凤</td><td align="left">称雄宛城、在官渡之战力战有功，封邑最多冀州牧韩馥帐下的大将。当十八路诸侯讨伐董卓之时，他奉韩馥、袁绍之命前往汜水关前挑战董卓部下大将华雄，结果不多时就被斩</td></tr><tr><td align="left">37</td><td align="left">孔融</td><td align="left">孔子的第二十世孙 （208年）因触怒丞相曹操而被杀  孔融让梨</td></tr><tr><td align="left">38</td><td align="left">沮授</td><td align="left">东汉末年袁绍的监军 多次提出策略不被采纳</td></tr><tr><td align="left">39</td><td align="left">逢纪</td><td align="left">袁绍谋士 辅佐袁绍平定河北</td></tr><tr><td align="left">40</td><td align="left">田丰</td><td align="left">袁绍谋士 助袁绍灭公孙瓒</td></tr><tr><td align="left">41</td><td align="left">于吉</td><td align="left">琅琊人 ，东汉末年道士，后为孙策所杀，代表作有《太平经》</td></tr><tr><td align="left">42</td><td align="left">蔡瑁</td><td align="left">协助刘表平定荆州 刘表后妻蔡夫人弟弟</td></tr><tr><td align="left">43</td><td align="left">司马徽</td><td align="left">东汉末年隐士，精通奇门、经学。有“水镜先生”之称 向刘备推荐了诸葛亮、庞统等人</td></tr><tr><td align="left">44</td><td align="left">马腾</td><td align="left">东汉末年军事将领，军阀之一，马超，马铁之父</td></tr><tr><td align="left">45</td><td align="left">孟获</td><td align="left">三国时期南中地区的首领，公元225年起兵反叛蜀汉，被诸葛亮率领大军擒拿后被赦免，遂降服，此后不再叛乱，后孟获随诸葛亮回到成都，担任御史中丞</td></tr></tbody></table><h3 id="5-1-3-2、魏"><a href="#5-1-3-2、魏" class="headerlink" title="5.1.3.2、魏"></a>5.1.3.2、魏</h3><table><thead><tr><th align="left">序号</th><th align="left">人物</th><th align="left">相关事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">曹操</td><td align="left">（1）太尉曹嵩之子 （2）献七星宝刀</td></tr><tr><td align="left">2</td><td align="left">乐进</td><td align="left">斩淳于琼；斩严敬；每战先登；击退关羽；降伏蛮夷</td></tr><tr><td align="left">3</td><td align="left">李典</td><td align="left">曾在博望坡之战识破刘备的伪遁之计，救下了夏侯惇、于禁。又参与了逍遥津之战</td></tr><tr><td align="left">4</td><td align="left">曹仁</td><td align="left">破袁术、攻陶谦、擒吕布、败刘备，参加官渡之战</td></tr><tr><td align="left">5</td><td align="left">夏侯惇</td><td align="left">夏侯渊之族兄，汉朝开国功臣之一夏侯婴的后代</td></tr><tr><td align="left">6</td><td align="left">夏侯渊</td><td align="left">夏侯惇族弟, 官渡督粮、平定凉州, 被黄忠斩杀</td></tr><tr><td align="left">7</td><td align="left">曹洪</td><td align="left">（1）曹操从弟 （2） 早年随曹操起兵讨伐董卓。荥阳兵败，舍命献马，救驾于危难</td></tr><tr><td align="left">8</td><td align="left">贾诩</td><td align="left">原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操</td></tr><tr><td align="left">9</td><td align="left">荀彧</td><td align="left">早年被称为“王佐之才” 为曹操规划军事战略方针，堪称其统一北方的首席谋</td></tr><tr><td align="left">10</td><td align="left">荀攸</td><td align="left">是荀彧的堂侄，曹操的重要谋士</td></tr><tr><td align="left">11</td><td align="left">程昱</td><td align="left">本名程立，因梦中在泰山捧日，更名程昱</td></tr><tr><td align="left">12</td><td align="left">郭嘉</td><td align="left">经荀彧推荐，任曹军祭酒</td></tr><tr><td align="left">13</td><td align="left">刘晔</td><td align="left">光武帝刘秀之子阜陵王刘延的后代</td></tr><tr><td align="left">14</td><td align="left">满宠</td><td align="left">平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰</td></tr><tr><td align="left">15</td><td align="left">典韦</td><td align="left">濮阳之战击退吕布、宛城死战阻张绣</td></tr><tr><td align="left">16</td><td align="left">于禁</td><td align="left">讨伐黄巾余党、于张绣叛乱中坚守营垒，杀夏侯惇的青州军</td></tr><tr><td align="left">17</td><td align="left">许诸</td><td align="left">负责曹操的护卫工作，累迁武卫中郎将，赐号“虎侯”</td></tr><tr><td align="left">18</td><td align="left">贾诩</td><td align="left">曹魏开国功臣，原为董卓部将，董卓死后，献计李傕、郭汜反攻长安，李傕等人失败后，辗转成为张绣的谋士。官渡之战前，贾诩劝张绣归降曹操</td></tr><tr><td align="left">19</td><td align="left">陈登</td><td align="left">沛相陈珪之子，向曹操献灭吕布之策</td></tr><tr><td align="left">20</td><td align="left">陈珪</td><td align="left">陈登、陈应之父。官至沛相。助破袁术，策应曹操</td></tr><tr><td align="left">21</td><td align="left">车胄</td><td align="left">曹操灭吕布占有徐州之地后，任命车胄为徐州刺史。被关羽斩杀，全家也被张飞杀害</td></tr><tr><td align="left">22</td><td align="left">曹昂</td><td align="left">曹操长子。建安二年（197年）随曹操出征张绣，张绣降而复叛，曹昂为救曹操被杀</td></tr><tr><td align="left">23</td><td align="left">张辽</td><td align="left">雁门马邑（今山西省朔州市）人。先后跟随丁原、何进、董卓、吕布，恪尽职守，历尽坎坷。吕布败亡后，张辽归属曹操</td></tr><tr><td align="left">24</td><td align="left">许攸</td><td align="left">本为袁绍帐下谋士，官渡之战时其家人因犯法而被收捕，许攸因此背袁投曹，并为曹操设下偷袭袁绍军屯粮之所——乌巢的计策，袁绍因此而大败于官渡。后许攸随曹操平定冀州，因自恃其功而屡屡口出狂言，终因触怒曹操而被杀</td></tr><tr><td align="left">25</td><td align="left">曹丕</td><td align="left">曹操长子 建立曹魏；大破羌胡，复通西域</td></tr><tr><td align="left">26</td><td align="left">司马懿</td><td align="left">司马懿辅佐了魏国四代君主，见证了曹氏家族从兴盛走向衰亡，为稳定曹魏政权做出了贡献，也为其孙司马炎以晋代魏一统中国奠定了基础</td></tr><tr><td align="left">27</td><td align="left">满宠</td><td align="left">平定汝南；镇守魏国南线；击退孙权；烧贼攻具，射杀孙泰</td></tr><tr><td align="left">28</td><td align="left">曹真</td><td align="left">曹操养子 大败羌胡联军 平定河西 大破吴国孙盛 击退蜀汉诸葛亮</td></tr><tr><td align="left">29</td><td align="left">曹睿</td><td align="left">曹魏第二位皇帝。魏文帝曹丕长子 与曹操、曹丕并称魏氏“三祖”</td></tr><tr><td align="left">30</td><td align="left">钟会</td><td align="left">平诸葛诞之叛、与邓艾分兵灭蜀</td></tr><tr><td align="left">31</td><td align="left">张郃</td><td align="left">江陵破吴，街亭败蜀</td></tr><tr><td align="left">32</td><td align="left">曹芳</td><td align="left">曹魏第三位皇帝，疑为魏武帝曹操曾孙</td></tr><tr><td align="left">33</td><td align="left">曹爽</td><td align="left">曹魏权臣，大司马曹真长子</td></tr><tr><td align="left">34</td><td align="left">司马师</td><td align="left">曹魏权臣，西晋王朝的奠基人之一，晋宣帝司马懿与宣穆皇后张春华的长子，晋文帝司马昭的同母兄，晋武帝司马炎的伯父</td></tr><tr><td align="left">35</td><td align="left">司马昭</td><td align="left">司马炎之父，专揽国政，攻灭蜀汉；奠定西晋基础</td></tr><tr><td align="left">36</td><td align="left">郭淮</td><td align="left">魏国名将，雁门郡太守郭缊之子 被姜维杀</td></tr><tr><td align="left">37</td><td align="left">曹髦</td><td align="left">曹丕之孙，东海王曹霖之子，曹魏第四位皇帝 不满司马昭掌权反抗被杀</td></tr><tr><td align="left">38</td><td align="left">邓艾</td><td align="left">治理魏国西方，与姜维多次对峙；率兵偷渡阴平，攻灭蜀汉</td></tr><tr><td align="left">39</td><td align="left">曹奂</td><td align="left">三国时期曹魏末代皇帝（第五位）。魏武帝曹操之孙 司马炎篡夺魏国政权，建立西晋</td></tr><tr><td align="left">40</td><td align="left">诸葛瞻</td><td align="left">诸葛亮之子 与邓艾决战，兵败被杀，绵竹失守。后主刘禅出降，蜀汉灭亡</td></tr><tr><td align="left">41</td><td align="left">刘禅</td><td align="left">小名阿斗。蜀汉末代皇帝，刘备之子，母为昭烈皇后甘氏</td></tr></tbody></table><h3 id="5-1-3-3、蜀"><a href="#5-1-3-3、蜀" class="headerlink" title="5.1.3.3、蜀"></a>5.1.3.3、蜀</h3><table><thead><tr><th align="left">序号</th><th align="left">人物</th><th align="left">相关事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">刘备</td><td align="left">汉景帝之子中山靖王刘胜之后</td></tr><tr><td align="left">2</td><td align="left">关羽</td><td align="left">山西运城人</td></tr><tr><td align="left">3</td><td align="left">张飞</td><td align="left">今河北保定涿州市人</td></tr><tr><td align="left">4</td><td align="left">糜竺</td><td align="left">麋竺原为徐州富商，后被徐州牧陶谦辟为别驾从事（官名）。陶谦病死后，奉其遗命迎接刘备</td></tr><tr><td align="left">5</td><td align="left">简雍</td><td align="left">刘备帐下谋士</td></tr><tr><td align="left">6</td><td align="left">诸葛亮</td><td align="left">蜀汉丞相，向刘备提出占据荆州、益州，联合孙权共同对抗曹操的隆中对  五次北伐</td></tr><tr><td align="left">7</td><td align="left">赵云</td><td align="left">（1）与关羽、张飞并称“燕南三士”   （2）先加入公孙瓒，后追随刘备</td></tr><tr><td align="left">8</td><td align="left">孙乾</td><td align="left">东汉末年刘备帐下幕僚</td></tr><tr><td align="left">9</td><td align="left">廖化</td><td align="left">攻破游奕，击杀王赟</td></tr><tr><td align="left">10</td><td align="left">周仓</td><td align="left">关羽身边的武将。在关羽镇守荆州对抗曹魏名将于禁与庞德的战斗中，于水中生擒庞德。最后周仓在关羽父子被斩之后自刎而死</td></tr><tr><td align="left">11</td><td align="left">廖化</td><td align="left">攻破游奕，击杀王赟</td></tr><tr><td align="left">12</td><td align="left">徐庶</td><td align="left">东汉末年刘备帐下谋士，后归曹操</td></tr><tr><td align="left">13</td><td align="left">庞统</td><td align="left">刘备帐下重要谋士，与诸葛亮同拜为军师中郎将   攻打益州刘璋时死于落凤坡</td></tr><tr><td align="left">14</td><td align="left">黄忠</td><td align="left">本为刘表部下中郎将，后归刘备，并助刘备攻破益州刘璋</td></tr><tr><td align="left">15</td><td align="left">魏延</td><td align="left">镇守汉中，大破费瑶和郭淮，子午谷奇谋</td></tr><tr><td align="left">16</td><td align="left">马超</td><td align="left">马腾长子，马铁，马休兄长  辅助刘备建立蜀汉</td></tr><tr><td align="left">17</td><td align="left">张苞</td><td align="left">张飞的长子。英年早逝，留有一子张遵</td></tr><tr><td align="left">18</td><td align="left">关兴</td><td align="left">关羽次子，关平之弟</td></tr><tr><td align="left">19</td><td align="left">马良</td><td align="left">马良兄弟五人，都有才华名气，乡里为他们编有谚语说：“马家五常，白眉最良。”马良眉中有白毛，故此人们这样称呼他</td></tr><tr><td align="left">20</td><td align="left">马谡</td><td align="left">马良之弟，诸葛亮北伐时因作战失误失守街亭</td></tr><tr><td align="left">21</td><td align="left">姜维</td><td align="left">洮西大破王经，据守剑阁阻挡住钟会大军</td></tr><tr><td align="left">22</td><td align="left">邓芝</td><td align="left">出使吴国，与之修好 讨平涪陵叛乱</td></tr><tr><td align="left">23</td><td align="left">王平</td><td align="left">击退曹爽大举伐蜀</td></tr><tr><td align="left">24</td><td align="left">杨仪</td><td align="left">辅佐诸葛亮、击杀魏延</td></tr><tr><td align="left">25</td><td align="left">蒋琬</td><td align="left">继诸葛亮执政，安定众心</td></tr><tr><td align="left">26</td><td align="left">李严</td><td align="left">与诸葛亮同为刘备临终前的托孤之臣 参与制定《蜀科》</td></tr><tr><td align="left">27</td><td align="left">马岱</td><td align="left">马超从弟，在诸葛亮病逝后受杨仪派遣斩杀了蜀将魏延</td></tr><tr><td align="left">28</td><td align="left">费祎</td><td align="left">蜀汉四相之一 休养生息，增强蜀汉国力</td></tr></tbody></table><h3 id="5-1-3-4、吴"><a href="#5-1-3-4、吴" class="headerlink" title="5.1.3.4、吴"></a>5.1.3.4、吴</h3><table><thead><tr><th align="left">序号</th><th align="left">人物</th><th align="left">相关事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">孙坚</td><td align="left">（1）孙吴政权的奠基者 （2）洛阳城外击溃董卓</td></tr><tr><td align="left">2</td><td align="left">程普</td><td align="left">从孙坚讨黄巾、破董卓；救孙策，定江东；参与赤壁之战、南郡之战</td></tr><tr><td align="left">3</td><td align="left">黄盖</td><td align="left">在赤壁之战中诈降，献计火攻</td></tr><tr><td align="left">4</td><td align="left">孙策</td><td align="left">孙坚长子，字伯符</td></tr><tr><td align="left">5</td><td align="left">孙权</td><td align="left">孙坚次子，字仲谋</td></tr><tr><td align="left">6</td><td align="left">孙尚香</td><td align="left">孙权之妹，曾为刘备之妻，民间戏剧称之为孙尚香</td></tr><tr><td align="left">7</td><td align="left">周瑜</td><td align="left">辅平江东、开拓荆州、赤壁破曹、督灭黄祖、谏阻纳质、提出征伐益州战略</td></tr><tr><td align="left">8</td><td align="left">张昭</td><td align="left">辅佐孙策、孙权安定江东，与孙邵、滕胤等撰定朝仪</td></tr><tr><td align="left">9</td><td align="left">张紘</td><td align="left">东汉末年文学家、官员，和张昭一起合称“二张”</td></tr><tr><td align="left">10</td><td align="left">大乔</td><td align="left">东汉末年江东孙策的夫人，本姓“桥”，小说《三国演义》误作“乔”，因为同时还有一个妹妹嫁给周瑜，为了进行区分，姐姐习惯称作“大乔（桥）”</td></tr><tr><td align="left">11</td><td align="left">鲁肃</td><td align="left">孙权部将、战略家、外交家</td></tr><tr><td align="left">12</td><td align="left">甘宁</td><td align="left">先投靠刘表，但未被重用，后归依孙权，孙权加以重用。曾随周瑜在乌林击败曹操在南郡攻打曹仁夺取夷陵</td></tr><tr><td align="left">13</td><td align="left">陆逊</td><td align="left">与吕蒙共同击败关羽、夺取荆州 夷陵之战破刘备 石亭之战败曹休</td></tr><tr><td align="left">14</td><td align="left">吕蒙</td><td align="left">攻皖城 取三郡 濡须之战 袭荆州</td></tr><tr><td align="left">15</td><td align="left">诸葛恪</td><td align="left">大将军诸葛瑾长子，蜀汉丞相诸葛亮之侄 在东兴堤大胜魏军</td></tr><tr><td align="left">16</td><td align="left">丁奉</td><td align="left">在东兴之战中大破魏军前屯</td></tr><tr><td align="left">17</td><td align="left">孙亮</td><td align="left">孙吴第二位皇帝 计除权臣诸葛恪 后被孙琳废</td></tr><tr><td align="left">18</td><td align="left">孙峻</td><td align="left">诛杀诸葛恪，专擅朝政</td></tr><tr><td align="left">19</td><td align="left">孙休</td><td align="left">孙权第六子。中国三国时期孙吴国主</td></tr><tr><td align="left">20</td><td align="left">孙綝（chen）</td><td align="left">孙亮即位后由孙峻辅政。 太平元年（公元256年）孙峻去世，孙綝接替堂兄掌控朝局 被孙休、丁奉等定计诛杀</td></tr><tr><td align="left">21</td><td align="left">陆抗</td><td align="left">西陵之战大破晋军；维护吴国稳定</td></tr></tbody></table><h2 id="5-1-4、三国势力图"><a href="#5-1-4、三国势力图" class="headerlink" title="5.1.4、三国势力图"></a>5.1.4、三国势力图</h2><ol><li>初期势力图</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031910885.png" alt="三国势力图|725"></p><ol start="2"><li>三足鼎立势力图</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202309031918859.png" alt="三足鼎立|975"></p><h1 id="6、魏晋南北朝时期"><a href="#6、魏晋南北朝时期" class="headerlink" title="6、魏晋南北朝时期"></a>6、魏晋南北朝时期</h1><h2 id="6-1、魏晋南北朝时期概览"><a href="#6-1、魏晋南北朝时期概览" class="headerlink" title="6.1、魏晋南北朝时期概览"></a>6.1、魏晋南北朝时期概览</h2><p>魏晋南北朝（220—589年，370年），又称三国两晋南北朝，是中国历史上政权更迭最频繁的时期，主要分为三国（曹魏、蜀汉、东吴）、西晋、东晋和南北朝时期，由于长期的封建割据和连绵不断的战争，使这一时期中国文化的发展受到特别的影响。其突出表现则是玄学的兴起、佛教的输入、道教的勃兴。三国至隋的<strong>三百六十余年</strong>，以及三十余个大小王朝交替兴灭过程</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308051110202.png" alt="魏晋南北朝时期"></p><h1 id="7、隋朝"><a href="#7、隋朝" class="headerlink" title="7、隋朝"></a>7、隋朝</h1><h2 id="7-1、隋朝年表"><a href="#7-1、隋朝年表" class="headerlink" title="7.1、隋朝年表"></a>7.1、隋朝年表</h2><p>隋朝（581年～619年,38年）是中国历史上承南北朝，下启唐朝的大统一朝代。定都大兴（西安）</p><table><thead><tr><th align="left">序号</th><th align="left">谥号</th><th align="left">姓名</th><th align="left">在位时间</th><th align="left">相关事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">隋文帝</td><td align="left">杨坚</td><td align="left">581年-604年（24年）</td><td align="left">三省六部制<div>开创科举</div><div>罢黜杨勇，立杨广</div></td></tr><tr><td align="left">2</td><td align="left">隋炀帝&#x2F;隋明帝</td><td align="left">杨广</td><td align="left">604年-618年（15年）</td><td align="left">迁都洛阳 <div>穷奢极欲</div><div>隋朝大运河</div><div>江都兵变</div></td></tr><tr><td align="left">3</td><td align="left">隋恭帝</td><td align="left">杨侑</td><td align="left">617年-618年（177天）</td><td align="left">被李渊拥立为帝，后被幽禁</td></tr><tr><td align="left">4</td><td align="left">隋秦王</td><td align="left">杨浩</td><td align="left">618年（半年）</td><td align="left">被宇文化及拥立为帝，后被毒杀</td></tr><tr><td align="left">5</td><td align="left">皇泰主</td><td align="left">杨侗（dong）</td><td align="left">618年-619年（1年）</td><td align="left">被王世充拥立为帝，后被杀害</td></tr></tbody></table><h1 id="8、唐朝"><a href="#8、唐朝" class="headerlink" title="8、唐朝"></a>8、唐朝</h1><h2 id="8-1、唐朝年表"><a href="#8-1、唐朝年表" class="headerlink" title="8.1、唐朝年表"></a>8.1、唐朝年表</h2><p>唐王李渊于618年逼隋恭帝禅位,推翻隋朝,改国号为“唐”(尊称“大唐”),建立了唐朝（618年－907年，289年）</p><table><thead><tr><th align="left">序号</th><th align="left">别名</th><th align="left">姓名</th><th align="left">在位时间</th><th align="left">主要事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">唐高祖</td><td align="left">李渊</td><td align="left">618-626（9年）</td><td align="left">晋阳起兵，建立唐朝</td></tr><tr><td align="left">2</td><td align="left">唐太宗</td><td align="left">李世民</td><td align="left">627-649（23年）</td><td align="left">玄武门之变，贞观之治</td></tr><tr><td align="left">3</td><td align="left">唐高宗</td><td align="left">李治</td><td align="left">650-683（24年）</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">唐中宗</td><td align="left">李显</td><td align="left">684</td><td align="left">被废</td></tr><tr><td align="left">5</td><td align="left">唐睿宗</td><td align="left">李旦</td><td align="left">684-690（6年）</td><td align="left">被废</td></tr><tr><td align="left">6</td><td align="left">武则天</td><td align="left">武曌（zhao）</td><td align="left">690-705（16年）</td><td align="left">武周开国君主（不属于唐）</td></tr><tr><td align="left">7</td><td align="left">唐中宗</td><td align="left">李显</td><td align="left">705-710（5年）</td><td align="left">神龙政变 被韦皇后毒死</td></tr><tr><td align="left">8</td><td align="left">唐少帝</td><td align="left">李重茂</td><td align="left">710</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">唐睿宗</td><td align="left">李旦</td><td align="left">710-712（2年）</td><td align="left">二次让位</td></tr><tr><td align="left">10</td><td align="left">唐玄宗</td><td align="left">李隆基</td><td align="left">712-756（44年）</td><td align="left">唐隆政变 唐明皇 安史之乱 开元之治</td></tr><tr><td align="left">11</td><td align="left">唐肃宗</td><td align="left">李亨</td><td align="left">756-762（5年）</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">唐代宗</td><td align="left">李豫</td><td align="left">762-779（17年）</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">唐德宗</td><td align="left">李适</td><td align="left">779-805（26年）</td><td align="left"></td></tr><tr><td align="left">14</td><td align="left">唐顺宗</td><td align="left">李诵</td><td align="left">805（8月）</td><td align="left"></td></tr><tr><td align="left">15</td><td align="left">唐宪宗</td><td align="left">李纯</td><td align="left">806-820（15年）</td><td align="left">元和中兴</td></tr><tr><td align="left">16</td><td align="left">唐穆宗</td><td align="left">李恒</td><td align="left">821-824（4年）</td><td align="left"></td></tr><tr><td align="left">17</td><td align="left">唐敬宗</td><td align="left">李湛</td><td align="left">824-826（2年）</td><td align="left"></td></tr><tr><td align="left">18</td><td align="left">唐文宗</td><td align="left">李昂</td><td align="left">826-840（14年）</td><td align="left"></td></tr><tr><td align="left">19</td><td align="left">唐武宗</td><td align="left">李炎</td><td align="left">840-846（6年）</td><td align="left"></td></tr><tr><td align="left">20</td><td align="left">唐宣宗</td><td align="left">李忱（chen）</td><td align="left">846-859（13年）</td><td align="left"></td></tr><tr><td align="left">21</td><td align="left">唐懿宗</td><td align="left">李漼（cui）</td><td align="left">859-873（14年）</td><td align="left"></td></tr><tr><td align="left">22</td><td align="left">唐僖宗</td><td align="left">李儇（xuan）</td><td align="left">873-888（15年）</td><td align="left">黄巢起义</td></tr><tr><td align="left">23</td><td align="left">唐昭宗</td><td align="left">李晔</td><td align="left">888-904（16年）</td><td align="left"></td></tr><tr><td align="left">24</td><td align="left">唐哀帝</td><td align="left">李柷（chu）</td><td align="left">904-907（3年）</td><td align="left"></td></tr></tbody></table><h1 id="9、五代十国"><a href="#9、五代十国" class="headerlink" title="9、五代十国"></a>9、五代十国</h1><h1 id="10、宋朝"><a href="#10、宋朝" class="headerlink" title="10、宋朝"></a>10、宋朝</h1><h2 id="10-1、宋朝年表"><a href="#10-1、宋朝年表" class="headerlink" title="10.1、宋朝年表"></a>10.1、宋朝年表</h2><p>宋朝（960年－1279年，319年）是中国历史上承五代十国下启元朝的中原王朝，分北宋和南宋两个阶段，共历十八帝</p><table><thead><tr><th align="left">序号</th><th align="left">别名</th><th align="left">姓名</th><th align="left">在位时间</th><th align="left">主要事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">宋太祖</td><td align="left">赵匡胤</td><td align="left">960-976（16年）</td><td align="left">改革官帽 两次杯酒释兵权</td></tr><tr><td align="left">2</td><td align="left">宋太宗</td><td align="left">赵炅</td><td align="left">976-997（21年）</td><td align="left">赵匡胤之弟 雪中送炭</td></tr><tr><td align="left">3</td><td align="left">宋真宗</td><td align="left">赵恒</td><td align="left">997-1022（15年）</td><td align="left">赵炅三子，澶渊之盟</td></tr><tr><td align="left">4</td><td align="left">宋仁宗</td><td align="left">赵祯</td><td align="left">1022-1063（41年）</td><td align="left">赵恒六子， 发行交子 狸猫换太子</td></tr><tr><td align="left">5</td><td align="left">宋英宗</td><td align="left">赵曙</td><td align="left">1063-1067（4年）</td><td align="left">赵祯堂兄赵允让第十三子     《资治通鉴》</td></tr><tr><td align="left">6</td><td align="left">宋神宗</td><td align="left">赵顼</td><td align="left">1067-1085（18年）</td><td align="left">赵曙长子，重用王安石变法</td></tr><tr><td align="left">7</td><td align="left">宋哲宗</td><td align="left">赵煦</td><td align="left">1085-1100（15年）</td><td align="left">赵顼六子</td></tr><tr><td align="left">8</td><td align="left">宋徽宗</td><td align="left">赵佶</td><td align="left">1100-1126（26年）</td><td align="left">赵顼十一子，书法绘画大师（瘦金体）  宋江起义 方腊起义    靖康之变</td></tr><tr><td align="left">9</td><td align="left">宋钦宗</td><td align="left">赵桓</td><td align="left">1126-1127（1年）</td><td align="left">赵佶长子，赵构异母兄弟 。1127年发生”靖康之变” 金朝南下攻取北宋首都东京，掳走徽、钦二帝，导致北宋灭亡的历史事件</td></tr><tr><td align="left">10</td><td align="left">宋高宗</td><td align="left">赵构</td><td align="left">1127-1162（35年）</td><td align="left">赵佶九子，南宋开国皇帝 ，重用秦桧</td></tr><tr><td align="left">11</td><td align="left">宋孝宗</td><td align="left">赵昚（shen）</td><td align="left">1162-1189（27年）</td><td align="left">赵构养子 平反岳飞 隆兴和议 被认为南宋最有作为的皇帝</td></tr><tr><td align="left">12</td><td align="left">宋光宗</td><td align="left">赵惇</td><td align="left">1189-1194（5年）</td><td align="left">绍熙内禅</td></tr><tr><td align="left">13</td><td align="left">宋宁宗</td><td align="left">赵扩</td><td align="left">1194 -1224（30年）</td><td align="left">赵惇次子</td></tr><tr><td align="left">14</td><td align="left">宋理宗</td><td align="left">赵昀（yun）</td><td align="left">1224-1264（40年）</td><td align="left">赵扩远方堂侄 ，联蒙灭金</td></tr><tr><td align="left">15</td><td align="left">宋度宗</td><td align="left">赵禥（qi）</td><td align="left">1264-1274（10年）</td><td align="left">赵昀之侄，智力低于常人</td></tr><tr><td align="left">16</td><td align="left">宋恭宗</td><td align="left">赵㬎（xian）</td><td align="left">1274-1276（2年）</td><td align="left">赵禥次子 ，退位降元</td></tr><tr><td align="left">17</td><td align="left">宋端宗</td><td align="left">赵昰（shi）</td><td align="left">1276-1278（2年）</td><td align="left">赵禥庶长子，九岁去世</td></tr><tr><td align="left">18</td><td align="left">宋卫王</td><td align="left">赵昺（昺）</td><td align="left">1278-1279（1年）</td><td align="left">赵禥三子，崖山海战，投海殉国</td></tr></tbody></table><h1 id="11、元朝"><a href="#11、元朝" class="headerlink" title="11、元朝"></a>11、元朝</h1><h2 id="11-1、元朝年表"><a href="#11-1、元朝年表" class="headerlink" title="11.1、元朝年表"></a>11.1、元朝年表</h2><p>元朝（1271年—1368年，98年），是中国历史上的朝代。铁木真于1206年建国；1271年忽必烈定国号为元，1279年灭南宋。 是首次由少数民族建立的大一统王朝，传五世十一帝</p><table><thead><tr><th>序号</th><th>姓名</th><th>庙号</th><th>统治时间</th><th>事件</th></tr></thead><tbody><tr><td>1</td><td>孛儿只斤·铁木真</td><td>元太祖</td><td>1206-1227年（21年）</td><td>大蒙古可汗，建立大蒙古国</td></tr><tr><td>2</td><td>孛儿只斤·窝阔台</td><td>元太宗</td><td>1229-1241年（12年）</td><td>蒙古帝国大汗，奠定元朝基础</td></tr><tr><td>3</td><td>孛儿只斤·贵由</td><td>元定宗</td><td>1246-1248年（2年）</td><td>蒙古帝国第三任大汗，西征欧洲</td></tr><tr><td>4</td><td>孛儿只斤·蒙哥</td><td>元宪宗</td><td>1251-1259年（8年）</td><td>大蒙古国可汗，招降吐蕃</td></tr><tr><td>1</td><td>孛儿只斤·忽必烈</td><td>元世祖</td><td>1260-1294年 （34年）</td><td>元朝开国皇帝，首创行省制度</td></tr><tr><td>2</td><td>孛儿只斤·铁穆耳</td><td>元成宗</td><td>1294-1307年（13年）</td><td>击败西北叛王</td></tr><tr><td>3</td><td>孛儿只斤·海山</td><td>元武宗</td><td>1307-1311年（4年）</td><td>设尚书省</td></tr><tr><td>4</td><td>孛儿只斤·爱育黎拔力八达</td><td>元仁宗</td><td>1311-1320年（9年）</td><td>实行科举制度</td></tr><tr><td>5</td><td>孛儿只斤·硕德八剌</td><td>元英宗</td><td>1320-1323年（3年）</td><td></td></tr><tr><td>6</td><td>孛儿只斤·也孙铁木儿</td><td>-</td><td>1323-1328年（5年）</td><td>史称泰定帝</td></tr><tr><td>7</td><td>孛儿只斤·阿速吉八</td><td>-</td><td>1328年（27天）</td><td>史称天顺帝</td></tr><tr><td>8</td><td>孛儿只斤·图帖睦尔</td><td>元文宗</td><td>1329-1332年（3年）</td><td></td></tr><tr><td>9</td><td>孛儿只斤·和世㻋</td><td>元明宗</td><td>1329年（184天）</td><td></td></tr><tr><td>10</td><td>孛儿只斤·懿璘质班</td><td>元宁宗</td><td>1332年（52天）</td><td></td></tr><tr><td>11</td><td>孛儿只斤·懽帖睦尔</td><td>元惠宗</td><td>1333-1370年（37年）</td><td>实施“至正新政”改革</td></tr></tbody></table><h1 id="12、明朝"><a href="#12、明朝" class="headerlink" title="12、明朝"></a>12、明朝</h1><h2 id="12-1、明朝年表"><a href="#12-1、明朝年表" class="headerlink" title="12.1、明朝年表"></a>12.1、明朝年表</h2><p>明朝（1368年―1644年，276年）明太祖朱元璋所建。初期建都南京，明成祖时期迁都北京。传十六帝</p><table><thead><tr><th align="left">序号</th><th align="left">别名</th><th align="left">姓名</th><th align="left">年号</th><th align="left">在位时间</th><th align="left">主要事件</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">明太祖</td><td align="left">朱元璋</td><td align="left">洪武</td><td align="left">1368-1398（20年）</td><td align="left">洪武之治</td></tr><tr><td align="left">2</td><td align="left">明惠宗</td><td align="left">朱允炆</td><td align="left">建文</td><td align="left">1398-1402（4年）</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left">明成祖</td><td align="left">朱棣</td><td align="left">永乐</td><td align="left">1402-1424（22年）</td><td align="left">永乐盛世</td></tr><tr><td align="left">4</td><td align="left">明仁宗</td><td align="left">朱高炽</td><td align="left">洪熙</td><td align="left">1424-1425（1年）</td><td align="left">仁宣之治</td></tr><tr><td align="left">5</td><td align="left">明宣宗</td><td align="left">朱瞻基</td><td align="left">宣德</td><td align="left">1425-1435（10年）</td><td align="left"></td></tr><tr><td align="left">6</td><td align="left">明英宗</td><td align="left">朱祁镇</td><td align="left">正统 天顺</td><td align="left">1435-1449 1457-1464</td><td align="left">夺门之变</td></tr><tr><td align="left">7</td><td align="left">明代宗</td><td align="left">朱祁钰</td><td align="left">景泰</td><td align="left">1449-1457（8年）</td><td align="left"></td></tr><tr><td align="left">8</td><td align="left">明宪宗</td><td align="left">朱见深</td><td align="left">成化</td><td align="left">1464-1487（23年）</td><td align="left"></td></tr><tr><td align="left">9</td><td align="left">明孝宗</td><td align="left">朱祐樘</td><td align="left">弘治</td><td align="left">1487-1505（18年）</td><td align="left">弘治中兴</td></tr><tr><td align="left">10</td><td align="left">明武宗</td><td align="left">朱厚照</td><td align="left">正德</td><td align="left">1505-1521（16年）</td><td align="left"></td></tr><tr><td align="left">11</td><td align="left">明世宗</td><td align="left">朱厚熜</td><td align="left">嘉靖</td><td align="left">1521-1566（45年）</td><td align="left"></td></tr><tr><td align="left">12</td><td align="left">明穆宗</td><td align="left">朱载坖</td><td align="left">隆庆</td><td align="left">1566-1572（6年）</td><td align="left"></td></tr><tr><td align="left">13</td><td align="left">明神宗</td><td align="left">朱翊（yi）钧</td><td align="left">万历</td><td align="left">1572-1620（48年）</td><td align="left">万历中兴</td></tr><tr><td align="left">14</td><td align="left">明光宗</td><td align="left">朱常洛</td><td align="left">泰昌</td><td align="left">1620</td><td align="left"></td></tr><tr><td align="left">15</td><td align="left">明熹宗</td><td align="left">朱由校</td><td align="left">天启</td><td align="left">1620-1627（7年）</td><td align="left"></td></tr><tr><td align="left">16</td><td align="left">明思宗</td><td align="left">朱由检</td><td align="left">崇祯</td><td align="left">1627-1644（17年）</td><td align="left"></td></tr><tr><td align="left"></td><td align="left">南明时期（1644-1662，18年）</td><td align="left"></td><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">1</td><td align="left">明安宗</td><td align="left">朱由崧</td><td align="left">弘光</td><td align="left">1644-1645（1年）</td><td align="left"></td></tr><tr><td align="left">2</td><td align="left">明绍宗</td><td align="left">朱聿键</td><td align="left">隆武</td><td align="left">1645-1646（1年）</td><td align="left"></td></tr><tr><td align="left">3</td><td align="left"></td><td align="left">朱聿鐭</td><td align="left">绍武</td><td align="left">1646年的1个月</td><td align="left"></td></tr><tr><td align="left">4</td><td align="left">明昭宗</td><td align="left">朱聿键</td><td align="left">永历</td><td align="left">1646-1662（16年）</td><td align="left"></td></tr></tbody></table><h1 id="13、清朝"><a href="#13、清朝" class="headerlink" title="13、清朝"></a>13、清朝</h1><h2 id="13-1、清朝年表"><a href="#13-1、清朝年表" class="headerlink" title="13.1、清朝年表"></a>13.1、清朝年表</h2><p>清朝（1616年—1912年，296年），是中国历史上最后一个封建王朝，共传十二帝，初称后金。从努尔哈赤建国起，总计296年。从皇太极改国号为清起，国祚276年</p><table><thead><tr><th>序号</th><th>姓名</th><th>年号</th><th>在位时间</th><th>主要事件</th></tr></thead><tbody><tr><td>1</td><td>努尔哈赤</td><td>天命</td><td>1616-1626（10年）</td><td>统一女真 建立后金 反抗明朝 萨尔浒之战</td></tr><tr><td>2</td><td>皇太极</td><td>天聪 崇德</td><td>1626-1643（17年）</td><td>征服朝鲜和蒙古 松锦大捷 改国号大清和族名满洲</td></tr><tr><td>3</td><td>福临</td><td>顺治</td><td>1643-1661（18年）</td><td>李自成攻入北京 崇祯自缢而死 吴三桂引清军入关 大清迁都北京</td></tr><tr><td>4</td><td>玄烨</td><td>康熙</td><td>1661-1722（61年）</td><td>囚禁鳌拜 削三番 收复台湾 签订《尼布楚条约》</td></tr><tr><td>5</td><td>胤禛</td><td>雍正</td><td>1722-1735（13年）</td><td>设军机处</td></tr><tr><td>6</td><td>弘历</td><td>乾隆</td><td>1736-1796（60年）</td><td>编纂《四库全书》 大兴文字狱 实行闭关锁国</td></tr><tr><td>7</td><td>永琰</td><td>嘉庆</td><td>1796-1820（24年）</td><td>诛杀和珅 白莲教天理教起义</td></tr><tr><td>8</td><td>旻宁</td><td>道光</td><td>1820-1850（30年）</td><td>虎门销烟 第一次鸦片战争 《南京条约》，割香港给英国</td></tr><tr><td>9</td><td>奕訢</td><td>咸丰</td><td>1850-1861（11年）</td><td>太平天国起义 第二次鸦片战争 圆明园被毁  《天津条约》《北京条约》  洋务运动</td></tr><tr><td>10</td><td>载淳</td><td>同治</td><td>1861-1874（13年）</td><td>辛酉政变 慈溪垂帘听政 镇压太平天国 同治中兴</td></tr><tr><td>11</td><td>载湉</td><td>光绪</td><td>1874-1908（34年）</td><td>中法战争 中日甲午战争 戊戌变法 义和团 八国联军   《马关条约》《辛丑条约》 慈溪仍掌政</td></tr><tr><td>12</td><td>溥仪</td><td>宣统</td><td>1908-1911（3年）</td><td>辛亥革命</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中国古代史 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis</title>
      <link href="/posts/44296.html"/>
      <url>/posts/44296.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h1><p>Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><h2 id="1-1、redis特性"><a href="#1-1、redis特性" class="headerlink" title="1.1、redis特性"></a>1.1、redis特性</h2><ol><li>键值（key-value）型，value支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li></ol><blockquote><p>Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行</p></blockquote><ol start="3"><li>低延迟，速度快</li></ol><blockquote><p>原因：基于内存、采用多路复用非阻塞I&#x2F;O、单线程</p></blockquote><ol><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语言客户端</li></ol><h2 id="1-2、数据类型"><a href="#1-2、数据类型" class="headerlink" title="1.2、数据类型"></a>1.2、数据类型</h2><blockquote><p>Redis是一个key-value的数据库，key一般是String类型，不过value的类型多种多样</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308071403029.png" alt="redis数据类型"></p><h1 id="2、redis常见命令"><a href="#2、redis常见命令" class="headerlink" title="2、redis常见命令"></a>2、redis常见命令</h1><h2 id="2-1、String"><a href="#2-1、String" class="headerlink" title="2.1、String"></a>2.1、String</h2><p>String是Redis中最基本的数据类型，可以存储任何数据，包括二进制数据、序列化的数据、JSON化的对象甚至是图片。 </p><blockquote><p>String类型，也就是字符串类型，是Redis中最简单的存储类型<br>底层SDS结构。为什么不直接实用字符串？①C 语言字符数组最后一个元素总是 ‘\0’，而在Redis中\0可能会被判定为提前结束而识别不了字符串②获取字符串长度为O(n)，因为C字符串需要去遍历，开销较大，SDS对象有len属性直接获取</p></blockquote><p>其value是字符串，不过根据字符串的格式不同，又可以分为3类：<br>（1）string：普通字符串<br>（2）int：整数类型，可以做自增、自减操作<br>（3）float：浮点类型，可以做自增、自减操作</p><table><thead><tr><th>命令</th><th>描述</th></tr></thead><tbody><tr><td>SET</td><td>添加或者修改已经存在的一个String类型的键值对</td></tr><tr><td>GET</td><td>根据key获取String类型的value</td></tr><tr><td>MSET</td><td>批量添加多个String类型的键值对</td></tr><tr><td>MGET</td><td>根据多个key获取多个String类型的value</td></tr><tr><td>INCR</td><td>让一个整型的key自增1</td></tr><tr><td>INCRBY</td><td>让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</td></tr><tr><td>INCRBYFLOAT</td><td>让一个浮点类型的数字自增并指定步长</td></tr><tr><td>SETNX</td><td>添加一个String类型的键值对，前提是这个key不存在，否则不执行</td></tr><tr><td>SETEX</td><td>添加一个String类型的键值对，并且指定有效期</td></tr></tbody></table><blockquote><p><strong>Redis的key允许有多个单词形成层级结构，多个单词之间用” ：“隔开，格式如下：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目名:业务名:类型:id</span><br></pre></td></tr></table></figure><h2 id="2-2、Hash"><a href="#2-2、Hash" class="headerlink" title="2.2、Hash"></a>2.2、Hash</h2><blockquote><p>Hash类型，也叫散列，底层是hashtable，其value是一个无序字典，类似于Java中的HashMap结构。</p></blockquote><p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>HSET key field value</td><td>添加或者修改hash类型key的field的值</td></tr><tr><td>HGET key field</td><td>获取一个hash类型key的field的值</td></tr><tr><td>HMSET</td><td>hmset 和 hset 效果相同 ，4.0之后hmset可以弃用了</td></tr><tr><td>HMGET</td><td>批量获取多个hash类型key的field的值</td></tr><tr><td>HGETALL</td><td>获取一个hash类型的key中的所有的field和value</td></tr><tr><td>HKEYS</td><td>获取一个hash类型的key中的所有的field</td></tr><tr><td>HVALS</td><td>获取一个hash类型的key中的所有的value</td></tr><tr><td>HINCRBY</td><td>让一个hash类型key的字段值自增并指定步长</td></tr><tr><td>HSETNX</td><td>添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td></tr></tbody></table><h2 id="2-3、List"><a href="#2-3、List" class="headerlink" title="2.3、List"></a>2.3、List</h2><blockquote><p>list列表的数据结构使用的是压缩列表ziplist和普通的双向链表linkedlist组成。元素少的时候会用ziplist，元素多的时候会用linkedlist<br>  ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的,当数据量较大的时候因为需要重新分配，开销较大</p></blockquote><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>LPUSH key element …</td><td>向列表左侧插入一个或多个元素</td></tr><tr><td>LPOP key</td><td>移除并返回列表左侧的第一个元素，没有则返回nil</td></tr><tr><td><strong>RPUSH key element …</strong></td><td>向列表右侧插入一个或多个元素</td></tr><tr><td>RPOP key</td><td>移除并返回列表右侧的第一个元素</td></tr><tr><td>LRANGE key star end</td><td>返回一段角标范围内的所有元素</td></tr><tr><td>BLPOP和BRPOP</td><td>与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</td></tr></tbody></table><h2 id="2-4、SET"><a href="#2-4、SET" class="headerlink" title="2.4、SET"></a>2.4、SET</h2><blockquote><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征。数据结构的底层实现有两种方式：Intset 和 Hashtable。当集合中的所有元素都是整数，并且元素数量较少时，Redis 会使用 Intset 作为底层实现。当集合中的元素不仅限于整数，或者元素数量较多时，Redis 会使用 Hashtable 作为底层实现</p></blockquote><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>SADD key member …</td><td>向set中添加一个或多个元素</td></tr><tr><td>SREM key member …</td><td>移除set中的指定元素</td></tr><tr><td>SCARD key</td><td>返回set中元素的个数</td></tr><tr><td>SISMEMBER key member</td><td>判断一个元素是否存在于set中</td></tr><tr><td>SMEMBERS</td><td>获取set中的所有元素</td></tr><tr><td>SINTER key1 key2 …</td><td>求key1与key2的交集</td></tr><tr><td>SDIFF key1 key2 …</td><td>求key1与key2的差集</td></tr><tr><td>SUNION key1 key2 …</td><td>求key1和key2的并集</td></tr></tbody></table><h2 id="2-5、SortedSet"><a href="#2-5、SortedSet" class="headerlink" title="2.5、SortedSet"></a>2.5、SortedSet</h2><blockquote><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。</p></blockquote><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>ZADD key score member</td><td>添加一个或多个元素到sorted set ，如果已经存在则更新其score值</td></tr><tr><td>ZREM key member</td><td>删除sorted set中的一个指定元素</td></tr><tr><td>ZSCORE key member</td><td>获取sorted set中的指定元素的score值</td></tr><tr><td>ZRANK key member</td><td>获取sorted set 中的指定元素的排名</td></tr><tr><td>ZCARD key</td><td>获取sorted set中的元素个数</td></tr><tr><td>ZCOUNT key min max</td><td>统计score值在给定范围内的所有元素的个数</td></tr><tr><td>ZINCRBY key increment member</td><td>让sorted set中的指定元素自增，步长为指定的increment值</td></tr><tr><td>ZRANGE key min max</td><td>按照score排序后，获取指定排名范围内的元素</td></tr><tr><td>ZRANGEBYSCORE key min max</td><td>按照score排序后，获取指定score范围内的元素</td></tr><tr><td>ZDIFF、ZINTER、ZUNION</td><td>求差集、交集、并集</td></tr></tbody></table><blockquote><p><strong>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</strong></p></blockquote><h1 id="3、java客户端"><a href="#3、java客户端" class="headerlink" title="3、java客户端"></a>3、java客户端</h1><h2 id="3-1、springboot整合redis"><a href="#3-1、springboot整合redis" class="headerlink" title="3.1、springboot整合redis"></a>3.1、springboot整合redis</h2><h3 id="3-1-1、引入依赖"><a href="#3-1-1、引入依赖" class="headerlink" title="3.1.1、引入依赖"></a>3.1.1、引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-1-2、redis基本配置"><a href="#3-1-2、redis基本配置" class="headerlink" title="3.1.2、redis基本配置"></a>3.1.2、redis基本配置</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#redis基本配置</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure><h3 id="3-1-3、redis固定配置"><a href="#3-1-3、redis固定配置" class="headerlink" title="3.1.3、redis固定配置"></a>3.1.3、redis固定配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;String, Object&gt;();</span><br><span class="line">        <span class="comment">// 配置连接池工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Jackson序列化配置</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 属性访问器为全部，作用域为全部</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 序列化输入类型必须是非final类型的</span></span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// String 的序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">// value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">// hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>redis使用JDK提供的序列化功能。 优点是反序列化时不需要提供类型信息(class)，但缺点是需要实现Serializable接口，还有序列化后的结果非常庞大，是JSON格式的5倍左右，这样就会消耗redis服务器的大量内存<br>所以我们需要  使用Jackson库将对象序列化为JSON字符串。优点是速度快，序列化后的字符串短小精悍，易读</p></blockquote><h3 id="3-1-4、工具类"><a href="#3-1-4、工具类" class="headerlink" title="3.1.4、工具类"></a>3.1.4、工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kaka.redis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.CollectionUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">RedisUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Set&lt;String&gt; <span class="title function_">keys</span><span class="params">(String keys)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.keys(keys);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete((Collection&lt;String&gt;) CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入, 不存在放入，存在返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setnx</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().setIfAbsent(key,value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间,不存在放入，存在返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setnx</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().setIfAbsent(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by 要减少记(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key, <span class="type">long</span> time, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end 结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> count, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisUtils redisUtils;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        redisUtils.set(<span class="string">&quot;test3:key3&quot;</span>,<span class="string">&quot;hello,redis&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> redisUtils.get(<span class="string">&quot;test3:key3&quot;</span>).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、进阶"><a href="#4、进阶" class="headerlink" title="4、进阶"></a>4、进阶</h1><h2 id="4-1、redis持久化"><a href="#4-1、redis持久化" class="headerlink" title="4.1、redis持久化"></a>4.1、redis持久化</h2><h3 id="4-1-1、rdb"><a href="#4-1-1、rdb" class="headerlink" title="4.1.1、rdb"></a>4.1.1、rdb</h3><p>把当前内存中的快照写入磁盘</p><p>（1）save：save指令执行会阻塞当前redis服务器，直到当前rdb过程执行完，可能造成长时间阻塞，线上环境不建议使用<br>（2）bgsave：调用fork函数生成子进程，解决了save的阻塞问题<br>（3）自动执行：（redis配置文件中配置）save 900 1   save 300 10   save 60 1000</p><h3 id="4-1-2、aof"><a href="#4-1-2、aof" class="headerlink" title="4.1.2、aof"></a>4.1.2、aof</h3><p>以日志的方式记录每次写命令，重启时再执行aof中的命令达到数据恢复的目的（是目前redis持久化的主流方式）</p><p>aof写数据策略：</p><p>（1）always：服务器每写入一个命令,就调用一次fdatasync（不会丢失数据）<br>（2）Everysec：服务器每一秒重调用一次fdatasync（数据同步），最多丢失1秒的数据<br>（3）NO：操作系统决定任何将缓冲区里面的命令写入磁盘里面，数据丢失量是不确定的</p><blockquote><p>注：always策略持久化数据：先把写命令追加到aof buffer中，下一次进入事件循环循环后，再将buffer写到磁盘上。也就是说，这次写到磁盘上的内容是上一个事件循环产生的所以，即使设置为always，也会丢失一个循环的数据</p></blockquote><h3 id="4-1-3、对比"><a href="#4-1-3、对比" class="headerlink" title="4.1.3、对比"></a>4.1.3、对比</h3><table><thead><tr><th></th><th>rdb</th><th>aof</th></tr></thead><tbody><tr><td>占用存储空间</td><td>小（数据级）</td><td>大（指令级）</td></tr><tr><td>恢复速度</td><td>快</td><td>慢（需要执行指令）</td></tr><tr><td>数据安全性</td><td>可能会丢失最后一次持久化后的数据</td><td>根据策略决定</td></tr></tbody></table><h2 id="4-2、redis数据删除策略"><a href="#4-2、redis数据删除策略" class="headerlink" title="4.2、redis数据删除策略"></a>4.2、redis数据删除策略</h2><h3 id="4-2-1、立即删除"><a href="#4-2-1、立即删除" class="headerlink" title="4.2.1、立即删除"></a>4.2.1、立即删除</h3><p>方式：创建一个定时器,当设置的key到达到期时间时,由定时器任务立即执行对key的删除操作</p><p>优缺点：<br>（1）节约内存,到时就删,快速释放掉不必要的内存占用<br>（2）CPU压力变大,无论CPU此时负载量多高,均占用CPU</p><h3 id="4-2-2、惰性删除"><a href="#4-2-2、惰性删除" class="headerlink" title="4.2.2、惰性删除"></a>4.2.2、惰性删除</h3><p>方式：数据到期时不做删除,等下次访问时进行删除</p><p>优缺点：<br>（1）节约cpu性能  <br>（2）若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p><h3 id="4-2-3、定期删除"><a href="#4-2-3、定期删除" class="headerlink" title="4.2.3、定期删除"></a>4.2.3、定期删除</h3><p>方式：每隔一段时间主动检查一批过期键，并将其删除。这样可以保证过期键及时地从内存中释放</p><blockquote><p>（1）Redis 默认每秒进行 10 次过期扫描，此配置可通过 Redis 的配置文件 redis.conf 进行配置，配置健为<br> hz 它的默认值是 hz 10。<br> 【注意】:Redis 每次扫描并不是遍历过期字典中的所有健，而是采用随机抽取判断并删除过期健的形式执行的。</p></blockquote><p>删除流程：<br>（1）从过期字典随机取20个键<br>（2）删除这20个键中过期的键<br>（3）如果过期key的比例超过25%，重复步骤1</p><p>优缺点：<br>（1）分批处理，以避免对cpu产生过大的负载</p><h2 id="4-3、redis内存淘汰策略"><a href="#4-3、redis内存淘汰策略" class="headerlink" title="4.3、redis内存淘汰策略"></a>4.3、redis内存淘汰策略</h2><p>Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据</p><blockquote><p>LRU：淘汰最长时间没有被使用的<br> LFU：一定时间内使用频次越低的<br> random：随机<br> ttl：越早过期的数据</p></blockquote><table><thead><tr><th>淘汰策略名称</th><th>策略含义</th></tr></thead><tbody><tr><td>noeviction</td><td>默认策略，不淘汰数据；大部分写命令都将返回错误（DEL等少数除外）</td></tr><tr><td>allkeys-lru</td><td>从所有数据中根据 LRU 算法挑选数据淘汰</td></tr><tr><td>volatile-lru</td><td>从设置了过期时间的数据中根据 LRU 算法挑选数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据中随机挑选数据淘汰</td></tr><tr><td>volatile-random</td><td>从设置了过期时间的数据中随机挑选数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从设置了过期时间的数据中，挑选越早过期的数据进行删除</td></tr><tr><td>allkeys-lfu</td><td>从所有数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）</td></tr><tr><td>volatile-lfu</td><td>从设置了过期时间的数据中根据 LFU 算法挑选数据淘汰（4.0及以上版本可用）</td></tr></tbody></table><h2 id="4-4、redis工作模式（高可用）"><a href="#4-4、redis工作模式（高可用）" class="headerlink" title="4.4、redis工作模式（高可用）"></a>4.4、redis工作模式（高可用）</h2><h3 id="4-4-1、单机模式"><a href="#4-4-1、单机模式" class="headerlink" title="4.4.1、单机模式"></a>4.4.1、单机模式</h3><p>单机模式是最简单的 Redis 工作模式。在单机模式下，Redis 只运行在单个节点上，数据存储在该节点的内存中。这种模式适用于小规模应用或开发环境</p><h3 id="4-4-2、主从复制模式"><a href="#4-4-2、主从复制模式" class="headerlink" title="4.4.2、主从复制模式"></a>4.4.2、主从复制模式</h3><p>主从复制模式通过将数据从主节点复制到一个或多个从节点来提高数据的可靠性和读取性能。主节点负责处理写入操作，从节点复制主节点的数据，并可以处理读取操作。主从复制模式适用于需要读取扩展和数据冗余的场景</p><h3 id="4-4-3、哨兵模式"><a href="#4-4-3、哨兵模式" class="headerlink" title="4.4.3、哨兵模式"></a>4.4.3、哨兵模式</h3><p>主从复制的基础上，引入了哨兵节点来监控主节点的状态。当主节点发生故障时，哨兵节点会自动将一个从节点升级为新的主节点，并将其他从节点重新配置为复制新的主节点。这种模式提供了故障转移和自动主节点切换的功能</p><h3 id="4-4-4、集群模式"><a href="#4-4-4、集群模式" class="headerlink" title="4.4.4、集群模式"></a>4.4.4、集群模式</h3><p>即使使用哨兵，redis每个实例也是全量存储，每个redis存储的内容都是完整的数据。cluster是为了解决单机Redis容量有限的问题，将数据按一定的规则分配到多台机器，提高并发量</p><h2 id="4-5、redis发布订阅机制"><a href="#4-5、redis发布订阅机制" class="headerlink" title="4.5、redis发布订阅机制"></a>4.5、redis发布订阅机制</h2><p>Redis 发布订阅（Pus&#x2F;Sub）是一种消息通信模式：发送者通过 PUBLISH发布消息，订阅者通过 SUBSCRIBE 订阅接收消息或通过UNSUBSCRIBE 取消订阅。<br>发布者和订阅者属于客户端，Channel 是 Redis 服务端，发布者将消息发布到频道，订阅这个频道的订阅者则收到消息。从而实现消息的广播和实时通知</p><blockquote><p>Redis 的发布订阅机制是一种简单的消息传递方式，并不提供消息持久化和消息队列的功能。如果需要更高级的消息队列功能，可以考虑rabbitmq，kafka等</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A订阅频道</span></span><br><span class="line">SUBSCRIBE channel1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">B向频道发送消息，A就可以收到消息</span></span><br><span class="line">PUBLISH channel1 &quot;Redis PUBLISH test&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-6、缓存穿透、击穿、雪崩"><a href="#4-6、缓存穿透、击穿、雪崩" class="headerlink" title="4.6、缓存穿透、击穿、雪崩"></a>4.6、缓存穿透、击穿、雪崩</h2><h3 id="4-6-1、缓存穿透"><a href="#4-6-1、缓存穿透" class="headerlink" title="4.6.1、缓存穿透"></a>4.6.1、缓存穿透</h3><p>缓存穿透：某些不存在的数据，被大量的查询访问，缓存层中没有这些数据的缓存，请求就直达存储层，造成宕机</p><blockquote><p>解决方法：<br>1.返回空对象，将该key的空值返回给缓存层，缓存层会直接返回空对象。<br>2.布隆过滤器：将所有的key都存在过滤器中，在访问缓存层的时候会首先访问过滤器，如果过滤器中不存在这个值，那么直接返回空值。 </p></blockquote><blockquote><p>布隆过滤器：它是一种类似哈希的数据结构，通过这个数据结构，可以快速的插入和查询，确定某个事件一定不存在或可能存在。特点是占用空间少，缺点是返回的结果是概率性<br>当一个元素加入集合时，就通过K个hash函数将这个映射成一个位数组中的K个点，把它们置为1。当查询时，只要检查这些点是否全为1，就能判断集合中是否可能存在。<br>如果k个点有任何一个0，则被检元素一定不在。如果都是1，则很可能存在，这个期望概率是可以设置</p></blockquote><h3 id="4-6-2、缓存击穿？"><a href="#4-6-2、缓存击穿？" class="headerlink" title="4.6.2、缓存击穿？"></a>4.6.2、缓存击穿？</h3><p>一份热点数据，在它缓存失效期间，大量的请求直接命中存储层</p><blockquote><p>解决方法：<br> 1.设置热点数据永不过期的策略。<br> 2.加互斥锁，在一个请求访问时另一个不能访问，这样，在这个请求访问过后，缓存重建，其他线程就可以访问了</p></blockquote><h3 id="4-6-3、缓存雪崩？"><a href="#4-6-3、缓存雪崩？" class="headerlink" title="4.6.3、缓存雪崩？"></a>4.6.3、缓存雪崩？</h3><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。</p><blockquote><p>解决方法：<br>1.不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀<br>2.在系统启动或低峰期(比如系统刚启动)，提前加载热门数据到缓存中，避免在高峰期大量请求同时访问导致缓存失效</p></blockquote><h2 id="4-7、redis实现分布式锁"><a href="#4-7、redis实现分布式锁" class="headerlink" title="4.7、redis实现分布式锁"></a>4.7、redis实现分布式锁</h2><p>在分布式的环境下,会发生多个server并发修改同一个资源的情况,这种情况下,由于多个server是多个不同的JRE环境,而Java自带的锁局限于当前JRE,所以Java自带的锁机制在这个场景下是无效的,那么就需要我们自己来实现一个分布式锁</p><ol><li>通过<code>set...nx...</code>命令,将加锁、过期命令编排到一起,把他们变成原子操作。完整命令：set key random-value nx ex seconds</li></ol><blockquote><p>其实目前通常所说的Setnx命令，并非单指Redis的setnx key value这条命令<br>一般代指Redis中对set命令加上nx参数进行使用</p></blockquote><blockquote><p>（1）nx  ex 是set指令的两个参数： ex过期时间    nx只有key不存在时设置新的key&#x2F;value<br>（2）key设置成随机数，避免一个线程过期时间内没释放掉锁，过期后有另一个线程获取到锁，该线程执行完后释放掉另一个线程获取的锁<br>（3）设置过期时间（EX）作用：如果客户端忘记解锁,那么这种情况就很有可能造成死锁<br>（4）NX的作用：避免重复获取锁</p></blockquote><ol start="2"><li>解锁的时候进行判断,是自己持有的锁才能释放,否则不能释放。另外判断,释放这两步需要保持原子性，所以通过Lua脚本将两个命令编排在一起,而整个Lua脚本的执行是原子的</li></ol><blockquote><p>if redis.call(“get”,KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(“del”,KEYS[1]) else return 0 end</p></blockquote><blockquote><p><strong>这里为什么要用原子操作？</strong><br>主要是怕误将其他客户端的锁解开。比如客户端A加锁，一段时间之后客户端A解锁，在进入unlock后执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisLock</span><span class="params">(Jedis jedis)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.jedis = jedis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识，用于释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 锁的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功获取锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String lockKey, String requestId, <span class="type">int</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, expireTime);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁的名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识，用于判断是否是同一个客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否成功释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">releaseLock</span><span class="params">(String lockKey, String requestId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">        <span class="comment">// jedis.eval是Jedis客户端提供的一个用于执行Lua脚本的方法</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> (Long) jedis.eval(script, <span class="number">1</span>, lockKey, requestId);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>另外可以通过Redisson框架，它的底层原理其实也是这个setnx</p></blockquote><h2 id="4-8、redis和数据库的双写一致性"><a href="#4-8、redis和数据库的双写一致性" class="headerlink" title="4.8、redis和数据库的双写一致性"></a>4.8、redis和数据库的双写一致性</h2><p>假设有 A、B 两个并发请求：</p><ul><li>先更新数据库再删除缓存：当请求 A 更新数据库之后，还未来得及进行缓存清除，此时请求 B 查询到并使用了 Cache 中的旧数据。</li><li>先删除缓存再更新数据库：当请求 A 执行清除缓存后，还未进行数据库更新，此时请求 B 进行查询，查到了旧数据并写入了 Cache</li></ul><ol><li>延迟双删</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202312211801651.png" alt="image.png"></p><p>延迟双删是这样：先执行缓存清除操作，再执行数据库更新操作，延迟 N 秒之后再执行一次缓存清除操作，这样就不用担心缓存中的数据和数据库中的数据不一致了</p><p>一般来说，N 要大于一次写入缓存操作的时间，如果延迟时间小于写入缓存的时间，会导致请求 A 已经延迟清除了缓存，但是此时请求 B 缓存还未写入，具体是多少，就要结合自己的业务来统计这个数值了</p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dubbo</title>
      <link href="/posts/22179.html"/>
      <url>/posts/22179.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h1><p>Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</p><blockquote><p><strong>dubbo可以是微服务的一部分，但不能以偏概全说dubbo就是微服务</strong>，微服务涉及的面比较广，比如服务发现，服务治理，服务网关，服务监控，链路追踪等等，可以用到的组件也比较多，而dubbo最多只能说是专注于服务治理的组件，所以从这一点上来看，可替代它的技术也是相当之多的，比如一系列rpc框架都可以</p></blockquote><h2 id="1-1、基本架构"><a href="#1-1、基本架构" class="headerlink" title="1.1、基本架构"></a>1.1、基本架构</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202308041522327.png" alt="dubbo架构"></p><p>Provider 暴露服务的服务提供方<br>Consumer 调用远程服务的服务消费方<br>Registry 服务注册与发现的注册中心<br>Monitor 统计服务的调用次数和调用时间的监控中心</p><p>调用过程:</p><p>(1) 服务容器 Container 负责启动加载运行服务提供者 Provider。根据配置中的 Registry 地址连接 Registry，在 Registry 注册自己提供的服务。<br>(2) Consumer 在启动时，根据配置文件中的服务引用信息，连接到 Registry，向 Registry 订阅自己所需的服务。<br>(3) Registry 根据服务订阅关系，返回 Provider 地址列表给 Consumer。如果有变更，Registry 会基于长连接推送最新的服务地址信息给 Consumer。<br>(4) Consumer 调用远程服务时，基于负载均衡算法，从缓存的 Provider 地址列表中选择一台进行跨进程调用服务<br>(5) 服务 Provider 和 Consumer，会在内存中记录调用次数和调用时间，每分钟发送一次统计数据到 Monitor。</p><h2 id="1-2、调用流程"><a href="#1-2、调用流程" class="headerlink" title="1.2、调用流程"></a>1.2、调用流程</h2><ol><li>服务启动，包括服务提供者和消费者的启动，封装服务调用链路。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于服务路由信息、负载均衡规则，选一台提供者进行调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时发送一次统计数据到监控中心。</li><li>服务提供方停止服务或者服务调用方关闭JVM的时候，会将provider及consumer进行销毁处理。</li></ol><h2 id="1-3、dubbo和springCloud区别"><a href="#1-3、dubbo和springCloud区别" class="headerlink" title="1.3、dubbo和springCloud区别"></a>1.3、dubbo和springCloud区别</h2><p>两者都是现在主流的分布式框架，但却存在不少差异：</p><ul><li><strong>生态环境不同：</strong> SpringCloud定位为微服务架构下的一站式解决方案（网关，分布式配置，服务跟踪）；Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用和治理</li><li><strong>调用方式：</strong> SpringCloud是采用Http协议做远程调用；Dubbo是基于RPC调用</li><li><strong>组件差异比较多</strong>，例如SpringCloud注册中心一般用Eureka，而Dubbo用的是Zookeeper</li></ul><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311141619063.png" alt="image.png"></p><h2 id="1-4、dubbo支持协议"><a href="#1-4、dubbo支持协议" class="headerlink" title="1.4、dubbo支持协议"></a>1.4、dubbo支持协议</h2><p><strong>1、dubbo 默认协议：</strong></p><ul><li>单一 TCP 长连接，Hessian 二进制序列化和 NIO 异步通讯</li><li>不适合传送大数据包的服务</li></ul><p><strong>2、rmi 协议：</strong></p><ul><li>采用 JDK 标准的 java.rmi.* 实现，采用阻塞式短连接和 JDK 标准序列化方式</li><li>对传输数据包不限，消费者和传输者个数相当</li></ul><p><strong>3、hessian 协议：</strong></p><ul><li>底层 Http 通讯，Servlet 暴露服务，Dubbo 缺省内嵌 Jetty 作为服务器实现</li><li>通讯效率高于 WebService 和 Java 自带的序列化</li><li>适用于传输数据包较大，提供者比消费者个数多，提供者压力较大</li></ul><p><strong>4、http 协议：</strong></p><ul><li>基于 http 表单的远程调用协议，短连接，json 序列化</li><li>对传输数据包不限，不支持传文件</li></ul><p><strong>5、webservice 协议：</strong></p><ul><li>基于 Apache CXF 的 frontend-simple 和 transports-http 实现，短连接，SOAP文本序列化</li><li>可与原生 WebService 服务互操作</li><li>适用于系统集成、跨语言调用</li></ul><p><strong>6、thrift 协议：</strong></p><ul><li>对 thrift 原生协议的扩展添加了额外的头信息</li><li>使用较少，不支持传 null 值</li></ul><p><strong>7、基于 Redis实现的 RPC 协议</strong><br><strong>8、基于 Memcached 实现的 RPC 协议</strong></p><h2 id="1-5、dubbo负载均衡策略"><a href="#1-5、dubbo负载均衡策略" class="headerlink" title="1.5、dubbo负载均衡策略"></a>1.5、dubbo负载均衡策略</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dubbo:</span><br><span class="line">  provider:</span><br><span class="line">    loadbalance: roundrobin</span><br></pre></td></tr></table></figure><blockquote><p>也可以在注解上进行配置<br>@Service(version &#x3D; “${product.service.version}”,loadbalance&#x3D;”roundrobin”)</p></blockquote><ol><li>RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的<strong>默认</strong>负载均衡策略。</li><li>RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。</li><li>LeastActiveLoadBalance: 最小活跃数负载均衡，活跃数也就是dubbo的连接数，每当收到一个请求活跃数+1，结束请求活跃数-1，假设如果多台机器的连接数是相同的，如果一台机器性能比较好，处理请求比较快那么活跃数减少的就快，活跃数就少。所以活跃数少的就会获取到的请求会变多，这样就可以合理的使用性能不同的机器了</li><li>ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。</li></ol><h2 id="1-6、dubbo集群容错"><a href="#1-6、dubbo集群容错" class="headerlink" title="1.6、dubbo集群容错"></a>1.6、dubbo集群容错</h2><table><thead><tr><th><strong>类型</strong></th><th><strong>负载均衡</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>failover</td><td>会</td><td>失败后会尝试调用其他服务器实例，默认尝试2次， 可以通过设置retries来设置次数。这是dubbo默认的容错机制，由于常常可能因为超时待原因触发异常但远程服务已经完成操作，所以这个类型不应就在数据更新的操作</td></tr><tr><td>failfast</td><td>会</td><td>有异常立即返回，不做尝试，我认为可以用在数据更新上，以保证数据的一致性</td></tr><tr><td>fastsafe</td><td>会</td><td>有异常会直接忽略，为的是保证调用方接下来的正常运行，一般用于日志收集等与正常流程无关的操作</td></tr><tr><td>failback</td><td>会</td><td>失败后会将任务丢到失败队列中，并会异步再次尝试</td></tr><tr><td>forking</td><td>否</td><td>同时调用多个服务，取最先返回的结果，可以通过forks设置最大并行数，这比较浪费资源</td></tr><tr><td>broadcast</td><td>否</td><td>调用所有可用的服务，任意一个有错都会返回异常</td></tr><tr><td>Mock</td><td>否</td><td>调用失败时返回伪造的响应结果</td></tr></tbody></table><blockquote><p>一般在@DubboService或@DubboReference指定cluster即可，如<br>  @DubboService(cluster &#x3D; “failover”) &#x2F;&#x2F;默认重试2次</p></blockquote><h1 id="2、Dubbo环境搭建"><a href="#2、Dubbo环境搭建" class="headerlink" title="2、Dubbo环境搭建"></a>2、Dubbo环境搭建</h1><h2 id="2-1、安装zookeeper"><a href="#2-1、安装zookeeper" class="headerlink" title="2.1、安装zookeeper"></a>2.1、安装zookeeper</h2><ol><li>下载zookeeper</li></ol><p>网址:<br><a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/</a>  </p><ol start="2"><li><p>解压zookeeper<br>解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件 </p></li><li><p>修改zoo.cfg配置文件<br>将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可,修改完成后再次启动zookeeper</p></li></ol><blockquote><p>注意几个重要位置:<br>dataDir&#x3D;.&#x2F;   临时数据存储的目录（可写相对路径）<br>clientPort&#x3D;2181   zookeeper的端口号</p></blockquote><ol start="4"><li>使用zkCli.cmd&#x2F;sh测试</li></ol><blockquote><p>ls &#x2F;：列出zookeeper根下保存的所有节点<br>create –e &#x2F;kaka123：创建一个kaka节点，值为123<br>get &#x2F;kaka：获取&#x2F;kaka节点的值<br>(dubbo注册后一个group是一个节点)</p></blockquote><h2 id="2-2、安装监控中心"><a href="#2-2、安装监控中心" class="headerlink" title="2.2、安装监控中心"></a>2.2、安装监控中心</h2><p>为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用</p><ol><li><p>下载dubbo-admin<br><a href="https://github.com/apache/incubator-dubbo-ops">https://github.com/apache/incubator-dubbo-ops</a><br>（注意是master分支） |</p></li><li><p>进入目录，修改dubbo-admin配置<br>修改src\main\resources\application.properties 指定zookeeper地址</p></li><li><p>打包dubbo-admin</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><ol start="4"><li>运行dubbo-admin</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar dubbo-admin-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>默认使用root&#x2F;root 登陆</p><h2 id="2-3、父工程"><a href="#2-3、父工程" class="headerlink" title="2.3、父工程"></a>2.3、父工程</h2><p>创建依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class="line">    &lt;packaging&gt;pom&lt;/packaging&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;modules&gt;</span><br><span class="line">        &lt;<span class="keyword">module</span>&gt;provider&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">module</span>&gt;api&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">module</span>&gt;consumer&lt;/<span class="keyword">module</span>&gt;</span><br><span class="line">    &lt;/modules&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 父级引用 --&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.1</span><span class="number">.1</span>.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--配置--&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;<span class="number">1.8</span>&lt;/java.version&gt;</span><br><span class="line">        &lt;dubbo.version&gt;<span class="number">2.7</span><span class="number">.5</span>&lt;/dubbo.version&gt;</span><br><span class="line">        &lt;zookeeper.version&gt;<span class="number">3.4</span><span class="number">.14</span>&lt;/zookeeper.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--声明全局依赖（子项目需要显示的引用才会继承依赖）--&gt;</span><br><span class="line">    &lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;!-- dubbo-start依赖 --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">            &lt;!--zookeeper 注册中心客户端引入 使用的是curator客户端 --&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;exclusions&gt;</span><br><span class="line">                    &lt;exclusion&gt;</span><br><span class="line">                        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">                        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                    &lt;/exclusion&gt;</span><br><span class="line">                &lt;/exclusions&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--声明全局依赖（子项目不需要显示的引用，自动继承依赖）--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!-- spring boot 依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;</span><br><span class="line">                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 打包插件 --&gt;</span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h2 id="2-4、api模块"><a href="#2-4、api模块" class="headerlink" title="2.4、api模块"></a>2.4、api模块</h2><p>创建接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Api1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-5、服务提供者模块"><a href="#2-5、服务提供者模块" class="headerlink" title="2.5、服务提供者模块"></a>2.5、服务提供者模块</h2><ol><li>引入依赖</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;provider&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--接口模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- zookeeper依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  # 服务端口</span><br><span class="line">  port: <span class="number">7777</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: provider</span><br><span class="line"># dubbo 相关配置(dubbo 的配置不再以 Spring 开头)</span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    # 应用名称</span><br><span class="line">    name: provider</span><br><span class="line">  scan:</span><br><span class="line">    # 接口实现者（服务实现）包</span><br><span class="line">    base-packages: com.kaka.service</span><br><span class="line">  # 注册中心信息</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper:<span class="comment">//127.0.0.1:2181</span></span><br><span class="line">  protocol:</span><br><span class="line">    # 协议名称</span><br><span class="line">    name: dubbo</span><br><span class="line">    # 协议端口</span><br><span class="line">    port: <span class="number">20880</span></span><br></pre></td></tr></table></figure><ol start="3"><li>服务实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Service1</span> <span class="keyword">implements</span> <span class="title class_">Api1</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;服务提供者提供服务...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6、服务消费者"><a href="#2-6、服务消费者" class="headerlink" title="2.6、服务消费者"></a>2.6、服务消费者</h2><ol><li>依赖</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="line">         xmlns:xsi=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;artifactId&gt;dubboDemo&lt;/artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;modelVersion&gt;<span class="number">4.0</span><span class="number">.0</span>&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;consumer&lt;/artifactId&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--接口模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.example&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;<span class="number">1.0</span>-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- web项目依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- dubbo依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- dubbo的zookeeper依赖 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;dubbo-dependencies-zookeeper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;dubbo.version&#125;&lt;/version&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;exclusions&gt;</span><br><span class="line">                &lt;exclusion&gt;</span><br><span class="line">                    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">                    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">                &lt;/exclusion&gt;</span><br><span class="line">            &lt;/exclusions&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: <span class="number">7000</span></span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer</span><br><span class="line"># dubbo 相关配置</span><br><span class="line">dubbo:</span><br><span class="line">  application:</span><br><span class="line">    name: consumer</span><br><span class="line">  registry:</span><br><span class="line">    address: zookeeper:<span class="comment">//127.0.0.1:2181</span></span><br></pre></td></tr></table></figure><ol start="3"><li>消费者类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    Api1 api1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">test</span> <span class="operator">=</span> api1.test();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springCloud</title>
      <link href="/posts/26325.html"/>
      <url>/posts/26325.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、微服务架构"><a href="#1、微服务架构" class="headerlink" title="1、微服务架构"></a>1、微服务架构</h1><h2 id="1-1、基本概念"><a href="#1-1、基本概念" class="headerlink" title="1.1、基本概念"></a>1.1、基本概念</h2><p>微服务是一种架构，这种架构是将单个整体应用程序分割成更小的项目关联的独立服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现，这些独立的微服务</p><h2 id="1-2、为什么要用微服务？"><a href="#1-2、为什么要用微服务？" class="headerlink" title="1.2、为什么要用微服务？"></a>1.2、为什么要用微服务？</h2><h3 id="1-2-1、优点"><a href="#1-2-1、优点" class="headerlink" title="1.2.1、优点"></a>1.2.1、优点</h3><ol><li>将服务拆分成单一职责的小服务，进行单独部署，服务之间通过网络进行通信</li><li>每个服务应该有自己的管理团队，高度自治</li><li>服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务崩溃</li></ol><h3 id="1-2-2、缺点"><a href="#1-2-2、缺点" class="headerlink" title="1.2.2、缺点"></a>1.2.2、缺点</h3><ol><li>开发人员需要处理分布式系统的复杂性</li><li>随着服务的增加，运维的压力也在增大</li><li>服务治理（负载均衡，服务熔断，服务配置管理）和服务监控</li></ol><h2 id="1-3、架构的演变"><a href="#1-3、架构的演变" class="headerlink" title="1.3、架构的演变"></a>1.3、架构的演变</h2><h3 id="1-3-1、单一架构（all-in-one）"><a href="#1-3-1、单一架构（all-in-one）" class="headerlink" title="1.3.1、单一架构（all in one）"></a>1.3.1、单一架构（all in one）</h3><p>一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(<strong>ORM</strong>)是影响项目开发的关键（mybatis，hibernate）</p><blockquote><p>缺点：随着应用功能的增多，代码量越来越大，越来越难维护</p></blockquote><h3 id="1-3-2、垂直架构（vertical-application）"><a href="#1-3-2、垂直架构（vertical-application）" class="headerlink" title="1.3.2、垂直架构（vertical application）"></a>1.3.2、垂直架构（vertical application）</h3><p>当访问量逐渐增大，单一应用无法满足需求，我们就需要增加节点来提供系统的访问能力，但是并不是所有的模块都需要进行性能的提高，这时候单体应用架构无法满足我们的需求；我们需要将系统里面的模块进行拆分，这样对于后面的水平扩容是非常友好的；<br><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307290956007.jpg" alt="垂直架构"></p><blockquote><p>优点：系统拆分实现了流量分担，提高了系统并发量<br>   垂直架构中可以针对不同模块进行针对性优化<br>   方便水平扩展，负载均衡，系统容错率提高</p></blockquote><blockquote><p>缺点：垂直架构中相同逻辑代码需要不断的复制，不能复用。每个垂直模块都相当于一个独立的系统</p></blockquote><h3 id="1-3-3、分布式服务架构（distributed-service）"><a href="#1-3-3、分布式服务架构（distributed-service）" class="headerlink" title="1.3.3、分布式服务架构（distributed service）"></a>1.3.3、分布式服务架构（distributed service）</h3><p>当垂直应用越来越多，重复的业务代码就会越来越多，并且在垂直架构中应用之间的交互不可避免，此时，为了解决基础代码重复太多、应用之间的调用等问题；我们将重复的代码抽取出来作为独立的服务，对外提供服务；</p><blockquote><p>rpc是传输层传输协议，效率比应用层传输要高<br>dubbo采用rpc<br>springcloud采用http，属于应用层传输</p></blockquote><blockquote><p>优点：将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</p></blockquote><blockquote><p>缺点：服务越来越多，需要管理每个服务的地址，调用关系错综复杂，难以理清依赖关系，服务状态难以管理，无法根据服务情况动态管理</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291006525.jpg" alt="分布式架构"></p><h3 id="1-3-4、SOA架构"><a href="#1-3-4、SOA架构" class="headerlink" title="1.3.4、SOA架构"></a>1.3.4、SOA架构</h3><p>在分布式架构下，当服务越来越多，容量的评估，小服务资源等浪费等问题逐渐显现，此时需增加一个调度中心对集群进行实时管理（根据请求量动态的分配资源）。它一般使用中心化的思想实现，服务的管理和调度都由中央的服务总线（ESB）来负责</p><h3 id="1-3-4、微服务架构"><a href="#1-3-4、微服务架构" class="headerlink" title="1.3.4、微服务架构"></a>1.3.4、微服务架构</h3><p>微服务架构模式是从SOA架构模式演变过来， 比SOA架构模式粒度更加精细，让专业的人去做专业的事情（专注），目的是提高效率，每个服务与服务之间互不影响，微服务架构中每个服务独立，互不影响；（怎么理解粒度更细？：微服务采用去中心化的思想来治理，注册中心只是服务发现的工具，而服务之间的调用，熔断，负载均衡等都是都是由服务自己控制的）</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291013480.png" alt="微服务架构"></p><h2 id="1-4、微服务架构解决方案"><a href="#1-4、微服务架构解决方案" class="headerlink" title="1.4、微服务架构解决方案"></a>1.4、微服务架构解决方案</h2><ul><li><strong>国内阿里系</strong></li></ul><p>springboot + dubbo + zookeeper</p><ul><li><strong>spring cloud技术栈</strong></li></ul><p>spring cloud netflix<br>spring cloud spring （spring自己封装的微服务解决方案）<br>spring cloud alibaba（阿里巴巴解决方案）</p><h2 id="1-5、SpringCloud概念"><a href="#1-5、SpringCloud概念" class="headerlink" title="1.5、SpringCloud概念"></a>1.5、SpringCloud概念</h2><h3 id="1-5-1、基本概念"><a href="#1-5-1、基本概念" class="headerlink" title="1.5.1、基本概念"></a>1.5.1、基本概念</h3><p>Spring Cloud是一个含概多个子项目的微服务开发工具集,集合了众多的开源框架,他利用了Spring Boot开发的便利性实现了很多功能,如服务注册,服务注册发现,负载均衡等.Spring Cloud在整合过程中主要是针对Netflix(耐非),alibaba开源组件的封装</p><h3 id="1-5-2、版本"><a href="#1-5-2、版本" class="headerlink" title="1.5.2、版本"></a>1.5.2、版本</h3><p>springcloud版本采用伦敦地铁站命名，根据首字母顺序排序 这样设计的目的是为了更好的管理每个springcloud子项目清单，避免了总版本号与子项目版本号混淆</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291014046.png" alt="image.png"></p><h3 id="1-5-3、组件"><a href="#1-5-3、组件" class="headerlink" title="1.5.3、组件"></a>1.5.3、组件</h3><table><thead><tr><th></th><th>spring cloud官方</th><th>spring cloud netflix</th><th>spring cloud alibaba</th></tr></thead><tbody><tr><td>服务注册发现</td><td>-</td><td>Eureka</td><td>nacos</td></tr><tr><td>分布式配置</td><td>spring cloud config</td><td>Archaius</td><td>nacos</td></tr><tr><td>服务熔断</td><td>-</td><td>Hystrix</td><td>Sentinel</td></tr><tr><td>服务调用</td><td>Open Fegin</td><td>Fegin</td><td>Dubbo RPC</td></tr><tr><td>服务路由</td><td>spring cloud gateway</td><td>zuul</td><td>dubbo proxy</td></tr><tr><td>分布式消息</td><td>rabbitmq</td><td>-</td><td>rocketmq</td></tr><tr><td>负载均衡</td><td>-</td><td>ribbon</td><td>dubbo LB</td></tr><tr><td>分布式事务</td><td>-</td><td>-</td><td>Seata</td></tr></tbody></table><h2 id="1-6、分布式和微服务的关系"><a href="#1-6、分布式和微服务的关系" class="headerlink" title="1.6、分布式和微服务的关系"></a>1.6、分布式和微服务的关系</h2><p>我理解的分布式是一种系统架构，指一个系统由多个独立的组件组成，这些组件可以在不同的物理位置上运行，从而提升了系统的性能<br>而微服务可以看作是分布式的一种实现方案。分布式实现方案有soa，基于rpc远程调用（dubbo），微服务（springcloud）</p><h1 id="2、项目搭建（父工程）"><a href="#2、项目搭建（父工程）" class="headerlink" title="2、项目搭建（父工程）"></a>2、项目搭建（父工程）</h1><h2 id="2-1、引入依赖"><a href="#2-1、引入依赖" class="headerlink" title="2.1、引入依赖"></a>2.1、引入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--springBoot父项目--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--springBoot--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--springCloud--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--maven只能有一个parent 所以这里以pom引入父项目--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3、eureka（注册中心）"><a href="#3、eureka（注册中心）" class="headerlink" title="3、eureka（注册中心）"></a>3、eureka（注册中心）</h1><h2 id="3-1、基本概念"><a href="#3-1、基本概念" class="headerlink" title="3.1、基本概念"></a>3.1、基本概念</h2><p>注册中心可以说是微服务架构中的”通讯录“，它记录了服务和服务地址的映射关系。在分布式架构中，服务会注册到这里，当服务需要调用其它服务时，就到这里找到服务的地址，进行调用。两个重要的功能：<strong>服务注册</strong>和<strong>服务发现</strong></p><h2 id="3-2、常用的注册中心"><a href="#3-2、常用的注册中心" class="headerlink" title="3.2、常用的注册中心"></a>3.2、常用的注册中心</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291044882.png" alt="常用的注册中心"></p><h2 id="3-3、eureka角色"><a href="#3-3、eureka角色" class="headerlink" title="3.3、eureka角色"></a>3.3、eureka角色</h2><ul><li><strong>服务注册中心（server</strong>）：Eureka的服务端应用，提供服务注册和发现功能.</li><li><strong>服务提供者（client）</strong>： 启动后向Eureka注册自己信息（地址，提供什么服务）</li></ul><blockquote><p>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</p></blockquote><ul><li><strong>服务消费者（client）</strong>：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li></ul><h2 id="3-4、eureka-server开发"><a href="#3-4、eureka-server开发" class="headerlink" title="3.4、eureka server开发"></a>3.4、eureka server开发</h2><p>搭建eureka server子项目</p><h3 id="3-4-1、引入依赖"><a href="#3-4-1、引入依赖" class="headerlink" title="3.4.1、引入依赖"></a>3.4.1、引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--springBoot--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--eurekaServer--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-2、配置文件"><a href="#3-4-2、配置文件" class="headerlink" title="3.4.2、配置文件"></a>3.4.2、配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eureka server端口号 （默认就是8761）</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8761</span></span><br><span class="line"><span class="comment"># 指定服务名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">EUREKASERVER</span></span><br><span class="line"><span class="comment"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class="line"><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8761/eureka</span></span><br><span class="line"><span class="comment"># 关闭立即注册（避免控制台报错）</span></span><br><span class="line"><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 让当前应用仅仅是服务注册中心</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><h3 id="3-4-3、入口类加注解"><a href="#3-4-3、入口类加注解" class="headerlink" title="3.4.3、入口类加注解"></a>3.4.3、入口类加注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-5、eureka-client开发"><a href="#3-5、eureka-client开发" class="headerlink" title="3.5、eureka client开发"></a>3.5、eureka client开发</h2><h3 id="3-5-1、引入依赖"><a href="#3-5-1、引入依赖" class="headerlink" title="3.5.1、引入依赖"></a>3.5.1、引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--eureka client依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--springboot依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-5-2、配置文件"><a href="#3-5-2、配置文件" class="headerlink" title="3.5.2、配置文件"></a>3.5.2、配置文件</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8989</span></span><br><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">EUREKACLIENT</span></span><br><span class="line"><span class="comment"># 注册中心地址</span></span><br><span class="line"><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8761/eureka</span></span><br></pre></td></tr></table></figure><h3 id="3-5-3、启动类"><a href="#3-5-3、启动类" class="headerlink" title="3.5.3、启动类"></a>3.5.3、启动类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaClientApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6、eureka自我保护机制"><a href="#3-6、eureka自我保护机制" class="headerlink" title="3.6、eureka自我保护机制"></a>3.6、eureka自我保护机制</h2><h3 id="3-6-1、自我保护机制"><a href="#3-6-1、自我保护机制" class="headerlink" title="3.6.1、自我保护机制"></a>3.6.1、自我保护机制</h3><p>默认情况下，如果eureka server在一定时间内（默认90秒）没有接收到某个微服务实例的心跳，eureka server将会移除掉该实例（eureka客户端每隔60秒会发送一次心跳包）</p><p>但是当网络分区发生故障，微服务和eureka server之间无法通信，但是微服务本身是正常的，此时不应该移除这个服务，所以就引入了自我保护机制</p><p>Eureka服务端会检查最近15分钟内所有Eureka 实例正常心跳占比，如果低于85%就会触发自我保护机制。触发了保护机制，Eureka将暂时把这些失效的服务保护起来，不让其过期</p><blockquote><p>自我保护机制清除：<br>（1）心跳次数高于预期值<br>（2）自我保护机制被禁用</p></blockquote><h3 id="3-6-2、如何关闭自我保护机制"><a href="#3-6-2、如何关闭自我保护机制" class="headerlink" title="3.6.2、如何关闭自我保护机制"></a>3.6.2、如何关闭自我保护机制</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">server</span>:<span class="string"></span></span><br><span class="line"><span class="comment">    #服务端是否开启自我保护机制 （默认true）</span></span><br><span class="line">    <span class="attr">enable-self-preservation</span>: <span class="string">false</span></span><br><span class="line"><span class="comment">    # eureka客户端每隔多长时间发一次心跳（单位毫秒，默认是60*1000）即60秒</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms</span>: <span class="string">60000</span></span><br></pre></td></tr></table></figure><h2 id="3-7、eureka-server集群"><a href="#3-7、eureka-server集群" class="headerlink" title="3.7、eureka server集群"></a>3.7、eureka server集群</h2><p>多个注册中心之间相互注册就可搭建eureka server集群</p><blockquote><p>服务端：eureka.client.service-url.defaultZone 配置其它的注册中心地址即可</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eureka server端口号 （默认就是8761）</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8761</span></span><br><span class="line"><span class="comment"># 指定服务名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">EUREKASERVER01</span></span><br><span class="line"><span class="comment"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class="line"><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8762/eureka</span></span><br><span class="line"><span class="comment"># 关闭立即注册（避免控制台报错）</span></span><br><span class="line"><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 让当前应用仅仅是服务注册中心</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># eureka server端口号 </span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8762</span></span><br><span class="line"><span class="comment"># 指定服务名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">EUREKASERVER02</span></span><br><span class="line"><span class="comment"># eureka server服务注册中心地址 暴露服务地址</span></span><br><span class="line"><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8761/eureka</span></span><br><span class="line"><span class="comment"># 关闭立即注册（避免控制台报错）</span></span><br><span class="line"><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 让当前应用仅仅是服务注册中心</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><blockquote><p>客户端：所有的注册中心地址都需要指明</p></blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8989</span></span><br><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">EUREKACLIENT</span></span><br><span class="line"><span class="comment"># 注册中心地址</span></span><br><span class="line"><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:8761/eureka,http://localhost:8762/eureka</span></span><br></pre></td></tr></table></figure><h1 id="4、consul（注册中心）"><a href="#4、consul（注册中心）" class="headerlink" title="4、consul（注册中心）"></a>4、consul（注册中心）</h1><h2 id="4-1、简介"><a href="#4-1、简介" class="headerlink" title="4.1、简介"></a>4.1、简介</h2><p>consul是基于go语言进行开发的服务注册中心，是一个可以直接运行的注册中心工具，不需要像eureka注册中心一样再进行编码。使用起来较为简单</p><h2 id="4-2、安装"><a href="#4-2、安装" class="headerlink" title="4.2、安装"></a>4.2、安装</h2><ol><li><p>下载 <a href="https://www.consul.io/downloads">https://www.consul.io/downloads</a></p></li><li><p>解压</p></li><li><p>启动服务注册中心（cmd）</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">consul</span> <span class="string">agent -dev</span></span><br></pre></td></tr></table></figure></li><li><p>访问管理界面：<a href="http://localhost:8500/">http://localhost:8500/</a></p></li></ol><h2 id="4-3、consul-client开发"><a href="#4-3、consul-client开发" class="headerlink" title="4.3、consul client开发"></a>4.3、consul client开发</h2><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--springboot依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--consul客户端组件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-consul-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>编写配置文件</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8082</span></span><br><span class="line"><span class="attr">spring.application.name</span>=<span class="string">CONSULCLIENT</span></span><br><span class="line"><span class="comment"># 向consul server服务注册地址</span></span><br><span class="line"><span class="attr">spring.cloud.consul.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="attr">spring.cloud.consul.port</span>=<span class="string">8500</span></span><br><span class="line"><span class="comment"># 默认为$&#123;spring.application.name&#125;</span></span><br><span class="line"><span class="attr">spring.cloud.consul.discovery.service-name</span>=<span class="string">CONSULCLIENT</span></span><br></pre></td></tr></table></figure><ol start="3"><li>启动类添加注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="comment">// 除了eureka，其它注册中心客户端都可以用该注解</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsulClientApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-4、consul健康检查"><a href="#4-4、consul健康检查" class="headerlink" title="4.4、consul健康检查"></a>4.4、consul健康检查</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291356805.png" alt="image (10).png"></p><ol><li>默认情况下consul监控健康是开启的，但必须依赖健康监控依赖才能正常响应客户端发来的心跳，否则界面会显示错误，引入健康依赖之后服务正常<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--健康检查依赖 actuator--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="5、openFeign（服务间通信）"><a href="#5、openFeign（服务间通信）" class="headerlink" title="5、openFeign（服务间通信）"></a>5、openFeign（服务间通信）</h1><h2 id="5-1、基于RestTemplate实现调用"><a href="#5-1、基于RestTemplate实现调用" class="headerlink" title="5.1、基于RestTemplate实现调用"></a>5.1、基于RestTemplate实现调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2Controller</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;client 2 OK!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://localhost:8088/test&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;调用client2成功：&quot;</span>+result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-2、基于RestTemplate-Ribbon实现负载均衡调用"><a href="#5-2、基于RestTemplate-Ribbon实现负载均衡调用" class="headerlink" title="5.2、基于RestTemplate+Ribbon实现负载均衡调用"></a>5.2、基于RestTemplate+Ribbon实现负载均衡调用</h2><p>spring cloud ribbon是一个基于HTTP和TCP的客户端负载均衡工具，它基于netflix ribbon实现，通过spring cloud封装，可以让我们轻松的进行客户端负载均衡调用。Ribbon可从注册中心中获取服务提供者地址列表，并基于负载均衡算法，请求其中一个服务提供者实例</p><ol><li><strong>编码形式</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 服务注册与发现客户端对象（获取服务列表后需要手动选取）</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">// 具有负载均衡的服务注册与发现客户端对象（根据负载均衡策略自动选取一个）</span></span><br><span class="line">    <span class="keyword">private</span> LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// （1）DiscoveryClient</span></span><br><span class="line">        List&lt;ServiceInstance&gt; serviceInstances = discoveryClient.getInstances(<span class="string">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>().getForObject(serviceInstances.get(<span class="number">0</span>).getUri() + <span class="string">&quot;/test&quot;</span>, String.class);</span><br><span class="line">        <span class="comment">// （2）LoadBalanceClient</span></span><br><span class="line">        <span class="type">ServiceInstance</span> <span class="variable">serviceInstances2</span> <span class="operator">=</span> loadBalancerClient.choose(<span class="string">&quot;CONSULCLIENT2&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>().getForObject(serviceInstances2.getUri() + <span class="string">&quot;/test&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;调用client2成功：&quot;</span> + result2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>@LoadBalance注解实现负载均衡</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span> <span class="comment">// 使RestTemplate对象具有ribbon负载均衡特性</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result3</span> <span class="operator">=</span> restTemplate.getForObject(<span class="string">&quot;http://CONSULCLIENT2/test&quot;</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;调用client2成功：&quot;</span> + result3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>Ribbon负载均衡策略</strong></li></ol><table><thead><tr><th>策略类</th><th>命名</th><th>描述</th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>轮询策略</td><td>轮询选择，轮询index，选择index对应位置的Server</td></tr><tr><td>RandomRule</td><td>随机策略</td><td>随机选择server</td></tr><tr><td>BestAvailableRule</td><td>最低并发策略</td><td>选择其中并发链接最低的server</td></tr><tr><td>RetryRule</td><td>重试策略</td><td>其实就是轮询策略的加强版，轮询策略服务不可用时不处理，重试策略会尝试其它节点</td></tr><tr><td>AvailabilityFilteringRule</td><td>可用过滤策略</td><td>过滤掉一直连接失败的provider和繁忙的provider</td></tr><tr><td>ZoneAvoidanceRule</td><td>区域权重策略</td><td>如果某个ip区域内有一个或多个示例不可达或响应慢，都会降低该ip区域内其它ip被选中的权重</td></tr></tbody></table><ol start="4"><li><strong>负载均衡策略设置</strong></li></ol><p>（1）局部修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 负载均衡策略 provider为调用的服务的名称</span><br><span class="line"># 格式：服务应用名.ribbon.负载均衡策略名字</span><br><span class="line">provider:</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure><p>（2）全局修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsulClientApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有被调用服务均使用该策略</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RandomRule <span class="title function_">randomRule</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3、基于openFeign实现调用"><a href="#5-3、基于openFeign实现调用" class="headerlink" title="5.3、基于openFeign实现调用"></a>5.3、基于openFeign实现调用</h2><h3 id="5-3-1、Feign"><a href="#5-3-1、Feign" class="headerlink" title="5.3.1、Feign"></a>5.3.1、Feign</h3><blockquote><p>Feign是Spring Cloud组件中一个轻量级RESTful的HTTP服务客户端，Feign内置了Ribbon，用来做客户端负载均衡，去调用服务注册中心的服务。Feign的使用方式是：使用Feign的注解定义接口，调用接口，就可以调用服务注册中心的服务</p></blockquote><h3 id="5-3-2、openFeign"><a href="#5-3-2、openFeign" class="headerlink" title="5.3.2、openFeign"></a>5.3.2、openFeign</h3><blockquote><p>OpenFeign是Spring Cloud 在Feign的基础上支持了Spring MVC的注解，如@RequesMapping等等。<br>OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，<br>并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</p></blockquote><h3 id="5-3-3、openFeign调用"><a href="#5-3-3、openFeign调用" class="headerlink" title="5.3.3、openFeign调用"></a>5.3.3、openFeign调用</h3><h4 id="5-3-3-1、编码"><a href="#5-3-3-1、编码" class="headerlink" title="5.3.3.1、编码"></a>5.3.3.1、编码</h4><p>（1）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--openFeign--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）启动类开启openFeign的调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsulClientApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）创建业务层接口，添加@FeginClient注解声明需要调用的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(&quot;CONSULCLIENT2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    String <span class="title function_">test2</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Client2 client2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> client2.test2();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;调用client2成功：&quot;</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-3-3-2、接口参数传递详解"><a href="#5-3-3-2、接口参数传递详解" class="headerlink" title="5.3.3.2、接口参数传递详解"></a>5.3.3.2、接口参数传递详解</h4><blockquote><p>（1）test？name&#x3D;xxx&amp;age&#x3D;10  —— @RequestParam(“name”)<br>（2）test&#x2F;{id}   ——  @PathVarible(“id”)<br>（3）test(@RequestBody User user)<br>（4）集合和数组作为参数时封装到VO对象中</p></blockquote><h4 id="5-3-3-3、超时处理"><a href="#5-3-3-3、超时处理" class="headerlink" title="5.3.3.3、超时处理"></a>5.3.3.3、超时处理</h4><ol><li>默认超时时间：1s</li><li>修改某个服务的超时时间</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign.client.config.PRODUCTS.connecTimeOut</span>=<span class="string">5000 # 配置指定服务连接超时</span></span><br><span class="line"><span class="attr">feign.client.config.PRODUCTS.readTimeOut</span>=<span class="string">5000 # 配置指定服务等待超时</span></span><br></pre></td></tr></table></figure><ol start="3"><li>修改所有服务超时时间</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign.client.config.default.connecTimeOut</span>=<span class="string">5000 # 配置服务连接超时</span></span><br><span class="line"><span class="attr">feign.client.config.default.readTimeOut</span>=<span class="string">5000 # 配置服务等待超时</span></span><br></pre></td></tr></table></figure><h1 id="6、Hystrix（服务熔断）"><a href="#6、Hystrix（服务熔断）" class="headerlink" title="6、Hystrix（服务熔断）"></a>6、Hystrix（服务熔断）</h1><h2 id="6-1、什么是服务雪崩？"><a href="#6-1、什么是服务雪崩？" class="headerlink" title="6.1、什么是服务雪崩？"></a>6.1、什么是服务雪崩？</h2><p>因“服务提供者的不可用”（原因）导致“服务调用者不可用”（结果），并将不可用逐渐放大的现象</p><blockquote><p>（1）程序bug导致服务不可用，或者运行缓慢<br>（2）缓存击穿，导致调用全部访问某服务，导致down掉<br>（3）访问量的突然激增</p></blockquote><h2 id="6-2、解决服务雪崩（-熔断-降级）"><a href="#6-2、解决服务雪崩（-熔断-降级）" class="headerlink" title="6.2、解决服务雪崩（ 熔断 + 降级）"></a>6.2、解决服务雪崩（ 熔断 + 降级）</h2><ol><li><strong>服务熔断</strong></li></ol><p>一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，向调用方返回一个符合预期的的备选响应，而不是长时间等待或抛出异常。所以很多地方把熔断亦称为过载保护</p><ol start="2"><li><strong>服务降级</strong></li></ol><p>当网站或服务流量突然增加时，为了保证系统核心服务正常运行，有策略的关闭系统中的边缘服务，以保证核心服务的正常运行</p><ol start="3"><li><strong>熔断降级的关系</strong></li></ol><p>熔断必会出发降级，所以熔断也是降级的一种，区别在于熔断是对调用链路的保护，降级是对系统过载的一种保护</p><h2 id="6-3、Hystrix概念"><a href="#6-3、Hystrix概念" class="headerlink" title="6.3、Hystrix概念"></a>6.3、Hystrix概念</h2><p>Hystrix是处理分布式系统延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，超时，异常等。Hystrix能够保证在一个依赖出现问题时，不会导致整体服务失败，避免雪崩效应，提高分布式系统的弹性</p><h2 id="6-4、编码"><a href="#6-4、编码" class="headerlink" title="6.4、编码"></a>6.4、编码</h2><ol><li>所有服务引入Hystrix依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--hystrix--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>服务提供者</li></ol><p>（直接调用服务提供者的方案，是一种服务降级的思想）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 开启熔断功能</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableHystrix</span> <span class="comment">//开启hystrix熔断功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsulClient2Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsulClient2Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2Controller</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line">    <span class="meta">@HystrixCommand(fallbackMethod = &quot;demoFallBack&quot;,defaultFallback = &quot;defaultFallBack&quot;)</span> <span class="comment">//熔断之后的处理</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (id &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;发生异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;client 2:8088 OK!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">demoFallBack</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;服务被熔断&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">defaultFallBack</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;服务被熔断(默认)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>服务消费者</li></ol><p>（通过服务消费者调用的方案，服务者完全挂掉时的处理，是一种服务熔断的思想）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 开启openFeign支持服务降级</span><br><span class="line">feign.hystrix.enabled=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span>  <span class="comment">// 开启服务注册客户端</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>  <span class="comment">// 开启openFeign调用</span></span><br><span class="line"><span class="meta">@EnableHystrix</span> <span class="comment">// 开启hystrix熔断功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsulClientApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ConsulClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fallback:指定当服务不可用时，默认的备选处理</span></span><br><span class="line"><span class="meta">@FeignClient(value = &quot;CONSULCLIENT2&quot;,fallback = Client2FallBack.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test2&quot;)</span></span><br><span class="line">    String <span class="title function_">test2</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> Integer id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client2FallBack</span> <span class="keyword">implements</span> <span class="title class_">Client2</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test2</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;当前服务不可达&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Client2 client2;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> client2.test2(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;调用client2成功：&quot;</span> + result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5、Hystrix服务熔断机制"><a href="#6-5、Hystrix服务熔断机制" class="headerlink" title="6.5、Hystrix服务熔断机制"></a>6.5、Hystrix服务熔断机制</h2><h3 id="6-5-1、Hystrix断路器打开的条件"><a href="#6-5-1、Hystrix断路器打开的条件" class="headerlink" title="6.5.1、Hystrix断路器打开的条件"></a>6.5.1、Hystrix断路器打开的条件</h3><p>a. 当满足一定阈值的时候（默认10秒内超过20个请求次数）<br>b. 当失败率达到一定的时候（默认10秒内超过50%的请求失败）</p><blockquote><p>注意：一旦断路开启之后，所有到这个服务请求均不可用，只有在断路关闭之后才可用</p></blockquote><h3 id="6-5-2、Hystrix监控流程"><a href="#6-5-2、Hystrix监控流程" class="headerlink" title="6.5.2、Hystrix监控流程"></a>6.5.2、Hystrix监控流程</h3><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307291357597.png" alt="Hystrix监控流程"></p><p>当服务调用达到两个阈值，会自动开启断路器，在熔断器打开期间，任何到该接口的请求均不可用，同时在断路器打开5s后断路器会处于半开状态，此时断路器允许放行一个请求到该服务接口，如果执行成功，断路器彻底关闭，执行失败则重新打开</p><h2 id="6-6、Hystrix-Dashboard（仪表盘）"><a href="#6-6、Hystrix-Dashboard（仪表盘）" class="headerlink" title="6.6、Hystrix Dashboard（仪表盘）"></a>6.6、Hystrix Dashboard（仪表盘）</h2><ol><li>基本概念</li></ol><p>Hystrix Dashboard主要用来实时监控Hystrix的各项指标信息。通过Hystrix Dashboard反馈的实时信息，可以帮助我们快速发现系统中存在的问题</p><ol start="2"><li>编码</li></ol><p>（1）新建一个 Hystrix Dashboard 工程<br>（2）引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Cloud Hystrix Dashboard --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）启动类开启监控功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 开启 Hystrix Dashboard 监控功能 */</span></span><br><span class="line"><span class="meta">@EnableHystrixDashboard</span></span><br></pre></td></tr></table></figure><p>（4）访问仪表盘界面</p><blockquote><p><a href="http://localhost:9000/hystrix">http://localhost:9000/hystrix</a><br>端口为项目的端口号</p></blockquote><h1 id="7、zuul（网关）"><a href="#7、zuul（网关）" class="headerlink" title="7、zuul（网关）"></a>7、zuul（网关）</h1><p>Zuul 是从设备和网站到应用程序后端的所有请求的前门。作为边缘服务应用程序，Zuul 旨在实现动态路由，监视，弹性和安全性。zuul 包含了对请求的<strong>路由</strong>和<strong>过滤</strong>两个最主要的功能。</p><p>Zuul是 Netflix 开源的微服务网关，它可以和 Eureka、Ribbon、Hystrix 等组件配合使用。Zuul 的核心是一系列的过滤器，这些过滤器可以完成以下功能:</p><p>（1）聚合接口使得服务对调用者透明，客户端与后端的耦合度降低<br>（2）聚合后台服务，节省流量，提高性能，提升用户体验<br>（3）提供安全、流控、过滤、缓存、计费、监控等 API 管理功能</p><h2 id="7-1、搭建环境"><a href="#7-1、搭建环境" class="headerlink" title="7.1、搭建环境"></a>7.1、搭建环境</h2><p>创建一个应用，在启动类中添加注解@EnableZuulProxy，声明这是一个网关服务提供者</p><h2 id="7-2、路由规则配置"><a href="#7-2、路由规则配置" class="headerlink" title="7.2、路由规则配置"></a>7.2、路由规则配置</h2><h3 id="7-2-1、URL地址路由"><a href="#7-2-1、URL地址路由" class="headerlink" title="7.2.1、URL地址路由"></a>7.2.1、URL地址路由</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 路由规则</span><br><span class="line">zuul:</span><br><span class="line">routes :</span><br><span class="line">        # 路由 id 自定义</span><br><span class="line">        product-service :</span><br><span class="line">path: /product-service<span class="comment">/**配请求 ur1 的映射路径#</span></span><br><span class="line"><span class="comment">    url: http://localhost:7070/ # 映射路径对应的微服务地址</span></span><br></pre></td></tr></table></figure><p>通配符含义：</p><table><thead><tr><th>通配符</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>？</td><td>匹配任意单个字符</td><td>&#x2F;product-service&#x2F;?</td></tr><tr><td>*</td><td>匹配任意数量字符不包括子路径</td><td>&#x2F;product-service&#x2F;*</td></tr><tr><td>**</td><td>匹配任意数量字符包括所有子路径</td><td>&#x2F;product-service&#x2F;**</td></tr></tbody></table><h3 id="7-2-2、服务名称路由"><a href="#7-2-2、服务名称路由" class="headerlink" title="7.2.2、服务名称路由"></a>7.2.2、服务名称路由</h3><p>微服务一般是由几十、上百个服务组成，对于 URL 地址路由的方式，如果对每个服务实例手动指定一个唯一访问地址，这样做显然是不合理的。<br>Zuul 支持与 Eureka 整合开发，根据 serviceld 自动从注册中心获取服务地并转发清求，这样做的好处不仅可以通过单个端点来访问应用的所有服务，而目在添加或移除服务实例时不用修改 Zuul 的路由配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">路由规则</span><br><span class="line">Zuul</span><br><span class="line">routes:</span><br><span class="line"># 路由 id 自定义</span><br><span class="line">product-service:</span><br><span class="line">path: /product-service<span class="comment">/**#配置请 url 的映射路径</span></span><br><span class="line"><span class="comment">serviceId: product-service # 根据 serviceId 自动从注册中心获取服务地址并转发请求</span></span><br></pre></td></tr></table></figure><h3 id="7-2-3、简化路由配置"><a href="#7-2-3、简化路由配置" class="headerlink" title="7.2.3、简化路由配置"></a>7.2.3、简化路由配置</h3><p>Zuul 为了方便大家使用，提供了默认路由配置: 路由 id 和 微服务名称 一致，path 默认对应 微服务名称&#x2F;* ，所以以下配置就没必要再写了。</p><h2 id="7-3、路由排除"><a href="#7-3、路由排除" class="headerlink" title="7.3、路由排除"></a>7.3、路由排除</h2><p>我们可以通过路由排除设置不允许被访问的资源。允许被访问的资源可以通过路由规则进行设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 路由规则</span><br><span class="line">Zuul:</span><br><span class="line">#ignored-patterns: <span class="comment">/**/order/** # URL 地址排除，排除所有包含 /order/ 的路径</span></span><br><span class="line"><span class="comment">ignored-services: order-service # 服务名称排除，多个服务逗号分隔，&#x27;*’排除所有</span></span><br></pre></td></tr></table></figure><h2 id="7-4、路由前缀"><a href="#7-4、路由前缀" class="headerlink" title="7.4、路由前缀"></a>7.4、路由前缀</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Zuul:</span><br><span class="line">prefix: /api</span><br></pre></td></tr></table></figure><h2 id="7-5、网关过滤器"><a href="#7-5、网关过滤器" class="headerlink" title="7.5、网关过滤器"></a>7.5、网关过滤器</h2><h3 id="7-5-1、关键名词"><a href="#7-5-1、关键名词" class="headerlink" title="7.5.1、关键名词"></a>7.5.1、关键名词</h3><p>类型: 定义路由流程中应用过滤器的阶段。共 pre、routing、 post、error 4 个类型<br>执行顺序: 在同类型中，定义过滤器执行的顺序。比如多个 pre 类型的执行顺序.<br>条件: 执行过滤器所需的条件。true 开启，false 关闭.<br>动作: 如果符合条件，将执行的动作。具体操作。</p><h3 id="7-5-2、过滤器类型"><a href="#7-5-2、过滤器类型" class="headerlink" title="7.5.2、过滤器类型"></a>7.5.2、过滤器类型</h3><p> <strong>pre</strong>: 请求被路由到源服务器之前执行的过滤器</p><blockquote><p>身份认证<br>选路由<br>请求日志</p></blockquote><p><strong>routing</strong>: 处理将请求发送到源服务器的过滤器。<br><strong>post</strong>: 响应从源服务器返回时执行的过滤器</p><blockquote><p>对响应增加 HTTP 头<br>收集统计和度量指标<br>将响应以流的方式发送回客户端</p></blockquote><p><strong>error</strong>:上述阶段中出现错误时执行的过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginFilter</span> <span class="keyword">extends</span> <span class="title class_">ZuulFilter</span>&#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">filterType</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 登录校验，肯定是在前置拦截 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;pre&quot;</span>; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">filterOrder</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 顺序设置为1 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldFilter</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="comment">// 返回true，代表过滤器生效。 </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException &#123;</span><br><span class="line">    <span class="comment">//处理业务逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-6、网关限流"><a href="#7-6、网关限流" class="headerlink" title="7.6、网关限流"></a>7.6、网关限流</h2><p>这些情况都是无法预知的，不知道什么时候会有 10 倍甚至 20 倍的流量打进来，如果真碰上这种情况，扩容是根本来不及的</p><p><strong>计数器</strong>：计算单元时间内访问接口的次数，如果达到次数，则限制访问</p><p><strong>漏桶算法</strong>：漏桶是一个固定容量的桶，按照固定的速率流出，可以以任意的速率流入到漏桶中，超出了漏桶的容量就被丢弃</p><p><strong>令牌桶算法：</strong><br>（1）所有的请求在处理之前都需要拿到一个可用的令牌才会被处理;<br>（2）根据限流大小，设置按照一定的速率往桶里添加令牌;<br>（3）桶设置最大的放置令牌限制，当桶满时、新添加的令牌就被丢弃或者拒绝;<br>（4）请求到达后首先要获取令牌桶中的令牌，拿着令牌才可以进行其他的业务逻辑，处理完业务逻辑之后，将令牌直接删除:<br>（5）令牌桶有最低限额，当桶中的令牌达到最低限额的时候，请求处理完之后将不会删除令牌，以此保证足够的限流。</p><blockquote><p>令牌桶算法是对漏桶算法的一种改进，漏桶算法能够限制请求调用的速率，而令牌桶算法能够在限制调用的平均速率的同时还允许一定程度的突发调用。在令牌桶算法中，存在一个桶，用来存放回定数量的令牌</p></blockquote><h3 id="7-6-1、网关限流"><a href="#7-6-1、网关限流" class="headerlink" title="7.6.1、网关限流"></a>7.6.1、网关限流</h3><ol><li>全局限流配置</li></ol><p>使用全局限流配置，zuul会对代理的所有服务提供限流保护</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启限流保护</span></span><br><span class="line"><span class="attr">zuul.ratelimit.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 60s内请求超过3次，服务端就抛出异常，60s后可以恢复正常请求</span></span><br><span class="line"><span class="attr">zuul.ratelimit.default-policy.limit</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">zuul.ratelimit.default-policy.refresh-interval</span>=<span class="string">60</span></span><br><span class="line"><span class="comment"># 针对IP进行限流，不影响其他IP</span></span><br><span class="line"><span class="attr">zuul.ratelimit.default-policy.type</span>=<span class="string">origin</span></span><br></pre></td></tr></table></figure><ol start="2"><li>局部限流配置</li></ol><p>使用局部限流配置，zuul仅针对配置的服务提供限流保护</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启限流保护</span></span><br><span class="line"><span class="attr">zuul.ratelimit.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># hystrix-application-client服务60s内请求超过3次，服务抛出异常。</span></span><br><span class="line"><span class="attr">zuul.ratelimit.policies.hystrix-application-client.limit</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">zuul.ratelimit.policies.hystrix-application-client.refresh-interval</span>=<span class="string">60</span></span><br><span class="line"><span class="comment"># 针对IP限流。</span></span><br><span class="line"><span class="attr">zuul.ratelimit.policies.hystrix-application-client.type</span>=<span class="string">origin</span></span><br></pre></td></tr></table></figure><h1 id="8、sleuth（链路追踪）"><a href="#8、sleuth（链路追踪）" class="headerlink" title="8、sleuth（链路追踪）"></a>8、sleuth（链路追踪）</h1><h2 id="8-1、链路追踪"><a href="#8-1、链路追踪" class="headerlink" title="8.1、链路追踪"></a>8.1、链路追踪</h2><p>单纯的理解链路追踪，就是指一次任务的开始到结束，期间调用的所有系统及耗时(时间跨度)都可以完整记录下来.</p><h2 id="8-2、sleuth"><a href="#8-2、sleuth" class="headerlink" title="8.2、sleuth"></a>8.2、sleuth</h2><p>Spring Cloud sleuth 为 Spring Cloud 实现了分布式跟踪解决方案。兼容 Zipkin，和其他基于日志的追踪系统，例如ELK (Elasticsearch 、 Logstash、Kibana)<br>Spring cloud sleuth 提供了以下功能:</p><ul><li>辩路追踪: 通过 Sleuth 可以很清楚的看出一个请求都经过了那些服务，可以很方便的理清服务间的调用关系等。</li><li>性能分析 :通过 sleuth 可以很方便的看出每个采样请求的耗时，分析哪些服务调用比较耗时，当服务调用的耗时随着请求量的增大而增大时，可以对服务的扩容提供一定的提醒。</li><li>数据分析，优化链路 : 对于频繁调用一个服务，或并行调用等，可以针对业务做一些优化措施.</li><li>可视化错误 : 对于程序未捕获的异常，可以配合 Zipkin 查看。</li></ul><h2 id="8-3、专业术语"><a href="#8-3、专业术语" class="headerlink" title="8.3、专业术语"></a>8.3、专业术语</h2><h3 id="8-3-1、span"><a href="#8-3-1、span" class="headerlink" title="8.3.1、span"></a>8.3.1、span</h3><p>基本工作单位，一次单独的调用链可以称为一个 Span，Dapper 记录的是 Span 的名称，以及每个 Span 的 ID 和父ID，以重建在一次追踪过程中不同 Span 之间的关系</p><h1 id="9、原理相关"><a href="#9、原理相关" class="headerlink" title="9、原理相关"></a>9、原理相关</h1><h2 id="9-1、如何保证分布式事务一致性？"><a href="#9-1、如何保证分布式事务一致性？" class="headerlink" title="9.1、如何保证分布式事务一致性？"></a>9.1、如何保证分布式事务一致性？</h2><ol><li>首先是设计方案尽可能规避分布式事务的场景（相似的业务放在一起，不要过度的拆分）</li><li>根据业务场景，选择使用柔性事务（ap）还是强事务(cp)<br> 如果可以允许消息存在一段时间不一致，只要保证最终一致性，可以用本地消息表来做。如果要保证一致性，可以用2pc，具体实现方案有阿里的seata</li><li>本地消息表（柔性事务）<br>不去同步的调用，先将要请求的消息插入到本地的消息表中，消息状态为正在处理，起一个定时任务去查询消息表，将正在处理的消息发送到消息队列，B中消息处理完后，向一个return队列发送一个成功的消息，A订阅了该消息队列，收到成功的消息后将状态该为处理完毕。（被调用方应保证幂等性，如库存系统在减库存前先查流水表，看该订单是否扣过库存，扣过就不执行）</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311150941880.png" alt="image.png"></p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202311150942538.png" alt="image.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> springCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/posts/33708.html"/>
      <url>/posts/33708.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、基本基础"><a href="#1、基本基础" class="headerlink" title="1、基本基础"></a>1、基本基础</h1><h2 id="1-1、mq概念"><a href="#1-1、mq概念" class="headerlink" title="1.1、mq概念"></a>1.1、mq概念</h2><p>MQ全称Message Queue（消息队列），是在消息传输过程中保存消息的容器。多用于分布式系统之间进行通信</p><h2 id="1-2、mq优缺点"><a href="#1-2、mq优缺点" class="headerlink" title="1.2、mq优缺点"></a>1.2、mq优缺点</h2><p><strong>优势：</strong><br>（1）应用解耦:eg：订单系统不直接调用库存系统，库存系统宕机并不影响下单<br>（2）异步提速：eg：订单系统不需要同步调用库存系统，提升速度<br>（3）削峰填谷：eg：mq承载了5000请求，系统慢慢消费，就是削峰。但是因为消息积压，高峰过一段时间后消息才能被消费完，这就是填谷。  </p><p><strong>劣势：</strong><br>（1）系统可用性降低：一旦mq宕机，就可能对多个业务造成影响。如何保证mq高可用<br>（2）系统复杂度提高：如何保证消息不被重复消费？怎么处理丢失情况？怎么保证消息传递的顺序性？<br>（3）一致性问题：A系统给B,C,D系统发送数据，如果B，c处理成功，D系统失败。如何保证消息数据处理的一致性</p><h2 id="1-3、mq产品选型"><a href="#1-3、mq产品选型" class="headerlink" title="1.3、mq产品选型"></a>1.3、mq产品选型</h2><table><thead><tr><th>指标</th><th><strong>ActiveMQ</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketM Q</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td>数据量级（每秒）</td><td>万级</td><td>万级</td><td>十万级</td><td>十万级</td></tr><tr><td>可靠性</td><td>低概率丢失</td><td>0丢失</td><td>0丢失</td><td>0丢失</td></tr><tr><td>可用性</td><td>主从架构</td><td>主从架构</td><td>分布式</td><td>分布式</td></tr><tr><td>时效性</td><td>毫秒</td><td>微秒</td><td>毫秒</td><td>毫秒</td></tr></tbody></table><blockquote><p>一个简单粗暴的判断方法：大量数据、日志采集用Kafka，需要高可靠性高并发性用RocketMQ，数据量不大的一般系统用RabbitMQ。</p></blockquote><h2 id="1-4、AMQP协议"><a href="#1-4、AMQP协议" class="headerlink" title="1.4、AMQP协议"></a>1.4、AMQP协议</h2><p> AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议，是<strong>应用层协议</strong>的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件同产品，不同的开发语言等条件的限制 1</p><h2 id="1-5、rabbitMQ安装"><a href="#1-5、rabbitMQ安装" class="headerlink" title="1.5、rabbitMQ安装"></a>1.5、rabbitMQ安装</h2><ol><li>安装Eralng，下面链接已提供otp_win64_20.2.exe</li></ol><p>链接： <a href="https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg">https://pan.baidu.com/s/1lmvCMPVAV1Ba9UogCdQpZg</a><br>提取码：x9m7</p><ol start="2"><li>安装rabbitmq，下面链接已提供rabbitmq-server-3.7.4.exe</li></ol><p>链接： <a href="https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg">https://pan.baidu.com/s/1CPfhg5X1e7UitpgMWIcAEg</a><br>提取码：h4r3</p><ol start="3"><li>配置erlang环境变量</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037440.png" alt="配置erlang环境变量"></p><ol start="4"><li>测试erlang</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037374.png" alt="测试erlang"></p><ol start="5"><li>启动rabbitmq</li></ol><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241037002.png" alt="启动rabbitmq"></p><ol start="6"><li>访问 <a href="http://127.0.0.1:15672/">http://127.0.0.1:15672/</a>      guest guest</li></ol><h1 id="2、组件"><a href="#2、组件" class="headerlink" title="2、组件"></a>2、组件</h1><h2 id="2-1、RabbitMQ架构"><a href="#2-1、RabbitMQ架构" class="headerlink" title="2.1、RabbitMQ架构"></a>2.1、RabbitMQ架构</h2><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241048618.png" alt="RabbitMQ架构"></p><p>（1）broker（服务端）：接收客户端的连接，实现AMQP实体服务。<br>（2）Connection：连接，应用程序与Server的网络连接，TCP连接。<br>（3）Channel：信道，消息读写等操作在信道中进行。客户端可以建立多个信道，每个信道代表一个会话任务。<br>（4）Virtual Host：虚拟主机，用于逻辑隔离。一个虚拟主机里面可以有若干个Exchange和Queue，同一个虚拟主机里面不能有相同名称的Exchange或Queue。<br>（5）Exchange：交换器，接收消息，按照路由规则将消息路由到一个或者多个队列。如果路由不到，或者返回给生产者，或者直接丢弃。RabbitMQ常用的交换器常用类型有direct、topic、fanout、headers四种，后面详细介绍。<br>（6）Queue：消息队列，用来保存消息，供消费者消费<br>（7）Message：消息，应用程序和服务器之间传送的数据，消息可以非常简单，也可以很复杂。有Properties和Body组成。Properties为外包装，可以对消息进行修饰，比如消息的优先级、延迟等高级特性；Body就是消息体内容。<br>（8）Binding：绑定，交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个RoutingKey。<br>（9）RoutingKey：路由键，生产者将消息发送给交换器的时候，会发送一个RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。路由键通常为一个“.”分割的字符串，例如“com.rabbitmq”</p><h2 id="2-2、4种Exchange交换机类型"><a href="#2-2、4种Exchange交换机类型" class="headerlink" title="2.2、4种Exchange交换机类型"></a>2.2、4种Exchange交换机类型</h2><h3 id="2-2-1、Direct-Exchange（直连交换机）"><a href="#2-2-1、Direct-Exchange（直连交换机）" class="headerlink" title="2.2.1、Direct Exchange（直连交换机）"></a>2.2.1、Direct Exchange（直连交换机）</h3><p>根据Routing Key(路由键)进行投递到不同队列。如果路由键不匹配，那么就不会发送到任何队列中去。</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241551705.png" alt="直连交换机"></p><h3 id="2-2-2、Fanout-Exchange（广播交换机）"><a href="#2-2-2、Fanout-Exchange（广播交换机）" class="headerlink" title="2.2.2、Fanout Exchange（广播交换机）"></a>2.2.2、Fanout Exchange（广播交换机）</h3><p>该类型的交换机会将⼀条消息⼴播到绑定到该交换机的所有队列上，不论你设置的路由键是什么</p><blockquote><p>如果想让多个消费者消费到数据必须不指定queues，指定交换机</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">        value = @Queue(), //注意这里不要定义队列名称,系统会随机产生</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;business_rrpc_exchange&quot;,type = ExchangeTypes.FANOUT)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-2-3、Topic-Exchange（主题交换机）"><a href="#2-2-3、Topic-Exchange（主题交换机）" class="headerlink" title="2.2.3、Topic Exchange（主题交换机）"></a>2.2.3、Topic Exchange（主题交换机）</h3><p>将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”匹配不多不少一个词。因此“abc.#”能够匹配到“abc.def.ghi”，但是“abc.* ” 只会匹配到“abc.def”。</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241552123.png" alt="主题交换机"></p><h3 id="2-2-4、Headers-Exchanges（头交换机）"><a href="#2-2-4、Headers-Exchanges（头交换机）" class="headerlink" title="2.2.4、Headers Exchanges（头交换机）"></a>2.2.4、Headers Exchanges（头交换机）</h3><p>与routingKey无关，匹配机制是匹配消息头中的属性信息。在绑定消息队列与交换机之前声明一个map键值对，通过这个map对象实现消息队列和交换机的绑定。当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列()</p><blockquote><p>匹配规则x-match有下列两种类型：<br>x-match &#x3D; all ：表示所有的键值对都匹配才能接受到消息<br>x-match &#x3D; any ：表示只要有键值对匹配就能接受到消息</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557662.png" alt="image (6).png"></p><h2 id="2-3、工作模式"><a href="#2-3、工作模式" class="headerlink" title="2.3、工作模式"></a>2.3、工作模式</h2><h3 id="2-3-1、简单模式"><a href="#2-3-1、简单模式" class="headerlink" title="2.3.1、简单模式"></a>2.3.1、简单模式</h3><p>一个生产者将消息发送到一个队列中，一个消费者从这个队列中获取消息并进行处理。这种模式仅适用于单个生产者和单个消费者的场景</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241557273.png" alt="简单模式"></p><blockquote><p>P代表生产者，C代表消费者，红色代表消息队列。P将消息发送到消息队列，C对消息进行处理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建队列</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">Queue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 生产者</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hello,rabbitmq&quot;</span>;</span><br><span class="line">        amqpTemplate.convertAndSend(<span class="string">&quot;queue1&quot;</span>, content);</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 消费者</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMsg</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-3-2、工作队列模式"><a href="#2-3-2、工作队列模式" class="headerlink" title="2.3.2、工作队列模式"></a>2.3.2、工作队列模式</h3><p>一个生产者将消息发送到一个队列中，多个消费者从这个队列中获取消息并进行处理。这种模式可以提高消息的处理效率</p><blockquote><p>对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241632591.png" alt="工作队列模式"></p><p><strong>实现方式</strong><br>多个消费者同时监听同一个队列,消息被消费，共同争抢当前的消息队列内容,谁先拿到谁负责消费消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加一个消费者监听同一个队列</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer2</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMsg</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer2: &quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2996398/1661394067626-05e7a3e3-889c-4b32-aac4-b411287a4c20.png#averageHue=%2334322f&clientId=u1f2092d6-850c-4&from=paste&height=268&id=u834eba4b&originHeight=268&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=7316&status=done&style=none&taskId=u30d0eca9-feeb-475a-8f5e-e2cbcd309fb&title=&width=276" alt="image.png"></p><h3 id="2-3-3、发布订阅模式"><a href="#2-3-3、发布订阅模式" class="headerlink" title="2.3.3、发布订阅模式"></a>2.3.3、发布订阅模式</h3><p>一个生产者将消息发送到一个交换机中，交换机将消息广播到所有绑定的队列中，多个消费者可以分别从这些队列中获取消息并进行处理。这种模式适用于需要将消息广播到多个消费者的场景</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241633780.png" alt="发布订阅模式"></p><ol><li><strong>实现方式</strong></li></ol><p>（1）创建两个队列和一个交换机，然后将队列绑定到交换机上 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queue1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queue1&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queue2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queue2&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">FanoutExchange <span class="title function_">fanoutExchange1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanoutExchange1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Binding <span class="title function_">bindingExchangeA</span><span class="params">(Queue queue1, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue1).to(fanoutExchange1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Binding <span class="title function_">bindingExchangeB</span><span class="params">(Queue queue2, FanoutExchange fanoutExchange1)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue2).to(fanoutExchange1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）生产者消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者：第二个参数是队列名，设置为空</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hello,rabbitmq&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            amqpTemplate.convertAndSend(<span class="string">&quot;fanoutExchange1&quot;</span>,<span class="string">&quot;&quot;</span>, content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者1</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMsg</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer1: &quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者2</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer2</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMsg</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer2: &quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2996398/1661413378872-162ba357-f8e8-44ca-858c-884732faf8fd.png#averageHue=%23353230&clientId=u1f2092d6-850c-4&from=paste&height=258&id=ub5bb0f8d&originHeight=258&originWidth=339&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32505&status=done&style=none&taskId=u45d190ce-12a2-4723-afca-16e723e524b&title=&width=339" alt="image.png"></p><h3 id="2-3-4、路由模式"><a href="#2-3-4、路由模式" class="headerlink" title="2.3.4、路由模式"></a>2.3.4、路由模式</h3><p>一个生产者将消息发送到一个交换机中，交换机根据消息的Routing Key将消息路由到对应的队列中，多个消费者可以从这些队列中获取消息并进行处理。这种模式适用于需要根据消息的路由键进行精确匹配的场景</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307241647936.png" alt="路由模式"></p><p><strong>实现方式</strong><br>（1）交换机和队列根据指定路由规则绑定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queue1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queue1&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">queue2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;queue2&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">DirectExchange <span class="title function_">directExchange1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;directExchange1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Binding <span class="title function_">bindingExchangeMessage1</span><span class="params">(Queue queue1, DirectExchange directExchange1)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue1).to(directExchange1).with(<span class="string">&quot;routingKey1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">Binding <span class="title function_">bindingExchangeMessage2</span><span class="params">(Queue queue2, DirectExchange directExchange1)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(queue2).to(directExchange1).with(<span class="string">&quot;routingKey2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）生产者和消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consumer1</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer1</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMsg</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;queue1 consumer1: &quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// consumer2</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer2</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue2&quot;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMsg</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;queue2 consumer2: &quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// producer</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AmqpTemplate amqpTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/send&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;hello,rabbitmq&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            amqpTemplate.convertAndSend(<span class="string">&quot;fanoutExchange1&quot;</span>,<span class="string">&quot;routingKey1&quot;</span>, content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2996398/1661473083570-947e0de2-9c97-47fb-8fba-4e568d152f28.png#averageHue=%23353330&clientId=u1f2092d6-850c-4&from=paste&height=129&id=u8c943953&originHeight=129&originWidth=335&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16674&status=done&style=none&taskId=uc8eec929-83ad-43c6-bda3-fb8dbe96e14&title=&width=335" alt="image.png"></p><h1 id="3、高级特性"><a href="#3、高级特性" class="headerlink" title="3、高级特性"></a>3、高级特性</h1><h2 id="3-1、保证消息传递的可靠性"><a href="#3-1、保证消息传递的可靠性" class="headerlink" title="3.1、保证消息传递的可靠性"></a>3.1、保证消息传递的可靠性</h2><p>RabbitMQ保证消息的可靠性主要分为两个部分：消息投递和消费者消息确认<br>（1）投递确认：<strong>confirm确认模式</strong>（producer——&gt;exchange），<strong>return退回模式</strong>（exchange——&gt;queue）<br>（2）消费者确认：ACK消息签收机制，表示消费者收到消息后的确认方式</p><h3 id="3-1-1、confirm确认模式"><a href="#3-1-1、confirm确认模式" class="headerlink" title="3.1.1、confirm确认模式"></a>3.1.1、confirm确认模式</h3><p>消息从 producer 到 rabbitmq broker有一个 confirmCallback 确认模式。(无论成功失败都有返回)</p><h3 id="3-1-2、return退回模式"><a href="#3-1-2、return退回模式" class="headerlink" title="3.1.2、return退回模式"></a>3.1.2、return退回模式</h3><p>消息从 exchange 到 queue 投递失败有一个 returnCallback 退回模式。（失败时才会有返回）</p><p><strong>实现confirm callback和return callback：</strong></p><ol><li>配置文件开启相关配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment">#配置rabbitMq 服务器</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">yancey</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">yancey</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># confirmCallback 确认模式</span></span><br><span class="line">    <span class="comment"># SIMPLE       禁用发布确认模式，是默认值</span></span><br><span class="line"><span class="comment"># CORRELATED   发布消息成功到交换器或失败后 会触发回调方法</span></span><br><span class="line"><span class="comment"># NONE         有两种效果，其一效果和CORRELATED值一样会触发回调方法，其二在发布消息成功后使用。rabbitTemplate调用waitForConfirms或waitForConfirmsOrDie方法等待broker节点返回 发送结果，根据返回结果来判定下一步的逻辑，要注意的点是waitForConfirmsOrDie方法如果 返回false则会关闭channel，则接下来无法发送消息到broker;</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># returnCallback 退回模式</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写配置类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RabbitTemplate <span class="title function_">createRabbitTemplate</span><span class="params">(ConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="type">RabbitTemplate</span> <span class="variable">rabbitTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>();</span><br><span class="line">        rabbitTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//设置消息投递失败的策略，有两种策略：自动删除或返回到客户端。</span></span><br><span class="line">        <span class="comment">//我们既然要做可靠性，当然是设置为返回到客户端(true是返回客户端，false是自动删除)</span></span><br><span class="line">        rabbitTemplate.setMandatory(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ConfirmCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">confirm</span><span class="params">(CorrelationData correlationData, <span class="type">boolean</span> ack, String cause)</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;相关数据：&quot;</span> + correlationData);</span><br><span class="line">                <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;投递成功,确认情况：&quot;</span> + ack);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.info(<span class="string">&quot;投递失败,确认情况：&quot;</span> + ack);</span><br><span class="line">                    log.info(<span class="string">&quot;原因：&quot;</span> + cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">new</span> <span class="title class_">RabbitTemplate</span>.ReturnCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">returnedMessage</span><span class="params">(Message message, <span class="type">int</span> replyCode, String replyText, String exchange, String routingKey)</span> &#123;</span><br><span class="line">               log.info(<span class="string">&quot;ReturnCallback:     &quot;</span> + <span class="string">&quot;消息：&quot;</span> + message);</span><br><span class="line">               log.info(<span class="string">&quot;ReturnCallback:     &quot;</span> + <span class="string">&quot;回应码：&quot;</span> + replyCode);</span><br><span class="line">               log.info(<span class="string">&quot;ReturnCallback:     &quot;</span> + <span class="string">&quot;回应信息：&quot;</span> + replyText);</span><br><span class="line">               log.info(<span class="string">&quot;ReturnCallback:     &quot;</span> + <span class="string">&quot;交换机：&quot;</span> + exchange);</span><br><span class="line">               log.info(<span class="string">&quot;ReturnCallback:     &quot;</span> + <span class="string">&quot;路由键：&quot;</span> + routingKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-3、消费者端ack机制"><a href="#3-1-3、消费者端ack机制" class="headerlink" title="3.1.3、消费者端ack机制"></a>3.1.3、消费者端ack机制</h3><p>消费者端消息接收确认采用的是ack模式。自动ACK：消息一旦被接收，消费者自动发送ACK，队列删除消息。手动ACK：消息接收后，不会发送ACK，需要手动调用<br>如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便<br>如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除</p><p>手动ack</p><p>开启方式简单，只需要放开此配置即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acknowledge-mode: manual # 设置消费端手动 ack</span><br></pre></td></tr></table></figure><p>消费者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;queue1&quot;)</span></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMsg</span><span class="params">(String msg, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>/<span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 消费成功后ack</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">// 消费失败后ack</span></span><br><span class="line">            <span class="comment">// 三个参数：</span></span><br><span class="line">            <span class="comment">// （1）delivery_tag：表示消息的唯一标识符</span></span><br><span class="line">            <span class="comment">// （2）multiple：表示是否将delivery_tag之前的所有未确认消息都拒绝。如果multiple为true，则RabbitMQ将拒绝所有未确认的消息，如果为false，则只拒绝指定的消息</span></span><br><span class="line">            <span class="comment">// （3）requeue：表示是否将被拒绝的消息重新放回队列中。如果requeue为true，则消息将返回到队列中以便重新处理，如果为false，则消息将被丢弃</span></span><br><span class="line">            channel.basicNack(message.getMessageProperties().getDeliveryTag(),<span class="literal">false</span>,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;<span class="comment">//判断是否已经重试过</span></span><br><span class="line">                log.error(<span class="string">&quot;消息已重复处理失败,拒绝再次接收...&quot;</span>);</span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>); <span class="comment">// 拒绝消息</span></span><br><span class="line">                <span class="comment">// 重复消费失败的消息入库...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;消息即将再次返回队列处理...&quot;</span>);</span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>requeue参数设置为true，可以将消息返回到队列中以便重新处理<br>但是这样可能导致无限循环地处理同一个错误消息<br>所以上面代码采用了折中方案：首次失败的消息通知队列重发，重复失败的消息落地进行后面的补偿机制</p></blockquote><h2 id="3-2、消息持久化机制"><a href="#3-2、消息持久化机制" class="headerlink" title="3.2、消息持久化机制"></a>3.2、消息持久化机制</h2><p>持久化是提高RabbitMQ 可靠性的基础，否则当 RabbitMQ 遇到异常时（如：重启、断电、停机等）数据将会丢失。主要从以下几个方面来保障消息的持久性：</p><ol><li>Exchange 的持久化。通过定义时设置  durable 参数为  ture  来保证  Exchange  相关的元数据不丢失。</li><li>Queue 的持久化。也是通过定义时设置  durable 参数为  ture  来保证  Queue  相关的元数据不丢失。</li><li>消息 的持久化。通过将消息的投递模式  (BasicProperties 中的 deliveryMode 属性 )  设置为 2 即可实现消息的持久化，保证消息自身不丢失。</li></ol><blockquote><p> 注:Exchange 和 Queue 的持久化只能保证 Exchange  跟 Queue 在RabbitMQ重启之后仍然存在，如果消息没有设置持久化的话，仅设置 Exchange 和 Queue 的持久化，消息仍然会丢失，想要保证消息不丢失， 交换机，队列，消息 三者的持久化缺一不可</p></blockquote><h3 id="3-2-1、交换机持久化"><a href="#3-2-1、交换机持久化" class="headerlink" title="3.2.1、交换机持久化"></a>3.2.1、交换机持久化</h3><p>在申明exchange的时候，有个参数：durable。当该参数为true，则对该exchange做持久化，重启rabbitmq服务器，该exchange不会消失。durable的默认值为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// autoDelete:当所有绑定队列都不在使用时，是否自动 删除</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">DirectExchange</span><span class="params">(String name, <span class="type">boolean</span> durable, <span class="type">boolean</span> autoDelete)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, durable, autoDelete);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-2-2、队列持久化"><a href="#3-2-2、队列持久化" class="headerlink" title="3.2.2、队列持久化"></a>3.2.2、队列持久化</h3><p>申明队列时也有个参数：durable。当该参数为true，则对该queue做持久化，重启rabbitmq服务器，该queue不会消失。durable的默认值为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// durable: 是否做队列持久化</span></span><br><span class="line"><span class="comment">// exclusive: 是否排外。两个作用：（1）当连接关闭时connection.close()该队列是否会自动删除（2）对当前队列加锁，其他通道channel是不能访问的，用于一个队列只能有一个消费者来消费的场景</span></span><br><span class="line"><span class="comment">// autoDelete:当所有消费客户端连接断开后，是否自动删除 </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Queue</span><span class="params">(String name, <span class="type">boolean</span> durable, <span class="type">boolean</span> exclusive, <span class="type">boolean</span> autoDelete)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(name, durable, exclusive, autoDelete, (Map)<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3、避免消息重复消费"><a href="#3-3、避免消息重复消费" class="headerlink" title="3.3、避免消息重复消费"></a>3.3、避免消息重复消费</h2><h3 id="3-3-1、消息重复发送的场景"><a href="#3-3-1、消息重复发送的场景" class="headerlink" title="3.3.1、消息重复发送的场景"></a>3.3.1、消息重复发送的场景</h3><p>消费者消费消息成功后，在给MQ发送消息确认的时候出现了网络异常(或者是服务中断)，MQ没有接收到确认，此时MQ不会将发送的消息删除，会继续给消费者投递之前的消息。这时候消费者就接收到了两条一样的消息</p><h3 id="3-3-2、解决方案"><a href="#3-3-2、解决方案" class="headerlink" title="3.3.2、解决方案"></a>3.3.2、解决方案</h3><p>保证消费者的幂等性（调用方，对一个系统进行重复调用（参数全部相同），不论重复调用多少次，这些调用对系统的影响都是相同的效果）</p><p>如何保证幂等性？</p><ol><li>使用代码的逻辑判断，判断消息状态是否已经被消费过了</li></ol><blockquote><p>使用数据库一个表来记录消息的状态（或者用redis来记录也可以）。每次消费之前，都查询判断消息的状态，是否已经被消费了。这个状态可以是id。例如，如果消息是订单，而且id是全局唯一的，那么只需要拿这个订单id来做判断即可。</p></blockquote><ol start="2"><li>使用token，要申请，一次有效性。</li></ol><blockquote><p>在创建订单的场景下。首先，先生成一个token，返回给客户端存起来，同时也在后端存起来（redis）。当他创建订单的时候，带着这个token来请求后端，后端判断redis里是否存在，如果存在，则操作成功，同时删除token（删除了之后，就算他重复多次调用，前边的判断不成立，这样子就不能多次操作了）</p></blockquote><h2 id="3-4、避免消息积压问题"><a href="#3-4、避免消息积压问题" class="headerlink" title="3.4、避免消息积压问题"></a>3.4、避免消息积压问题</h2><h3 id="3-4-1、消息积压场景"><a href="#3-4-1、消息积压场景" class="headerlink" title="3.4.1、消息积压场景"></a>3.4.1、消息积压场景</h3><p>消费者宕机&#x2F;消费能力不足，没有人去消费了，但依旧源源不断生产消息，导致消息积压</p><h3 id="3-4-2、解决方案"><a href="#3-4-2、解决方案" class="headerlink" title="3.4.2、解决方案"></a>3.4.2、解决方案</h3><ol><li>上线更多的消费者（如：库存服务），进行正常消费</li><li>上线专门的队列消费服务，将消息先批量取出来，记录数据库，离线慢慢处理。</li></ol><h2 id="3-5、保证消息的顺序性"><a href="#3-5、保证消息的顺序性" class="headerlink" title="3.5、保证消息的顺序性"></a>3.5、保证消息的顺序性</h2><h3 id="3-5-1、消息顺序错乱场景"><a href="#3-5-1、消息顺序错乱场景" class="headerlink" title="3.5.1、消息顺序错乱场景"></a>3.5.1、消息顺序错乱场景</h3><p>生产者向一个消息队列发送 创建学生信息 与 更新学生信息 两条消息。如果有两个消费者，可能同时一个消费者做创建学生的操作，另外一个消费者做更新学生的操作。那么就有可能发生，更新学生基本信息的操作早于创建学生基本信息的操作。这样的话更新就会失败。</p><h3 id="3-5-2、解决方案"><a href="#3-5-2、解决方案" class="headerlink" title="3.5.2、解决方案"></a>3.5.2、解决方案</h3><p>保证队列与消费者一对一<br>思路就是拆分队列，使得每个队列只有一个消费者，这样消费者一定是按照顺序消费的 </p>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> RabbitMQ </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>juc</title>
      <link href="/posts/42310.html"/>
      <url>/posts/42310.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、java多线程基本概念"><a href="#1、java多线程基本概念" class="headerlink" title="1、java多线程基本概念"></a>1、java多线程基本概念</h1><h2 id="1-1、进程和线程"><a href="#1-1、进程和线程" class="headerlink" title="1.1、进程和线程"></a>1.1、进程和线程</h2><ol><li><strong>进程</strong></li></ol><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li><li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><ol start="2"><li><strong>线程</strong></li></ol><ul><li>一个进程之内可以分为一到多个线程。 </li><li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li><li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li></ul><h2 id="1-2、并发和并行"><a href="#1-2、并发和并行" class="headerlink" title="1.2、并发和并行"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p><h2 id="1-3、多线程的应用"><a href="#1-3、多线程的应用" class="headerlink" title="1.3、多线程的应用"></a>1.3、多线程的应用</h2><h3 id="1-3-1、异步调用"><a href="#1-3-1、异步调用" class="headerlink" title="1.3.1、异步调用"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p><h3 id="1-3-2、提升效率"><a href="#1-3-2、提升效率" class="headerlink" title="1.3.2、提升效率"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 <span class="number">1</span> 花费 <span class="number">10</span> ms</span><br><span class="line">计算 <span class="number">2</span> 花费 <span class="number">11</span> ms</span><br><span class="line">计算 <span class="number">3</span> 花费 <span class="number">9</span> ms</span><br><span class="line">汇总需要 <span class="number">1</span> ms</span><br></pre></td></tr></table></figure><ul><li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li><li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms</li></ul><blockquote><p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p></blockquote><h1 id="2、java线程"><a href="#2、java线程" class="headerlink" title="2、java线程"></a>2、java线程</h1><h2 id="2-1、线程的创建"><a href="#2-1、线程的创建" class="headerlink" title="2.1、线程的创建"></a>2.1、线程的创建</h2><h3 id="2-1-1、直接使用Thread"><a href="#2-1-1、直接使用Thread" class="headerlink" title="2.1.1、直接使用Thread"></a>2.1.1、直接使用Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><h3 id="2-1-2、使用-Runnable-配合-Thread"><a href="#2-1-2、使用-Runnable-配合-Thread" class="headerlink" title="2.1.2、使用 Runnable 配合 Thread"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure><p>java8可用lambda精简</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure><h3 id="2-1-3、FutureTask-配合-Thread"><a href="#2-1-3、FutureTask-配合-Thread" class="headerlink" title="2.1.3、FutureTask 配合 Thread"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task3.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure><h2 id="2-2、查看进程线程"><a href="#2-2、查看进程线程" class="headerlink" title="2.2、查看进程线程"></a>2.2、查看进程线程</h2><h3 id="2-2-1、windows"><a href="#2-2-1、windows" class="headerlink" title="2.2.1、windows"></a>2.2.1、windows</h3><p>1.tasklist 查看进程<br>2.taskkill 杀死进程<br>3.netstat -ano|findstr 8080 根据端口查看进程</p><h3 id="2-2-2、linux"><a href="#2-2-2、linux" class="headerlink" title="2.2.2、linux"></a>2.2.2、linux</h3><p>1.ps -fe 查看所有进程<br>2.kill 杀死进程<br>3.top -Hp PID 查看某个进程（PID）的所有线程<br>4.netstat -nlp|grep 8080 根据端口查看进程</p><h3 id="2-2-3、JDK"><a href="#2-2-3、JDK" class="headerlink" title="2.2.3、JDK"></a>2.2.3、JDK</h3><p>1.jps 命令查看所有 Java 进程<br>2.jstack PID 查看某个 Java 进程（PID）的所有线程状态<br>3.jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p><h2 id="2-3、线程运行原理"><a href="#2-3、线程运行原理" class="headerlink" title="2.3、线程运行原理"></a>2.3、线程运行原理</h2><p>1.<strong>线程创建</strong></p><p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成，栈帧对应着每次方法调用所占内存</p><p>2.<strong>上下文切换</strong></p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p><blockquote><p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p></blockquote><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p><h2 id="2-4、start与run"><a href="#2-4、start与run" class="headerlink" title="2.4、start与run"></a>2.4、start与run</h2><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul><h2 id="2-5、sleep-与-yield"><a href="#2-5、sleep-与-yield" class="headerlink" title="2.5、sleep 与 yield"></a>2.5、sleep 与 yield</h2><p>1.<strong>sleep</strong></p><ul><li><ol><li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li></ol></li><li><ol start="2"><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li></ol></li><li><ol start="3"><li>睡眠结束后的线程未必会立刻得到执行</li></ol></li></ul><p>2.<strong>yield</strong></p><ul><li><ol><li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li></ol></li><li><ol start="2"><li>具体的实现依赖于操作系统的任务调度器</li></ol></li></ul><h2 id="2-6、join"><a href="#2-6、join" class="headerlink" title="2.6、join"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// t1.join();</span></span><br><span class="line">    log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果不加t1.join()结果为0，加上以后结果为1</p></blockquote><h2 id="2-7、interrupt"><a href="#2-7、interrupt" class="headerlink" title="2.7、interrupt"></a>2.7、interrupt</h2><p>interrupt虽然是打断线程的方法，但不会立即结束线程运行，而是将线程的打断状态设置为true，在线程的isInterrupted方法来查看打断状态。</p><h3 id="2-7-1、打断阻塞状态的线程"><a href="#2-7-1、打断阻塞状态的线程" class="headerlink" title="2.7.1、打断阻塞状态的线程"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，当使用interrupt()方法去打断处于阻塞状态的线程时，会以异常的方式打印，而不会更新打断标记，因此，虽然被打断，但是打断标记依然为false。此时就需要在try catch异常捕获处再次调用interrupt()方法，就会使打断状态为true，优雅结束线程运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">     at java.lang.Thread.sleep(Native Method)</span><br><span class="line">     at java.lang.Thread.sleep(Thread.java:<span class="number">340</span>)</span><br><span class="line">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class="number">8</span>)</span><br><span class="line">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class="number">3</span>(TestInterrupt.java:<span class="number">59</span>)</span><br><span class="line">     at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">18</span>:<span class="number">10.374</span> [main] c.TestInterrupt - 打断状态: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="2-7-2、打断正常运行的线程"><a href="#2-7-2、打断正常运行的线程" class="headerlink" title="2.7.2、打断正常运行的线程"></a>2.7.2、打断正常运行的线程</h3><p>当使用interrupt()方法去打断正在运行线程时，被打断的线程会继续运行，但是该线程的打断标记会更新，更新为true，因此可以根据打断标记来作为判断条件使得线程停止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">57</span>:<span class="number">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class="literal">true</span> </span><br></pre></td></tr></table></figure><h3 id="2-7-3、除了interrupt外的别的方法（设置标志位）"><a href="#2-7-3、除了interrupt外的别的方法（设置标志位）" class="headerlink" title="2.7.3、除了interrupt外的别的方法（设置标志位）"></a>2.7.3、除了interrupt外的别的方法（设置标志位）</h3><p>设置标志位：设置标志位是用到了共享变量的方式，我们了解线程对于变量的操作都是操作的变量副本，而一旦使用volatile关键字修饰后，因为其可见性，变量变更始将终从主存中获取最新值,因此主线程修改变量对新线程可见，在判断共享变量为fasle时，手动抛出异常可中止该线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">/**共享变量**/</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">heartbeat</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="comment">/**判断标志是否为true**/</span></span><br><span class="line">            <span class="keyword">if</span> (heartbeat)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Throw <span class="keyword">new</span> <span class="title class_">RuntimeException</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="number">2.8</span>、主线程与守护线程</span><br><span class="line"></span><br><span class="line">默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </span><br><span class="line"></span><br><span class="line">例</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;daemon&quot;</span>);</span><br><span class="line"><span class="comment">// 设置该线程为守护线程</span></span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">08:<span class="number">26</span>:<span class="number">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class="line">08:<span class="number">26</span>:<span class="number">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class="line">08:<span class="number">26</span>:<span class="number">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><ul><li>垃圾回收器线程就是一种守护线程 </li><li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li></ul></blockquote><h2 id="2-9、线程状态"><a href="#2-9、线程状态" class="headerlink" title="2.9、线程状态"></a>2.9、线程状态</h2><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态:线程被创建，但还没有调用start()方法</td></tr><tr><td>RUNNABLE</td><td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td></tr><tr><td>BLOCKED</td><td>阻塞状态:表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td></tr><tr><td>TIMEWAITING</td><td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td></tr><tr><td>TERMINATED</td><td>终止状态:表示当前线程已经执行完毕</td></tr></tbody></table><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg" alt="线程状态"></p><h1 id="3、共享模型之管程"><a href="#3、共享模型之管程" class="headerlink" title="3、共享模型之管程"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p><h2 id="3-1、monitor"><a href="#3-1、monitor" class="headerlink" title="3.1、monitor"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p><h3 id="3-1-1、Monitor结构"><a href="#3-1-1、Monitor结构" class="headerlink" title="3.1.1、Monitor结构"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg" alt="monitor结构"></p><h3 id="3-1-2、Monitor原理"><a href="#3-1-2、Monitor原理" class="headerlink" title="3.1.2、Monitor原理"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p><h2 id="3-2、java对象结构"><a href="#3-2、java对象结构" class="headerlink" title="3.2、java对象结构"></a>3.2、java对象结构</h2><p>1.对象头</p><p>包括：Mark Word（标记字段）、Class Pointer（类型指针，它主要指向类的数据，也就是指向方法区中的位置）,数组长度（如果是数组）</p><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg" alt="markdown"></p><ol start="2"><li><strong>实例数据</strong></li></ol><p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p><ol start="3"><li><strong>对齐填充</strong></li></ol><p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p><h2 id="3-3、synchronized"><a href="#3-3、synchronized" class="headerlink" title="3.3、synchronized"></a>3.3、synchronized</h2><h3 id="3-3-1、synchronized锁升级"><a href="#3-3-1、synchronized锁升级" class="headerlink" title="3.3.1、synchronized锁升级"></a>3.3.1、synchronized锁升级</h3><h4 id="3-3-1-1、偏向锁"><a href="#3-3-1-1、偏向锁" class="headerlink" title="3.3.1.1、偏向锁"></a>3.3.1.1、偏向锁</h4><blockquote><p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p></blockquote><p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p><h4 id="3-3-1-2、轻量级锁"><a href="#3-3-1-2、轻量级锁" class="headerlink" title="3.3.1.2、轻量级锁"></a>3.3.1.2、轻量级锁</h4><blockquote><p>使用场景：有时候会存在多个线程访问同步代码的情况，但每个线程执行的时间很短，这时候没必要阻塞等待，通过自旋来等待</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg" alt="轻量级锁"></p><p>（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间 （注意：是每次都会建，即使是重入），用于存储旧的Mark Word的拷贝，官方称其为Displaced Mark Word。(锁记录解锁的时候会用到)</p><p>（2）虚拟机将使用CAS操作尝试将对象的Mark Word更新为轻量级锁的标志位和指向锁记录（Lock Record）的指针。</p><p>（3）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁。</p><p>（4）如果这个更新操作失败了，虚拟机首先会检查当前线程是否已经拥有了这个对象的锁，如果已经拥有，那就可以直接进入同步块继续执行（重入）。否则就说明这个锁度已经被其他线程抢占了。一旦发生这种情况，那么轻量级锁就会膨胀为重量级锁。Mark Word中存储的就会指向重量级锁的指针，后面等待锁的线程也会进入阻塞状态。</p><blockquote><p>轻量级锁解锁流程如下（基于使用lock record重入计数的情况）：<br> 遍历栈的Lock Record，如果_displaced_header(存储markword的拷贝) 为 NULL，表明锁是可重入的，跳过不作处理<br> 如果_displaced_header 不为 NULL，即最后一个锁记录，调用 CAS恢复锁对象头的Markword，并恢复为无锁状态，解锁成功</p></blockquote><h4 id="3-3-1-3、重量级锁"><a href="#3-3-1-3、重量级锁" class="headerlink" title="3.3.1.3、重量级锁"></a>3.3.1.3、重量级锁</h4><blockquote><p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p></blockquote><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg" alt="重量级锁"></p><p>在Java中，每个对象都有一个监视器锁（monitor）。当一个线程想要访问一个被synchronized修饰的方法或代码块时，它会尝试获取这个对象的监视器锁。如果这个锁没有被其他线程占用，那么这个线程就可以获取这个锁，并执行synchronized修饰的方法或代码块。如果这个锁已经被其他线程占用，那么这个线程就会进入阻塞状态（waitset，entrylist），直到它能够获取这个锁为止</p><h3 id="3-3-2、synchronized使用"><a href="#3-3-2、synchronized使用" class="headerlink" title="3.3.2、synchronized使用"></a>3.3.2、synchronized使用</h3><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202312211615519.png" alt="image.png|725"></p><h2 id="3-4、wait-notify"><a href="#3-4、wait-notify" class="headerlink" title="3.4、wait&#x2F;notify"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p><h3 id="3-4-1、sleep和wait的区别？"><a href="#3-4-1、sleep和wait的区别？" class="headerlink" title="3.4.1、sleep和wait的区别？"></a>3.4.1、sleep和wait的区别？</h3><ol><li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li><li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li></ol><blockquote><p>wait()为什么只能在同步方法中调用？因为wait操作的是monitor</p></blockquote><h2 id="3-5、park-unpark"><a href="#3-5、park-unpark" class="headerlink" title="3.5、park&#x2F;unpark"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park(); </span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure><h3 id="3-5-1、与-Object-的-wait-notify-相比"><a href="#3-5-1、与-Object-的-wait-notify-相比" class="headerlink" title="3.5.1、与 Object 的 wait &amp; notify 相比"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li></ul><h3 id="3-5-2、原理"><a href="#3-5-2、原理" class="headerlink" title="3.5.2、原理"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p><p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p><h2 id="3-6、死锁"><a href="#3-6、死锁" class="headerlink" title="3.6、死锁"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p><h3 id="3-6-1、死锁的必要条件"><a href="#3-6-1、死锁的必要条件" class="headerlink" title="3.6.1、死锁的必要条件"></a>3.6.1、死锁的必要条件</h3><ol><li>互斥条件：一个资源一次只能被一个进程使用</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li><li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li><li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li></ol><h3 id="3-6-2、死锁的实现"><a href="#3-6-2、死锁的实现" class="headerlink" title="3.6.2、死锁的实现"></a>3.6.2、死锁的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现一个死锁</span></span><br><span class="line"><span class="comment"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">//开启一个新线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock(owner, target);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        lock(target, owner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(Object owner, Object target)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (owner) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-3、定位死锁"><a href="#3-6-3、定位死锁" class="headerlink" title="3.6.3、定位死锁"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p><h3 id="3-6-4、哲学家就餐问题"><a href="#3-6-4、哲学家就餐问题" class="headerlink" title="3.6.4、哲学家就餐问题"></a>3.6.4、哲学家就餐问题</h3><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg" alt="哲学家就餐问题"></p><p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p><ol><li>筷子类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>哲学家类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    <span class="comment">// 吃饭</span></span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 放下右手筷子</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放下左手筷子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>就餐</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"><span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure><h2 id="3-7、活锁"><a href="#3-7、活锁" class="headerlink" title="3.7、活锁"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p><blockquote><p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p></blockquote><h1 id="4、共享模型之内存"><a href="#4、共享模型之内存" class="headerlink" title="4、共享模型之内存"></a>4、共享模型之内存</h1><h2 id="4-1、java内存模型（jmm）"><a href="#4-1、java内存模型（jmm）" class="headerlink" title="4.1、java内存模型（jmm）"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p><h2 id="4-2、线程安全性的三个体现"><a href="#4-2、线程安全性的三个体现" class="headerlink" title="4.2、线程安全性的三个体现"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）</p><p><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）</p><blockquote><p>关联到cpu层面其实就是cpu的三级缓存和主内存，一个线程在读取数据时，先从本地内存查询，如果没有，再从主存中查，然后复制到本地内存进行操作，操作完后，会将修改后的数据刷新回主内存。因为现在cpu都是多核的，所以存在多个线程同时操作一个共享变量，但是本地内存中的修改对于其它线程是不可见的</p></blockquote><p><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行,cpu为了提升执行效率，会进行执行重排 （happens-before原则,volatile）</p><h1 id="5、共享模型之无锁"><a href="#5、共享模型之无锁" class="headerlink" title="5、共享模型之无锁"></a>5、共享模型之无锁</h1><h2 id="5-1、CAS"><a href="#5-1、CAS" class="headerlink" title="5.1、CAS"></a>5.1、CAS</h2><h3 id="5-1-1、CAS基本概念"><a href="#5-1-1、CAS基本概念" class="headerlink" title="5.1.1、CAS基本概念"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p><blockquote><ol><li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li><li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li></ol></blockquote><h3 id="5-1-2、CAS问题"><a href="#5-1-2、CAS问题" class="headerlink" title="5.1.2、CAS问题"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p><p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p><h2 id="5-2、volatile"><a href="#5-2、volatile" class="headerlink" title="5.2、volatile"></a>5.2、volatile</h2><h3 id="5-2-1、如何保证可见性和有序性"><a href="#5-2-1、如何保证可见性和有序性" class="headerlink" title="5.2.1、如何保证可见性和有序性"></a>5.2.1、如何保证可见性和有序性</h3><ol><li><strong>保证可见性（缓存一致性协议MESI）</strong></li></ol><p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p><blockquote><p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p></blockquote><blockquote><p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p></blockquote><ol start="2"><li><strong>保证有序性（禁止指令重排优化）</strong></li></ol><p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p><h2 id="5-3、原子类"><a href="#5-3、原子类" class="headerlink" title="5.3、原子类"></a>5.3、原子类</h2><table><thead><tr><th>类型</th><th>具体类</th></tr></thead><tbody><tr><td>Atomic 基本类型原子类</td><td>AtomicInteger AtomicLong AtomicBoolean</td></tr><tr><td>AtomicArray 数组类型原子类</td><td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td></tr><tr><td>AtomicReference 引用类型原子类</td><td>AtomicReference AtomicStampedReference AtomicMarkableReference</td></tr><tr><td>AtomicFieldUpdate 升级类型原子类</td><td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td></tr></tbody></table><h1 id="6、共享模式之工具"><a href="#6、共享模式之工具" class="headerlink" title="6、共享模式之工具"></a>6、共享模式之工具</h1><h2 id="6-1、线程池"><a href="#6-1、线程池" class="headerlink" title="6.1、线程池"></a>6.1、线程池</h2><ol><li>线程池可以有效地管理线程：它可以管理线程的数量,做到线程的服用，可以避免无节制的创建线程,导致超出系统负荷直至崩溃</li><li>构造方法的重要参数：corePoolSize（核心线程数）、workQueue（等待队列）、maxinumPoolSize（最大线程数）、handler（拒绝策略）、keepAliveTime（空闲线程存活时间）</li></ol><h3 id="6-1-1、ThreadPoolExecutor"><a href="#6-1-1、ThreadPoolExecutor" class="headerlink" title="6.1.1、ThreadPoolExecutor"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol><li><strong>构造方法</strong></li></ol><p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p><blockquote><ol><li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li><li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li><li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li><li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li><li>workQueue：缓存队列，用来存放等待被执行的任务。</li><li>threadFactory 线程工厂</li><li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li></ol></blockquote><ol start="2"><li><strong>工作原理</strong></li></ol><p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p><h3 id="6-1-2、Executors类中提供的工厂方法"><a href="#6-1-2、Executors类中提供的工厂方法" class="headerlink" title="6.1.2、Executors类中提供的工厂方法"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p><ol><li><strong>newFixedThreadPool</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特点：</p><ul><li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li><li>阻塞队列是无界的，可以放任意数量的任务</li></ul></blockquote><p>评价：</p><blockquote><p>适用于任务量已知，相对耗时的任务</p></blockquote><ol start="2"><li><strong>newCachedThreadPool</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>特点 </p><ul><li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul><li>全部都是救急线程（60s 后可以回收）</li><li>救急线程可以无限创建</li></ul></li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li></ul></blockquote><p>评价：</p><blockquote><p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p></blockquote><ol start="3"><li>newSingleThreadExecutor</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。 </p><h3 id="6-1-3、创建多大的线程池"><a href="#6-1-3、创建多大的线程池" class="headerlink" title="6.1.3、创建多大的线程池"></a>6.1.3、创建多大的线程池</h3><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li><li>过大会导致更多的线程上下文切换，影响性能</li></ul><ol><li>**CPU 密集型运算 **</li></ol><p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p><ol start="2"><li><strong>I&#x2F;O密集型</strong></li></ol><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p><h3 id="6-1-4、线程池状态"><a href="#6-1-4、线程池状态" class="headerlink" title="6.1.4、线程池状态"></a>6.1.4、线程池状态</h3><ol><li>RUNNING状态：线程池创建后，初始状态为RUNNING。</li><li>SHUTDOWN状态：当调用线程池的shutdown()方法时，线程池进入SHUTDOWN状态。此时线程池不再接受新的任务，但会执行已经提交的任务。当所有任务都执行完毕后，线程池会转换到TIDYING状态。</li><li>STOP状态：当调用线程池的shutdownNow()方法时，线程池进入STOP状态。此时线程池不再接受新的任务，并且会中断正在执行的任务。当所有任务都执行完毕后，线程池会转换到TIDYING状态。</li><li>TIDYING状态：当线程池处于SHUTDOWN或STOP状态时，所有任务都执行完毕后，线程池会进入TIDYING状态。在此状态下，线程池会进行清理工作，如关闭线程池中的所有线程等。当清理工作完成后，线程池会转换到TERMINATED状态。</li><li>TERMINATED状态：线程池处于TERMINATED状态时，表示线程池已经完全终止，所有任务已经执行完毕并且清理工作也已经完成。此时线程池不再能接受新的任务。</li></ol><h2 id="6-2、锁"><a href="#6-2、锁" class="headerlink" title="6.2、锁"></a>6.2、锁</h2><h3 id="6-2-1、AQS"><a href="#6-2-1、AQS" class="headerlink" title="6.2.1、AQS"></a>6.2.1、AQS</h3><ol><li>基本概念</li></ol><p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p><ol start="2"><li>原理</li></ol><p>它维护了一个volatile int state（代表共享资源）和一个FIFO双向队列（CLH队列，多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到等待队列（entrylist）中。如果调用了锁对象的<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）<br>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了</p><ol start="3"><li>实现</li></ol><p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p><blockquote><p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p></blockquote><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p><h3 id="6-2-2、ReentrantLock"><a href="#6-2-2、ReentrantLock" class="headerlink" title="6.2.2、ReentrantLock"></a>6.2.2、ReentrantLock</h3><p>相对于 synchronized 它具备如下特点 </p><ol><li>可中断 </li><li>可以设置超时时间 </li><li>可以设置为公平锁 （默认不公平）</li><li>支持多个条件变量</li></ol><p>与 synchronized 一样，都支持可重入 </p><p><strong>实现原理</strong></p><ol><li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li><li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li><li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li><li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li></ol><p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p><h3 id="6-2-3、ReentrantReadWriteLock"><a href="#6-2-3、ReentrantReadWriteLock" class="headerlink" title="6.2.3、ReentrantReadWriteLock"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id="4-2-3-1、ReentrantReadWriteLock基本概念"><a href="#4-2-3-1、ReentrantReadWriteLock基本概念" class="headerlink" title="4.2.3.1、ReentrantReadWriteLock基本概念"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p><p>ReadWriteLock也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个资源可以被多个线程同时读，或者被一个线程写，但是不能同时存在读和写线程。<br>读锁：共享锁 readLock<br>写锁：独占锁 writeLock<br>读写锁 ： 一个资源可以被多个读的线程进行访问 ，或者可以被一个写的线程访问，但是不能同时存在读和写进程 ，读写互斥，读读共享。</p><h4 id="4-2-3-2、锁获取过程"><a href="#4-2-3-2、锁获取过程" class="headerlink" title="4.2.3.2、锁获取过程"></a>4.2.3.2、锁获取过程</h4><ol><li>获取读锁</li></ol><p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直到获取读锁为止。</p><ol start="4"><li>获取写入锁</li></ol><p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p><h4 id="4-2-3-3、常见问题"><a href="#4-2-3-3、常见问题" class="headerlink" title="4.2.3.3、常见问题"></a>4.2.3.3、常见问题</h4><ol><li><strong>读锁和写锁的可重入性</strong></li></ol><p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p><ol start="2"><li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li></ol><p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p><ol start="3"><li><strong>锁降级是怎么降级的？</strong></li></ol><p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p><h3 id="6-2-4、锁分类"><a href="#6-2-4、锁分类" class="headerlink" title="6.2.4、锁分类"></a>6.2.4、锁分类</h3><ol><li><strong>可重入锁和不可重入锁</strong></li></ol><p>Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是可重入<br>重入：当前线程获取到A锁，在获取之后尝试再次获取A锁是可以直接拿到的。<br>不可重入：当前线程获取到A锁，在获取之后尝试再次获取A锁，无法获取到的，因为A锁被当前线程占用着，需要等待自己释放锁再获取锁</p><ol start="2"><li><strong>乐观锁和悲观锁</strong></li></ol><p>Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是悲观锁<br>Java中提供的CAS操作，就是乐观锁的一种实现<br>悲观锁：获取不到锁资源时，会将当前线程挂起 (进入BLOCKED、WAITING)，线程挂起会涉及到用户态和内核态的切换，而这种切换是比较消耗资源的。<br>乐观锁：获取不到锁，再让CPU调度，重新尝试获取锁资源。Automic原子类中，就是基于CAS乐观锁实现的</p><ol start="3"><li><strong>公平锁和非公平锁</strong></li></ol><p>synchronized是非公平锁<br>ReentrantLock和ReentrantReadWriteLock可以实现公平锁和非公平锁</p><ol start="4"><li><strong>互斥锁和共享锁</strong></li></ol><p>Synchronized，ReentrantLock是互斥锁<br>ReentrantReadWriteLock有互斥锁也有共享锁（写互斥读共享）<br>互斥锁：同一时间，只有一个线程持有当前互斥锁<br>共享锁：同一时间点，多个线程可以共同持有</p><h2 id="6-3、工具"><a href="#6-3、工具" class="headerlink" title="6.3、工具"></a>6.3、工具</h2><h3 id="6-3-1、Semaphore"><a href="#6-3-1、Semaphore" class="headerlink" title="6.3.1、Semaphore"></a>6.3.1、Semaphore</h3><ol><li><strong>概念</strong></li></ol><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourcePool</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用到了信号量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataSourcePool</span><span class="params">(<span class="type">int</span> size)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            list.add(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用同步方法获取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">return</span> list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">close</span><span class="params">(Connection connection)</span>&#123;</span><br><span class="line">        <span class="comment">//信号量+1</span></span><br><span class="line">        semaphore.release();</span><br><span class="line">        list.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>原理</strong></li></ol><p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p><p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p><h3 id="6-3-2、CountdownLatch"><a href="#6-3-2、CountdownLatch" class="headerlink" title="6.3.2、CountdownLatch"></a>6.3.2、CountdownLatch</h3><ol><li><strong>概念</strong></li></ol><p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    service.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">4</span>] - waiting... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">26.835</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - end..<span class="number">.2</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.335</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - end..<span class="number">.1</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.835</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - end..<span class="number">.0</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.835</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">4</span>] - wait end...</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>原理</strong></li></ol><p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p><ol start="3"><li><strong>和join的区别？</strong></li></ol><p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p><h3 id="6-3-3、CyclicBarrier"><a href="#6-3-3、CyclicBarrier" class="headerlink" title="6.3.3、CyclicBarrier"></a>6.3.3、CyclicBarrier</h3><ol><li><strong>概念</strong></li></ol><p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(count, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;全部加载完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; count; x++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Worker</span>(cb));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已加载完&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span> 已加载完</span><br><span class="line">全部加载完毕</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>原理</strong></li></ol><p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p><h2 id="6-4、线程安全集合类"><a href="#6-4、线程安全集合类" class="headerlink" title="6.4、线程安全集合类"></a>6.4、线程安全集合类</h2><h3 id="6-4-1、概述"><a href="#6-4-1、概述" class="headerlink" title="6.4.1、概述"></a>6.4.1、概述</h3><p>线程安全实现类有三类：</p><ol><li>遗留的线程安全集合如 Hashtable ， Vector </li><li>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</li></ol><blockquote><ul><li>Collections.synchronizedCollection </li><li>Collections.synchronizedList </li><li>Collections.synchronizedMap </li><li>Collections.synchronizedSet </li><li>Collections.synchronizedNavigableMap </li><li>Collections.synchronizedNavigableSet</li><li>Collections.synchronizedSortedMap </li><li>Collections.synchronizedSortedSet</li></ul></blockquote><ol start="4"><li>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent</li></ol><blockquote><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li><li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li><li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul><li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li><li>弱一致性 <ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li><li>求大小弱一致性，size 操作未必是 100% 准确 </li><li>读取弱一致性</li></ul></li></ul></li></ul></blockquote><blockquote><p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p></blockquote><h3 id="6-4-2、concurrentHashMap"><a href="#6-4-2、concurrentHashMap" class="headerlink" title="6.4.2、concurrentHashMap"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p><p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p><p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p><blockquote><p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p></blockquote><p><strong>JDK1.8</strong></p><p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p><ol><li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li><li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li><li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li><li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li></ol><h3 id="6-4-3、BlockingQueue"><a href="#6-4-3、BlockingQueue" class="headerlink" title="6.4.3、BlockingQueue"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p><ol><li>区别</li></ol><p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；LinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p><h3 id="6-4-4、ConcurrentLinkedQueue"><a href="#6-4-4、ConcurrentLinkedQueue" class="headerlink" title="6.4.4、ConcurrentLinkedQueue"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p><h3 id="6-4-5、CopyOnWriteArrayList"><a href="#6-4-5、CopyOnWriteArrayList" class="headerlink" title="6.4.5、CopyOnWriteArrayList"></a>6.4.5、CopyOnWriteArrayList</h3><ol><li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li><li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li><li>写操作结束后会把原数组指向新数组</li><li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li></ol>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx</title>
      <link href="/posts/58122.html"/>
      <url>/posts/58122.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、nginx简介"><a href="#1、nginx简介" class="headerlink" title="1、nginx简介"></a>1、nginx简介</h1><h2 id="1-1、nginx概述"><a href="#1-1、nginx概述" class="headerlink" title="1.1、nginx概述"></a>1.1、nginx概述</h2><p>Nginx (“engine x”) 是一个高性能的 HTTP 和 反向代理服务器，特点是占有内存少，并发能力强，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数 。</p><h2 id="1-2、正向代理"><a href="#1-2、正向代理" class="headerlink" title="1.2、正向代理"></a>1.2、正向代理</h2><p>nginx不仅能做反向代理，实现负载均衡，还能用作正向代理来进行上网等功能<br>正向代理：个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理【<strong>代理客户端，服务端不知道实际发起请求的客户端</strong>】</p><blockquote><p>例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替A向C借钱，A就得到了C的钱，C并不知道A的存在，B就充当了A的代理人的角色</p></blockquote><h2 id="1-3、反向代理"><a href="#1-3、反向代理" class="headerlink" title="1.3、反向代理"></a>1.3、反向代理</h2><p>反向代理，以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器【<strong>代理服务端，客户端不知道实际提供服务的服务端</strong>】</p><blockquote><p>例子：A向B借钱，B没有拿自己的钱，而是悄悄地向C借钱，拿到钱之后再交给A,A以为是B的钱，他并不知道C的存在</p></blockquote><h2 id="1-4、负载均衡"><a href="#1-4、负载均衡" class="headerlink" title="1.4、负载均衡"></a>1.4、负载均衡</h2><p>增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡 </p><h2 id="1-5、动静分离"><a href="#1-5、动静分离" class="headerlink" title="1.5、动静分离"></a>1.5、动静分离</h2><p>为了加快网站的解析速度，可以把 动态页面 和 静态页面 由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力</p><blockquote><p>静态资源请求（如html、css、图片等）由静态资源服务器处理，动态资源请求（如 jsp页面、servlet程序等）由 tomcat 服务器处理，tomcat 本身是用来处理动态资源的，同时 tomcat 也能处理静态资源，<strong>但是 tomcat 本身处理静态资源的效率并不高</strong>，而且还会带来额外的资源开销。利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由静态资源服务器处理，从而提升整个服务系统的性能 </p></blockquote><h1 id="2、nginx安装"><a href="#2、nginx安装" class="headerlink" title="2、nginx安装"></a>2、nginx安装</h1><ol><li><strong>安装pcre依赖</strong></li></ol><p>（1）联网下载 pcre 压缩文件依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure><p>（2）解压压缩文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar –xvf pcre-8.37.tar.gz</span><br></pre></td></tr></table></figure><p>（3）编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>（4）查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pcre-config --version</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>安装安装 openssl 、zlib 、 gcc 依赖</strong></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>安装nginx</strong></li></ol><p>（1）解压</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf nginx-1.12.2.tar.gz</span><br></pre></td></tr></table></figure><p>（2）进入解压后目录，执行config命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>（3）编译</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>（4）启动nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入进入目录 /usr/local/nginx/sbin/nginx</span></span><br><span class="line">./nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止</span></span><br><span class="line">./nginx -s stop</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">./nginx -s reload</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3、nginx配置文件"><a href="#3、nginx配置文件" class="headerlink" title="3、nginx配置文件"></a>3、nginx配置文件</h1><p>Nginx配置文件分为三大块：全局块，events块，http块</p><ol><li>从配置文件开始到events块开始之前的内容，都属于全局块。在全局块中配置的都是影响Nginx整体运行的配置。比如说：worker(工作进程)的数量，错误日志的位置等</li><li>events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个 workderprocess进程⽀持的最⼤连接数为1024</li><li>http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡 等</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">================ 全局快 ==================<span class="comment">#</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">定义Nginx运行的用户和用户组</span></span><br><span class="line">user  nginx;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">工作进程数，一般配置成和CPU数一样</span></span><br><span class="line">worker_processes  auto;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class="line">error_log  /var/log/nginx/error.log notice;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进程pid文件</span></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">=============== events块 ================<span class="comment">#</span></span></span><br><span class="line">events &#123;</span><br><span class="line">    # 标识单个woker进程最大并发数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">=============== http块 =================<span class="comment">#</span></span></span><br><span class="line">http &#123;</span><br><span class="line">    #文件扩展名与文件类型映射表</span><br><span class="line">    include       /etc/nginx/mime.types;</span><br><span class="line">    #默认文件类型</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    #日志格式设定</span><br><span class="line">    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span><br><span class="line">                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span><br><span class="line">                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;</span><br><span class="line">    #定义本虚拟主机的访问日志</span><br><span class="line">    access_log  /var/log/nginx/access.log  main;</span><br><span class="line">     #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载</span><br><span class="line">    sendfile        on;</span><br><span class="line">    #长连接超时时间，单位是秒</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    #包括多个server块，而每个server块就相当于一个虚拟主机</span><br><span class="line">    server &#123;</span><br><span class="line">          listen       80;</span><br><span class="line">          server_name  localhost;</span><br><span class="line">          # 对特定地址进行处理，地址定向</span><br><span class="line">          location / &#123;</span><br><span class="line">              root   html;</span><br><span class="line">              index  index.html index.htm;</span><br><span class="line">          &#125;</span><br><span class="line">  </span><br><span class="line">          error_page   500 502 503 504  /50x.html;</span><br><span class="line">          location = /50x.html &#123;</span><br><span class="line">              root   html;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4、反向代理实现"><a href="#4、反向代理实现" class="headerlink" title="4、反向代理实现"></a>4、反向代理实现</h1><p>实现效果：输入 <a href="http://www.test.com/">http://www.test.com</a>, 自动跳转到百度首页</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">         listen          80;</span><br><span class="line">         server_name     www.test.com;  #你的域名</span><br><span class="line">         location / &#123;</span><br><span class="line">               proxy_pass          http://www.baidu.com/;  #需要反代的域名</span><br><span class="line">               proxy_redirect      off;</span><br><span class="line">               proxy_set_header    X-Real-IP      $remote_addr;</span><br><span class="line">               proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5、正向代理实现"><a href="#5、正向代理实现" class="headerlink" title="5、正向代理实现"></a>5、正向代理实现</h1><p>场景1：从本地无法直接调用第三方接口，因为本地ip不在白名单中的问题<br>场景2：内网机器访问外网，就需要正向代理，类似VPN</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen 8090;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    # resolver后面填写dns地址，可以多个，将以轮询方式请求</span><br><span class="line">resolver 218.85.157.99 218.85.152.99;</span><br><span class="line">    # resolver_timeout 解析超时时间</span><br><span class="line">resolver_timeout 30s;</span><br><span class="line">    # 代理服务器地址（即要请求的地址）</span><br><span class="line">proxy_pass http://$host$request_uri;</span><br><span class="line">&#125;</span><br><span class="line">access_log /data/httplogs/proxy-$host-aceess.log;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="6、负载均衡实现"><a href="#6、负载均衡实现" class="headerlink" title="6、负载均衡实现"></a>6、负载均衡实现</h1><h2 id="6-1、轮询（默认）"><a href="#6-1、轮询（默认）" class="headerlink" title="6.1、轮询（默认）"></a>6.1、轮询（默认）</h2><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    upstream webservers&#123;</span><br><span class="line">      # weight 多台机器，可以配置权重值，权重高的服务将会优先被访问</span><br><span class="line">      server  192.168.9.134:8081;</span><br><span class="line">      server  192.168.9.134:8082;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">             #转发到负载服务上</span><br><span class="line">            proxy_pass http://webservers/api/;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2、weight"><a href="#6-2、weight" class="headerlink" title="6.2、weight"></a>6.2、weight</h2><p>weight 代表权重默认为 1,权重越高被分配的客户端越多。指定轮询几率，weight权重大小和访问比率成正比。用于后端服务器性能不均衡的情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">upstream webservers&#123;</span><br><span class="line">  server  192.168.9.134:8081 weight=8;</span><br><span class="line">  server  192.168.9.134:8082 weight=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3、ip-hash"><a href="#6-3、ip-hash" class="headerlink" title="6.3、ip_hash"></a>6.3、ip_hash</h2><p>每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器</p><blockquote><p>使用nginx+ip_hash这种策略代理，很好解决了同一用户访问同一个应用，session不共享的问题,实现session共享的问题</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream webservers&#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server  192.168.9.134:8081;</span><br><span class="line">  server  192.168.9.134:8082;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4、fair"><a href="#6-4、fair" class="headerlink" title="6.4、fair"></a>6.4、fair</h2><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream webservers&#123;</span><br><span class="line">        server 192.168.9.134:8081;</span><br><span class="line">        server 192.168.9.134:8082;</span><br><span class="line">        fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5、url-hash"><a href="#6-5、url-hash" class="headerlink" title="6.5、url_hash"></a>6.5、url_hash</h2><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p><blockquote><p>相同的url会被分配到同一个节点，主要为了提高缓存命中率</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream webservers&#123;</span><br><span class="line">    hash &amp;request_uri;</span><br><span class="line">    server 192.168.9.134:8081;</span><br><span class="line">    server 192.168.9.134:8082;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-6、least-conn"><a href="#6-6、least-conn" class="headerlink" title="6.6、least_conn"></a>6.6、least_conn</h2><p>按节点连接数分配，把请求优先分配给连接数少的节点。该策略主要为了解决，各个节点请求处理时间长短不一造成某些节点超负荷的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream webservers&#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.9.134:8081;</span><br><span class="line">    server 192.168.9.134:8082;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7、动静分离"><a href="#7、动静分离" class="headerlink" title="7、动静分离"></a>7、动静分离</h1><p>利用 nginx 实现动静分离的架构，能够让 tomcat 专注于处理动态资源，静态资源统一由nginx处理，从而提升整个服务系统的性能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有js,css相关的静态资源文件的请求由Nginx处理</span></span><br><span class="line">location ~.*\.(js|css)$ &#123;</span><br><span class="line">    root    /opt/static-resources; #指定文件路径</span><br><span class="line">    expires     12h; #过期时间为12小时</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有图片等多媒体相关静态资源文件的请求由Nginx处理</span></span><br><span class="line">location ~.*\.(html|jpg|jpeg|png|bmp|gif|ico|mp3|mid|wma|mp4|swf|flv|rar|zip|txt|doc|ppt|xls|pdf)$ &#123;</span><br><span class="line">    root    /opt/static-resources; #指定文件路径</span><br><span class="line">    expires     7d; #过期时间为7天</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> coding </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
