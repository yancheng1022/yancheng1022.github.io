<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>juc | 去码头整些薯条</title><meta name="author" content="Guo Yancheng"><meta name="copyright" content="Guo Yancheng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="referrer" content="no-referrer"><meta name="description" content="1、java多线程基本概念1.1、进程和线程 进程   程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的  当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。  进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、">
<meta property="og:type" content="article">
<meta property="og:title" content="juc">
<meta property="og:url" content="https://www.guoyancheng.top/posts/42310.html">
<meta property="og:site_name" content="去码头整些薯条">
<meta property="og:description" content="1、java多线程基本概念1.1、进程和线程 进程   程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的  当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。  进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.guoyancheng.top/img/avatar.jpg">
<meta property="article:published_time" content="2022-07-14T16:00:00.000Z">
<meta property="article:modified_time" content="2025-01-07T07:39:25.713Z">
<meta property="article:author" content="Guo Yancheng">
<meta property="article:tag" content="juc">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="编程基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.guoyancheng.top/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.guoyancheng.top/posts/42310.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><meta name="baidu-site-verification" content="&lt;meta name=&quot;baidu-site-verification&quot; content=&quot;codeva-w6PavDHB8h&quot; /&gt;"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'juc',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-07 15:39:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="去码头整些薯条"><span class="site-name">去码头整些薯条</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">juc</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-14T16:00:00.000Z" title="发表于 2022-07-15 00:00:00">2022-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-07T07:39:25.713Z" title="更新于 2025-01-07 15:39:25">2025-01-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/coding/">coding</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span></div></div></div><article class="post-content" id="article-container"><h1 id="1、java多线程基本概念"><a href="#1、java多线程基本概念" class="headerlink" title="1、java多线程基本概念"></a>1、java多线程基本概念</h1><h2 id="1-1、进程和线程"><a href="#1-1、进程和线程" class="headerlink" title="1.1、进程和线程"></a>1.1、进程和线程</h2><ol>
<li><strong>进程</strong></li>
</ol>
<ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 </li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 </li>
<li>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>
</ul>
<ol start="2">
<li><strong>线程</strong></li>
</ol>
<ul>
<li>一个进程之内可以分为一到多个线程。 </li>
<li>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 </li>
<li><strong>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</strong></li>
</ul>
<h2 id="1-2、并发和并行"><a href="#1-2、并发和并行" class="headerlink" title="1.2、并发和并行"></a>1.2、并发和并行</h2><p>并发：线程轮流使用CPU<br>并行：多核cpu下，多个核同时调度运行线程</p>
<h2 id="1-3、多线程的应用"><a href="#1-3、多线程的应用" class="headerlink" title="1.3、多线程的应用"></a>1.3、多线程的应用</h2><h3 id="1-3-1、异步调用"><a href="#1-3-1、异步调用" class="headerlink" title="1.3.1、异步调用"></a>1.3.1、异步调用</h3><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程 </p>
<h3 id="1-3-2、提升效率"><a href="#1-3-2、提升效率" class="headerlink" title="1.3.2、提升效率"></a>1.3.2、提升效率</h3><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行 3 个计算，最后将计算结果汇总。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 <span class="number">1</span> 花费 <span class="number">10</span> ms</span><br><span class="line">计算 <span class="number">2</span> 花费 <span class="number">11</span> ms</span><br><span class="line">计算 <span class="number">3</span> 花费 <span class="number">9</span> ms</span><br><span class="line">汇总需要 <span class="number">1</span> ms</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 &#x3D; 31ms </li>
<li>但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 个 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms最后加上汇总时间只会花费 12ms</li>
</ul>
<blockquote>
<p>需要在多核 cpu 才能提高效率，单核仍然时是轮流执行</p>
</blockquote>
<h1 id="2、java线程"><a href="#2、java线程" class="headerlink" title="2、java线程"></a>2、java线程</h1><h2 id="2-1、线程的创建"><a href="#2-1、线程的创建" class="headerlink" title="2.1、线程的创建"></a>2.1、线程的创建</h2><h3 id="2-1-1、直接使用Thread"><a href="#2-1-1、直接使用Thread" class="headerlink" title="2.1.1、直接使用Thread"></a>2.1.1、直接使用Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2、使用-Runnable-配合-Thread"><a href="#2-1-2、使用-Runnable-配合-Thread" class="headerlink" title="2.1.2、使用 Runnable 配合 Thread"></a>2.1.2、使用 Runnable 配合 Thread</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 要执行的任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>( runnable );</span><br><span class="line"><span class="comment">// 启动线程</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>java8可用lambda精简</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3、FutureTask-配合-Thread"><a href="#2-1-3、FutureTask-配合-Thread" class="headerlink" title="2.1.3、FutureTask 配合 Thread"></a>2.1.3、FutureTask 配合 Thread</h3><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建任务对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task3 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1 是任务对象; 参数2 是线程名字，推荐</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task3, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task3.get();</span><br><span class="line">log.debug(<span class="string">&quot;结果是:&#123;&#125;&quot;</span>, result);</span><br></pre></td></tr></table></figure>
<h2 id="2-2、查看进程线程"><a href="#2-2、查看进程线程" class="headerlink" title="2.2、查看进程线程"></a>2.2、查看进程线程</h2><h3 id="2-2-1、windows"><a href="#2-2-1、windows" class="headerlink" title="2.2.1、windows"></a>2.2.1、windows</h3><p>1.tasklist 查看进程<br>2.taskkill 杀死进程<br>3.netstat -ano|findstr 8080 根据端口查看进程</p>
<h3 id="2-2-2、linux"><a href="#2-2-2、linux" class="headerlink" title="2.2.2、linux"></a>2.2.2、linux</h3><p>1.ps -fe 查看所有进程<br>2.kill 杀死进程<br>3.top -Hp PID 查看某个进程（PID）的所有线程<br>4.netstat -nlp|grep 8080 根据端口查看进程</p>
<h3 id="2-2-3、JDK"><a href="#2-2-3、JDK" class="headerlink" title="2.2.3、JDK"></a>2.2.3、JDK</h3><p>1.jps 命令查看所有 Java 进程<br>2.jstack PID 查看某个 Java 进程（PID）的所有线程状态<br>3.jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p>
<h2 id="2-3、线程运行原理"><a href="#2-3、线程运行原理" class="headerlink" title="2.3、线程运行原理"></a>2.3、线程运行原理</h2><p>1.<strong>线程创建</strong></p>
<p>每个线程启动后，虚拟机就会为其分配一块栈内存。 每个栈由多个栈帧（Frame）组成，栈帧对应着每次方法调用所占内存</p>
<p>2.<strong>上下文切换</strong></p>
<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 </p>
<blockquote>
<p>线程的 cpu 时间片用完<br>垃圾回收<br>有更高优先级的线程需要运行<br>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 </p>
</blockquote>
<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 </p>
<h2 id="2-4、start与run"><a href="#2-4、start与run" class="headerlink" title="2.4、start与run"></a>2.4、start与run</h2><ul>
<li>直接调用 run 是在主线程中执行了 run，没有启动新的线程 </li>
<li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li>
</ul>
<h2 id="2-5、sleep-与-yield"><a href="#2-5、sleep-与-yield" class="headerlink" title="2.5、sleep 与 yield"></a>2.5、sleep 与 yield</h2><p>1.<strong>sleep</strong></p>
<ul>
<li><ol>
<li>调用 sleep 会让当前线程从 _Running_进入 _Timed Waiting _状态（阻塞）</li>
</ol>
</li>
<li><ol start="2">
<li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li>
</ol>
</li>
<li><ol start="3">
<li>睡眠结束后的线程未必会立刻得到执行</li>
</ol>
</li>
</ul>
<p>2.<strong>yield</strong></p>
<ul>
<li><ol>
<li>调用 yield 会让当前线程从 _Running _进入 _Runnable_就绪状态，然后调度执行其它线程</li>
</ol>
</li>
<li><ol start="2">
<li>具体的实现依赖于操作系统的任务调度器</li>
</ol>
</li>
</ul>
<h2 id="2-6、join"><a href="#2-6、join" class="headerlink" title="2.6、join"></a>2.6、join</h2><p>join：t1调用t2的join方法，会先执行t2，然后执行t1<br>如果调用的是无参join方法，则等待thread执行完毕，如果调用的是指定了时间参数的join方法，则等待一定的时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;开始&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        r = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    t1.start();</span><br><span class="line">    <span class="comment">// t1.join();</span></span><br><span class="line">    log.debug(<span class="string">&quot;结果为:&#123;&#125;&quot;</span>, r);</span><br><span class="line">    log.debug(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果不加t1.join()结果为0，加上以后结果为1</p>
</blockquote>
<h2 id="2-7、interrupt"><a href="#2-7、interrupt" class="headerlink" title="2.7、interrupt"></a>2.7、interrupt</h2><p>interrupt虽然是打断线程的方法，但不会立即结束线程运行，而是将线程的打断状态设置为true，在线程的isInterrupted方法来查看打断状态。</p>
<h3 id="2-7-1、打断阻塞状态的线程"><a href="#2-7-1、打断阻塞状态的线程" class="headerlink" title="2.7.1、打断阻塞状态的线程"></a>2.7.1、打断阻塞状态的线程</h3><p>sleep，wait，join 的线程 这几个方法都会让线程进入阻塞状态 ，当使用interrupt()方法去打断处于阻塞状态的线程时，会以异常的方式打印，而不会更新打断标记，因此，虽然被打断，但是打断标记依然为false。此时就需要在try catch异常捕获处再次调用interrupt()方法，就会使打断状态为true，优雅结束线程运行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">     at java.lang.Thread.sleep(Native Method)</span><br><span class="line">     at java.lang.Thread.sleep(Thread.java:<span class="number">340</span>)</span><br><span class="line">     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:<span class="number">386</span>)</span><br><span class="line">     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:<span class="number">8</span>)</span><br><span class="line">     at cn.itcast.n4.TestInterrupt.lambda$test1$<span class="number">3</span>(TestInterrupt.java:<span class="number">59</span>)</span><br><span class="line">     at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br><span class="line"><span class="number">21</span>:<span class="number">18</span>:<span class="number">10.374</span> [main] c.TestInterrupt - 打断状态: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-2、打断正常运行的线程"><a href="#2-7-2、打断正常运行的线程" class="headerlink" title="2.7.2、打断正常运行的线程"></a>2.7.2、打断正常运行的线程</h3><p>当使用interrupt()方法去打断正在运行线程时，被打断的线程会继续运行，但是该线程的打断标记会更新，更新为true，因此可以根据打断标记来作为判断条件使得线程停止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> current.isInterrupted();</span><br><span class="line">            <span class="keyword">if</span>(interrupted) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, interrupted);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    t2.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">57</span>:<span class="number">37.964</span> [t2] c.TestInterrupt - 打断状态: <span class="literal">true</span> </span><br></pre></td></tr></table></figure>

<h3 id="2-7-3、除了interrupt外的别的方法（设置标志位）"><a href="#2-7-3、除了interrupt外的别的方法（设置标志位）" class="headerlink" title="2.7.3、除了interrupt外的别的方法（设置标志位）"></a>2.7.3、除了interrupt外的别的方法（设置标志位）</h3><p>设置标志位：设置标志位是用到了共享变量的方式，我们了解线程对于变量的操作都是操作的变量副本，而一旦使用volatile关键字修饰后，因为其可见性，变量变更始将终从主存中获取最新值,因此主线程修改变量对新线程可见，在判断共享变量为fasle时，手动抛出异常可中止该线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">/**共享变量**/</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">heartbeat</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">           <span class="comment">/**判断标志是否为true**/</span></span><br><span class="line">            <span class="keyword">if</span> (heartbeat)&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Throw <span class="keyword">new</span> <span class="title class_">RuntimeException</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="number">2.8</span>、主线程与守护线程</span><br><span class="line"></span><br><span class="line">默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 </span><br><span class="line"></span><br><span class="line">例</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;开始运行...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;daemon&quot;</span>);</span><br><span class="line"><span class="comment">// 设置该线程为守护线程</span></span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;运行结束...&quot;</span>);</span><br><span class="line"></span><br><span class="line">输出</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">08:<span class="number">26</span>:<span class="number">38.123</span> [main] c.TestDaemon - 开始运行... </span><br><span class="line">08:<span class="number">26</span>:<span class="number">38.213</span> [daemon] c.TestDaemon - 开始运行... </span><br><span class="line">08:<span class="number">26</span>:<span class="number">39.215</span> [main] c.TestDaemon - 运行结束...</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<ul>
<li>垃圾回收器线程就是一种守护线程 </li>
<li>Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求</li>
</ul>
</blockquote>
<h2 id="2-9、线程状态"><a href="#2-9、线程状态" class="headerlink" title="2.9、线程状态"></a>2.9、线程状态</h2><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>NEW</td>
<td>初始状态:线程被创建，但还没有调用start()方法</td>
</tr>
<tr>
<td>RUNNABLE</td>
<td>运行状态:Java线程将操作系统中的就绪和运行两种状态笼统的称作”运行”</td>
</tr>
<tr>
<td>BLOCKED</td>
<td>阻塞状态:表示线程阻塞于锁</td>
</tr>
<tr>
<td>WAITING</td>
<td>等待状态:表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</td>
</tr>
<tr>
<td>TIMEWAITING</td>
<td>超时等待状态:该状态不同于WAITIND，它是可以在指定的时间自行返回的</td>
</tr>
<tr>
<td>TERMINATED</td>
<td>终止状态:表示当前线程已经执行完毕</td>
</tr>
</tbody></table>
<p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930532.jpg" alt="线程状态"></p>
<h1 id="3、共享模型之管程"><a href="#3、共享模型之管程" class="headerlink" title="3、共享模型之管程"></a>3、共享模型之管程</h1><p>管程（monitor），管理共享变量以及对其的操作过程，让这个类是线程安全的</p>
<h2 id="3-1、monitor"><a href="#3-1、monitor" class="headerlink" title="3.1、monitor"></a>3.1、monitor</h2><p>Monitor 被翻译为<strong>监视器</strong>或<strong>管程</strong><br>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针</p>
<h3 id="3-1-1、Monitor结构"><a href="#3-1-1、Monitor结构" class="headerlink" title="3.1.1、Monitor结构"></a>3.1.1、Monitor结构</h3><p><strong>结构</strong>：owner  entryList  waitSet</p>
<p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930118.jpg" alt="monitor结构"></p>
<h3 id="3-1-2、Monitor原理"><a href="#3-1-2、Monitor原理" class="headerlink" title="3.1.2、Monitor原理"></a>3.1.2、Monitor原理</h3><p>（1）刚开始monitor中owner为null<br>（2）当某个线程t1执行同步方法synchronized时，会将owner置为该线程<br>（3）t1持有锁过程中，t2，t3来了就会进入entryList中阻塞<br>（4）t1执行完会唤醒entrylist中的某个线程（不公平）<br>（5）调用wait方法，会将此线程放入到wait set中，然后放弃锁。直到有其它线程调用notify（），才会重新进入entrylist中，重新争夺锁的拥有权</p>
<h2 id="3-2、java对象结构"><a href="#3-2、java对象结构" class="headerlink" title="3.2、java对象结构"></a>3.2、java对象结构</h2><p>1.对象头</p>
<p>包括：Mark Word（标记字段）、Class Pointer（类型指针，它主要指向类的数据，也就是指向方法区中的位置）,数组长度（如果是数组）</p>
<p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930015.jpg" alt="markdown"></p>
<ol start="2">
<li><strong>实例数据</strong></li>
</ol>
<p>实例数据：对象真正存储的有效信息，存放类的属性数据信息，包括父类的属性信息</p>
<ol start="3">
<li><strong>对齐填充</strong></li>
</ol>
<p>对齐填充：由于虚拟机要求 对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。</p>
<h2 id="3-3、synchronized"><a href="#3-3、synchronized" class="headerlink" title="3.3、synchronized"></a>3.3、synchronized</h2><h3 id="3-3-1、synchronized锁升级"><a href="#3-3-1、synchronized锁升级" class="headerlink" title="3.3.1、synchronized锁升级"></a>3.3.1、synchronized锁升级</h3><h4 id="3-3-1-1、偏向锁"><a href="#3-3-1-1、偏向锁" class="headerlink" title="3.3.1.1、偏向锁"></a>3.3.1.1、偏向锁</h4><blockquote>
<p>使用场景：如果只有一个线程，就不需要每次的申请释放锁</p>
</blockquote>
<p>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 </p>
<h4 id="3-3-1-2、轻量级锁"><a href="#3-3-1-2、轻量级锁" class="headerlink" title="3.3.1.2、轻量级锁"></a>3.3.1.2、轻量级锁</h4><blockquote>
<p>使用场景：有时候会存在多个线程访问同步代码的情况，但每个线程执行的时间很短，这时候没必要阻塞等待，通过自旋来等待</p>
</blockquote>
<p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230930202.jpg" alt="轻量级锁"></p>
<p>（1）在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间 （注意：是每次都会建，即使是重入），用于存储旧的Mark Word的拷贝，官方称其为Displaced Mark Word。(锁记录解锁的时候会用到)</p>
<p>（2）虚拟机将使用CAS操作尝试将对象的Mark Word更新为轻量级锁的标志位和指向锁记录（Lock Record）的指针。</p>
<p>（3）如果这个更新动作成功了，那么这个线程就拥有了该对象的锁。</p>
<p>（4）如果这个更新操作失败了，虚拟机首先会检查当前线程是否已经拥有了这个对象的锁，如果已经拥有，那就可以直接进入同步块继续执行（重入）。否则就说明这个锁度已经被其他线程抢占了。一旦发生这种情况，那么轻量级锁就会膨胀为重量级锁。Mark Word中存储的就会指向重量级锁的指针，后面等待锁的线程也会进入阻塞状态。</p>
<blockquote>
<p>轻量级锁解锁流程如下（基于使用lock record重入计数的情况）：<br> 遍历栈的Lock Record，如果_displaced_header(存储markword的拷贝) 为 NULL，表明锁是可重入的，跳过不作处理<br> 如果_displaced_header 不为 NULL，即最后一个锁记录，调用 CAS恢复锁对象头的Markword，并恢复为无锁状态，解锁成功</p>
</blockquote>
<h4 id="3-3-1-3、重量级锁"><a href="#3-3-1-3、重量级锁" class="headerlink" title="3.3.1.3、重量级锁"></a>3.3.1.3、重量级锁</h4><blockquote>
<p>使用场景：如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>
</blockquote>
<p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931871.jpg" alt="重量级锁"></p>
<p>在Java中，每个对象都有一个监视器锁（monitor）。当一个线程想要访问一个被synchronized修饰的方法或代码块时，它会尝试获取这个对象的监视器锁。如果这个锁没有被其他线程占用，那么这个线程就可以获取这个锁，并执行synchronized修饰的方法或代码块。如果这个锁已经被其他线程占用，那么这个线程就会进入阻塞状态（waitset，entrylist），直到它能够获取这个锁为止</p>
<h3 id="3-3-2、synchronized使用"><a href="#3-3-2、synchronized使用" class="headerlink" title="3.3.2、synchronized使用"></a>3.3.2、synchronized使用</h3><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202312211615519.png" alt="image.png|725"></p>
<h2 id="3-4、wait-notify"><a href="#3-4、wait-notify" class="headerlink" title="3.4、wait&#x2F;notify"></a>3.4、wait&#x2F;notify</h2><p>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 。BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 。BLOCKED 线程会在 Owner 线程释放锁时唤醒 。WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</p>
<h3 id="3-4-1、sleep和wait的区别？"><a href="#3-4-1、sleep和wait的区别？" class="headerlink" title="3.4.1、sleep和wait的区别？"></a>3.4.1、sleep和wait的区别？</h3><ol>
<li>sleep 是 Thread 方法，而 wait 是 Object 的方法 </li>
<li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 </li>
<li>sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁</li>
</ol>
<blockquote>
<p>wait()为什么只能在同步方法中调用？因为wait操作的是monitor</p>
</blockquote>
<h2 id="3-5、park-unpark"><a href="#3-5、park-unpark" class="headerlink" title="3.5、park&#x2F;unpark"></a>3.5、park&#x2F;unpark</h2><p>它们是 LockSupport 类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park(); </span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>

<h3 id="3-5-1、与-Object-的-wait-notify-相比"><a href="#3-5-1、与-Object-的-wait-notify-相比" class="headerlink" title="3.5.1、与 Object 的 wait &amp; notify 相比"></a>3.5.1、与 Object 的 wait &amp; notify 相比</h3><ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 </li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ul>
<h3 id="3-5-2、原理"><a href="#3-5-2、原理" class="headerlink" title="3.5.2、原理"></a>3.5.2、原理</h3><p>每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 _counter ， _cond 和_mutex </p>
<p>核心部分是counter，我们可以理解为一个标记位。<br>当调用park时会看counter是否为0，为0则进入阻塞队列。为1则继续运行并将counter置为0。<br>当调用unpark时，会将counter置为1，若之前的counter值为0，还唤醒阻塞的线程。</p>
<h2 id="3-6、死锁"><a href="#3-6、死锁" class="headerlink" title="3.6、死锁"></a>3.6、死锁</h2><p>多个线程，比如A持有1资源，B持有2资源，A要获取2资源，B要获取1资源。但两个线程都不释放他们当前持有的线程，就会导致死锁</p>
<h3 id="3-6-1、死锁的必要条件"><a href="#3-6-1、死锁的必要条件" class="headerlink" title="3.6.1、死锁的必要条件"></a>3.6.1、死锁的必要条件</h3><ol>
<li>互斥条件：一个资源一次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>
<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>
</ol>
<h3 id="3-6-2、死锁的实现"><a href="#3-6-2、死锁的实现" class="headerlink" title="3.6.2、死锁的实现"></a>3.6.2、死锁的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现一个死锁</span></span><br><span class="line"><span class="comment"> * 如果把lock(target, owner);放到上面则不会死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="comment">//开启一个新线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock(owner, target);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//主线程</span></span><br><span class="line">        lock(target, owner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">(Object owner, Object target)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (owner) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (target) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-3、定位死锁"><a href="#3-6-3、定位死锁" class="headerlink" title="3.6.3、定位死锁"></a>3.6.3、定位死锁</h3><p>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</p>
<h3 id="3-6-4、哲学家就餐问题"><a href="#3-6-4、哲学家就餐问题" class="headerlink" title="3.6.4、哲学家就餐问题"></a>3.6.4、哲学家就餐问题</h3><p><img src="https://yancey-note-img.oss-cn-beijing.aliyuncs.com/202307230931868.jpg" alt="哲学家就餐问题"></p>
<p>有五位哲学家，围坐在圆桌旁。 他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 如果筷子被身边的人拿着，自己就得等待 </p>
<ol>
<li>筷子类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>哲学家类</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 获得左手筷子</span></span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 获得右手筷子</span></span><br><span class="line">                <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                    <span class="comment">// 吃饭</span></span><br><span class="line">                    eat();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 放下右手筷子</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 放下左手筷子</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>就餐</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Chopstick</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="type">Chopstick</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="type">Chopstick</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="type">Chopstick</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"><span class="type">Chopstick</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chopstick</span>(<span class="string">&quot;5&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;苏格拉底&quot;</span>, c1, c2).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;柏拉图&quot;</span>, c2, c3).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;亚里士多德&quot;</span>, c3, c4).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;赫拉克利特&quot;</span>, c4, c5).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Philosopher</span>(<span class="string">&quot;阿基米德&quot;</span>, c5, c1).start();</span><br></pre></td></tr></table></figure>
<h2 id="3-7、活锁"><a href="#3-7、活锁" class="headerlink" title="3.7、活锁"></a>3.7、活锁</h2><p>两个线程互相改变对方的结束条件导致谁也无法结束</p>
<blockquote>
<p>eg：共享变量count为10000, t1线程while count &gt; 0, count– ;t2线程while count &lt; 20000, count++ .两个线程同时运行，这样count的值一直无法达到结束循环的条件。两个线程一直在执行</p>
</blockquote>
<h1 id="4、共享模型之内存"><a href="#4、共享模型之内存" class="headerlink" title="4、共享模型之内存"></a>4、共享模型之内存</h1><h2 id="4-1、java内存模型（jmm）"><a href="#4-1、java内存模型（jmm）" class="headerlink" title="4.1、java内存模型（jmm）"></a>4.1、java内存模型（jmm）</h2><p>Java内存模型(即Java Memory Model，简称JMM) 。它是一个规范，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本</p>
<h2 id="4-2、线程安全性的三个体现"><a href="#4-2、线程安全性的三个体现" class="headerlink" title="4.2、线程安全性的三个体现"></a>4.2、线程安全性的三个体现</h2><p><strong>原子性</strong>：原子性指的是一个或多个操作要么全部执行成功要么全部执行失败（一个操作CPU不可被中断）（Atomic、CAS算法、synchronized、Lock）</p>
<p><strong>可见性</strong>：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值（synchronized、volatile）</p>
<blockquote>
<p>关联到cpu层面其实就是cpu的三级缓存和主内存，一个线程在读取数据时，先从本地内存查询，如果没有，再从主存中查，然后复制到本地内存进行操作，操作完后，会将修改后的数据刷新回主内存。因为现在cpu都是多核的，所以存在多个线程同时操作一个共享变量，但是本地内存中的修改对于其它线程是不可见的</p>
</blockquote>
<p><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行,cpu为了提升执行效率，会进行执行重排 （happens-before原则,volatile）</p>
<h1 id="5、共享模型之无锁"><a href="#5、共享模型之无锁" class="headerlink" title="5、共享模型之无锁"></a>5、共享模型之无锁</h1><h2 id="5-1、CAS"><a href="#5-1、CAS" class="headerlink" title="5.1、CAS"></a>5.1、CAS</h2><h3 id="5-1-1、CAS基本概念"><a href="#5-1-1、CAS基本概念" class="headerlink" title="5.1.1、CAS基本概念"></a>5.1.1、CAS基本概念</h3><p>CAS是所有原子类的底层原理，乐观锁主要采用CAS算法。<br>CAS，比较并交换，是JDK提供的非阻塞原子性操作，CAS的思想很简单：三个参数，一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。</p>
<blockquote>
<ol>
<li>CAS利用了处理器的CMPXCHG指令，该指令操作的内存区域就会加锁，导致其他处理器不能同时访问它，保证原子性</li>
<li>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</li>
</ol>
</blockquote>
<h3 id="5-1-2、CAS问题"><a href="#5-1-2、CAS问题" class="headerlink" title="5.1.2、CAS问题"></a>5.1.2、CAS问题</h3><p>多线程环境，线程1读取了数据A，然后线程2将数据A变为B再变为A，线程1进行cas操作时就会认为数据没有被修改过，其实数据是被修改过的。</p>
<p><strong>解决方案：</strong><br>使用AtomicStampReference<br>AtomicStampReference在cas的基础上增加了一个标记stamp，使用这个标记可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验</p>
<h2 id="5-2、volatile"><a href="#5-2、volatile" class="headerlink" title="5.2、volatile"></a>5.2、volatile</h2><h3 id="5-2-1、如何保证可见性和有序性"><a href="#5-2-1、如何保证可见性和有序性" class="headerlink" title="5.2.1、如何保证可见性和有序性"></a>5.2.1、如何保证可见性和有序性</h3><ol>
<li><strong>保证可见性（缓存一致性协议MESI）</strong></li>
</ol>
<p>首先cpu会根据共享变量是否带有Volatile字段，来决定是否使用<strong>MESI协议</strong>保证缓存一致性。<br>如果有Volatile，汇编层面会对变量加上Lock前缀，当一个线程修改变量的值后，会马上经过store、write等原子操作修改主内存的值（如果不加Lock前缀不会马上同步），为什么监听到修改会马上同步呢？cpu<strong>总线嗅探机制</strong>监听到这个变量被修改，就会把其他线程的变量副本由共享S置为无效I，当其他线程在使用变量副本时，发现其已经无效，就回去主内存中拿一个最新的值</p>
<blockquote>
<p><strong>M 修改</strong> (Modified) 代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中<br><strong>E 独享、互斥</strong> (Exclusive) E代表该缓存行对应内存中的内容只被该CPU缓存.该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态。<br><strong>S 共享</strong> (Shared) 当多个线程都拿到了共享变量，此时为共享状态.当有一个CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态<br><strong>I 无效</strong> (Invalid) 线程丢弃了自己工作内存中的变量，为无效状态</p>
</blockquote>
<blockquote>
<p>涉及到的指令<br>lock(锁定)：将一个变量标识为被一个线程独占状态<br>store(存储)：作用于工作内存的变量,将变量传输到主内存中<br>write(写入)：将store入主内存的变量,放入到主内存的变量中</p>
</blockquote>
<ol start="2">
<li><strong>保证有序性（禁止指令重排优化）</strong></li>
</ol>
<p>多线程环境下，有序性问题产生的主要原因就是执行重排优化，而Volatile的另一个作用就是禁止指令重排优化。具体是通过对Volatile修饰的变量增加内存屏障来完成的<br>内存屏障的主要工作原理为：通过在指令间插入一条内存屏障并禁止cpu对Volatile修饰的变量进行重排序</p>
<h2 id="5-3、原子类"><a href="#5-3、原子类" class="headerlink" title="5.3、原子类"></a>5.3、原子类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>具体类</th>
</tr>
</thead>
<tbody><tr>
<td>Atomic 基本类型原子类</td>
<td>AtomicInteger AtomicLong AtomicBoolean</td>
</tr>
<tr>
<td>AtomicArray 数组类型原子类</td>
<td>AtomicIntegerArray  AtomicLongArray AtomicReferenceArray</td>
</tr>
<tr>
<td>AtomicReference 引用类型原子类</td>
<td>AtomicReference AtomicStampedReference AtomicMarkableReference</td>
</tr>
<tr>
<td>AtomicFieldUpdate 升级类型原子类</td>
<td>AtomicIntegerFieldupdater AtomicLongFieldUpdater AtomicReferenceFieldUpdater</td>
</tr>
</tbody></table>
<h1 id="6、共享模式之工具"><a href="#6、共享模式之工具" class="headerlink" title="6、共享模式之工具"></a>6、共享模式之工具</h1><h2 id="6-1、线程池"><a href="#6-1、线程池" class="headerlink" title="6.1、线程池"></a>6.1、线程池</h2><ol>
<li>线程池可以有效地管理线程：它可以管理线程的数量,做到线程的服用，可以避免无节制的创建线程,导致超出系统负荷直至崩溃</li>
<li>构造方法的重要参数：corePoolSize（核心线程数）、workQueue（等待队列）、maxinumPoolSize（最大线程数）、handler（拒绝策略）、keepAliveTime（空闲线程存活时间）</li>
</ol>
<h3 id="6-1-1、ThreadPoolExecutor"><a href="#6-1-1、ThreadPoolExecutor" class="headerlink" title="6.1.1、ThreadPoolExecutor"></a>6.1.1、<strong>ThreadPoolExecutor</strong></h3><ol>
<li><strong>构造方法</strong></li>
</ol>
<p>通过new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)自定义创建</p>
<blockquote>
<ol>
<li>corePoolSize：核心线程池的大小，如果核心线程池有空闲位置，新的任务就会被核心线程池新建一个线程执行，执行完毕后不会销毁线程，线程会进入缓存队列等待再次被运行。</li>
<li>maximunPoolSize：线程池能创建最大的线程数量。如果核心线程池和缓存队列都已经满了，新的任务进来就会创建救急线程来执行。但是数量不能超过maximunPoolSize，否侧会采取拒绝接受任务策略，我们下面会具体分析。</li>
<li>keepAliveTime：救急线程线程能够空闲的最长时间，超过时间，线程终止。这个参数默认只有在线程数量超过核心线程池大小时才会起作用。只要线程数量不超过核心线程大小，就不会起作用。</li>
<li>unit：空闲线程存活时间单位 创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等</li>
<li>workQueue：缓存队列，用来存放等待被执行的任务。</li>
<li>threadFactory 线程工厂</li>
<li>handler：拒绝策略<br>（1）abortPolicy：抛出异常（默认）<br>（2）discardPolicy：放弃本次任务<br>（3）discardoldestPolicy：放弃队列中最早的任务，本任务取代<br>（4）callerrunPolicy：让调用者运行任务</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>工作原理</strong></li>
</ol>
<p>如果当前线程池中正在执行的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务；<br>如果当前线程池中正在执行任务的的线程数目&gt;&#x3D;corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程(救急线程)去执行这个任务；<br>如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；<br>如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理</p>
<h3 id="6-1-2、Executors类中提供的工厂方法"><a href="#6-1-2、Executors类中提供的工厂方法" class="headerlink" title="6.1.2、Executors类中提供的工厂方法"></a>6.1.2、Executors类中提供的工厂方法</h3><p>根据上面的ThreadPoolExecutor这个构造方法，JDK Executors类中提供了众多工厂方法来创建各种用途的线程池</p>
<ol>
<li><strong>newFixedThreadPool</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：</p>
<ul>
<li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间 </li>
<li>阻塞队列是无界的，可以放任意数量的任务</li>
</ul>
</blockquote>
<p>评价：</p>
<blockquote>
<p>适用于任务量已知，相对耗时的任务</p>
</blockquote>
<ol start="2">
<li><strong>newCachedThreadPool</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点 </p>
<ul>
<li>核心线程数是 0，最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 <ul>
<li>全部都是救急线程（60s 后可以回收）</li>
<li>救急线程可以无限创建</li>
</ul>
</li>
<li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交货）</li>
</ul>
</blockquote>
<p>评价：</p>
<blockquote>
<p>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完，空闲 1分钟后释放线程<br>适合任务数比较密集，但每个任务执行时间较短的情况</p>
</blockquote>
<ol start="3">
<li>newSingleThreadExecutor</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用场景：<br>希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。<br>任务执行完毕，这唯一的线程也不会被释放。 </p>
<h3 id="6-1-3、创建多大的线程池"><a href="#6-1-3、创建多大的线程池" class="headerlink" title="6.1.3、创建多大的线程池"></a>6.1.3、创建多大的线程池</h3><ul>
<li>过小会导致程序不能充分地利用系统资源、容易导致饥饿 </li>
<li>过大会导致更多的线程上下文切换，影响性能</li>
</ul>
<ol>
<li>**CPU 密集型运算 **</li>
</ol>
<p>通常采用 <code>cpu 核数 + 1</code> 能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费 </p>
<ol start="2">
<li><strong>I&#x2F;O密集型</strong></li>
</ol>
<p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当你执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU 就闲下来了，你可以利用多线程提高它的利用率。<br>经验公式如下 ：<br><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p>
<h3 id="6-1-4、线程池状态"><a href="#6-1-4、线程池状态" class="headerlink" title="6.1.4、线程池状态"></a>6.1.4、线程池状态</h3><ol>
<li>RUNNING状态：线程池创建后，初始状态为RUNNING。</li>
<li>SHUTDOWN状态：当调用线程池的shutdown()方法时，线程池进入SHUTDOWN状态。此时线程池不再接受新的任务，但会执行已经提交的任务。当所有任务都执行完毕后，线程池会转换到TIDYING状态。</li>
<li>STOP状态：当调用线程池的shutdownNow()方法时，线程池进入STOP状态。此时线程池不再接受新的任务，并且会中断正在执行的任务。当所有任务都执行完毕后，线程池会转换到TIDYING状态。</li>
<li>TIDYING状态：当线程池处于SHUTDOWN或STOP状态时，所有任务都执行完毕后，线程池会进入TIDYING状态。在此状态下，线程池会进行清理工作，如关闭线程池中的所有线程等。当清理工作完成后，线程池会转换到TERMINATED状态。</li>
<li>TERMINATED状态：线程池处于TERMINATED状态时，表示线程池已经完全终止，所有任务已经执行完毕并且清理工作也已经完成。此时线程池不再能接受新的任务。</li>
</ol>
<h2 id="6-2、锁"><a href="#6-2、锁" class="headerlink" title="6.2、锁"></a>6.2、锁</h2><h3 id="6-2-1、AQS"><a href="#6-2-1、AQS" class="headerlink" title="6.2.1、AQS"></a>6.2.1、AQS</h3><ol>
<li>基本概念</li>
</ol>
<p>AbstractQueuedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。这个类在java.util.concurrent.locks包。AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的ReentrantLock&#x2F;Semaphore&#x2F;CountDownLatch…</p>
<ol start="2">
<li>原理</li>
</ol>
<p>它维护了一个volatile int state（代表共享资源）和一个FIFO双向队列（CLH队列，多线程争用资源被阻塞时会进入此队列），核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，那么就将暂时获取不到锁的线程加入到等待队列（entrylist）中。如果调用了锁对象的<br>AQS定义两种资源共享方式：Exclusive（独占，只有一个线程能执行，如ReentrantLock）和Share（共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch）<br>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了</p>
<ol start="3">
<li>实现</li>
</ol>
<p>自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&#x2F;唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p>
<blockquote>
<p>**isHeldExclusively()**：该线程是否正在独占资源。只有用到condition才需要去实现它。<br>**tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。<br>**tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。<br>**tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。<br>**tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
</blockquote>
<p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state&#x3D;0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的</p>
<h3 id="6-2-2、ReentrantLock"><a href="#6-2-2、ReentrantLock" class="headerlink" title="6.2.2、ReentrantLock"></a>6.2.2、ReentrantLock</h3><p>相对于 synchronized 它具备如下特点 </p>
<ol>
<li>可中断 </li>
<li>可以设置超时时间 </li>
<li>可以设置为公平锁 （默认不公平）</li>
<li>支持多个条件变量</li>
</ol>
<p>与 synchronized 一样，都支持可重入 </p>
<p><strong>实现原理</strong></p>
<ol>
<li>首先，ReentrantLock实现Lock接口，这样他就向外提供了加锁，解锁，中断锁的基本功能</li>
<li>它内部维护了一个sync同步器，继承了AQS。它加锁，解锁的实现其实就是调用这个同步器的方法</li>
<li>加锁的时候用CAS尝试去修改state从0变为1，修改成功则把owner线程改成当前线程。修改失败说明已经有线程获取锁，判断当前持有锁的线程是否是该线程，是的话state+1，冲入。否则进入等待队列</li>
<li>持有锁的线程释放时，找到队列中离 head 最近的一个 Node，unpark 恢复其运行，tryAcquire尝试获取锁。如果在默认的非公平状态下，这时如果又有新的线程获取锁，它仍有可能获取失败。如果是公平状态，该线程可以顺利拿到锁（新来的线程会添加到队列尾部）</li>
</ol>
<p><strong>条件变量——Condition</strong><br>Condition 是一个多线程协调通信的工具类，作用类似于synchronized中的waitset。可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒。两个重要的方法：await:把当前线程阻塞挂起 signal:唤醒阻塞的线程</p>
<h3 id="6-2-3、ReentrantReadWriteLock"><a href="#6-2-3、ReentrantReadWriteLock" class="headerlink" title="6.2.3、ReentrantReadWriteLock"></a>6.2.3、<strong>ReentrantReadWriteLock</strong></h3><h4 id="4-2-3-1、ReentrantReadWriteLock基本概念"><a href="#4-2-3-1、ReentrantReadWriteLock基本概念" class="headerlink" title="4.2.3.1、ReentrantReadWriteLock基本概念"></a>4.2.3.1、ReentrantReadWriteLock基本概念</h4><p>ReadLock和WriteLock是ReentrantReadWriteLock的两个内部类，Lock的上锁和释放锁都是通过一个AQS同步器sync来实现的。将 state 的 高 16 位和低 16 位拆开表示读写锁。其中高 16 位表示读锁，低 16 位表示写锁。读锁，允许共享；写锁，是独占锁。适合在读多写少的场景中使用</p>
<p>ReadWriteLock也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个资源可以被多个线程同时读，或者被一个线程写，但是不能同时存在读和写线程。<br>读锁：共享锁 readLock<br>写锁：独占锁 writeLock<br>读写锁 ： 一个资源可以被多个读的线程进行访问 ，或者可以被一个写的线程访问，但是不能同时存在读和写进程 ，读写互斥，读读共享。</p>
<h4 id="4-2-3-2、锁获取过程"><a href="#4-2-3-2、锁获取过程" class="headerlink" title="4.2.3.2、锁获取过程"></a>4.2.3.2、锁获取过程</h4><ol>
<li>获取读锁</li>
</ol>
<p>如果写锁没有被另一个线程持有，则获取读锁并立即返回。<br>如果写锁由另一个线程持有，则出于线程调度目的，当前线程将被禁用（unpark），并处于休眠状态，直	到获取读锁为止。</p>
<ol start="4">
<li>获取写入锁</li>
</ol>
<p>如果没有其他线程持有读锁或写锁，会直接返回，并将写锁计数设置为1<br>如果当前线程持有写锁，则将写锁计数 +1，然后返回<br>如果锁正在被其他线程持有，则当前线程将被禁用，并处于休眠状态，直到获取读锁并将写锁计数设置为1。</p>
<h4 id="4-2-3-3、常见问题"><a href="#4-2-3-3、常见问题" class="headerlink" title="4.2.3.3、常见问题"></a>4.2.3.3、常见问题</h4><ol>
<li><strong>读锁和写锁的可重入性</strong></li>
</ol>
<p>在加锁的时候，判断是否为当前线程，如果是当前线程，则直接累加计数。值得注意的是：读锁重入计数使用的 ThreadLocal 在线程中缓存计数，而写锁则直接用的 state 进行累加</p>
<ol start="2">
<li><strong>当前线程获取锁失败，被阻塞的后续操作是什么？</strong></li>
</ol>
<p>获取失败，会放到 AQS 等待队列中，在队列中不断循环，监视前一个节点是否为 head ，是的话，会重新尝试获取锁</p>
<ol start="3">
<li><strong>锁降级是怎么降级的？</strong></li>
</ol>
<p>在获取读锁的时候，如果当前线程持有写锁，是可以获取读锁的。这块就是指锁降级，比如线程 A 获取到了写锁，当线程 A 执行完毕时，它需要获取当前数据，假设不支持锁降级，就会导致 A 释放写锁，然后再次请求读锁。而在这中间是有可能被其他阻塞的线程获取到写锁的。从而导致线程 A 在一次执行过程中数据不一致（脏读）</p>
<h3 id="6-2-4、锁分类"><a href="#6-2-4、锁分类" class="headerlink" title="6.2.4、锁分类"></a>6.2.4、锁分类</h3><ol>
<li><strong>可重入锁和不可重入锁</strong></li>
</ol>
<p>Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是可重入<br>重入：当前线程获取到A锁，在获取之后尝试再次获取A锁是可以直接拿到的。<br>不可重入：当前线程获取到A锁，在获取之后尝试再次获取A锁，无法获取到的，因为A锁被当前线程占用着，需要等待自己释放锁再获取锁</p>
<ol start="2">
<li><strong>乐观锁和悲观锁</strong></li>
</ol>
<p>Java中提供的synchronized，ReentrantLock，ReentrantReadWriteLock都是悲观锁<br>Java中提供的CAS操作，就是乐观锁的一种实现<br>悲观锁：获取不到锁资源时，会将当前线程挂起 (进入BLOCKED、WAITING)，线程挂起会涉及到用户态和内核态的切换，而这种切换是比较消耗资源的。<br>乐观锁：获取不到锁，再让CPU调度，重新尝试获取锁资源。Automic原子类中，就是基于CAS乐观锁实现的</p>
<ol start="3">
<li><strong>公平锁和非公平锁</strong></li>
</ol>
<p>synchronized是非公平锁<br>ReentrantLock和ReentrantReadWriteLock可以实现公平锁和非公平锁</p>
<ol start="4">
<li><strong>互斥锁和共享锁</strong></li>
</ol>
<p>Synchronized，ReentrantLock是互斥锁<br>ReentrantReadWriteLock有互斥锁也有共享锁（写互斥读共享）<br>互斥锁：同一时间，只有一个线程持有当前互斥锁<br>共享锁：同一时间点，多个线程可以共同持有</p>
<h2 id="6-3、工具"><a href="#6-3、工具" class="headerlink" title="6.3、工具"></a>6.3、工具</h2><h3 id="6-3-1、Semaphore"><a href="#6-3-1、Semaphore" class="headerlink" title="6.3.1、Semaphore"></a>6.3.1、Semaphore</h3><ol>
<li><strong>概念</strong></li>
</ol>
<p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源（Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourcePool</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;Connection&gt; list;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用到了信号量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataSourcePool</span><span class="params">(<span class="type">int</span> size)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        semaphore = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            list.add(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用同步方法获取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//先将当前信号量-1，如果为0，将阻塞</span></span><br><span class="line">        semaphore.acquire();</span><br><span class="line">        <span class="keyword">return</span> list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">close</span><span class="params">(Connection connection)</span>&#123;</span><br><span class="line">        <span class="comment">//信号量+1</span></span><br><span class="line">        semaphore.release();</span><br><span class="line">        list.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>原理</strong></li>
</ol>
<p>Semaphore的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的</p>
<p>1、把初始令牌数量赋值给同步队列的state状态，state的值就代表当前所剩余的令牌数量。<br>2、 semaphore.acquire(); 当前线程会尝试去同步队列获取一个令牌，获取令牌的过程也就是使用原子的操作去修改同步队列的state ,获取一个令牌则修改为state&#x3D;state-1。state&lt;0,令牌数量不足，加入阻塞队列。&gt;&#x3D;0则获取成功<br>3、semaphore.release() ，释放令牌的过程也就是把同步状态的state修改为state&#x3D;state+1的过程。释放令牌成功之后，同时会唤醒同步队列的所有阻塞节共享节点线程</p>
<h3 id="6-3-2、CountdownLatch"><a href="#6-3-2、CountdownLatch" class="headerlink" title="6.3.2、CountdownLatch"></a>6.3.2、CountdownLatch</h3><ol>
<li><strong>概念</strong></li>
</ol>
<p>CountDownLatch允许一个或多个线程等待其他线程完成操作。await（）用来等待计数归0，countDown（）用来让计数减少一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    service.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - begin... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">25.831</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">4</span>] - waiting... </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">26.835</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">1</span>] - end..<span class="number">.2</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.335</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">2</span>] - end..<span class="number">.1</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.835</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">3</span>] - end..<span class="number">.0</span> </span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27.835</span> c.TestCountDownLatch [pool-<span class="number">1</span>-thread-<span class="number">4</span>] - wait end...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>原理</strong></li>
</ol>
<p>CountDownLatch的实现原理主要是通过内部类Sync来实现的，内部类Sync是AQS的子类，主要是通过重写AQS的共享式获取和释放同步状态方法来实现的<br>1、初始化CountDownLatch实际就是设置了AQS的state为计数的值<br>2、调用CountDownLatch的countDown方法时实际就是调用AQS的relase方法，每调用一次就自减一次state值<br>3、调用await方法实际就调用AQS的共享式获取同步状态state，当AQS的state值为0时，await方法才会执行成功，否则就会一直处于死循环中不断重试</p>
<ol start="3">
<li><strong>和join的区别？</strong></li>
</ol>
<p>CountDownLatch：控制力度更细，比如可以在子线程执行一部分后coutdown，就不一定要等到线程执行完成</p>
<h3 id="6-3-3、CyclicBarrier"><a href="#6-3-3、CyclicBarrier" class="headerlink" title="6.3.3、CyclicBarrier"></a>6.3.3、CyclicBarrier</h3><ol>
<li><strong>概念</strong></li>
</ol>
<p>CyclicBarrier可以理解为一个循环同步屏障，定义一个同步屏障之后，当一组线程都全部达到同步屏障之前都会被阻塞，直到最后一个线程达到了同步屏障之后才会被打开，其他线程才可继续执行<br>实现王者荣耀10个人都加载完才开始游戏</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(count, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;全部加载完毕&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(count);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>; x &lt; count; x++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Worker</span>(cb));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已加载完&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span> 已加载完</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span> 已加载完</span><br><span class="line">全部加载完毕</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>原理</strong></li>
</ol>
<p>1、创建CyclicBarrier时定义了CyclicBarrier对象需要达到的线程数count<br>2、每当一个线程执行了await方法时，需要先通过ReentrantLock进行加锁操作，然后对count进行自减操作，操作成功则判断当前count是否为0；<br>3、如果当前count不为0则调用Condition的await方法使当前线程进入等待状态；<br>4、如果当前count为0则表示同步屏障已经完全，此时调用Condition的signalAll方法唤醒之前所有等待的线程，并开启循环的下一次同步屏障功能；<br>5、唤醒其他线程之后，其他线程继续执行剩余的逻辑。</p>
<h2 id="6-4、线程安全集合类"><a href="#6-4、线程安全集合类" class="headerlink" title="6.4、线程安全集合类"></a>6.4、线程安全集合类</h2><h3 id="6-4-1、概述"><a href="#6-4-1、概述" class="headerlink" title="6.4.1、概述"></a>6.4.1、概述</h3><p>线程安全实现类有三类：</p>
<ol>
<li>遗留的线程安全集合如 Hashtable ， Vector </li>
<li>使用 Collections 装饰的线程安全集合（调用所有方法时加synchronized修饰）</li>
</ol>
<blockquote>
<ul>
<li>Collections.synchronizedCollection </li>
<li>Collections.synchronizedList </li>
<li>Collections.synchronizedMap </li>
<li>Collections.synchronizedSet </li>
<li>Collections.synchronizedNavigableMap </li>
<li>Collections.synchronizedNavigableSet</li>
<li>Collections.synchronizedSortedMap </li>
<li>Collections.synchronizedSortedSet</li>
</ul>
</blockquote>
<ol start="4">
<li>JUC下的安全集合: Blocking、CopyOnWrite、Concurrent</li>
</ol>
<blockquote>
<ul>
<li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 (Lock)</li>
<li>CopyOnWrite 之类容器修改开销相对较重 (修改时拷贝)</li>
<li>Concurrent 类型的容器 （内部很多操作使用cas优化）<ul>
<li>内部很多操作使用 cas 优化，一般可以提供较高吞吐量 </li>
<li>弱一致性 <ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li>
<li>求大小弱一致性，size 操作未必是 100% 准确 </li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<blockquote>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用 **fail-fast **机制也就是让遍历立刻失败，抛出ConcurrentModifificationException，不再继续遍历</p>
</blockquote>
<h3 id="6-4-2、concurrentHashMap"><a href="#6-4-2、concurrentHashMap" class="headerlink" title="6.4.2、concurrentHashMap"></a>6.4.2、concurrentHashMap</h3><p><strong>JDK1.8前</strong><br>ConcurrentHashMap使用分段锁技术，数据结构：ReentrantLock+segement+hashEntry。一个segement中包含一个hashentry数组（hashentry结构类似hashmap：数组+链表）。</p>
<p>元素查询：使用二次hash，第一次定位到segement，第二次hash定位到元素所在链表的头部</p>
<p>锁：segement继承了reentrantLock，锁定操作的segement，其它segement不受影响，并发度为segement个数</p>
<blockquote>
<p>ConcurrentHashMap 与HashMap和Hashtable 最大的不同在于：put和 get 两次Hash到达指定的HashEntry，第一次hash到达Segment,第二次到达Segment里面的Entry,然后在遍历entry链表</p>
</blockquote>
<p><strong>JDK1.8</strong></p>
<p>在JDK8中，ConcurrentHashMap的底层数据结构与HashMap一样，也是采用“数组+链表+红黑树”的形式。同时，它又采用锁定头节点的方式降低了锁粒度，以较低的性能代价实现了线程安全</p>
<ol>
<li>初始化数组或头节点时，ConcurrentHashMap并没有加锁，而是CAS的方式进行原子替换（原子操作，基于Unsafe类的原子操作API）。 </li>
<li>插入数据时会进行加锁处理，但锁定的不是整个数组，而是槽中的头节点。所以，ConcurrentHashMap中锁的粒度是槽，而不是整个数组，并发的性能很好。 </li>
<li>扩容时会进行加锁处理，锁定的仍然是头节点。并且，支持多个线程同时对数组扩容，提高并发能力。每个线程需先以CAS操作抢任务，争抢一段连续槽位的数据转移权。抢到任务后，该线程会锁定槽内的头节点，然后将链表或树中的数据迁移到新的数组里。 </li>
<li>查找数据时并不会加锁，所以性能很好。另外，在扩容的过程中，依然可以支持查找操作。如果某个槽还未进行迁移，则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕，但是整个扩容还没结束，则扩容线程会创建一个转发节点，在这个节点里面记录的是新的 ConcurrentHashMap 的引用，从新数组中找到目标数据。</li>
</ol>
<h3 id="6-4-3、BlockingQueue"><a href="#6-4-3、BlockingQueue" class="headerlink" title="6.4.3、BlockingQueue"></a>6.4.3、BlockingQueue</h3><p>主要的两个实现ArrayBlockingQueue 和 LinkedBlockingQueue </p>
<ol>
<li>区别</li>
</ol>
<p>（1）内部实现：ArrayBlockingQueue 使用数组；LinkedBlockingQueue 使用单链表<br>（2）锁的个数：ArrayBlockingQueue只有一把锁（最多只允许一个线程，生产者或消费者二选一）；	LinkedBlockingQueue 有两把锁：takeLock、putLock（可以允许两个线程同时执行，一个生产者，一个消费者）<br>（3）支持公平锁：ArrayBlockingQueue 支持；LinkedBlockingQueue 不支持，因为有两把锁，没法实现</p>
<h3 id="6-4-4、ConcurrentLinkedQueue"><a href="#6-4-4、ConcurrentLinkedQueue" class="headerlink" title="6.4.4、ConcurrentLinkedQueue"></a>6.4.4、ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue 的设计与 LinkedBlockingQueue 非常像，也是 两把【锁】，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）</p>
<h3 id="6-4-5、CopyOnWriteArrayList"><a href="#6-4-5、CopyOnWriteArrayList" class="headerlink" title="6.4.5、CopyOnWriteArrayList"></a>6.4.5、CopyOnWriteArrayList</h3><ol>
<li>首先CopyOnWriteArrayList的内部也是通过数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新的数组上进行，读操作在原数组上进行</li>
<li>写数据时会加ReentLocak锁，防止并发写入丢失数据的问题</li>
<li>写操作结束后会把原数组指向新数组</li>
<li>CopyOnWriteArrayList允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的场景。但是CopyOnWriteArrayList比较占用内存，同时可能督导的数据不是实时最新的数据，所以不适合实时性要求很高的场景</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.guoyancheng.top">Guo Yancheng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.guoyancheng.top/posts/42310.html">https://www.guoyancheng.top/posts/42310.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.guoyancheng.top" target="_blank">去码头整些薯条</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/juc/">juc</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/33708.html" title="RabbitMQ"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ</div></div></a></div><div class="next-post pull-right"><a href="/posts/58122.html" title="nginx"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">nginx</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Guo Yancheng</div><div class="author-info__description">人生不过三万天</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">61</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1、java多线程基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.1、进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2%E3%80%81%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-text">1.2、并发和并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">1.3、多线程的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1%E3%80%81%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8"><span class="toc-text">1.3.1、异步调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2%E3%80%81%E6%8F%90%E5%8D%87%E6%95%88%E7%8E%87"><span class="toc-text">1.3.2、提升效率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81java%E7%BA%BF%E7%A8%8B"><span class="toc-text">2、java线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">2.1、线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1%E3%80%81%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8Thread"><span class="toc-text">2.1.1、直接使用Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2%E3%80%81%E4%BD%BF%E7%94%A8-Runnable-%E9%85%8D%E5%90%88-Thread"><span class="toc-text">2.1.2、使用 Runnable 配合 Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3%E3%80%81FutureTask-%E9%85%8D%E5%90%88-Thread"><span class="toc-text">2.1.3、FutureTask 配合 Thread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.2、查看进程线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1%E3%80%81windows"><span class="toc-text">2.2.1、windows</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2%E3%80%81linux"><span class="toc-text">2.2.2、linux</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3%E3%80%81JDK"><span class="toc-text">2.2.3、JDK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">2.3、线程运行原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81start%E4%B8%8Erun"><span class="toc-text">2.4、start与run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5%E3%80%81sleep-%E4%B8%8E-yield"><span class="toc-text">2.5、sleep 与 yield</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6%E3%80%81join"><span class="toc-text">2.6、join</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7%E3%80%81interrupt"><span class="toc-text">2.7、interrupt</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1%E3%80%81%E6%89%93%E6%96%AD%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.7.1、打断阻塞状态的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2%E3%80%81%E6%89%93%E6%96%AD%E6%AD%A3%E5%B8%B8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.7.2、打断正常运行的线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3%E3%80%81%E9%99%A4%E4%BA%86interrupt%E5%A4%96%E7%9A%84%E5%88%AB%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E8%AE%BE%E7%BD%AE%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%89"><span class="toc-text">2.7.3、除了interrupt外的别的方法（设置标志位）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">2.9、线程状态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E7%AE%A1%E7%A8%8B"><span class="toc-text">3、共享模型之管程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81monitor"><span class="toc-text">3.1、monitor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E3%80%81Monitor%E7%BB%93%E6%9E%84"><span class="toc-text">3.1.1、Monitor结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E3%80%81Monitor%E5%8E%9F%E7%90%86"><span class="toc-text">3.1.2、Monitor原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81java%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-text">3.2、java对象结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E3%80%81synchronized"><span class="toc-text">3.3、synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1%E3%80%81synchronized%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-text">3.3.1、synchronized锁升级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1%E3%80%81%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">3.3.1.1、偏向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-2%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">3.3.1.2、轻量级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-3%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">3.3.1.3、重量级锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2%E3%80%81synchronized%E4%BD%BF%E7%94%A8"><span class="toc-text">3.3.2、synchronized使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E3%80%81wait-notify"><span class="toc-text">3.4、wait&#x2F;notify</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1%E3%80%81sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">3.4.1、sleep和wait的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5%E3%80%81park-unpark"><span class="toc-text">3.5、park&#x2F;unpark</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-1%E3%80%81%E4%B8%8E-Object-%E7%9A%84-wait-notify-%E7%9B%B8%E6%AF%94"><span class="toc-text">3.5.1、与 Object 的 wait &amp; notify 相比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-2%E3%80%81%E5%8E%9F%E7%90%86"><span class="toc-text">3.5.2、原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6%E3%80%81%E6%AD%BB%E9%94%81"><span class="toc-text">3.6、死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-1%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text">3.6.1、死锁的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-2%E3%80%81%E6%AD%BB%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.6.2、死锁的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-3%E3%80%81%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81"><span class="toc-text">3.6.3、定位死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-4%E3%80%81%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">3.6.4、哲学家就餐问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7%E3%80%81%E6%B4%BB%E9%94%81"><span class="toc-text">3.7、活锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%86%85%E5%AD%98"><span class="toc-text">4、共享模型之内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88jmm%EF%BC%89"><span class="toc-text">4.1、java内存模型（jmm）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E4%B8%89%E4%B8%AA%E4%BD%93%E7%8E%B0"><span class="toc-text">4.2、线程安全性的三个体现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E6%97%A0%E9%94%81"><span class="toc-text">5、共享模型之无锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E3%80%81CAS"><span class="toc-text">5.1、CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1%E3%80%81CAS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1.1、CAS基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2%E3%80%81CAS%E9%97%AE%E9%A2%98"><span class="toc-text">5.1.2、CAS问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E3%80%81volatile"><span class="toc-text">5.2、volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-text">5.2.1、如何保证可见性和有序性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E3%80%81%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-text">5.3、原子类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%85%B7"><span class="toc-text">6、共享模式之工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">6.1、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1%E3%80%81ThreadPoolExecutor"><span class="toc-text">6.1.1、ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2%E3%80%81Executors%E7%B1%BB%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-text">6.1.2、Executors类中提供的工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3%E3%80%81%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%A4%A7%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">6.1.3、创建多大的线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81"><span class="toc-text">6.1.4、线程池状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E9%94%81"><span class="toc-text">6.2、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1%E3%80%81AQS"><span class="toc-text">6.2.1、AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2%E3%80%81ReentrantLock"><span class="toc-text">6.2.2、ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-3%E3%80%81ReentrantReadWriteLock"><span class="toc-text">6.2.3、ReentrantReadWriteLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-1%E3%80%81ReentrantReadWriteLock%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">4.2.3.1、ReentrantReadWriteLock基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-2%E3%80%81%E9%94%81%E8%8E%B7%E5%8F%96%E8%BF%87%E7%A8%8B"><span class="toc-text">4.2.3.2、锁获取过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-3%E3%80%81%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-text">4.2.3.3、常见问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-4%E3%80%81%E9%94%81%E5%88%86%E7%B1%BB"><span class="toc-text">6.2.4、锁分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E5%B7%A5%E5%85%B7"><span class="toc-text">6.3、工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1%E3%80%81Semaphore"><span class="toc-text">6.3.1、Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2%E3%80%81CountdownLatch"><span class="toc-text">6.3.2、CountdownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3%E3%80%81CyclicBarrier"><span class="toc-text">6.3.3、CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">6.4、线程安全集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">6.4.1、概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2%E3%80%81concurrentHashMap"><span class="toc-text">6.4.2、concurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3%E3%80%81BlockingQueue"><span class="toc-text">6.4.3、BlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-4%E3%80%81ConcurrentLinkedQueue"><span class="toc-text">6.4.4、ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-5%E3%80%81CopyOnWriteArrayList"><span class="toc-text">6.4.5、CopyOnWriteArrayList</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Guo Yancheng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'OEq3iszm4hiLRFQ80CCuoT2B-gzGzoHsz',
      appKey: 'E2tu5GKsWgzxBtHDe0SXDcYC',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: true
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/jquery.js"></script><script src="/js/foot.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>